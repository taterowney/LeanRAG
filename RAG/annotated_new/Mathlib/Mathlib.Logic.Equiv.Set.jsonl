{"name":"Equiv.range_eq_univ","module":"Mathlib.Logic.Equiv.Set","initialProofState":"α : Type u_1\nβ : Type u_2\ne : Equiv α β\n⊢ Eq (Set.range ⇑e) Set.univ","decl":"@[simp]\ntheorem range_eq_univ {α : Type*} {β : Type*} (e : α ≃ β) : range e = univ :=\n  eq_univ_of_forall e.surjective\n\n"}
{"name":"Equiv.image_eq_preimage","module":"Mathlib.Logic.Equiv.Set","initialProofState":"α : Type u_1\nβ : Type u_2\ne : Equiv α β\ns : Set α\n⊢ Eq (Set.image (⇑e) s) (Set.preimage (⇑e.symm) s)","decl":"protected theorem image_eq_preimage {α β} (e : α ≃ β) (s : Set α) : e '' s = e.symm ⁻¹' s :=\n  Set.ext fun _ => mem_image_iff_of_inverse e.left_inv e.right_inv\n\n"}
{"name":"Set.mem_image_equiv","module":"Mathlib.Logic.Equiv.Set","initialProofState":"α : Type u_1\nβ : Type u_2\nS : Set α\nf : Equiv α β\nx : β\n⊢ Iff (Membership.mem (Set.image (⇑f) S) x) (Membership.mem S (f.symm x))","decl":"@[simp 1001]\ntheorem _root_.Set.mem_image_equiv {α β} {S : Set α} {f : α ≃ β} {x : β} :\n    x ∈ f '' S ↔ f.symm x ∈ S :=\n  Set.ext_iff.mp (f.image_eq_preimage S) x\n\n"}
{"name":"Set.image_equiv_eq_preimage_symm","module":"Mathlib.Logic.Equiv.Set","initialProofState":"α : Type u_1\nβ : Type u_2\nS : Set α\nf : Equiv α β\n⊢ Eq (Set.image (⇑f) S) (Set.preimage (⇑f.symm) S)","decl":"/-- Alias for `Equiv.image_eq_preimage` -/\ntheorem _root_.Set.image_equiv_eq_preimage_symm {α β} (S : Set α) (f : α ≃ β) :\n    f '' S = f.symm ⁻¹' S :=\n  f.image_eq_preimage S\n\n"}
{"name":"Set.preimage_equiv_eq_image_symm","module":"Mathlib.Logic.Equiv.Set","initialProofState":"α : Type u_1\nβ : Type u_2\nS : Set α\nf : Equiv β α\n⊢ Eq (Set.preimage (⇑f) S) (Set.image (⇑f.symm) S)","decl":"/-- Alias for `Equiv.image_eq_preimage` -/\ntheorem _root_.Set.preimage_equiv_eq_image_symm {α β} (S : Set α) (f : β ≃ α) :\n    f ⁻¹' S = f.symm '' S :=\n  (f.symm.image_eq_preimage S).symm\n\n-- Porting note: increased priority so this fires before `image_subset_iff`\n"}
{"name":"Equiv.symm_image_subset","module":"Mathlib.Logic.Equiv.Set","initialProofState":"α : Type u_1\nβ : Type u_2\ne : Equiv α β\ns : Set α\nt : Set β\n⊢ Iff (HasSubset.Subset (Set.image (⇑e.symm) t) s) (HasSubset.Subset t (Set.image (⇑e) s))","decl":"@[simp high]\nprotected theorem symm_image_subset {α β} (e : α ≃ β) (s : Set α) (t : Set β) :\n    e.symm '' t ⊆ s ↔ t ⊆ e '' s := by rw [image_subset_iff, e.image_eq_preimage]\n\n-- Porting note: increased priority so this fires before `image_subset_iff`\n"}
{"name":"Equiv.subset_symm_image","module":"Mathlib.Logic.Equiv.Set","initialProofState":"α : Type u_1\nβ : Type u_2\ne : Equiv α β\ns : Set α\nt : Set β\n⊢ Iff (HasSubset.Subset s (Set.image (⇑e.symm) t)) (HasSubset.Subset (Set.image (⇑e) s) t)","decl":"@[simp high]\nprotected theorem subset_symm_image {α β} (e : α ≃ β) (s : Set α) (t : Set β) :\n    s ⊆ e.symm '' t ↔ e '' s ⊆ t :=\n  calc\n    s ⊆ e.symm '' t ↔ e.symm.symm '' s ⊆ t := by rw [e.symm.symm_image_subset]\n    _ ↔ e '' s ⊆ t := by rw [e.symm_symm]\n\n"}
{"name":"Equiv.symm_image_image","module":"Mathlib.Logic.Equiv.Set","initialProofState":"α : Type u_1\nβ : Type u_2\ne : Equiv α β\ns : Set α\n⊢ Eq (Set.image (⇑e.symm) (Set.image (⇑e) s)) s","decl":"@[simp]\ntheorem symm_image_image {α β} (e : α ≃ β) (s : Set α) : e.symm '' (e '' s) = s :=\n  e.leftInverse_symm.image_image s\n\n"}
{"name":"Equiv.eq_image_iff_symm_image_eq","module":"Mathlib.Logic.Equiv.Set","initialProofState":"α : Type u_1\nβ : Type u_2\ne : Equiv α β\ns : Set α\nt : Set β\n⊢ Iff (Eq t (Set.image (⇑e) s)) (Eq (Set.image (⇑e.symm) t) s)","decl":"theorem eq_image_iff_symm_image_eq {α β} (e : α ≃ β) (s : Set α) (t : Set β) :\n    t = e '' s ↔ e.symm '' t = s :=\n  (e.symm.injective.image_injective.eq_iff' (e.symm_image_image s)).symm\n\n"}
{"name":"Equiv.image_symm_image","module":"Mathlib.Logic.Equiv.Set","initialProofState":"α : Type u_1\nβ : Type u_2\ne : Equiv α β\ns : Set β\n⊢ Eq (Set.image (⇑e) (Set.image (⇑e.symm) s)) s","decl":"@[simp]\ntheorem image_symm_image {α β} (e : α ≃ β) (s : Set β) : e '' (e.symm '' s) = s :=\n  e.symm.symm_image_image s\n\n"}
{"name":"Equiv.image_preimage","module":"Mathlib.Logic.Equiv.Set","initialProofState":"α : Type u_1\nβ : Type u_2\ne : Equiv α β\ns : Set β\n⊢ Eq (Set.image (⇑e) (Set.preimage (⇑e) s)) s","decl":"@[simp]\ntheorem image_preimage {α β} (e : α ≃ β) (s : Set β) : e '' (e ⁻¹' s) = s :=\n  e.surjective.image_preimage s\n\n"}
{"name":"Equiv.preimage_image","module":"Mathlib.Logic.Equiv.Set","initialProofState":"α : Type u_1\nβ : Type u_2\ne : Equiv α β\ns : Set α\n⊢ Eq (Set.preimage (⇑e) (Set.image (⇑e) s)) s","decl":"@[simp]\ntheorem preimage_image {α β} (e : α ≃ β) (s : Set α) : e ⁻¹' (e '' s) = s :=\n  e.injective.preimage_image s\n\n"}
{"name":"Equiv.image_compl","module":"Mathlib.Logic.Equiv.Set","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Equiv α β\ns : Set α\n⊢ Eq (Set.image (⇑f) (HasCompl.compl s)) (HasCompl.compl (Set.image (⇑f) s))","decl":"protected theorem image_compl {α β} (f : Equiv α β) (s : Set α) : f '' sᶜ = (f '' s)ᶜ :=\n  image_compl_eq f.bijective\n\n"}
{"name":"Equiv.symm_preimage_preimage","module":"Mathlib.Logic.Equiv.Set","initialProofState":"α : Type u_1\nβ : Type u_2\ne : Equiv α β\ns : Set β\n⊢ Eq (Set.preimage (⇑e.symm) (Set.preimage (⇑e) s)) s","decl":"@[simp]\ntheorem symm_preimage_preimage {α β} (e : α ≃ β) (s : Set β) : e.symm ⁻¹' (e ⁻¹' s) = s :=\n  e.rightInverse_symm.preimage_preimage s\n\n"}
{"name":"Equiv.preimage_symm_preimage","module":"Mathlib.Logic.Equiv.Set","initialProofState":"α : Type u_1\nβ : Type u_2\ne : Equiv α β\ns : Set α\n⊢ Eq (Set.preimage (⇑e) (Set.preimage (⇑e.symm) s)) s","decl":"@[simp]\ntheorem preimage_symm_preimage {α β} (e : α ≃ β) (s : Set α) : e ⁻¹' (e.symm ⁻¹' s) = s :=\n  e.leftInverse_symm.preimage_preimage s\n\n"}
{"name":"Equiv.preimage_subset","module":"Mathlib.Logic.Equiv.Set","initialProofState":"α : Type u_1\nβ : Type u_2\ne : Equiv α β\ns t : Set β\n⊢ Iff (HasSubset.Subset (Set.preimage (⇑e) s) (Set.preimage (⇑e) t)) (HasSubset.Subset s t)","decl":"theorem preimage_subset {α β} (e : α ≃ β) (s t : Set β) : e ⁻¹' s ⊆ e ⁻¹' t ↔ s ⊆ t :=\n  e.surjective.preimage_subset_preimage_iff\n\n"}
{"name":"Equiv.image_subset","module":"Mathlib.Logic.Equiv.Set","initialProofState":"α : Type u_1\nβ : Type u_2\ne : Equiv α β\ns t : Set α\n⊢ Iff (HasSubset.Subset (Set.image (⇑e) s) (Set.image (⇑e) t)) (HasSubset.Subset s t)","decl":"theorem image_subset {α β} (e : α ≃ β) (s t : Set α) : e '' s ⊆ e '' t ↔ s ⊆ t :=\n  image_subset_image_iff e.injective\n\n"}
{"name":"Equiv.image_eq_iff_eq","module":"Mathlib.Logic.Equiv.Set","initialProofState":"α : Type u_1\nβ : Type u_2\ne : Equiv α β\ns t : Set α\n⊢ Iff (Eq (Set.image (⇑e) s) (Set.image (⇑e) t)) (Eq s t)","decl":"@[simp]\ntheorem image_eq_iff_eq {α β} (e : α ≃ β) (s t : Set α) : e '' s = e '' t ↔ s = t :=\n  image_eq_image e.injective\n\n"}
{"name":"Equiv.preimage_eq_iff_eq_image","module":"Mathlib.Logic.Equiv.Set","initialProofState":"α : Type u_1\nβ : Type u_2\ne : Equiv α β\ns : Set β\nt : Set α\n⊢ Iff (Eq (Set.preimage (⇑e) s) t) (Eq s (Set.image (⇑e) t))","decl":"theorem preimage_eq_iff_eq_image {α β} (e : α ≃ β) (s t) : e ⁻¹' s = t ↔ s = e '' t :=\n  Set.preimage_eq_iff_eq_image e.bijective\n\n"}
{"name":"Equiv.eq_preimage_iff_image_eq","module":"Mathlib.Logic.Equiv.Set","initialProofState":"α : Type u_1\nβ : Type u_2\ne : Equiv α β\ns : Set α\nt : Set β\n⊢ Iff (Eq s (Set.preimage (⇑e) t)) (Eq (Set.image (⇑e) s) t)","decl":"theorem eq_preimage_iff_image_eq {α β} (e : α ≃ β) (s t) : s = e ⁻¹' t ↔ e '' s = t :=\n  Set.eq_preimage_iff_image_eq e.bijective\n\n"}
{"name":"Equiv.setOf_apply_symm_eq_image_setOf","module":"Mathlib.Logic.Equiv.Set","initialProofState":"α : Type u_1\nβ : Type u_2\ne : Equiv α β\np : α → Prop\n⊢ Eq (setOf fun b => p (e.symm b)) (Set.image (⇑e) (setOf fun a => p a))","decl":"lemma setOf_apply_symm_eq_image_setOf {α β} (e : α ≃ β) (p : α → Prop) :\n    {b | p (e.symm b)} = e '' {a | p a} := by\n  rw [Equiv.image_eq_preimage, preimage_setOf_eq]\n\n"}
{"name":"Equiv.prod_assoc_preimage","module":"Mathlib.Logic.Equiv.Set","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ns : Set α\nt : Set β\nu : Set γ\n⊢ Eq (Set.preimage (⇑(Equiv.prodAssoc α β γ)) (SProd.sprod s (SProd.sprod t u))) (SProd.sprod (SProd.sprod s t) u)","decl":"@[simp]\ntheorem prod_assoc_preimage {α β γ} {s : Set α} {t : Set β} {u : Set γ} :\n    Equiv.prodAssoc α β γ ⁻¹' s ×ˢ t ×ˢ u = (s ×ˢ t) ×ˢ u := by\n  ext\n  simp [and_assoc]\n\n"}
{"name":"Equiv.prod_assoc_symm_preimage","module":"Mathlib.Logic.Equiv.Set","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ns : Set α\nt : Set β\nu : Set γ\n⊢ Eq (Set.preimage (⇑(Equiv.prodAssoc α β γ).symm) (SProd.sprod (SProd.sprod s t) u)) (SProd.sprod s (SProd.sprod t u))","decl":"@[simp]\ntheorem prod_assoc_symm_preimage {α β γ} {s : Set α} {t : Set β} {u : Set γ} :\n    (Equiv.prodAssoc α β γ).symm ⁻¹' (s ×ˢ t) ×ˢ u = s ×ˢ t ×ˢ u := by\n  ext\n  simp [and_assoc]\n\n-- `@[simp]` doesn't like these lemmas, as it uses `Set.image_congr'` to turn `Equiv.prodAssoc`\n-- into a lambda expression and then unfold it.\n"}
{"name":"Equiv.prod_assoc_image","module":"Mathlib.Logic.Equiv.Set","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ns : Set α\nt : Set β\nu : Set γ\n⊢ Eq (Set.image (⇑(Equiv.prodAssoc α β γ)) (SProd.sprod (SProd.sprod s t) u)) (SProd.sprod s (SProd.sprod t u))","decl":"theorem prod_assoc_image {α β γ} {s : Set α} {t : Set β} {u : Set γ} :\n    Equiv.prodAssoc α β γ '' (s ×ˢ t) ×ˢ u = s ×ˢ t ×ˢ u := by\n  simpa only [Equiv.image_eq_preimage] using prod_assoc_symm_preimage\n\n"}
{"name":"Equiv.prod_assoc_symm_image","module":"Mathlib.Logic.Equiv.Set","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ns : Set α\nt : Set β\nu : Set γ\n⊢ Eq (Set.image (⇑(Equiv.prodAssoc α β γ).symm) (SProd.sprod s (SProd.sprod t u))) (SProd.sprod (SProd.sprod s t) u)","decl":"theorem prod_assoc_symm_image {α β γ} {s : Set α} {t : Set β} {u : Set γ} :\n    (Equiv.prodAssoc α β γ).symm '' s ×ˢ t ×ˢ u = (s ×ˢ t) ×ˢ u := by\n  simpa only [Equiv.image_eq_preimage] using prod_assoc_preimage\n\n"}
{"name":"Equiv.setCongr_apply","module":"Mathlib.Logic.Equiv.Set","initialProofState":"α : Type u_1\ns t : Set α\nh : Eq s t\na : Subtype fun a => (fun x => Membership.mem s x) a\n⊢ Eq ((Equiv.setCongr h) a) ⟨↑a, ⋯⟩","decl":"/-- The subtypes corresponding to equal sets are equivalent. -/\n@[simps! apply]\ndef setCongr {α : Type*} {s t : Set α} (h : s = t) : s ≃ t :=\n  subtypeEquivProp h\n\n-- We could construct this using `Equiv.Set.image e s e.injective`,\n-- but this definition provides an explicit inverse.\n"}
{"name":"Equiv.image_apply_coe","module":"Mathlib.Logic.Equiv.Set","initialProofState":"α : Type u_1\nβ : Type u_2\ne : Equiv α β\ns : Set α\nx : ↑s\n⊢ Eq (↑((e.image s) x)) (e ↑x)","decl":"/-- A set is equivalent to its image under an equivalence.\n-/\n@[simps]\ndef image {α β : Type*} (e : α ≃ β) (s : Set α) :\n    s ≃ e '' s where\n  toFun x := ⟨e x.1, by simp⟩\n  invFun y :=\n    ⟨e.symm y.1, by\n      rcases y with ⟨-, ⟨a, ⟨m, rfl⟩⟩⟩\n      simpa using m⟩\n  left_inv x := by simp\n  right_inv y := by simp\n\n"}
{"name":"Equiv.image_symm_apply_coe","module":"Mathlib.Logic.Equiv.Set","initialProofState":"α : Type u_1\nβ : Type u_2\ne : Equiv α β\ns : Set α\ny : ↑(Set.image (⇑e) s)\n⊢ Eq (↑((e.image s).symm y)) (e.symm ↑y)","decl":"/-- A set is equivalent to its image under an equivalence.\n-/\n@[simps]\ndef image {α β : Type*} (e : α ≃ β) (s : Set α) :\n    s ≃ e '' s where\n  toFun x := ⟨e x.1, by simp⟩\n  invFun y :=\n    ⟨e.symm y.1, by\n      rcases y with ⟨-, ⟨a, ⟨m, rfl⟩⟩⟩\n      simpa using m⟩\n  left_inv x := by simp\n  right_inv y := by simp\n\n"}
{"name":"Equiv.Set.univ_apply","module":"Mathlib.Logic.Equiv.Set","initialProofState":"α : Type u_1\nself : Subtype fun x => Membership.mem Set.univ x\n⊢ Eq ((Equiv.Set.univ α) self) ↑self","decl":"/-- `univ α` is equivalent to `α`. -/\n@[simps apply symm_apply]\nprotected def univ (α) : @univ α ≃ α :=\n  ⟨Subtype.val, fun a => ⟨a, trivial⟩, fun ⟨_, _⟩ => rfl, fun _ => rfl⟩\n\n"}
{"name":"Equiv.Set.univ_symm_apply","module":"Mathlib.Logic.Equiv.Set","initialProofState":"α : Type u_1\na : α\n⊢ Eq ((Equiv.Set.univ α).symm a) ⟨a, trivial⟩","decl":"/-- `univ α` is equivalent to `α`. -/\n@[simps apply symm_apply]\nprotected def univ (α) : @univ α ≃ α :=\n  ⟨Subtype.val, fun a => ⟨a, trivial⟩, fun ⟨_, _⟩ => rfl, fun _ => rfl⟩\n\n"}
{"name":"Equiv.Set.union_apply_left","module":"Mathlib.Logic.Equiv.Set","initialProofState":"α : Type u_1\ns t : Set α\ninst✝ : DecidablePred fun x => Membership.mem s x\nH : Disjoint s t\na : ↑(Union.union s t)\nha : Membership.mem s ↑a\n⊢ Eq ((Equiv.Set.union H) a) (Sum.inl ⟨↑a, ha⟩)","decl":"theorem union_apply_left {α} {s t : Set α} [DecidablePred fun x => x ∈ s] (H : Disjoint s t)\n    {a : (s ∪ t : Set α)} (ha : ↑a ∈ s) : Equiv.Set.union H a = Sum.inl ⟨a, ha⟩ :=\n  dif_pos ha\n\n"}
{"name":"Equiv.Set.union_apply_right","module":"Mathlib.Logic.Equiv.Set","initialProofState":"α : Type u_1\ns t : Set α\ninst✝ : DecidablePred fun x => Membership.mem s x\nH : Disjoint s t\na : ↑(Union.union s t)\nha : Membership.mem t ↑a\n⊢ Eq ((Equiv.Set.union H) a) (Sum.inr ⟨↑a, ha⟩)","decl":"theorem union_apply_right {α} {s t : Set α} [DecidablePred fun x => x ∈ s] (H : Disjoint s t)\n    {a : (s ∪ t : Set α)} (ha : ↑a ∈ t) : Equiv.Set.union H a = Sum.inr ⟨a, ha⟩ :=\n  dif_neg fun h => Set.disjoint_left.mp H h ha\n\n"}
{"name":"Equiv.Set.union_symm_apply_left","module":"Mathlib.Logic.Equiv.Set","initialProofState":"α : Type u_1\ns t : Set α\ninst✝ : DecidablePred fun x => Membership.mem s x\nH : Disjoint s t\na : ↑s\n⊢ Eq ((Equiv.Set.union H).symm (Sum.inl a)) ⟨↑a, ⋯⟩","decl":"@[simp]\ntheorem union_symm_apply_left {α} {s t : Set α} [DecidablePred fun x => x ∈ s] (H : Disjoint s t)\n    (a : s) : (Equiv.Set.union H).symm (Sum.inl a) = ⟨a, by simp⟩ :=\n  rfl\n\n"}
{"name":"Equiv.Set.union_symm_apply_right","module":"Mathlib.Logic.Equiv.Set","initialProofState":"α : Type u_1\ns t : Set α\ninst✝ : DecidablePred fun x => Membership.mem s x\nH : Disjoint s t\na : ↑t\n⊢ Eq ((Equiv.Set.union H).symm (Sum.inr a)) ⟨↑a, ⋯⟩","decl":"@[simp]\ntheorem union_symm_apply_right {α} {s t : Set α} [DecidablePred fun x => x ∈ s] (H : Disjoint s t)\n    (a : t) : (Equiv.Set.union H).symm (Sum.inr a) = ⟨a, by simp⟩ :=\n  rfl\n\n"}
{"name":"Equiv.Set.ofEq_symm_apply","module":"Mathlib.Logic.Equiv.Set","initialProofState":"α : Type u\ns t : Set α\nh : Eq s t\nb : Subtype fun b => (fun x => Membership.mem t x) b\n⊢ Eq ((Equiv.Set.ofEq h).symm b) ⟨↑b, ⋯⟩","decl":"/-- Equal sets are equivalent.\n\nTODO: this is the same as `Equiv.setCongr`! -/\n@[simps! apply symm_apply]\nprotected def ofEq {α : Type u} {s t : Set α} (h : s = t) : s ≃ t :=\n  Equiv.setCongr h\n\n"}
{"name":"Equiv.Set.ofEq_apply","module":"Mathlib.Logic.Equiv.Set","initialProofState":"α : Type u\ns t : Set α\nh : Eq s t\na : Subtype fun a => (fun x => Membership.mem s x) a\n⊢ Eq ((Equiv.Set.ofEq h) a) ⟨↑a, ⋯⟩","decl":"/-- Equal sets are equivalent.\n\nTODO: this is the same as `Equiv.setCongr`! -/\n@[simps! apply symm_apply]\nprotected def ofEq {α : Type u} {s t : Set α} (h : s = t) : s ≃ t :=\n  Equiv.setCongr h\n\n"}
{"name":"Equiv.Set.Equiv.strictMono_setCongr","module":"Mathlib.Logic.Equiv.Set","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\nS T : Set α\nh : Eq S T\n⊢ StrictMono ⇑(Equiv.setCongr h)","decl":"lemma Equiv.strictMono_setCongr {α : Type*} [PartialOrder α] {S T : Set α} (h : S = T) :\n    StrictMono (setCongr h) := fun _ _ ↦ id\n\n"}
{"name":"Equiv.Set.insert_symm_apply_inl","module":"Mathlib.Logic.Equiv.Set","initialProofState":"α : Type u\ns : Set α\ninst✝ : DecidablePred fun x => Membership.mem s x\na : α\nH : Not (Membership.mem s a)\nb : ↑s\n⊢ Eq ((Equiv.Set.insert H).symm (Sum.inl b)) ⟨↑b, ⋯⟩","decl":"@[simp]\ntheorem insert_symm_apply_inl {α} {s : Set.{u} α} [DecidablePred (· ∈ s)] {a : α} (H : a ∉ s)\n    (b : s) : (Equiv.Set.insert H).symm (Sum.inl b) = ⟨b, Or.inr b.2⟩ :=\n  rfl\n\n"}
{"name":"Equiv.Set.insert_symm_apply_inr","module":"Mathlib.Logic.Equiv.Set","initialProofState":"α : Type u\ns : Set α\ninst✝ : DecidablePred fun x => Membership.mem s x\na : α\nH : Not (Membership.mem s a)\nb : PUnit.{u + 1}\n⊢ Eq ((Equiv.Set.insert H).symm (Sum.inr b)) ⟨a, ⋯⟩","decl":"@[simp]\ntheorem insert_symm_apply_inr {α} {s : Set.{u} α} [DecidablePred (· ∈ s)] {a : α} (H : a ∉ s)\n    (b : PUnit.{u + 1}) : (Equiv.Set.insert H).symm (Sum.inr b) = ⟨a, Or.inl rfl⟩ :=\n  rfl\n\n"}
{"name":"Equiv.Set.insert_apply_left","module":"Mathlib.Logic.Equiv.Set","initialProofState":"α : Type u\ns : Set α\ninst✝ : DecidablePred fun x => Membership.mem s x\na : α\nH : Not (Membership.mem s a)\n⊢ Eq ((Equiv.Set.insert H) ⟨a, ⋯⟩) (Sum.inr PUnit.unit)","decl":"@[simp]\ntheorem insert_apply_left {α} {s : Set.{u} α} [DecidablePred (· ∈ s)] {a : α} (H : a ∉ s) :\n    Equiv.Set.insert H ⟨a, Or.inl rfl⟩ = Sum.inr PUnit.unit :=\n  (Equiv.Set.insert H).apply_eq_iff_eq_symm_apply.2 rfl\n\n"}
{"name":"Equiv.Set.insert_apply_right","module":"Mathlib.Logic.Equiv.Set","initialProofState":"α : Type u\ns : Set α\ninst✝ : DecidablePred fun x => Membership.mem s x\na : α\nH : Not (Membership.mem s a)\nb : ↑s\n⊢ Eq ((Equiv.Set.insert H) ⟨↑b, ⋯⟩) (Sum.inl b)","decl":"@[simp]\ntheorem insert_apply_right {α} {s : Set.{u} α} [DecidablePred (· ∈ s)] {a : α} (H : a ∉ s) (b : s) :\n    Equiv.Set.insert H ⟨b, Or.inr b.2⟩ = Sum.inl b :=\n  (Equiv.Set.insert H).apply_eq_iff_eq_symm_apply.2 rfl\n\n"}
{"name":"Equiv.Set.sumCompl_apply_inl","module":"Mathlib.Logic.Equiv.Set","initialProofState":"α : Type u\ns : Set α\ninst✝ : DecidablePred fun x => Membership.mem s x\nx : ↑s\n⊢ Eq ((Equiv.Set.sumCompl s) (Sum.inl x)) ↑x","decl":"@[simp]\ntheorem sumCompl_apply_inl {α : Type u} (s : Set α) [DecidablePred (· ∈ s)] (x : s) :\n    Equiv.Set.sumCompl s (Sum.inl x) = x :=\n  rfl\n\n"}
{"name":"Equiv.Set.sumCompl_apply_inr","module":"Mathlib.Logic.Equiv.Set","initialProofState":"α : Type u\ns : Set α\ninst✝ : DecidablePred fun x => Membership.mem s x\nx : ↑(HasCompl.compl s)\n⊢ Eq ((Equiv.Set.sumCompl s) (Sum.inr x)) ↑x","decl":"@[simp]\ntheorem sumCompl_apply_inr {α : Type u} (s : Set α) [DecidablePred (· ∈ s)] (x : (sᶜ : Set α)) :\n    Equiv.Set.sumCompl s (Sum.inr x) = x :=\n  rfl\n\n"}
{"name":"Equiv.Set.sumCompl_symm_apply_of_mem","module":"Mathlib.Logic.Equiv.Set","initialProofState":"α : Type u\ns : Set α\ninst✝ : DecidablePred fun x => Membership.mem s x\nx : α\nhx : Membership.mem s x\n⊢ Eq ((Equiv.Set.sumCompl s).symm x) (Sum.inl ⟨x, hx⟩)","decl":"theorem sumCompl_symm_apply_of_mem {α : Type u} {s : Set α} [DecidablePred (· ∈ s)] {x : α}\n    (hx : x ∈ s) : (Equiv.Set.sumCompl s).symm x = Sum.inl ⟨x, hx⟩ := by\n  simp [Equiv.Set.sumCompl, Equiv.Set.univ, union_apply_left, hx]\n\n"}
{"name":"Equiv.Set.sumCompl_symm_apply_of_not_mem","module":"Mathlib.Logic.Equiv.Set","initialProofState":"α : Type u\ns : Set α\ninst✝ : DecidablePred fun x => Membership.mem s x\nx : α\nhx : Not (Membership.mem s x)\n⊢ Eq ((Equiv.Set.sumCompl s).symm x) (Sum.inr ⟨x, hx⟩)","decl":"theorem sumCompl_symm_apply_of_not_mem {α : Type u} {s : Set α} [DecidablePred (· ∈ s)] {x : α}\n    (hx : x ∉ s) : (Equiv.Set.sumCompl s).symm x = Sum.inr ⟨x, hx⟩ := by\n  simp [Equiv.Set.sumCompl, Equiv.Set.univ, union_apply_right, hx]\n\n"}
{"name":"Equiv.Set.sumCompl_symm_apply","module":"Mathlib.Logic.Equiv.Set","initialProofState":"α : Type u_1\ns : Set α\ninst✝ : DecidablePred fun x => Membership.mem s x\nx : ↑s\n⊢ Eq ((Equiv.Set.sumCompl s).symm ↑x) (Sum.inl x)","decl":"@[simp]\ntheorem sumCompl_symm_apply {α : Type*} {s : Set α} [DecidablePred (· ∈ s)] {x : s} :\n    (Equiv.Set.sumCompl s).symm x = Sum.inl x :=\n  Set.sumCompl_symm_apply_of_mem x.2\n\n"}
{"name":"Equiv.Set.sumCompl_symm_apply_compl","module":"Mathlib.Logic.Equiv.Set","initialProofState":"α : Type u_1\ns : Set α\ninst✝ : DecidablePred fun x => Membership.mem s x\nx : ↑(HasCompl.compl s)\n⊢ Eq ((Equiv.Set.sumCompl s).symm ↑x) (Sum.inr x)","decl":"@[simp]\ntheorem sumCompl_symm_apply_compl {α : Type*} {s : Set α} [DecidablePred (· ∈ s)]\n    {x : (sᶜ : Set α)} : (Equiv.Set.sumCompl s).symm x = Sum.inr x :=\n  Set.sumCompl_symm_apply_of_not_mem x.2\n\n"}
{"name":"Equiv.Set.sumDiffSubset_apply_inl","module":"Mathlib.Logic.Equiv.Set","initialProofState":"α : Type u_1\ns t : Set α\nh : HasSubset.Subset s t\ninst✝ : DecidablePred fun x => Membership.mem s x\nx : ↑s\n⊢ Eq ((Equiv.Set.sumDiffSubset h) (Sum.inl x)) (Set.inclusion h x)","decl":"@[simp]\ntheorem sumDiffSubset_apply_inl {α} {s t : Set α} (h : s ⊆ t) [DecidablePred (· ∈ s)] (x : s) :\n    Equiv.Set.sumDiffSubset h (Sum.inl x) = inclusion h x :=\n  rfl\n\n"}
{"name":"Equiv.Set.sumDiffSubset_apply_inr","module":"Mathlib.Logic.Equiv.Set","initialProofState":"α : Type u_1\ns t : Set α\nh : HasSubset.Subset s t\ninst✝ : DecidablePred fun x => Membership.mem s x\nx : ↑(SDiff.sdiff t s)\n⊢ Eq ((Equiv.Set.sumDiffSubset h) (Sum.inr x)) (Set.inclusion ⋯ x)","decl":"@[simp]\ntheorem sumDiffSubset_apply_inr {α} {s t : Set α} (h : s ⊆ t) [DecidablePred (· ∈ s)]\n    (x : (t \\ s : Set α)) : Equiv.Set.sumDiffSubset h (Sum.inr x) = inclusion diff_subset x :=\n  rfl\n\n"}
{"name":"Equiv.Set.sumDiffSubset_symm_apply_of_mem","module":"Mathlib.Logic.Equiv.Set","initialProofState":"α : Type u_1\ns t : Set α\nh : HasSubset.Subset s t\ninst✝ : DecidablePred fun x => Membership.mem s x\nx : ↑t\nhx : Membership.mem s ↑x\n⊢ Eq ((Equiv.Set.sumDiffSubset h).symm x) (Sum.inl ⟨↑x, hx⟩)","decl":"theorem sumDiffSubset_symm_apply_of_mem {α} {s t : Set α} (h : s ⊆ t) [DecidablePred (· ∈ s)]\n    {x : t} (hx : x.1 ∈ s) : (Equiv.Set.sumDiffSubset h).symm x = Sum.inl ⟨x, hx⟩ := by\n  apply (Equiv.Set.sumDiffSubset h).injective\n  simp only [apply_symm_apply, sumDiffSubset_apply_inl, Set.inclusion_mk]\n\n"}
{"name":"Equiv.Set.sumDiffSubset_symm_apply_of_not_mem","module":"Mathlib.Logic.Equiv.Set","initialProofState":"α : Type u_1\ns t : Set α\nh : HasSubset.Subset s t\ninst✝ : DecidablePred fun x => Membership.mem s x\nx : ↑t\nhx : Not (Membership.mem s ↑x)\n⊢ Eq ((Equiv.Set.sumDiffSubset h).symm x) (Sum.inr ⟨↑x, ⋯⟩)","decl":"theorem sumDiffSubset_symm_apply_of_not_mem {α} {s t : Set α} (h : s ⊆ t) [DecidablePred (· ∈ s)]\n    {x : t} (hx : x.1 ∉ s) : (Equiv.Set.sumDiffSubset h).symm x = Sum.inr ⟨x, ⟨x.2, hx⟩⟩ := by\n  apply (Equiv.Set.sumDiffSubset h).injective\n  simp only [apply_symm_apply, sumDiffSubset_apply_inr, Set.inclusion_mk]\n\n"}
{"name":"Equiv.Set.univPi_symm_apply_coe","module":"Mathlib.Logic.Equiv.Set","initialProofState":"α : Type u_1\nβ : α → Type u_2\ns : (a : α) → Set (β a)\nf : (a : α) → ↑(s a)\na : α\n⊢ Eq (↑((Equiv.Set.univPi s).symm f) a) ↑(f a)","decl":"/-- The set `Set.pi Set.univ s` is equivalent to `Π a, s a`. -/\n@[simps]\nprotected def univPi {α : Type*} {β : α → Type*} (s : ∀ a, Set (β a)) :\n    pi univ s ≃ ∀ a, s a where\n  toFun f a := ⟨(f : ∀ a, β a) a, f.2 a (mem_univ a)⟩\n  invFun f := ⟨fun a => f a, fun a _ => (f a).2⟩\n  left_inv := fun ⟨f, hf⟩ => by\n    ext a\n    rfl\n  right_inv f := by\n    ext a\n    rfl\n\n"}
{"name":"Equiv.Set.univPi_apply_coe","module":"Mathlib.Logic.Equiv.Set","initialProofState":"α : Type u_1\nβ : α → Type u_2\ns : (a : α) → Set (β a)\nf : ↑(Set.univ.pi s)\na : α\n⊢ Eq (↑((Equiv.Set.univPi s) f a)) (↑f a)","decl":"/-- The set `Set.pi Set.univ s` is equivalent to `Π a, s a`. -/\n@[simps]\nprotected def univPi {α : Type*} {β : α → Type*} (s : ∀ a, Set (β a)) :\n    pi univ s ≃ ∀ a, s a where\n  toFun f a := ⟨(f : ∀ a, β a) a, f.2 a (mem_univ a)⟩\n  invFun f := ⟨fun a => f a, fun a _ => (f a).2⟩\n  left_inv := fun ⟨f, hf⟩ => by\n    ext a\n    rfl\n  right_inv f := by\n    ext a\n    rfl\n\n"}
{"name":"Equiv.Set.image_apply","module":"Mathlib.Logic.Equiv.Set","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ns : Set α\nH : Function.Injective f\np : ↑s\n⊢ Eq ((Equiv.Set.image f s H) p) ⟨f ↑p, ⋯⟩","decl":"/-- If `f` is an injective function, then `s` is equivalent to `f '' s`. -/\n@[simps! apply]\nprotected noncomputable def image {α β} (f : α → β) (s : Set α) (H : Injective f) : s ≃ f '' s :=\n  Equiv.Set.imageOfInjOn f s H.injOn\n\n"}
{"name":"Equiv.Set.image_symm_apply","module":"Mathlib.Logic.Equiv.Set","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ns : Set α\nH : Function.Injective f\nx : α\nh : Membership.mem (Set.image f s) (f x)\n⊢ Eq ((Equiv.Set.image f s H).symm ⟨f x, h⟩) ⟨x, ⋯⟩","decl":"@[simp]\nprotected theorem image_symm_apply {α β} (f : α → β) (s : Set α) (H : Injective f) (x : α)\n    (h : f x ∈ f '' s) : (Set.image f s H).symm ⟨f x, h⟩ = ⟨x, H.mem_set_image.1 h⟩ :=\n  (Equiv.symm_apply_eq _).2 rfl\n\n"}
{"name":"Equiv.Set.image_symm_preimage","module":"Mathlib.Logic.Equiv.Set","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nhf : Function.Injective f\nu s : Set α\n⊢ Eq (Set.preimage (fun x => ↑((Equiv.Set.image f s hf).symm x)) u) (Set.preimage Subtype.val (Set.image f u))","decl":"theorem image_symm_preimage {α β} {f : α → β} (hf : Injective f) (u s : Set α) :\n    (fun x => (Set.image f s hf).symm x : f '' s → α) ⁻¹' u = Subtype.val ⁻¹' (f '' u) := by\n  ext ⟨b, a, has, rfl⟩\n  simp [hf.eq_iff]\n\n"}
{"name":"Equiv.Set.congr_symm_apply","module":"Mathlib.Logic.Equiv.Set","initialProofState":"α : Type u_1\nβ : Type u_2\ne : Equiv α β\nt : Set β\n⊢ Eq ((Equiv.Set.congr e).symm t) (Set.image (⇑e.symm) t)","decl":"/-- If `α` is equivalent to `β`, then `Set α` is equivalent to `Set β`. -/\n@[simps]\nprotected def congr {α β : Type*} (e : α ≃ β) : Set α ≃ Set β :=\n  ⟨fun s => e '' s, fun t => e.symm '' t, symm_image_image e, symm_image_image e.symm⟩\n\n"}
{"name":"Equiv.Set.congr_apply","module":"Mathlib.Logic.Equiv.Set","initialProofState":"α : Type u_1\nβ : Type u_2\ne : Equiv α β\ns : Set α\n⊢ Eq ((Equiv.Set.congr e) s) (Set.image (⇑e) s)","decl":"/-- If `α` is equivalent to `β`, then `Set α` is equivalent to `Set β`. -/\n@[simps]\nprotected def congr {α β : Type*} (e : α ≃ β) : Set α ≃ Set β :=\n  ⟨fun s => e '' s, fun t => e.symm '' t, symm_image_image e, symm_image_image e.symm⟩\n\n"}
{"name":"Equiv.Set.rangeSplittingImageEquiv_symm_apply_coe","module":"Mathlib.Logic.Equiv.Set","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ns : Set ↑(Set.range f)\nx : ↑s\n⊢ Eq (↑((Equiv.Set.rangeSplittingImageEquiv f s).symm x)) (Set.rangeSplitting f ↑x)","decl":"/-- If `s` is a set in `range f`,\nthen its image under `rangeSplitting f` is in bijection (via `f`) with `s`.\n-/\n@[simps]\nnoncomputable def rangeSplittingImageEquiv {α β : Type*} (f : α → β) (s : Set (range f)) :\n    rangeSplitting f '' s ≃ s where\n  toFun x :=\n    ⟨⟨f x, by simp⟩, by\n      rcases x with ⟨x, ⟨y, ⟨m, rfl⟩⟩⟩\n      simpa [apply_rangeSplitting f] using m⟩\n  invFun x := ⟨rangeSplitting f x, ⟨x, ⟨x.2, rfl⟩⟩⟩\n  left_inv x := by\n    rcases x with ⟨x, ⟨y, ⟨m, rfl⟩⟩⟩\n    simp [apply_rangeSplitting f]\n  right_inv x := by simp [apply_rangeSplitting f]\n\n"}
{"name":"Equiv.Set.rangeSplittingImageEquiv_apply_coe_coe","module":"Mathlib.Logic.Equiv.Set","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\ns : Set ↑(Set.range f)\nx : ↑(Set.image (Set.rangeSplitting f) s)\n⊢ Eq (↑↑((Equiv.Set.rangeSplittingImageEquiv f s) x)) (f ↑x)","decl":"/-- If `s` is a set in `range f`,\nthen its image under `rangeSplitting f` is in bijection (via `f`) with `s`.\n-/\n@[simps]\nnoncomputable def rangeSplittingImageEquiv {α β : Type*} (f : α → β) (s : Set (range f)) :\n    rangeSplitting f '' s ≃ s where\n  toFun x :=\n    ⟨⟨f x, by simp⟩, by\n      rcases x with ⟨x, ⟨y, ⟨m, rfl⟩⟩⟩\n      simpa [apply_rangeSplitting f] using m⟩\n  invFun x := ⟨rangeSplitting f x, ⟨x, ⟨x.2, rfl⟩⟩⟩\n  left_inv x := by\n    rcases x with ⟨x, ⟨y, ⟨m, rfl⟩⟩⟩\n    simp [apply_rangeSplitting f]\n  right_inv x := by simp [apply_rangeSplitting f]\n\n"}
{"name":"Equiv.Set.rangeInl_symm_apply_coe","module":"Mathlib.Logic.Equiv.Set","initialProofState":"α : Type u_1\nβ : Type u_2\nx : α\n⊢ Eq (↑((Equiv.Set.rangeInl α β).symm x)) (Sum.inl x)","decl":"/-- Equivalence between the range of `Sum.inl : α → α ⊕ β` and `α`. -/\n@[simps symm_apply_coe]\ndef rangeInl (α β : Type*) : Set.range (Sum.inl : α → α ⊕ β) ≃ α where\n  toFun\n  | ⟨.inl x, _⟩ => x\n  | ⟨.inr _, h⟩ => False.elim <| by rcases h with ⟨x, h'⟩; cases h'\n  invFun x := ⟨.inl x, mem_range_self _⟩\n  left_inv := fun ⟨_, _, rfl⟩ => rfl\n  right_inv _ := rfl\n\n"}
{"name":"Equiv.Set.rangeInl_apply_inl","module":"Mathlib.Logic.Equiv.Set","initialProofState":"α : Type u_1\nβ : Type u_2\nx : α\n⊢ Eq ((Equiv.Set.rangeInl α β) ⟨Sum.inl x, ⋯⟩) x","decl":"@[simp] lemma rangeInl_apply_inl {α : Type*} (β : Type*) (x : α) :\n    (rangeInl α β) ⟨.inl x, mem_range_self _⟩ = x :=\n  rfl\n\n"}
{"name":"Equiv.Set.rangeInr_symm_apply_coe","module":"Mathlib.Logic.Equiv.Set","initialProofState":"α : Type u_1\nβ : Type u_2\nx : β\n⊢ Eq (↑((Equiv.Set.rangeInr α β).symm x)) (Sum.inr x)","decl":"/-- Equivalence between the range of `Sum.inr : β → α ⊕ β` and `β`. -/\n@[simps symm_apply_coe]\ndef rangeInr (α β : Type*) : Set.range (Sum.inr : β → α ⊕ β) ≃ β where\n  toFun\n  | ⟨.inl _, h⟩ => False.elim <| by rcases h with ⟨x, h'⟩; cases h'\n  | ⟨.inr x, _⟩ => x\n  invFun x := ⟨.inr x, mem_range_self _⟩\n  left_inv := fun ⟨_, _, rfl⟩ => rfl\n  right_inv _ := rfl\n\n"}
{"name":"Equiv.Set.rangeInr_apply_inr","module":"Mathlib.Logic.Equiv.Set","initialProofState":"α : Type u_1\nβ : Type u_2\nx : β\n⊢ Eq ((Equiv.Set.rangeInr α β) ⟨Sum.inr x, ⋯⟩) x","decl":"@[simp] lemma rangeInr_apply_inr (α : Type*) {β : Type*} (x : β) :\n    (rangeInr α β) ⟨.inr x, mem_range_self _⟩ = x :=\n  rfl\n\n"}
{"name":"Equiv.ofLeftInverse_apply_coe","module":"Mathlib.Logic.Equiv.Set","initialProofState":"α : Sort u_1\nβ : Type u_2\nf : α → β\nf_inv : Nonempty α → β → α\nhf : ∀ (h : Nonempty α), Function.LeftInverse (f_inv h) f\na : α\n⊢ Eq (↑((Equiv.ofLeftInverse f f_inv hf) a)) (f a)","decl":"/-- If `f : α → β` has a left-inverse when `α` is nonempty, then `α` is computably equivalent to the\nrange of `f`.\n\nWhile awkward, the `Nonempty α` hypothesis on `f_inv` and `hf` allows this to be used when `α` is\nempty too. This hypothesis is absent on analogous definitions on stronger `Equiv`s like\n`LinearEquiv.ofLeftInverse` and `RingEquiv.ofLeftInverse` as their typeclass assumptions\nare already sufficient to ensure non-emptiness. -/\n@[simps]\ndef ofLeftInverse {α β : Sort _} (f : α → β) (f_inv : Nonempty α → β → α)\n    (hf : ∀ h : Nonempty α, LeftInverse (f_inv h) f) :\n    α ≃ range f where\n  toFun a := ⟨f a, a, rfl⟩\n  invFun b := f_inv (nonempty_of_exists b.2) b\n  left_inv a := hf ⟨a⟩ a\n  right_inv := fun ⟨b, a, ha⟩ =>\n    Subtype.eq <| show f (f_inv ⟨a⟩ b) = b from Eq.trans (congr_arg f <| ha ▸ hf _ a) ha\n\n"}
{"name":"Equiv.ofLeftInverse_symm_apply","module":"Mathlib.Logic.Equiv.Set","initialProofState":"α : Sort u_1\nβ : Type u_2\nf : α → β\nf_inv : Nonempty α → β → α\nhf : ∀ (h : Nonempty α), Function.LeftInverse (f_inv h) f\nb : ↑(Set.range f)\n⊢ Eq ((Equiv.ofLeftInverse f f_inv hf).symm b) (f_inv ⋯ ↑b)","decl":"/-- If `f : α → β` has a left-inverse when `α` is nonempty, then `α` is computably equivalent to the\nrange of `f`.\n\nWhile awkward, the `Nonempty α` hypothesis on `f_inv` and `hf` allows this to be used when `α` is\nempty too. This hypothesis is absent on analogous definitions on stronger `Equiv`s like\n`LinearEquiv.ofLeftInverse` and `RingEquiv.ofLeftInverse` as their typeclass assumptions\nare already sufficient to ensure non-emptiness. -/\n@[simps]\ndef ofLeftInverse {α β : Sort _} (f : α → β) (f_inv : Nonempty α → β → α)\n    (hf : ∀ h : Nonempty α, LeftInverse (f_inv h) f) :\n    α ≃ range f where\n  toFun a := ⟨f a, a, rfl⟩\n  invFun b := f_inv (nonempty_of_exists b.2) b\n  left_inv a := hf ⟨a⟩ a\n  right_inv := fun ⟨b, a, ha⟩ =>\n    Subtype.eq <| show f (f_inv ⟨a⟩ b) = b from Eq.trans (congr_arg f <| ha ▸ hf _ a) ha\n\n"}
{"name":"Equiv.ofInjective_apply","module":"Mathlib.Logic.Equiv.Set","initialProofState":"α : Sort u_1\nβ : Type u_2\nf : α → β\nhf : Function.Injective f\na : α\n⊢ Eq ((Equiv.ofInjective f hf) a) ⟨f a, ⋯⟩","decl":"/-- If `f : α → β` is an injective function, then domain `α` is equivalent to the range of `f`. -/\n@[simps! apply]\nnoncomputable def ofInjective {α β} (f : α → β) (hf : Injective f) : α ≃ range f :=\n  Equiv.ofLeftInverse f (fun _ => Function.invFun f) fun _ => Function.leftInverse_invFun hf\n\n"}
{"name":"Equiv.apply_ofInjective_symm","module":"Mathlib.Logic.Equiv.Set","initialProofState":"α : Sort u_1\nβ : Type u_2\nf : α → β\nhf : Function.Injective f\nb : ↑(Set.range f)\n⊢ Eq (f ((Equiv.ofInjective f hf).symm b)) ↑b","decl":"theorem apply_ofInjective_symm {α β} {f : α → β} (hf : Injective f) (b : range f) :\n    f ((ofInjective f hf).symm b) = b :=\n  Subtype.ext_iff.1 <| (ofInjective f hf).apply_symm_apply b\n\n"}
{"name":"Equiv.ofInjective_symm_apply","module":"Mathlib.Logic.Equiv.Set","initialProofState":"α : Sort u_1\nβ : Type u_2\nf : α → β\nhf : Function.Injective f\na : α\n⊢ Eq ((Equiv.ofInjective f hf).symm ⟨f a, ⋯⟩) a","decl":"@[simp]\ntheorem ofInjective_symm_apply {α β} {f : α → β} (hf : Injective f) (a : α) :\n    (ofInjective f hf).symm ⟨f a, ⟨a, rfl⟩⟩ = a := by\n  apply (ofInjective f hf).injective\n  simp [apply_ofInjective_symm hf]\n\n"}
{"name":"Equiv.coe_ofInjective_symm","module":"Mathlib.Logic.Equiv.Set","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nhf : Function.Injective f\n⊢ Eq (⇑(Equiv.ofInjective f hf).symm) (Set.rangeSplitting f)","decl":"theorem coe_ofInjective_symm {α β} {f : α → β} (hf : Injective f) :\n    ((ofInjective f hf).symm : range f → α) = rangeSplitting f := by\n  ext ⟨y, x, rfl⟩\n  apply hf\n  simp [apply_rangeSplitting f]\n\n"}
{"name":"Equiv.self_comp_ofInjective_symm","module":"Mathlib.Logic.Equiv.Set","initialProofState":"α : Sort u_1\nβ : Type u_2\nf : α → β\nhf : Function.Injective f\n⊢ Eq (Function.comp f ⇑(Equiv.ofInjective f hf).symm) Subtype.val","decl":"@[simp]\ntheorem self_comp_ofInjective_symm {α β} {f : α → β} (hf : Injective f) :\n    f ∘ (ofInjective f hf).symm = Subtype.val :=\n  funext fun x => apply_ofInjective_symm hf x\n\n"}
{"name":"Equiv.ofLeftInverse_eq_ofInjective","module":"Mathlib.Logic.Equiv.Set","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nf_inv : Nonempty α → β → α\nhf : ∀ (h : Nonempty α), Function.LeftInverse (f_inv h) f\n⊢ Eq (Equiv.ofLeftInverse f f_inv hf) (Equiv.ofInjective f ⋯)","decl":"theorem ofLeftInverse_eq_ofInjective {α β : Type*} (f : α → β) (f_inv : Nonempty α → β → α)\n    (hf : ∀ h : Nonempty α, LeftInverse (f_inv h) f) :\n    ofLeftInverse f f_inv hf =\n      ofInjective f ((isEmpty_or_nonempty α).elim (fun _ _ _ _ => Subsingleton.elim _ _)\n        (fun h => (hf h).injective)) := by\n  ext\n  simp\n\n"}
{"name":"Equiv.ofLeftInverse'_eq_ofInjective","module":"Mathlib.Logic.Equiv.Set","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nf_inv : β → α\nhf : Function.LeftInverse f_inv f\n⊢ Eq (Equiv.ofLeftInverse' f f_inv hf) (Equiv.ofInjective f ⋯)","decl":"theorem ofLeftInverse'_eq_ofInjective {α β : Type*} (f : α → β) (f_inv : β → α)\n    (hf : LeftInverse f_inv f) : ofLeftInverse' f f_inv hf = ofInjective f hf.injective := by\n  ext\n  simp\n\n"}
{"name":"Equiv.set_forall_iff","module":"Mathlib.Logic.Equiv.Set","initialProofState":"α : Type u_1\nβ : Type u_2\ne : Equiv α β\np : Set α → Prop\n⊢ Iff (∀ (a : Set α), p a) (∀ (a : Set β), p (Set.preimage (⇑e) a))","decl":"protected theorem set_forall_iff {α β} (e : α ≃ β) {p : Set α → Prop} :\n    (∀ a, p a) ↔ ∀ a, p (e ⁻¹' a) :=\n  e.injective.preimage_surjective.forall\n\n"}
{"name":"Equiv.preimage_piEquivPiSubtypeProd_symm_pi","module":"Mathlib.Logic.Equiv.Set","initialProofState":"α : Type u_1\nβ : α → Type u_2\np : α → Prop\ninst✝ : DecidablePred p\ns : (i : α) → Set (β i)\n⊢ Eq (Set.preimage (⇑(Equiv.piEquivPiSubtypeProd p β).symm) (Set.univ.pi s)) (SProd.sprod (Set.univ.pi fun i => s ↑i) (Set.univ.pi fun i => s ↑i))","decl":"theorem preimage_piEquivPiSubtypeProd_symm_pi {α : Type*} {β : α → Type*} (p : α → Prop)\n    [DecidablePred p] (s : ∀ i, Set (β i)) :\n    (piEquivPiSubtypeProd p β).symm ⁻¹' pi univ s =\n      (pi univ fun i : { i // p i } => s i) ×ˢ pi univ fun i : { i // ¬p i } => s i := by\n  ext ⟨f, g⟩\n  simp only [mem_preimage, mem_univ_pi, prod_mk_mem_set_prod_eq, Subtype.forall, ← forall_and]\n  refine forall_congr' fun i => ?_\n  dsimp only [Subtype.coe_mk]\n  by_cases hi : p i <;> simp [hi]\n\n-- See also `Equiv.sigmaFiberEquiv`.\n"}
{"name":"Equiv.sigmaPreimageEquiv_symm_apply_snd_coe","module":"Mathlib.Logic.Equiv.Set","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nx : α\n⊢ Eq (↑((Equiv.sigmaPreimageEquiv f).symm x).snd) x","decl":"/-- `sigmaPreimageEquiv f` for `f : α → β` is the natural equivalence between\nthe type of all preimages of points under `f` and the total space `α`. -/\n@[simps!]\ndef sigmaPreimageEquiv {α β} (f : α → β) : (Σb, f ⁻¹' {b}) ≃ α :=\n  sigmaFiberEquiv f\n\n-- See also `Equiv.ofFiberEquiv`.\n"}
{"name":"Equiv.sigmaPreimageEquiv_apply","module":"Mathlib.Logic.Equiv.Set","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nx : Sigma fun y => Subtype fun x => Eq (f x) y\n⊢ Eq ((Equiv.sigmaPreimageEquiv f) x) ↑x.snd","decl":"/-- `sigmaPreimageEquiv f` for `f : α → β` is the natural equivalence between\nthe type of all preimages of points under `f` and the total space `α`. -/\n@[simps!]\ndef sigmaPreimageEquiv {α β} (f : α → β) : (Σb, f ⁻¹' {b}) ≃ α :=\n  sigmaFiberEquiv f\n\n-- See also `Equiv.ofFiberEquiv`.\n"}
{"name":"Equiv.sigmaPreimageEquiv_symm_apply_fst","module":"Mathlib.Logic.Equiv.Set","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nx : α\n⊢ Eq ((Equiv.sigmaPreimageEquiv f).symm x).fst (f x)","decl":"/-- `sigmaPreimageEquiv f` for `f : α → β` is the natural equivalence between\nthe type of all preimages of points under `f` and the total space `α`. -/\n@[simps!]\ndef sigmaPreimageEquiv {α β} (f : α → β) : (Σb, f ⁻¹' {b}) ≃ α :=\n  sigmaFiberEquiv f\n\n-- See also `Equiv.ofFiberEquiv`.\n"}
{"name":"Equiv.ofPreimageEquiv_symm_apply","module":"Mathlib.Logic.Equiv.Set","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : α → γ\ng : β → γ\ne : (c : γ) → Equiv ↑(Set.preimage f (Singleton.singleton c)) ↑(Set.preimage g (Singleton.singleton c))\na✝ : β\n⊢ Eq ((Equiv.ofPreimageEquiv e).symm a✝) ↑((Equiv.sigmaCongrRight e).symm ((Equiv.sigmaFiberEquiv g).symm a✝)).snd","decl":"/-- A family of equivalences between preimages of points gives an equivalence between domains. -/\n@[simps!]\ndef ofPreimageEquiv {α β γ} {f : α → γ} {g : β → γ} (e : ∀ c, f ⁻¹' {c} ≃ g ⁻¹' {c}) : α ≃ β :=\n  Equiv.ofFiberEquiv e\n\n"}
{"name":"Equiv.ofPreimageEquiv_apply","module":"Mathlib.Logic.Equiv.Set","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : α → γ\ng : β → γ\ne : (c : γ) → Equiv ↑(Set.preimage f (Singleton.singleton c)) ↑(Set.preimage g (Singleton.singleton c))\na✝ : α\n⊢ Eq ((Equiv.ofPreimageEquiv e) a✝) ↑((e (f a✝)) ((Equiv.sigmaFiberEquiv f).symm a✝).snd)","decl":"/-- A family of equivalences between preimages of points gives an equivalence between domains. -/\n@[simps!]\ndef ofPreimageEquiv {α β γ} {f : α → γ} {g : β → γ} (e : ∀ c, f ⁻¹' {c} ≃ g ⁻¹' {c}) : α ≃ β :=\n  Equiv.ofFiberEquiv e\n\n"}
{"name":"Equiv.ofPreimageEquiv_map","module":"Mathlib.Logic.Equiv.Set","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : α → γ\ng : β → γ\ne : (c : γ) → Equiv ↑(Set.preimage f (Singleton.singleton c)) ↑(Set.preimage g (Singleton.singleton c))\na : α\n⊢ Eq (g ((Equiv.ofPreimageEquiv e) a)) (f a)","decl":"theorem ofPreimageEquiv_map {α β γ} {f : α → γ} {g : β → γ} (e : ∀ c, f ⁻¹' {c} ≃ g ⁻¹' {c})\n    (a : α) : g (ofPreimageEquiv e a) = f a :=\n  Equiv.ofFiberEquiv_map e a\n\n"}
{"name":"dite_comp_equiv_update","module":"Mathlib.Logic.Equiv.Set","initialProofState":"α : Type u_1\nβ : Sort u_2\nγ : Sort u_3\np : α → Prop\ne : Equiv β (Subtype p)\nv : β → γ\nw : α → γ\nj : β\nx : γ\ninst✝² : DecidableEq β\ninst✝¹ : DecidableEq α\ninst✝ : (j : α) → Decidable (p j)\n⊢ Eq (fun i => dite (p i) (fun h => Function.update v j x (e.symm ⟨i, h⟩)) fun h => w i) (Function.update (fun i => dite (p i) (fun h => v (e.symm ⟨i, h⟩)) fun h => w i) (↑(e j)) x)","decl":"/-- The composition of an updated function with an equiv on a subtype can be expressed as an\nupdated function. -/\n-- Porting note: replace `s : Set α` and `: s` with `p : α → Prop` and `: Subtype p`, since the\n-- former now unfolds syntactically to a less general case of the latter.\ntheorem dite_comp_equiv_update {α : Type*} {β : Sort*} {γ : Sort*} {p : α → Prop}\n    (e : β ≃ Subtype p)\n    (v : β → γ) (w : α → γ) (j : β) (x : γ) [DecidableEq β] [DecidableEq α]\n    [∀ j, Decidable (p j)] :\n    (fun i : α => if h : p i then (Function.update v j x) (e.symm ⟨i, h⟩) else w i) =\n      Function.update (fun i : α => if h : p i then v (e.symm ⟨i, h⟩) else w i) (e j) x := by\n  ext i\n  by_cases h : p i\n  · rw [dif_pos h, Function.update_apply_equiv_apply, Equiv.symm_symm,\n      Function.update_apply, Function.update_apply, dif_pos h]\n    have h_coe : (⟨i, h⟩ : Subtype p) = e j ↔ i = e j :=\n      Subtype.ext_iff.trans (by rw [Subtype.coe_mk])\n    simp [h_coe]\n  · have : i ≠ e j := by\n      contrapose! h\n      have : p (e j : α) := (e j).2\n      rwa [← h] at this\n    simp [h, this]\n\n"}
{"name":"Equiv.swap_bijOn_self","module":"Mathlib.Logic.Equiv.Set","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na b : α\ns : Set α\nhs : Iff (Membership.mem s a) (Membership.mem s b)\n⊢ Set.BijOn (⇑(Equiv.swap a b)) s s","decl":"theorem Equiv.swap_bijOn_self (hs : a ∈ s ↔ b ∈ s) : BijOn (Equiv.swap a b) s s := by\n  refine ⟨fun x hx ↦ ?_, (Equiv.injective _).injOn, fun x hx ↦ ?_⟩\n  · obtain (rfl | hxa) := eq_or_ne x a\n    · rwa [swap_apply_left, ← hs]\n    obtain (rfl | hxb) := eq_or_ne x b\n    · rwa [swap_apply_right, hs]\n    rwa [swap_apply_of_ne_of_ne hxa hxb]\n  obtain (rfl | hxa) := eq_or_ne x a\n  · simp [hs.1 hx]\n  obtain (rfl | hxb) := eq_or_ne x b\n  · simp [hs.2 hx]\n  exact ⟨x, hx, swap_apply_of_ne_of_ne hxa hxb⟩\n\n"}
{"name":"Equiv.swap_bijOn_exchange","module":"Mathlib.Logic.Equiv.Set","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na b : α\ns : Set α\nha : Membership.mem s a\nhb : Not (Membership.mem s b)\n⊢ Set.BijOn (⇑(Equiv.swap a b)) s (Insert.insert b (SDiff.sdiff s (Singleton.singleton a)))","decl":"theorem Equiv.swap_bijOn_exchange (ha : a ∈ s) (hb : b ∉ s) :\n    BijOn (Equiv.swap a b) s (insert b (s \\ {a})) := by\n  refine ⟨fun x hx ↦ ?_, (Equiv.injective _).injOn, fun x hx ↦ ?_⟩\n  · obtain (rfl | hxa) := eq_or_ne x a\n    · simp [swap_apply_left]\n    rw [swap_apply_of_ne_of_ne hxa (by rintro rfl; contradiction)]\n    exact .inr ⟨hx, hxa⟩\n  obtain (rfl | hxb) := eq_or_ne x b\n  · exact ⟨a, ha, by simp⟩\n  simp only [mem_insert_iff, mem_diff, mem_singleton_iff, or_iff_right hxb] at hx\n  exact ⟨x, hx.1, swap_apply_of_ne_of_ne hx.2 hxb⟩\n\n"}
