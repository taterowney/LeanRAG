{"name":"CategoryTheory.StructuredArrow.proj_obj","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nS : D\nT : CategoryTheory.Functor C D\nX : CategoryTheory.Comma (CategoryTheory.Functor.fromPUnit S) T\n‚ä¢ Eq ((CategoryTheory.StructuredArrow.proj S T).obj X) X.right","decl":"/-- The obvious projection functor from structured arrows. -/\n@[simps!]\ndef proj (S : D) (T : C ‚•§ D) : StructuredArrow S T ‚•§ C :=\n  Comma.snd _ _\n\n"}
{"name":"CategoryTheory.StructuredArrow.proj_map","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nS : D\nT : CategoryTheory.Functor C D\nX‚úù Y‚úù : CategoryTheory.Comma (CategoryTheory.Functor.fromPUnit S) T\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.StructuredArrow.proj S T).map f) f.right","decl":"/-- The obvious projection functor from structured arrows. -/\n@[simps!]\ndef proj (S : D) (T : C ‚•§ D) : StructuredArrow S T ‚•§ C :=\n  Comma.snd _ _\n\n"}
{"name":"CategoryTheory.StructuredArrow.hom_ext","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nS : D\nT : CategoryTheory.Functor C D\nX Y : CategoryTheory.StructuredArrow S T\nf g : Quiver.Hom X Y\nh : Eq f.right g.right\n‚ä¢ Eq f g","decl":"@[ext]\nlemma hom_ext {X Y : StructuredArrow S T} (f g : X ‚ü∂ Y) (h : f.right = g.right) : f = g :=\n  CommaMorphism.ext (Subsingleton.elim _ _) h\n\n"}
{"name":"CategoryTheory.StructuredArrow.hom_ext_iff","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nS : D\nT : CategoryTheory.Functor C D\nX Y : CategoryTheory.StructuredArrow S T\nf g : Quiver.Hom X Y\n‚ä¢ Iff (Eq f g) (Eq f.right g.right)","decl":"@[ext]\nlemma hom_ext {X Y : StructuredArrow S T} (f g : X ‚ü∂ Y) (h : f.right = g.right) : f = g :=\n  CommaMorphism.ext (Subsingleton.elim _ _) h\n\n"}
{"name":"CategoryTheory.StructuredArrow.hom_eq_iff","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nS : D\nT : CategoryTheory.Functor C D\nX Y : CategoryTheory.StructuredArrow S T\nf g : Quiver.Hom X Y\n‚ä¢ Iff (Eq f g) (Eq f.right g.right)","decl":"@[simp]\ntheorem hom_eq_iff {X Y : StructuredArrow S T} (f g : X ‚ü∂ Y) : f = g ‚Üî f.right = g.right :=\n  ‚ü®fun h ‚Ü¶ by rw [h], hom_ext _ _‚ü©\n\n"}
{"name":"CategoryTheory.StructuredArrow.mk_left","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nS : D\nY : C\nT : CategoryTheory.Functor C D\nf : Quiver.Hom S (T.obj Y)\n‚ä¢ Eq (CategoryTheory.StructuredArrow.mk f).left { as := PUnit.unit }","decl":"@[simp]\ntheorem mk_left (f : S ‚ü∂ T.obj Y) : (mk f).left = ‚ü®‚ü®‚ü©‚ü© :=\n  rfl\n\n"}
{"name":"CategoryTheory.StructuredArrow.mk_right","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nS : D\nY : C\nT : CategoryTheory.Functor C D\nf : Quiver.Hom S (T.obj Y)\n‚ä¢ Eq (CategoryTheory.StructuredArrow.mk f).right Y","decl":"@[simp]\ntheorem mk_right (f : S ‚ü∂ T.obj Y) : (mk f).right = Y :=\n  rfl\n\n"}
{"name":"CategoryTheory.StructuredArrow.mk_hom_eq_self","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nS : D\nY : C\nT : CategoryTheory.Functor C D\nf : Quiver.Hom S (T.obj Y)\n‚ä¢ Eq (CategoryTheory.StructuredArrow.mk f).hom f","decl":"@[simp]\ntheorem mk_hom_eq_self (f : S ‚ü∂ T.obj Y) : (mk f).hom = f :=\n  rfl\n\n"}
{"name":"CategoryTheory.StructuredArrow.w_assoc","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nS : D\nT : CategoryTheory.Functor C D\nA B : CategoryTheory.StructuredArrow S T\nf : Quiver.Hom A B\nZ : D\nh : Quiver.Hom (T.obj B.right) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp A.hom (CategoryTheory.CategoryStruct.comp (T.map f.right) h)) (CategoryTheory.CategoryStruct.comp B.hom h)","decl":"@[reassoc (attr := simp)]\ntheorem w {A B : StructuredArrow S T} (f : A ‚ü∂ B) : A.hom ‚â´ T.map f.right = B.hom := by\n  have := f.w; aesop_cat\n\n"}
{"name":"CategoryTheory.StructuredArrow.w","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nS : D\nT : CategoryTheory.Functor C D\nA B : CategoryTheory.StructuredArrow S T\nf : Quiver.Hom A B\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp A.hom (T.map f.right)) B.hom","decl":"@[reassoc (attr := simp)]\ntheorem w {A B : StructuredArrow S T} (f : A ‚ü∂ B) : A.hom ‚â´ T.map f.right = B.hom := by\n  have := f.w; aesop_cat\n\n"}
{"name":"CategoryTheory.StructuredArrow.comp_right","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nS : D\nT : CategoryTheory.Functor C D\nX Y Z : CategoryTheory.StructuredArrow S T\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f g).right (CategoryTheory.CategoryStruct.comp f.right g.right)","decl":"@[simp]\ntheorem comp_right {X Y Z : StructuredArrow S T} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) :\n    (f ‚â´ g).right = f.right ‚â´ g.right := rfl\n\n"}
{"name":"CategoryTheory.StructuredArrow.id_right","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nS : D\nT : CategoryTheory.Functor C D\nX : CategoryTheory.StructuredArrow S T\n‚ä¢ Eq (CategoryTheory.CategoryStruct.id X).right (CategoryTheory.CategoryStruct.id X.right)","decl":"@[simp]\ntheorem id_right (X : StructuredArrow S T) : (ùüô X : X ‚ü∂ X).right = ùüô X.right := rfl\n\n"}
{"name":"CategoryTheory.StructuredArrow.eqToHom_right","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nS : D\nT : CategoryTheory.Functor C D\nX Y : CategoryTheory.StructuredArrow S T\nh : Eq X Y\n‚ä¢ Eq (CategoryTheory.eqToHom h).right (CategoryTheory.eqToHom ‚ãØ)","decl":"@[simp]\ntheorem eqToHom_right {X Y : StructuredArrow S T} (h : X = Y) :\n    (eqToHom h).right = eqToHom (by rw [h]) := by\n  subst h\n  simp only [eqToHom_refl, id_right]\n\n"}
{"name":"CategoryTheory.StructuredArrow.left_eq_id","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nS : D\nT : CategoryTheory.Functor C D\nX Y : CategoryTheory.StructuredArrow S T\nf : Quiver.Hom X Y\n‚ä¢ Eq f.left (CategoryTheory.CategoryStruct.id X.left)","decl":"@[simp]\ntheorem left_eq_id {X Y : StructuredArrow S T} (f : X ‚ü∂ Y) : f.left = ùüô X.left := rfl\n\n"}
{"name":"CategoryTheory.StructuredArrow.homMk_right","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nS : D\nT : CategoryTheory.Functor C D\nf f' : CategoryTheory.StructuredArrow S T\ng : Quiver.Hom f.right f'.right\nw : autoParam (Eq (CategoryTheory.CategoryStruct.comp f.hom (T.map g)) f'.hom) _auto‚úù\n‚ä¢ Eq (CategoryTheory.StructuredArrow.homMk g w).right g","decl":"/-- To construct a morphism of structured arrows,\nwe need a morphism of the objects underlying the target,\nand to check that the triangle commutes.\n-/\n@[simps right]\ndef homMk {f f' : StructuredArrow S T} (g : f.right ‚ü∂ f'.right)\n    (w : f.hom ‚â´ T.map g = f'.hom := by aesop_cat) : f ‚ü∂ f' where\n  left := ùüô f.left\n  right := g\n  w := by\n    dsimp\n    simpa using w.symm\n\n"}
{"name":"CategoryTheory.StructuredArrow.homMk_surjective","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nS : D\nT : CategoryTheory.Functor C D\nf f' : CategoryTheory.StructuredArrow S T\nœÜ : Quiver.Hom f f'\n‚ä¢ Exists fun œà => Exists fun hœà => Eq œÜ (CategoryTheory.StructuredArrow.homMk œà hœà)","decl":"theorem homMk_surjective {f f' : StructuredArrow S T} (œÜ : f ‚ü∂ f') :\n    ‚àÉ (œà : f.right ‚ü∂ f'.right) (hœà : f.hom ‚â´ T.map œà = f'.hom),\n      œÜ = StructuredArrow.homMk œà hœà :=\n  ‚ü®œÜ.right, StructuredArrow.w œÜ, rfl‚ü©\n\n"}
{"name":"CategoryTheory.StructuredArrow.homMk'_right","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nS : D\nY' : C\nT : CategoryTheory.Functor C D\nf : CategoryTheory.StructuredArrow S T\ng : Quiver.Hom f.right Y'\n‚ä¢ Eq (f.homMk' g).right g","decl":"/-- Given a structured arrow `X ‚ü∂ T(Y)`, and an arrow `Y ‚ü∂ Y'`, we can construct a morphism of\n    structured arrows given by `(X ‚ü∂ T(Y)) ‚ü∂ (X ‚ü∂ T(Y) ‚ü∂ T(Y'))`. -/\n@[simps]\ndef homMk' (f : StructuredArrow S T) (g : f.right ‚ü∂ Y') : f ‚ü∂ mk (f.hom ‚â´ T.map g) where\n  left := ùüô _\n  right := g\n\n"}
{"name":"CategoryTheory.StructuredArrow.homMk'_left","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nS : D\nY' : C\nT : CategoryTheory.Functor C D\nf : CategoryTheory.StructuredArrow S T\ng : Quiver.Hom f.right Y'\n‚ä¢ Eq (f.homMk' g).left (CategoryTheory.CategoryStruct.id f.left)","decl":"/-- Given a structured arrow `X ‚ü∂ T(Y)`, and an arrow `Y ‚ü∂ Y'`, we can construct a morphism of\n    structured arrows given by `(X ‚ü∂ T(Y)) ‚ü∂ (X ‚ü∂ T(Y) ‚ü∂ T(Y'))`. -/\n@[simps]\ndef homMk' (f : StructuredArrow S T) (g : f.right ‚ü∂ Y') : f ‚ü∂ mk (f.hom ‚â´ T.map g) where\n  left := ùüô _\n  right := g\n\n"}
{"name":"CategoryTheory.StructuredArrow.homMk'_id","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nS : D\nT : CategoryTheory.Functor C D\nf : CategoryTheory.StructuredArrow S T\n‚ä¢ Eq (f.homMk' (CategoryTheory.CategoryStruct.id f.right)) (CategoryTheory.eqToHom ‚ãØ)","decl":"lemma homMk'_id (f : StructuredArrow S T) : homMk' f (ùüô f.right) = eqToHom (by aesop_cat) := by\n  ext\n  simp [eqToHom_right]\n\n"}
{"name":"CategoryTheory.StructuredArrow.homMk'_mk_id","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nS : D\nY : C\nT : CategoryTheory.Functor C D\nf : Quiver.Hom S (T.obj Y)\n‚ä¢ Eq ((CategoryTheory.StructuredArrow.mk f).homMk' (CategoryTheory.CategoryStruct.id Y)) (CategoryTheory.eqToHom ‚ãØ)","decl":"lemma homMk'_mk_id (f : S ‚ü∂ T.obj Y) : homMk' (mk f) (ùüô Y) = eqToHom (by simp) :=\n  homMk'_id _\n\n"}
{"name":"CategoryTheory.StructuredArrow.homMk'_comp","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nS : D\nY' Y'' : C\nT : CategoryTheory.Functor C D\nf : CategoryTheory.StructuredArrow S T\ng : Quiver.Hom f.right Y'\ng' : Quiver.Hom Y' Y''\n‚ä¢ Eq (f.homMk' (CategoryTheory.CategoryStruct.comp g g')) (CategoryTheory.CategoryStruct.comp (f.homMk' g) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.StructuredArrow.mk (CategoryTheory.CategoryStruct.comp f.hom (T.map g))).homMk' g') (CategoryTheory.eqToHom ‚ãØ)))","decl":"lemma homMk'_comp (f : StructuredArrow S T) (g : f.right ‚ü∂ Y') (g' : Y' ‚ü∂ Y'') :\n    homMk' f (g ‚â´ g') = homMk' f g ‚â´ homMk' (mk (f.hom ‚â´ T.map g)) g' ‚â´ eqToHom (by simp) := by\n  ext\n  simp [eqToHom_right]\n\n"}
{"name":"CategoryTheory.StructuredArrow.homMk'_mk_comp","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nS : D\nY Y' Y'' : C\nT : CategoryTheory.Functor C D\nf : Quiver.Hom S (T.obj Y)\ng : Quiver.Hom Y Y'\ng' : Quiver.Hom Y' Y''\n‚ä¢ Eq ((CategoryTheory.StructuredArrow.mk f).homMk' (CategoryTheory.CategoryStruct.comp g g')) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.StructuredArrow.mk f).homMk' g) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.StructuredArrow.mk (CategoryTheory.CategoryStruct.comp f (T.map g))).homMk' g') (CategoryTheory.eqToHom ‚ãØ)))","decl":"lemma homMk'_mk_comp (f : S ‚ü∂ T.obj Y) (g : Y ‚ü∂ Y') (g' : Y' ‚ü∂ Y'') :\n    homMk' (mk f) (g ‚â´ g') = homMk' (mk f) g ‚â´ homMk' (mk (f ‚â´ T.map g)) g' ‚â´ eqToHom (by simp) :=\n  homMk'_comp _ _ _\n\n"}
{"name":"CategoryTheory.StructuredArrow.mkPostcomp_right","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nS : D\nY Y' : C\nT : CategoryTheory.Functor C D\nf : Quiver.Hom S (T.obj Y)\ng : Quiver.Hom Y Y'\n‚ä¢ Eq (CategoryTheory.StructuredArrow.mkPostcomp f g).right g","decl":"/-- Variant of `homMk'` where both objects are applications of `mk`. -/\n@[simps]\ndef mkPostcomp (f : S ‚ü∂ T.obj Y) (g : Y ‚ü∂ Y') : mk f ‚ü∂ mk (f ‚â´ T.map g) where\n  left := ùüô _\n  right := g\n\n"}
{"name":"CategoryTheory.StructuredArrow.mkPostcomp_left","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nS : D\nY Y' : C\nT : CategoryTheory.Functor C D\nf : Quiver.Hom S (T.obj Y)\ng : Quiver.Hom Y Y'\n‚ä¢ Eq (CategoryTheory.StructuredArrow.mkPostcomp f g).left (CategoryTheory.CategoryStruct.id (CategoryTheory.StructuredArrow.mk f).left)","decl":"/-- Variant of `homMk'` where both objects are applications of `mk`. -/\n@[simps]\ndef mkPostcomp (f : S ‚ü∂ T.obj Y) (g : Y ‚ü∂ Y') : mk f ‚ü∂ mk (f ‚â´ T.map g) where\n  left := ùüô _\n  right := g\n\n"}
{"name":"CategoryTheory.StructuredArrow.mkPostcomp_id","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nS : D\nY : C\nT : CategoryTheory.Functor C D\nf : Quiver.Hom S (T.obj Y)\n‚ä¢ Eq (CategoryTheory.StructuredArrow.mkPostcomp f (CategoryTheory.CategoryStruct.id Y)) (CategoryTheory.eqToHom ‚ãØ)","decl":"lemma mkPostcomp_id (f : S ‚ü∂ T.obj Y) : mkPostcomp f (ùüô Y) = eqToHom (by simp) := by simp\n"}
{"name":"CategoryTheory.StructuredArrow.mkPostcomp_comp","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nS : D\nY Y' Y'' : C\nT : CategoryTheory.Functor C D\nf : Quiver.Hom S (T.obj Y)\ng : Quiver.Hom Y Y'\ng' : Quiver.Hom Y' Y''\n‚ä¢ Eq (CategoryTheory.StructuredArrow.mkPostcomp f (CategoryTheory.CategoryStruct.comp g g')) (CategoryTheory.CategoryStruct.comp (CategoryTheory.StructuredArrow.mkPostcomp f g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.StructuredArrow.mkPostcomp (CategoryTheory.CategoryStruct.comp f (T.map g)) g') (CategoryTheory.eqToHom ‚ãØ)))","decl":"lemma mkPostcomp_comp (f : S ‚ü∂ T.obj Y) (g : Y ‚ü∂ Y') (g' : Y' ‚ü∂ Y'') :\n    mkPostcomp f (g ‚â´ g') = mkPostcomp f g ‚â´ mkPostcomp (f ‚â´ T.map g) g' ‚â´ eqToHom (by simp) := by\n  simp\n\n"}
{"name":"CategoryTheory.StructuredArrow.isoMk_hom_right","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nS : D\nT : CategoryTheory.Functor C D\nf f' : CategoryTheory.StructuredArrow S T\ng : CategoryTheory.Iso f.right f'.right\nw : autoParam (Eq (CategoryTheory.CategoryStruct.comp f.hom (T.map g.hom)) f'.hom) _auto‚úù\n‚ä¢ Eq (CategoryTheory.StructuredArrow.isoMk g w).hom.right g.hom","decl":"/-- To construct an isomorphism of structured arrows,\nwe need an isomorphism of the objects underlying the target,\nand to check that the triangle commutes.\n-/\n@[simps! hom_right inv_right]\ndef isoMk {f f' : StructuredArrow S T} (g : f.right ‚âÖ f'.right)\n    (w : f.hom ‚â´ T.map g.hom = f'.hom := by aesop_cat) :\n    f ‚âÖ f' :=\n  Comma.isoMk (eqToIso (by ext)) g (by simpa using w.symm)\n\n"}
{"name":"CategoryTheory.StructuredArrow.isoMk_inv_right","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nS : D\nT : CategoryTheory.Functor C D\nf f' : CategoryTheory.StructuredArrow S T\ng : CategoryTheory.Iso f.right f'.right\nw : autoParam (Eq (CategoryTheory.CategoryStruct.comp f.hom (T.map g.hom)) f'.hom) _auto‚úù\n‚ä¢ Eq (CategoryTheory.StructuredArrow.isoMk g w).inv.right g.inv","decl":"/-- To construct an isomorphism of structured arrows,\nwe need an isomorphism of the objects underlying the target,\nand to check that the triangle commutes.\n-/\n@[simps! hom_right inv_right]\ndef isoMk {f f' : StructuredArrow S T} (g : f.right ‚âÖ f'.right)\n    (w : f.hom ‚â´ T.map g.hom = f'.hom := by aesop_cat) :\n    f ‚âÖ f' :=\n  Comma.isoMk (eqToIso (by ext)) g (by simpa using w.symm)\n\n"}
{"name":"CategoryTheory.StructuredArrow.ext","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nS : D\nT : CategoryTheory.Functor C D\nA B : CategoryTheory.StructuredArrow S T\nf g : Quiver.Hom A B\na‚úù : Eq f.right g.right\n‚ä¢ Eq f g","decl":"theorem ext {A B : StructuredArrow S T} (f g : A ‚ü∂ B) : f.right = g.right ‚Üí f = g :=\n  CommaMorphism.ext (Subsingleton.elim _ _)\n\n"}
{"name":"CategoryTheory.StructuredArrow.ext_iff","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nS : D\nT : CategoryTheory.Functor C D\nA B : CategoryTheory.StructuredArrow S T\nf g : Quiver.Hom A B\n‚ä¢ Iff (Eq f g) (Eq f.right g.right)","decl":"theorem ext_iff {A B : StructuredArrow S T} (f g : A ‚ü∂ B) : f = g ‚Üî f.right = g.right :=\n  ‚ü®fun h => h ‚ñ∏ rfl, ext f g‚ü©\n\n"}
{"name":"CategoryTheory.StructuredArrow.proj_faithful","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nS : D\nT : CategoryTheory.Functor C D\n‚ä¢ (CategoryTheory.StructuredArrow.proj S T).Faithful","decl":"instance proj_faithful : (proj S T).Faithful where\n  map_injective {_ _} := ext\n\n"}
{"name":"CategoryTheory.StructuredArrow.mono_of_mono_right","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nS : D\nT : CategoryTheory.Functor C D\nA B : CategoryTheory.StructuredArrow S T\nf : Quiver.Hom A B\nh : CategoryTheory.Mono f.right\n‚ä¢ CategoryTheory.Mono f","decl":"/-- The converse of this is true with additional assumptions, see `mono_iff_mono_right`. -/\ntheorem mono_of_mono_right {A B : StructuredArrow S T} (f : A ‚ü∂ B) [h : Mono f.right] : Mono f :=\n  (proj S T).mono_of_mono_map h\n\n"}
{"name":"CategoryTheory.StructuredArrow.epi_of_epi_right","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nS : D\nT : CategoryTheory.Functor C D\nA B : CategoryTheory.StructuredArrow S T\nf : Quiver.Hom A B\nh : CategoryTheory.Epi f.right\n‚ä¢ CategoryTheory.Epi f","decl":"theorem epi_of_epi_right {A B : StructuredArrow S T} (f : A ‚ü∂ B) [h : Epi f.right] : Epi f :=\n  (proj S T).epi_of_epi_map h\n\n"}
{"name":"CategoryTheory.StructuredArrow.mono_homMk","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nS : D\nT : CategoryTheory.Functor C D\nA B : CategoryTheory.StructuredArrow S T\nf : Quiver.Hom A.right B.right\nw : Eq (CategoryTheory.CategoryStruct.comp A.hom (T.map f)) B.hom\nh : CategoryTheory.Mono f\n‚ä¢ CategoryTheory.Mono (CategoryTheory.StructuredArrow.homMk f w)","decl":"instance mono_homMk {A B : StructuredArrow S T} (f : A.right ‚ü∂ B.right) (w) [h : Mono f] :\n    Mono (homMk f w) :=\n  (proj S T).mono_of_mono_map h\n\n"}
{"name":"CategoryTheory.StructuredArrow.epi_homMk","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nS : D\nT : CategoryTheory.Functor C D\nA B : CategoryTheory.StructuredArrow S T\nf : Quiver.Hom A.right B.right\nw : Eq (CategoryTheory.CategoryStruct.comp A.hom (T.map f)) B.hom\nh : CategoryTheory.Epi f\n‚ä¢ CategoryTheory.Epi (CategoryTheory.StructuredArrow.homMk f w)","decl":"instance epi_homMk {A B : StructuredArrow S T} (f : A.right ‚ü∂ B.right) (w) [h : Epi f] :\n    Epi (homMk f w) :=\n  (proj S T).epi_of_epi_map h\n\n"}
{"name":"CategoryTheory.StructuredArrow.eq_mk","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nS : D\nT : CategoryTheory.Functor C D\nf : CategoryTheory.StructuredArrow S T\n‚ä¢ Eq f (CategoryTheory.StructuredArrow.mk f.hom)","decl":"/-- Eta rule for structured arrows. Prefer `StructuredArrow.eta` for rewriting, since equality of\n    objects tends to cause problems. -/\ntheorem eq_mk (f : StructuredArrow S T) : f = mk f.hom :=\n  rfl\n\n"}
{"name":"CategoryTheory.StructuredArrow.eta_inv_right","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nS : D\nT : CategoryTheory.Functor C D\nf : CategoryTheory.StructuredArrow S T\n‚ä¢ Eq f.eta.inv.right (CategoryTheory.CategoryStruct.id f.right)","decl":"/-- Eta rule for structured arrows. -/\n@[simps! hom_right inv_right]\ndef eta (f : StructuredArrow S T) : f ‚âÖ mk f.hom :=\n  isoMk (Iso.refl _)\n\n"}
{"name":"CategoryTheory.StructuredArrow.eta_hom_right","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nS : D\nT : CategoryTheory.Functor C D\nf : CategoryTheory.StructuredArrow S T\n‚ä¢ Eq f.eta.hom.right (CategoryTheory.CategoryStruct.id f.right)","decl":"/-- Eta rule for structured arrows. -/\n@[simps! hom_right inv_right]\ndef eta (f : StructuredArrow S T) : f ‚âÖ mk f.hom :=\n  isoMk (Iso.refl _)\n\n"}
{"name":"CategoryTheory.StructuredArrow.mk_surjective","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nS : D\nT : CategoryTheory.Functor C D\nf : CategoryTheory.StructuredArrow S T\n‚ä¢ Exists fun Y => Exists fun g => Eq f (CategoryTheory.StructuredArrow.mk g)","decl":"lemma mk_surjective (f : StructuredArrow S T) :\n    ‚àÉ (Y : C) (g : S ‚ü∂ T.obj Y), f = mk g :=\n  ‚ü®_, _, eq_mk f‚ü©\n\n"}
{"name":"CategoryTheory.StructuredArrow.map_obj_hom","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nS S' : D\nT : CategoryTheory.Functor C D\nf : Quiver.Hom S S'\nX : CategoryTheory.Comma (CategoryTheory.Functor.fromPUnit S') T\n‚ä¢ Eq ((CategoryTheory.StructuredArrow.map f).obj X).hom (CategoryTheory.CategoryStruct.comp f X.hom)","decl":"/-- A morphism between source objects `S ‚ü∂ S'`\ncontravariantly induces a functor between structured arrows,\n`StructuredArrow S' T ‚•§ StructuredArrow S T`.\n\nIdeally this would be described as a 2-functor from `D`\n(promoted to a 2-category with equations as 2-morphisms)\nto `Cat`.\n-/\n@[simps!]\ndef map (f : S ‚ü∂ S') : StructuredArrow S' T ‚•§ StructuredArrow S T :=\n  Comma.mapLeft _ ((Functor.const _).map f)\n\n"}
{"name":"CategoryTheory.StructuredArrow.map_map_right","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nS S' : D\nT : CategoryTheory.Functor C D\nf‚úù : Quiver.Hom S S'\nX‚úù Y‚úù : CategoryTheory.Comma (CategoryTheory.Functor.fromPUnit S') T\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.StructuredArrow.map f‚úù).map f).right f.right","decl":"/-- A morphism between source objects `S ‚ü∂ S'`\ncontravariantly induces a functor between structured arrows,\n`StructuredArrow S' T ‚•§ StructuredArrow S T`.\n\nIdeally this would be described as a 2-functor from `D`\n(promoted to a 2-category with equations as 2-morphisms)\nto `Cat`.\n-/\n@[simps!]\ndef map (f : S ‚ü∂ S') : StructuredArrow S' T ‚•§ StructuredArrow S T :=\n  Comma.mapLeft _ ((Functor.const _).map f)\n\n"}
{"name":"CategoryTheory.StructuredArrow.map_map_left","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nS S' : D\nT : CategoryTheory.Functor C D\nf‚úù : Quiver.Hom S S'\nX‚úù Y‚úù : CategoryTheory.Comma (CategoryTheory.Functor.fromPUnit S') T\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.StructuredArrow.map f‚úù).map f).left (CategoryTheory.CategoryStruct.id X‚úù.left)","decl":"/-- A morphism between source objects `S ‚ü∂ S'`\ncontravariantly induces a functor between structured arrows,\n`StructuredArrow S' T ‚•§ StructuredArrow S T`.\n\nIdeally this would be described as a 2-functor from `D`\n(promoted to a 2-category with equations as 2-morphisms)\nto `Cat`.\n-/\n@[simps!]\ndef map (f : S ‚ü∂ S') : StructuredArrow S' T ‚•§ StructuredArrow S T :=\n  Comma.mapLeft _ ((Functor.const _).map f)\n\n"}
{"name":"CategoryTheory.StructuredArrow.map_obj_right","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nS S' : D\nT : CategoryTheory.Functor C D\nf : Quiver.Hom S S'\nX : CategoryTheory.Comma (CategoryTheory.Functor.fromPUnit S') T\n‚ä¢ Eq ((CategoryTheory.StructuredArrow.map f).obj X).right X.right","decl":"/-- A morphism between source objects `S ‚ü∂ S'`\ncontravariantly induces a functor between structured arrows,\n`StructuredArrow S' T ‚•§ StructuredArrow S T`.\n\nIdeally this would be described as a 2-functor from `D`\n(promoted to a 2-category with equations as 2-morphisms)\nto `Cat`.\n-/\n@[simps!]\ndef map (f : S ‚ü∂ S') : StructuredArrow S' T ‚•§ StructuredArrow S T :=\n  Comma.mapLeft _ ((Functor.const _).map f)\n\n"}
{"name":"CategoryTheory.StructuredArrow.map_obj_left","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nS S' : D\nT : CategoryTheory.Functor C D\nf : Quiver.Hom S S'\nX : CategoryTheory.Comma (CategoryTheory.Functor.fromPUnit S') T\n‚ä¢ Eq ((CategoryTheory.StructuredArrow.map f).obj X).left X.left","decl":"/-- A morphism between source objects `S ‚ü∂ S'`\ncontravariantly induces a functor between structured arrows,\n`StructuredArrow S' T ‚•§ StructuredArrow S T`.\n\nIdeally this would be described as a 2-functor from `D`\n(promoted to a 2-category with equations as 2-morphisms)\nto `Cat`.\n-/\n@[simps!]\ndef map (f : S ‚ü∂ S') : StructuredArrow S' T ‚•§ StructuredArrow S T :=\n  Comma.mapLeft _ ((Functor.const _).map f)\n\n"}
{"name":"CategoryTheory.StructuredArrow.map_mk","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nS S' : D\nY : C\nT : CategoryTheory.Functor C D\nf : Quiver.Hom S' (T.obj Y)\ng : Quiver.Hom S S'\n‚ä¢ Eq ((CategoryTheory.StructuredArrow.map g).obj (CategoryTheory.StructuredArrow.mk f)) (CategoryTheory.StructuredArrow.mk (CategoryTheory.CategoryStruct.comp g f))","decl":"@[simp]\ntheorem map_mk {f : S' ‚ü∂ T.obj Y} (g : S ‚ü∂ S') : (map g).obj (mk f) = mk (g ‚â´ f) :=\n  rfl\n\n"}
{"name":"CategoryTheory.StructuredArrow.map_id","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nS : D\nT : CategoryTheory.Functor C D\nf : CategoryTheory.StructuredArrow S T\n‚ä¢ Eq ((CategoryTheory.StructuredArrow.map (CategoryTheory.CategoryStruct.id S)).obj f) f","decl":"@[simp]\ntheorem map_id {f : StructuredArrow S T} : (map (ùüô S)).obj f = f := by\n  rw [eq_mk f]\n  simp\n\n"}
{"name":"CategoryTheory.StructuredArrow.map_comp","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nS S' S'' : D\nT : CategoryTheory.Functor C D\nf : Quiver.Hom S S'\nf' : Quiver.Hom S' S''\nh : CategoryTheory.StructuredArrow S'' T\n‚ä¢ Eq ((CategoryTheory.StructuredArrow.map (CategoryTheory.CategoryStruct.comp f f')).obj h) ((CategoryTheory.StructuredArrow.map f).obj ((CategoryTheory.StructuredArrow.map f').obj h))","decl":"@[simp]\ntheorem map_comp {f : S ‚ü∂ S'} {f' : S' ‚ü∂ S''} {h : StructuredArrow S'' T} :\n    (map (f ‚â´ f')).obj h = (map f).obj ((map f').obj h) := by\n  rw [eq_mk h]\n  simp\n\n"}
{"name":"CategoryTheory.StructuredArrow.proj_reflectsIsomorphisms","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nS : D\nT : CategoryTheory.Functor C D\n‚ä¢ (CategoryTheory.StructuredArrow.proj S T).ReflectsIsomorphisms","decl":"instance proj_reflectsIsomorphisms : (proj S T).ReflectsIsomorphisms where\n  reflects {Y Z} f t :=\n    ‚ü®‚ü®StructuredArrow.homMk\n        (inv ((proj S T).map f))\n        (by rw [Functor.map_inv, IsIso.comp_inv_eq]; simp),\n      by constructor <;> apply CommaMorphism.ext <;> dsimp at t ‚ä¢ <;> simp‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.StructuredArrow.pre_obj_right","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nB : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} B\nS : D\nF : CategoryTheory.Functor B C\nG : CategoryTheory.Functor C D\nX : CategoryTheory.Comma (CategoryTheory.Functor.fromPUnit S) (F.comp G)\n‚ä¢ Eq ((CategoryTheory.StructuredArrow.pre S F G).obj X).right (F.obj X.right)","decl":"/-- The functor `(S, F ‚ãô G) ‚•§ (S, G)`. -/\n@[simps!]\ndef pre (S : D) (F : B ‚•§ C) (G : C ‚•§ D) : StructuredArrow S (F ‚ãô G) ‚•§ StructuredArrow S G :=\n  Comma.preRight _ F G\n\n"}
{"name":"CategoryTheory.StructuredArrow.pre_map_left","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nB : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} B\nS : D\nF : CategoryTheory.Functor B C\nG : CategoryTheory.Functor C D\nX‚úù Y‚úù : CategoryTheory.Comma (CategoryTheory.Functor.fromPUnit S) (F.comp G)\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.StructuredArrow.pre S F G).map f).left (CategoryTheory.CategoryStruct.id X‚úù.left)","decl":"/-- The functor `(S, F ‚ãô G) ‚•§ (S, G)`. -/\n@[simps!]\ndef pre (S : D) (F : B ‚•§ C) (G : C ‚•§ D) : StructuredArrow S (F ‚ãô G) ‚•§ StructuredArrow S G :=\n  Comma.preRight _ F G\n\n"}
{"name":"CategoryTheory.StructuredArrow.pre_obj_hom","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nB : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} B\nS : D\nF : CategoryTheory.Functor B C\nG : CategoryTheory.Functor C D\nX : CategoryTheory.Comma (CategoryTheory.Functor.fromPUnit S) (F.comp G)\n‚ä¢ Eq ((CategoryTheory.StructuredArrow.pre S F G).obj X).hom X.hom","decl":"/-- The functor `(S, F ‚ãô G) ‚•§ (S, G)`. -/\n@[simps!]\ndef pre (S : D) (F : B ‚•§ C) (G : C ‚•§ D) : StructuredArrow S (F ‚ãô G) ‚•§ StructuredArrow S G :=\n  Comma.preRight _ F G\n\n"}
{"name":"CategoryTheory.StructuredArrow.pre_map_right","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nB : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} B\nS : D\nF : CategoryTheory.Functor B C\nG : CategoryTheory.Functor C D\nX‚úù Y‚úù : CategoryTheory.Comma (CategoryTheory.Functor.fromPUnit S) (F.comp G)\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.StructuredArrow.pre S F G).map f).right (F.map f.right)","decl":"/-- The functor `(S, F ‚ãô G) ‚•§ (S, G)`. -/\n@[simps!]\ndef pre (S : D) (F : B ‚•§ C) (G : C ‚•§ D) : StructuredArrow S (F ‚ãô G) ‚•§ StructuredArrow S G :=\n  Comma.preRight _ F G\n\n"}
{"name":"CategoryTheory.StructuredArrow.pre_obj_left","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nB : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} B\nS : D\nF : CategoryTheory.Functor B C\nG : CategoryTheory.Functor C D\nX : CategoryTheory.Comma (CategoryTheory.Functor.fromPUnit S) (F.comp G)\n‚ä¢ Eq ((CategoryTheory.StructuredArrow.pre S F G).obj X).left X.left","decl":"/-- The functor `(S, F ‚ãô G) ‚•§ (S, G)`. -/\n@[simps!]\ndef pre (S : D) (F : B ‚•§ C) (G : C ‚•§ D) : StructuredArrow S (F ‚ãô G) ‚•§ StructuredArrow S G :=\n  Comma.preRight _ F G\n\n"}
{"name":"CategoryTheory.StructuredArrow.instFaithfulCompPre","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nB : Type u‚ÇÑ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} B\nS : D\nF : CategoryTheory.Functor B C\nG : CategoryTheory.Functor C D\ninst‚úù : F.Faithful\n‚ä¢ (CategoryTheory.StructuredArrow.pre S F G).Faithful","decl":"instance (S : D) (F : B ‚•§ C) (G : C ‚•§ D) [F.Faithful] : (pre S F G).Faithful :=\n  show (Comma.preRight _ _ _).Faithful from inferInstance\n\n"}
{"name":"CategoryTheory.StructuredArrow.instFullCompPre","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nB : Type u‚ÇÑ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} B\nS : D\nF : CategoryTheory.Functor B C\nG : CategoryTheory.Functor C D\ninst‚úù : F.Full\n‚ä¢ (CategoryTheory.StructuredArrow.pre S F G).Full","decl":"instance (S : D) (F : B ‚•§ C) (G : C ‚•§ D) [F.Full] : (pre S F G).Full :=\n  show (Comma.preRight _ _ _).Full from inferInstance\n\n"}
{"name":"CategoryTheory.StructuredArrow.instEssSurjCompPre","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nB : Type u‚ÇÑ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} B\nS : D\nF : CategoryTheory.Functor B C\nG : CategoryTheory.Functor C D\ninst‚úù : F.EssSurj\n‚ä¢ (CategoryTheory.StructuredArrow.pre S F G).EssSurj","decl":"instance (S : D) (F : B ‚•§ C) (G : C ‚•§ D) [F.EssSurj] : (pre S F G).EssSurj :=\n  show (Comma.preRight _ _ _).EssSurj from inferInstance\n\n"}
{"name":"CategoryTheory.StructuredArrow.isEquivalence_pre","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nB : Type u‚ÇÑ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} B\nS : D\nF : CategoryTheory.Functor B C\nG : CategoryTheory.Functor C D\ninst‚úù : F.IsEquivalence\n‚ä¢ (CategoryTheory.StructuredArrow.pre S F G).IsEquivalence","decl":"/-- If `F` is an equivalence, then so is the functor `(S, F ‚ãô G) ‚•§ (S, G)`. -/\ninstance isEquivalence_pre (S : D) (F : B ‚•§ C) (G : C ‚•§ D) [F.IsEquivalence] :\n    (pre S F G).IsEquivalence :=\n  Comma.isEquivalence_preRight _ _ _\n\n"}
{"name":"CategoryTheory.StructuredArrow.post_obj","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nB : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} B\nS : C\nF : CategoryTheory.Functor B C\nG : CategoryTheory.Functor C D\nX : CategoryTheory.StructuredArrow S F\n‚ä¢ Eq ((CategoryTheory.StructuredArrow.post S F G).obj X) (CategoryTheory.StructuredArrow.mk (G.map X.hom))","decl":"/-- The functor `(S, F) ‚•§ (G(S), F ‚ãô G)`. -/\n@[simps]\ndef post (S : C) (F : B ‚•§ C) (G : C ‚•§ D) :\n    StructuredArrow S F ‚•§ StructuredArrow (G.obj S) (F ‚ãô G) where\n  obj X := StructuredArrow.mk (G.map X.hom)\n  map f := StructuredArrow.homMk f.right (by simp [Functor.comp_map, ‚Üê G.map_comp, ‚Üê f.w])\n\n"}
{"name":"CategoryTheory.StructuredArrow.post_map","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nB : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} B\nS : C\nF : CategoryTheory.Functor B C\nG : CategoryTheory.Functor C D\nX‚úù Y‚úù : CategoryTheory.StructuredArrow S F\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.StructuredArrow.post S F G).map f) (CategoryTheory.StructuredArrow.homMk f.right ‚ãØ)","decl":"/-- The functor `(S, F) ‚•§ (G(S), F ‚ãô G)`. -/\n@[simps]\ndef post (S : C) (F : B ‚•§ C) (G : C ‚•§ D) :\n    StructuredArrow S F ‚•§ StructuredArrow (G.obj S) (F ‚ãô G) where\n  obj X := StructuredArrow.mk (G.map X.hom)\n  map f := StructuredArrow.homMk f.right (by simp [Functor.comp_map, ‚Üê G.map_comp, ‚Üê f.w])\n\n"}
{"name":"CategoryTheory.StructuredArrow.instFaithfulObjCompPost","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nB : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} B\nS : C\nF : CategoryTheory.Functor B C\nG : CategoryTheory.Functor C D\n‚ä¢ (CategoryTheory.StructuredArrow.post S F G).Faithful","decl":"instance (S : C) (F : B ‚•§ C) (G : C ‚•§ D) : (post S F G).Faithful where\n  map_injective {_ _} _ _ h := by simpa [ext_iff] using h\n\n"}
{"name":"CategoryTheory.StructuredArrow.instFullObjCompPostOfFaithful","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nB : Type u‚ÇÑ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} B\nS : C\nF : CategoryTheory.Functor B C\nG : CategoryTheory.Functor C D\ninst‚úù : G.Faithful\n‚ä¢ (CategoryTheory.StructuredArrow.post S F G).Full","decl":"instance (S : C) (F : B ‚•§ C) (G : C ‚•§ D) [G.Faithful] : (post S F G).Full where\n  map_surjective f := ‚ü®homMk f.right (G.map_injective (by simpa using f.w.symm)), by simp‚ü©\n\n"}
{"name":"CategoryTheory.StructuredArrow.instEssSurjObjCompPostOfFull","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nB : Type u‚ÇÑ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} B\nS : C\nF : CategoryTheory.Functor B C\nG : CategoryTheory.Functor C D\ninst‚úù : G.Full\n‚ä¢ (CategoryTheory.StructuredArrow.post S F G).EssSurj","decl":"instance (S : C) (F : B ‚•§ C) (G : C ‚•§ D) [G.Full] : (post S F G).EssSurj where\n  mem_essImage h := ‚ü®mk (G.preimage h.hom), ‚ü®isoMk (Iso.refl _) (by simp)‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.StructuredArrow.isEquivalence_post","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nB : Type u‚ÇÑ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} B\nS : C\nF : CategoryTheory.Functor B C\nG : CategoryTheory.Functor C D\ninst‚úù¬π : G.Full\ninst‚úù : G.Faithful\n‚ä¢ (CategoryTheory.StructuredArrow.post S F G).IsEquivalence","decl":"/-- If `G` is fully faithful, then `post S F G : (S, F) ‚•§ (G(S), F ‚ãô G)` is an equivalence. -/\ninstance isEquivalence_post (S : C) (F : B ‚•§ C) (G : C ‚•§ D) [G.Full] [G.Faithful] :\n    (post S F G).IsEquivalence where\n\n"}
{"name":"CategoryTheory.StructuredArrow.map‚ÇÇ_map_left","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nA : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} A\nB : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} B\nL : D\nR : CategoryTheory.Functor C D\nL' : B\nR' : CategoryTheory.Functor A B\nF : CategoryTheory.Functor C A\nG : CategoryTheory.Functor D B\nŒ± : Quiver.Hom L' (G.obj L)\nŒ≤ : Quiver.Hom (R.comp G) (F.comp R')\nX Y : CategoryTheory.Comma (CategoryTheory.Functor.fromPUnit L) R\nœÜ : Quiver.Hom X Y\n‚ä¢ Eq ((CategoryTheory.StructuredArrow.map‚ÇÇ Œ± Œ≤).map œÜ).left (CategoryTheory.CategoryStruct.id X.left)","decl":"/-- The functor `StructuredArrow L R ‚•§ StructuredArrow L' R'` that is deduced from\na natural transformation `R ‚ãô G ‚ü∂ F ‚ãô R'` and a morphism `L' ‚ü∂ G.obj L.` -/\n@[simps!]\ndef map‚ÇÇ : StructuredArrow L R ‚•§ StructuredArrow L' R' :=\n  Comma.map (F‚ÇÅ := ùü≠ (Discrete PUnit)) (Discrete.natTrans (fun _ => Œ±)) Œ≤\n\n"}
{"name":"CategoryTheory.StructuredArrow.map‚ÇÇ_map_right","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nA : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} A\nB : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} B\nL : D\nR : CategoryTheory.Functor C D\nL' : B\nR' : CategoryTheory.Functor A B\nF : CategoryTheory.Functor C A\nG : CategoryTheory.Functor D B\nŒ± : Quiver.Hom L' (G.obj L)\nŒ≤ : Quiver.Hom (R.comp G) (F.comp R')\nX Y : CategoryTheory.Comma (CategoryTheory.Functor.fromPUnit L) R\nœÜ : Quiver.Hom X Y\n‚ä¢ Eq ((CategoryTheory.StructuredArrow.map‚ÇÇ Œ± Œ≤).map œÜ).right (F.map œÜ.right)","decl":"/-- The functor `StructuredArrow L R ‚•§ StructuredArrow L' R'` that is deduced from\na natural transformation `R ‚ãô G ‚ü∂ F ‚ãô R'` and a morphism `L' ‚ü∂ G.obj L.` -/\n@[simps!]\ndef map‚ÇÇ : StructuredArrow L R ‚•§ StructuredArrow L' R' :=\n  Comma.map (F‚ÇÅ := ùü≠ (Discrete PUnit)) (Discrete.natTrans (fun _ => Œ±)) Œ≤\n\n"}
{"name":"CategoryTheory.StructuredArrow.map‚ÇÇ_obj_hom","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nA : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} A\nB : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} B\nL : D\nR : CategoryTheory.Functor C D\nL' : B\nR' : CategoryTheory.Functor A B\nF : CategoryTheory.Functor C A\nG : CategoryTheory.Functor D B\nŒ± : Quiver.Hom L' (G.obj L)\nŒ≤ : Quiver.Hom (R.comp G) (F.comp R')\nX : CategoryTheory.Comma (CategoryTheory.Functor.fromPUnit L) R\n‚ä¢ Eq ((CategoryTheory.StructuredArrow.map‚ÇÇ Œ± Œ≤).obj X).hom (CategoryTheory.CategoryStruct.comp Œ± (CategoryTheory.CategoryStruct.comp (G.map X.hom) (Œ≤.app X.right)))","decl":"/-- The functor `StructuredArrow L R ‚•§ StructuredArrow L' R'` that is deduced from\na natural transformation `R ‚ãô G ‚ü∂ F ‚ãô R'` and a morphism `L' ‚ü∂ G.obj L.` -/\n@[simps!]\ndef map‚ÇÇ : StructuredArrow L R ‚•§ StructuredArrow L' R' :=\n  Comma.map (F‚ÇÅ := ùü≠ (Discrete PUnit)) (Discrete.natTrans (fun _ => Œ±)) Œ≤\n\n"}
{"name":"CategoryTheory.StructuredArrow.map‚ÇÇ_obj_left","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nA : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} A\nB : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} B\nL : D\nR : CategoryTheory.Functor C D\nL' : B\nR' : CategoryTheory.Functor A B\nF : CategoryTheory.Functor C A\nG : CategoryTheory.Functor D B\nŒ± : Quiver.Hom L' (G.obj L)\nŒ≤ : Quiver.Hom (R.comp G) (F.comp R')\nX : CategoryTheory.Comma (CategoryTheory.Functor.fromPUnit L) R\n‚ä¢ Eq ((CategoryTheory.StructuredArrow.map‚ÇÇ Œ± Œ≤).obj X).left X.left","decl":"/-- The functor `StructuredArrow L R ‚•§ StructuredArrow L' R'` that is deduced from\na natural transformation `R ‚ãô G ‚ü∂ F ‚ãô R'` and a morphism `L' ‚ü∂ G.obj L.` -/\n@[simps!]\ndef map‚ÇÇ : StructuredArrow L R ‚•§ StructuredArrow L' R' :=\n  Comma.map (F‚ÇÅ := ùü≠ (Discrete PUnit)) (Discrete.natTrans (fun _ => Œ±)) Œ≤\n\n"}
{"name":"CategoryTheory.StructuredArrow.map‚ÇÇ_obj_right","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nA : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} A\nB : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} B\nL : D\nR : CategoryTheory.Functor C D\nL' : B\nR' : CategoryTheory.Functor A B\nF : CategoryTheory.Functor C A\nG : CategoryTheory.Functor D B\nŒ± : Quiver.Hom L' (G.obj L)\nŒ≤ : Quiver.Hom (R.comp G) (F.comp R')\nX : CategoryTheory.Comma (CategoryTheory.Functor.fromPUnit L) R\n‚ä¢ Eq ((CategoryTheory.StructuredArrow.map‚ÇÇ Œ± Œ≤).obj X).right (F.obj X.right)","decl":"/-- The functor `StructuredArrow L R ‚•§ StructuredArrow L' R'` that is deduced from\na natural transformation `R ‚ãô G ‚ü∂ F ‚ãô R'` and a morphism `L' ‚ü∂ G.obj L.` -/\n@[simps!]\ndef map‚ÇÇ : StructuredArrow L R ‚•§ StructuredArrow L' R' :=\n  Comma.map (F‚ÇÅ := ùü≠ (Discrete PUnit)) (Discrete.natTrans (fun _ => Œ±)) Œ≤\n\n"}
{"name":"CategoryTheory.StructuredArrow.faithful_map‚ÇÇ","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nA : Type u‚ÇÉ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} A\nB : Type u‚ÇÑ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} B\nL : D\nR : CategoryTheory.Functor C D\nL' : B\nR' : CategoryTheory.Functor A B\nF : CategoryTheory.Functor C A\nG : CategoryTheory.Functor D B\nŒ± : Quiver.Hom L' (G.obj L)\nŒ≤ : Quiver.Hom (R.comp G) (F.comp R')\ninst‚úù : F.Faithful\n‚ä¢ (CategoryTheory.StructuredArrow.map‚ÇÇ Œ± Œ≤).Faithful","decl":"instance faithful_map‚ÇÇ [F.Faithful] : (map‚ÇÇ Œ± Œ≤).Faithful := by\n  apply Comma.faithful_map\n\n"}
{"name":"CategoryTheory.StructuredArrow.full_map‚ÇÇ","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å∑ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù‚Å∂ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nA : Type u‚ÇÉ\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} A\nB : Type u‚ÇÑ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} B\nL : D\nR : CategoryTheory.Functor C D\nL' : B\nR' : CategoryTheory.Functor A B\nF : CategoryTheory.Functor C A\nG : CategoryTheory.Functor D B\nŒ± : Quiver.Hom L' (G.obj L)\nŒ≤ : Quiver.Hom (R.comp G) (F.comp R')\ninst‚úù¬≥ : G.Faithful\ninst‚úù¬≤ : F.Full\ninst‚úù¬π : CategoryTheory.IsIso Œ±\ninst‚úù : CategoryTheory.IsIso Œ≤\n‚ä¢ (CategoryTheory.StructuredArrow.map‚ÇÇ Œ± Œ≤).Full","decl":"instance full_map‚ÇÇ [G.Faithful] [F.Full] [IsIso Œ±] [IsIso Œ≤] : (map‚ÇÇ Œ± Œ≤).Full := by\n  apply Comma.full_map\n\n"}
{"name":"CategoryTheory.StructuredArrow.essSurj_map‚ÇÇ","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å∑ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù‚Å∂ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nA : Type u‚ÇÉ\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} A\nB : Type u‚ÇÑ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} B\nL : D\nR : CategoryTheory.Functor C D\nL' : B\nR' : CategoryTheory.Functor A B\nF : CategoryTheory.Functor C A\nG : CategoryTheory.Functor D B\nŒ± : Quiver.Hom L' (G.obj L)\nŒ≤ : Quiver.Hom (R.comp G) (F.comp R')\ninst‚úù¬≥ : F.EssSurj\ninst‚úù¬≤ : G.Full\ninst‚úù¬π : CategoryTheory.IsIso Œ±\ninst‚úù : CategoryTheory.IsIso Œ≤\n‚ä¢ (CategoryTheory.StructuredArrow.map‚ÇÇ Œ± Œ≤).EssSurj","decl":"instance essSurj_map‚ÇÇ [F.EssSurj] [G.Full] [IsIso Œ±] [IsIso Œ≤] : (map‚ÇÇ Œ± Œ≤).EssSurj := by\n  apply Comma.essSurj_map\n\n"}
{"name":"CategoryTheory.StructuredArrow.isEquivalenceMap‚ÇÇ","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å∏ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù‚Å∑ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nA : Type u‚ÇÉ\ninst‚úù‚Å∂ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} A\nB : Type u‚ÇÑ\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} B\nL : D\nR : CategoryTheory.Functor C D\nL' : B\nR' : CategoryTheory.Functor A B\nF : CategoryTheory.Functor C A\nG : CategoryTheory.Functor D B\nŒ± : Quiver.Hom L' (G.obj L)\nŒ≤ : Quiver.Hom (R.comp G) (F.comp R')\ninst‚úù‚Å¥ : F.IsEquivalence\ninst‚úù¬≥ : G.Faithful\ninst‚úù¬≤ : G.Full\ninst‚úù¬π : CategoryTheory.IsIso Œ±\ninst‚úù : CategoryTheory.IsIso Œ≤\n‚ä¢ (CategoryTheory.StructuredArrow.map‚ÇÇ Œ± Œ≤).IsEquivalence","decl":"noncomputable instance isEquivalenceMap‚ÇÇ\n    [F.IsEquivalence] [G.Faithful] [G.Full] [IsIso Œ±] [IsIso Œ≤] :\n    (map‚ÇÇ Œ± Œ≤).IsEquivalence := by\n  apply Comma.isEquivalenceMap\n\n"}
{"name":"CategoryTheory.StructuredArrow.IsUniversal.uniq","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nS : D\nT : CategoryTheory.Functor C D\nf g : CategoryTheory.StructuredArrow S T\nh : f.IsUniversal\nŒ∑ : Quiver.Hom f g\n‚ä¢ Eq Œ∑ (CategoryTheory.Limits.IsInitial.to h g)","decl":"theorem uniq (h : IsUniversal f) (Œ∑ : f ‚ü∂ g) : Œ∑ = h.to g :=\n  h.hom_ext Œ∑ (h.to g)\n\n"}
{"name":"CategoryTheory.StructuredArrow.IsUniversal.fac_assoc","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nS : D\nT : CategoryTheory.Functor C D\nf : CategoryTheory.StructuredArrow S T\nh‚úù : f.IsUniversal\ng : CategoryTheory.StructuredArrow S T\nZ : D\nh : Quiver.Hom (T.obj g.right) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f.hom (CategoryTheory.CategoryStruct.comp (T.map (h‚úù.desc g)) h)) (CategoryTheory.CategoryStruct.comp g.hom h)","decl":"/-- Any structured arrow factors through a universal arrow. -/\n@[reassoc (attr := simp)]\ntheorem fac (h : IsUniversal f) (g : StructuredArrow S T) :\n    f.hom ‚â´ T.map (h.desc g) = g.hom :=\n  Category.id_comp g.hom ‚ñ∏ (h.to g).w.symm\n\n"}
{"name":"CategoryTheory.StructuredArrow.IsUniversal.fac","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nS : D\nT : CategoryTheory.Functor C D\nf : CategoryTheory.StructuredArrow S T\nh : f.IsUniversal\ng : CategoryTheory.StructuredArrow S T\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f.hom (T.map (h.desc g))) g.hom","decl":"/-- Any structured arrow factors through a universal arrow. -/\n@[reassoc (attr := simp)]\ntheorem fac (h : IsUniversal f) (g : StructuredArrow S T) :\n    f.hom ‚â´ T.map (h.desc g) = g.hom :=\n  Category.id_comp g.hom ‚ñ∏ (h.to g).w.symm\n\n"}
{"name":"CategoryTheory.StructuredArrow.IsUniversal.hom_desc","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nS : D\nT : CategoryTheory.Functor C D\nf : CategoryTheory.StructuredArrow S T\nh : f.IsUniversal\nc : C\nŒ∑ : Quiver.Hom f.right c\n‚ä¢ Eq Œ∑ (h.desc (CategoryTheory.StructuredArrow.mk (CategoryTheory.CategoryStruct.comp f.hom (T.map Œ∑))))","decl":"theorem hom_desc (h : IsUniversal f) {c : C} (Œ∑ : f.right ‚ü∂ c) :\n    Œ∑ = h.desc (mk <| f.hom ‚â´ T.map Œ∑) :=\n  let g := mk <| f.hom ‚â´ T.map Œ∑\n  congrArg CommaMorphism.right (h.hom_ext (homMk Œ∑ rfl : f ‚ü∂ g) (h.to g))\n\n"}
{"name":"CategoryTheory.StructuredArrow.IsUniversal.hom_ext","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nS : D\nT : CategoryTheory.Functor C D\nf : CategoryTheory.StructuredArrow S T\nh : f.IsUniversal\nc : C\nŒ∑ Œ∑' : Quiver.Hom f.right c\nw : Eq (CategoryTheory.CategoryStruct.comp f.hom (T.map Œ∑)) (CategoryTheory.CategoryStruct.comp f.hom (T.map Œ∑'))\n‚ä¢ Eq Œ∑ Œ∑'","decl":"/-- Two morphisms out of a universal `T`-structured arrow are equal if their image under `T` are\nequal after precomposing the universal arrow. -/\ntheorem hom_ext (h : IsUniversal f) {c : C} {Œ∑ Œ∑' : f.right ‚ü∂ c}\n    (w : f.hom ‚â´ T.map Œ∑ = f.hom ‚â´ T.map Œ∑') : Œ∑ = Œ∑' := by\n  rw [h.hom_desc Œ∑, h.hom_desc Œ∑', w]\n\n"}
{"name":"CategoryTheory.StructuredArrow.IsUniversal.existsUnique","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nS : D\nT : CategoryTheory.Functor C D\nf : CategoryTheory.StructuredArrow S T\nh : f.IsUniversal\ng : CategoryTheory.StructuredArrow S T\n‚ä¢ ExistsUnique fun Œ∑ => Eq (CategoryTheory.CategoryStruct.comp f.hom (T.map Œ∑)) g.hom","decl":"theorem existsUnique (h : IsUniversal f) (g : StructuredArrow S T) :\n    ‚àÉ! Œ∑ : f.right ‚ü∂ g.right, f.hom ‚â´ T.map Œ∑ = g.hom :=\n  ‚ü®h.desc g, h.fac g, fun f w ‚Ü¶ h.hom_ext <| by simp [w]‚ü©\n\n"}
{"name":"CategoryTheory.CostructuredArrow.proj_obj","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nS : CategoryTheory.Functor C D\nT : D\nX : CategoryTheory.Comma S (CategoryTheory.Functor.fromPUnit T)\n‚ä¢ Eq ((CategoryTheory.CostructuredArrow.proj S T).obj X) X.left","decl":"/-- The obvious projection functor from costructured arrows. -/\n@[simps!]\ndef proj (S : C ‚•§ D) (T : D) : CostructuredArrow S T ‚•§ C :=\n  Comma.fst _ _\n\n"}
{"name":"CategoryTheory.CostructuredArrow.proj_map","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nS : CategoryTheory.Functor C D\nT : D\nX‚úù Y‚úù : CategoryTheory.Comma S (CategoryTheory.Functor.fromPUnit T)\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.CostructuredArrow.proj S T).map f) f.left","decl":"/-- The obvious projection functor from costructured arrows. -/\n@[simps!]\ndef proj (S : C ‚•§ D) (T : D) : CostructuredArrow S T ‚•§ C :=\n  Comma.fst _ _\n\n"}
{"name":"CategoryTheory.CostructuredArrow.hom_ext_iff","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nT : D\nS : CategoryTheory.Functor C D\nX Y : CategoryTheory.CostructuredArrow S T\nf g : Quiver.Hom X Y\n‚ä¢ Iff (Eq f g) (Eq f.left g.left)","decl":"@[ext]\nlemma hom_ext {X Y : CostructuredArrow S T} (f g : X ‚ü∂ Y) (h : f.left = g.left) : f = g :=\n  CommaMorphism.ext h (Subsingleton.elim _ _)\n\n"}
{"name":"CategoryTheory.CostructuredArrow.hom_ext","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nT : D\nS : CategoryTheory.Functor C D\nX Y : CategoryTheory.CostructuredArrow S T\nf g : Quiver.Hom X Y\nh : Eq f.left g.left\n‚ä¢ Eq f g","decl":"@[ext]\nlemma hom_ext {X Y : CostructuredArrow S T} (f g : X ‚ü∂ Y) (h : f.left = g.left) : f = g :=\n  CommaMorphism.ext h (Subsingleton.elim _ _)\n\n"}
{"name":"CategoryTheory.CostructuredArrow.hom_eq_iff","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nT : D\nS : CategoryTheory.Functor C D\nX Y : CategoryTheory.CostructuredArrow S T\nf g : Quiver.Hom X Y\n‚ä¢ Iff (Eq f g) (Eq f.left g.left)","decl":"@[simp]\ntheorem hom_eq_iff {X Y : CostructuredArrow S T} (f g : X ‚ü∂ Y) : f = g ‚Üî f.left = g.left :=\n  ‚ü®fun h ‚Ü¶ by rw [h], hom_ext _ _‚ü©\n\n"}
{"name":"CategoryTheory.CostructuredArrow.mk_left","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nT : D\nY : C\nS : CategoryTheory.Functor C D\nf : Quiver.Hom (S.obj Y) T\n‚ä¢ Eq (CategoryTheory.CostructuredArrow.mk f).left Y","decl":"@[simp]\ntheorem mk_left (f : S.obj Y ‚ü∂ T) : (mk f).left = Y :=\n  rfl\n\n"}
{"name":"CategoryTheory.CostructuredArrow.mk_right","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nT : D\nY : C\nS : CategoryTheory.Functor C D\nf : Quiver.Hom (S.obj Y) T\n‚ä¢ Eq (CategoryTheory.CostructuredArrow.mk f).right { as := PUnit.unit }","decl":"@[simp]\ntheorem mk_right (f : S.obj Y ‚ü∂ T) : (mk f).right = ‚ü®‚ü®‚ü©‚ü© :=\n  rfl\n\n"}
{"name":"CategoryTheory.CostructuredArrow.mk_hom_eq_self","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nT : D\nY : C\nS : CategoryTheory.Functor C D\nf : Quiver.Hom (S.obj Y) T\n‚ä¢ Eq (CategoryTheory.CostructuredArrow.mk f).hom f","decl":"@[simp]\ntheorem mk_hom_eq_self (f : S.obj Y ‚ü∂ T) : (mk f).hom = f :=\n  rfl\n\n-- @[reassoc (attr := simp)] Porting note: simp can solve these\n"}
{"name":"CategoryTheory.CostructuredArrow.w","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nT : D\nS : CategoryTheory.Functor C D\nA B : CategoryTheory.CostructuredArrow S T\nf : Quiver.Hom A B\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (S.map f.left) B.hom) A.hom","decl":"@[reassoc]\ntheorem w {A B : CostructuredArrow S T} (f : A ‚ü∂ B) : S.map f.left ‚â´ B.hom = A.hom := by simp\n\n"}
{"name":"CategoryTheory.CostructuredArrow.w_assoc","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nT : D\nS : CategoryTheory.Functor C D\nA B : CategoryTheory.CostructuredArrow S T\nf : Quiver.Hom A B\nZ : D\nh : Quiver.Hom ((CategoryTheory.Functor.fromPUnit T).obj B.right) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (S.map f.left) (CategoryTheory.CategoryStruct.comp B.hom h)) (CategoryTheory.CategoryStruct.comp A.hom h)","decl":"@[reassoc]\ntheorem w {A B : CostructuredArrow S T} (f : A ‚ü∂ B) : S.map f.left ‚â´ B.hom = A.hom := by simp\n\n"}
{"name":"CategoryTheory.CostructuredArrow.comp_left","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nT : D\nS : CategoryTheory.Functor C D\nX Y Z : CategoryTheory.CostructuredArrow S T\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f g).left (CategoryTheory.CategoryStruct.comp f.left g.left)","decl":"@[simp]\ntheorem comp_left {X Y Z : CostructuredArrow S T} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) :\n    (f ‚â´ g).left = f.left ‚â´ g.left := rfl\n\n"}
{"name":"CategoryTheory.CostructuredArrow.id_left","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nT : D\nS : CategoryTheory.Functor C D\nX : CategoryTheory.CostructuredArrow S T\n‚ä¢ Eq (CategoryTheory.CategoryStruct.id X).left (CategoryTheory.CategoryStruct.id X.left)","decl":"@[simp]\ntheorem id_left (X : CostructuredArrow S T) : (ùüô X : X ‚ü∂ X).left = ùüô X.left := rfl\n\n"}
{"name":"CategoryTheory.CostructuredArrow.eqToHom_left","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nT : D\nS : CategoryTheory.Functor C D\nX Y : CategoryTheory.CostructuredArrow S T\nh : Eq X Y\n‚ä¢ Eq (CategoryTheory.eqToHom h).left (CategoryTheory.eqToHom ‚ãØ)","decl":"@[simp]\ntheorem eqToHom_left {X Y : CostructuredArrow S T} (h : X = Y) :\n    (eqToHom h).left = eqToHom (by rw [h]) := by\n  subst h\n  simp only [eqToHom_refl, id_left]\n\n"}
{"name":"CategoryTheory.CostructuredArrow.right_eq_id","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nT : D\nS : CategoryTheory.Functor C D\nX Y : CategoryTheory.CostructuredArrow S T\nf : Quiver.Hom X Y\n‚ä¢ Eq f.right (CategoryTheory.CategoryStruct.id X.right)","decl":"@[simp]\ntheorem right_eq_id {X Y : CostructuredArrow S T} (f : X ‚ü∂ Y) : f.right = ùüô X.right := rfl\n\n"}
{"name":"CategoryTheory.CostructuredArrow.homMk_left","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nT : D\nS : CategoryTheory.Functor C D\nf f' : CategoryTheory.CostructuredArrow S T\ng : Quiver.Hom f.left f'.left\nw : autoParam (Eq (CategoryTheory.CategoryStruct.comp (S.map g) f'.hom) f.hom) _auto‚úù\n‚ä¢ Eq (CategoryTheory.CostructuredArrow.homMk g w).left g","decl":"/-- To construct a morphism of costructured arrows,\nwe need a morphism of the objects underlying the source,\nand to check that the triangle commutes.\n-/\n@[simps! left]\ndef homMk {f f' : CostructuredArrow S T} (g : f.left ‚ü∂ f'.left)\n    (w : S.map g ‚â´ f'.hom = f.hom := by aesop_cat) : f ‚ü∂ f' where\n  left := g\n  right := ùüô f.right\n\n"}
{"name":"CategoryTheory.CostructuredArrow.homMk_surjective","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nT : D\nS : CategoryTheory.Functor C D\nf f' : CategoryTheory.CostructuredArrow S T\nœÜ : Quiver.Hom f f'\n‚ä¢ Exists fun œà => Exists fun hœà => Eq œÜ (CategoryTheory.CostructuredArrow.homMk œà hœà)","decl":"theorem homMk_surjective {f f' : CostructuredArrow S T} (œÜ : f ‚ü∂ f') :\n    ‚àÉ (œà : f.left ‚ü∂ f'.left) (hœà : S.map œà ‚â´ f'.hom = f.hom),\n      œÜ = CostructuredArrow.homMk œà hœà :=\n  ‚ü®œÜ.left, CostructuredArrow.w œÜ, rfl‚ü©\n\n"}
{"name":"CategoryTheory.CostructuredArrow.homMk'_left","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nT : D\nY' : C\nS : CategoryTheory.Functor C D\nf : CategoryTheory.CostructuredArrow S T\ng : Quiver.Hom Y' f.left\n‚ä¢ Eq (f.homMk' g).left g","decl":"/-- Given a costructured arrow `S(Y) ‚ü∂ X`, and an arrow `Y' ‚ü∂ Y'`, we can construct a morphism of\n    costructured arrows given by `(S(Y) ‚ü∂ X) ‚ü∂ (S(Y') ‚ü∂ S(Y) ‚ü∂ X)`. -/\n@[simps]\ndef homMk' (f : CostructuredArrow S T) (g : Y' ‚ü∂ f.left) : mk (S.map g ‚â´ f.hom) ‚ü∂ f where\n  left := g\n  right := ùüô _\n\n"}
{"name":"CategoryTheory.CostructuredArrow.homMk'_right","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nT : D\nY' : C\nS : CategoryTheory.Functor C D\nf : CategoryTheory.CostructuredArrow S T\ng : Quiver.Hom Y' f.left\n‚ä¢ Eq (f.homMk' g).right (CategoryTheory.CategoryStruct.id (CategoryTheory.CostructuredArrow.mk (CategoryTheory.CategoryStruct.comp (S.map g) f.hom)).right)","decl":"/-- Given a costructured arrow `S(Y) ‚ü∂ X`, and an arrow `Y' ‚ü∂ Y'`, we can construct a morphism of\n    costructured arrows given by `(S(Y) ‚ü∂ X) ‚ü∂ (S(Y') ‚ü∂ S(Y) ‚ü∂ X)`. -/\n@[simps]\ndef homMk' (f : CostructuredArrow S T) (g : Y' ‚ü∂ f.left) : mk (S.map g ‚â´ f.hom) ‚ü∂ f where\n  left := g\n  right := ùüô _\n\n"}
{"name":"CategoryTheory.CostructuredArrow.homMk'_id","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nT : D\nS : CategoryTheory.Functor C D\nf : CategoryTheory.CostructuredArrow S T\n‚ä¢ Eq (f.homMk' (CategoryTheory.CategoryStruct.id f.left)) (CategoryTheory.eqToHom ‚ãØ)","decl":"lemma homMk'_id (f : CostructuredArrow S T) : homMk' f (ùüô f.left) = eqToHom (by aesop_cat) := by\n  ext\n  simp [eqToHom_left]\n\n"}
{"name":"CategoryTheory.CostructuredArrow.homMk'_mk_id","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nT : D\nY : C\nS : CategoryTheory.Functor C D\nf : Quiver.Hom (S.obj Y) T\n‚ä¢ Eq ((CategoryTheory.CostructuredArrow.mk f).homMk' (CategoryTheory.CategoryStruct.id Y)) (CategoryTheory.eqToHom ‚ãØ)","decl":"lemma homMk'_mk_id (f : S.obj Y ‚ü∂ T) : homMk' (mk f) (ùüô Y) = eqToHom (by simp) :=\n  homMk'_id _\n\n"}
{"name":"CategoryTheory.CostructuredArrow.homMk'_comp","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nT : D\nY' Y'' : C\nS : CategoryTheory.Functor C D\nf : CategoryTheory.CostructuredArrow S T\ng : Quiver.Hom Y' f.left\ng' : Quiver.Hom Y'' Y'\n‚ä¢ Eq (f.homMk' (CategoryTheory.CategoryStruct.comp g' g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ‚ãØ) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.CostructuredArrow.mk (CategoryTheory.CategoryStruct.comp (S.map g) f.hom)).homMk' g') (f.homMk' g)))","decl":"lemma homMk'_comp (f : CostructuredArrow S T) (g : Y' ‚ü∂ f.left) (g' : Y'' ‚ü∂ Y') :\n    homMk' f (g' ‚â´ g) = eqToHom (by simp) ‚â´ homMk' (mk (S.map g ‚â´ f.hom)) g' ‚â´ homMk' f g := by\n  ext\n  simp [eqToHom_left]\n\n"}
{"name":"CategoryTheory.CostructuredArrow.homMk'_mk_comp","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nT : D\nY Y' Y'' : C\nS : CategoryTheory.Functor C D\nf : Quiver.Hom (S.obj Y) T\ng : Quiver.Hom Y' Y\ng' : Quiver.Hom Y'' Y'\n‚ä¢ Eq ((CategoryTheory.CostructuredArrow.mk f).homMk' (CategoryTheory.CategoryStruct.comp g' g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ‚ãØ) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.CostructuredArrow.mk (CategoryTheory.CategoryStruct.comp (S.map g) f)).homMk' g') ((CategoryTheory.CostructuredArrow.mk f).homMk' g)))","decl":"lemma homMk'_mk_comp (f : S.obj Y ‚ü∂ T) (g : Y' ‚ü∂ Y) (g' : Y'' ‚ü∂ Y') :\n    homMk' (mk f) (g' ‚â´ g) = eqToHom (by simp) ‚â´ homMk' (mk (S.map g ‚â´ f)) g' ‚â´ homMk' (mk f) g :=\n  homMk'_comp _ _ _\n\n"}
{"name":"CategoryTheory.CostructuredArrow.mkPrecomp_left","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nT : D\nY Y' : C\nS : CategoryTheory.Functor C D\nf : Quiver.Hom (S.obj Y) T\ng : Quiver.Hom Y' Y\n‚ä¢ Eq (CategoryTheory.CostructuredArrow.mkPrecomp f g).left g","decl":"/-- Variant of `homMk'` where both objects are applications of `mk`. -/\n@[simps]\ndef mkPrecomp (f : S.obj Y ‚ü∂ T) (g : Y' ‚ü∂ Y) : mk (S.map g ‚â´ f) ‚ü∂ mk f where\n  left := g\n  right := ùüô _\n\n"}
{"name":"CategoryTheory.CostructuredArrow.mkPrecomp_right","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nT : D\nY Y' : C\nS : CategoryTheory.Functor C D\nf : Quiver.Hom (S.obj Y) T\ng : Quiver.Hom Y' Y\n‚ä¢ Eq (CategoryTheory.CostructuredArrow.mkPrecomp f g).right (CategoryTheory.CategoryStruct.id (CategoryTheory.CostructuredArrow.mk (CategoryTheory.CategoryStruct.comp (S.map g) f)).right)","decl":"/-- Variant of `homMk'` where both objects are applications of `mk`. -/\n@[simps]\ndef mkPrecomp (f : S.obj Y ‚ü∂ T) (g : Y' ‚ü∂ Y) : mk (S.map g ‚â´ f) ‚ü∂ mk f where\n  left := g\n  right := ùüô _\n\n"}
{"name":"CategoryTheory.CostructuredArrow.mkPrecomp_id","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nT : D\nY : C\nS : CategoryTheory.Functor C D\nf : Quiver.Hom (S.obj Y) T\n‚ä¢ Eq (CategoryTheory.CostructuredArrow.mkPrecomp f (CategoryTheory.CategoryStruct.id Y)) (CategoryTheory.eqToHom ‚ãØ)","decl":"lemma mkPrecomp_id (f : S.obj Y ‚ü∂ T) : mkPrecomp f (ùüô Y) = eqToHom (by simp) := by simp\n"}
{"name":"CategoryTheory.CostructuredArrow.mkPrecomp_comp","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nT : D\nY Y' Y'' : C\nS : CategoryTheory.Functor C D\nf : Quiver.Hom (S.obj Y) T\ng : Quiver.Hom Y' Y\ng' : Quiver.Hom Y'' Y'\n‚ä¢ Eq (CategoryTheory.CostructuredArrow.mkPrecomp f (CategoryTheory.CategoryStruct.comp g' g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ‚ãØ) (CategoryTheory.CategoryStruct.comp (CategoryTheory.CostructuredArrow.mkPrecomp (CategoryTheory.CategoryStruct.comp (S.map g) f) g') (CategoryTheory.CostructuredArrow.mkPrecomp f g)))","decl":"lemma mkPrecomp_comp (f : S.obj Y ‚ü∂ T) (g : Y' ‚ü∂ Y) (g' : Y'' ‚ü∂ Y') :\n    mkPrecomp f (g' ‚â´ g) = eqToHom (by simp) ‚â´ mkPrecomp (S.map g ‚â´ f) g' ‚â´ mkPrecomp f g := by\n  simp\n\n"}
{"name":"CategoryTheory.CostructuredArrow.isoMk_hom_left","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nT : D\nS : CategoryTheory.Functor C D\nf f' : CategoryTheory.CostructuredArrow S T\ng : CategoryTheory.Iso f.left f'.left\nw : autoParam (Eq (CategoryTheory.CategoryStruct.comp (S.map g.hom) f'.hom) f.hom) _auto‚úù\n‚ä¢ Eq (CategoryTheory.CostructuredArrow.isoMk g w).hom.left g.hom","decl":"/-- To construct an isomorphism of costructured arrows,\nwe need an isomorphism of the objects underlying the source,\nand to check that the triangle commutes.\n-/\n@[simps! hom_left inv_left]\ndef isoMk {f f' : CostructuredArrow S T} (g : f.left ‚âÖ f'.left)\n    (w : S.map g.hom ‚â´ f'.hom = f.hom := by aesop_cat) : f ‚âÖ f' :=\n  Comma.isoMk g (eqToIso (by ext)) (by simpa using w)\n\n"}
{"name":"CategoryTheory.CostructuredArrow.isoMk_inv_left","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nT : D\nS : CategoryTheory.Functor C D\nf f' : CategoryTheory.CostructuredArrow S T\ng : CategoryTheory.Iso f.left f'.left\nw : autoParam (Eq (CategoryTheory.CategoryStruct.comp (S.map g.hom) f'.hom) f.hom) _auto‚úù\n‚ä¢ Eq (CategoryTheory.CostructuredArrow.isoMk g w).inv.left g.inv","decl":"/-- To construct an isomorphism of costructured arrows,\nwe need an isomorphism of the objects underlying the source,\nand to check that the triangle commutes.\n-/\n@[simps! hom_left inv_left]\ndef isoMk {f f' : CostructuredArrow S T} (g : f.left ‚âÖ f'.left)\n    (w : S.map g.hom ‚â´ f'.hom = f.hom := by aesop_cat) : f ‚âÖ f' :=\n  Comma.isoMk g (eqToIso (by ext)) (by simpa using w)\n\n"}
{"name":"CategoryTheory.CostructuredArrow.ext","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nT : D\nS : CategoryTheory.Functor C D\nA B : CategoryTheory.CostructuredArrow S T\nf g : Quiver.Hom A B\nh : Eq f.left g.left\n‚ä¢ Eq f g","decl":"theorem ext {A B : CostructuredArrow S T} (f g : A ‚ü∂ B) (h : f.left = g.left) : f = g :=\n  CommaMorphism.ext h (Subsingleton.elim _ _)\n\n"}
{"name":"CategoryTheory.CostructuredArrow.ext_iff","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nT : D\nS : CategoryTheory.Functor C D\nA B : CategoryTheory.CostructuredArrow S T\nf g : Quiver.Hom A B\n‚ä¢ Iff (Eq f g) (Eq f.left g.left)","decl":"theorem ext_iff {A B : CostructuredArrow S T} (f g : A ‚ü∂ B) : f = g ‚Üî f.left = g.left :=\n  ‚ü®fun h => h ‚ñ∏ rfl, ext f g‚ü©\n\n"}
{"name":"CategoryTheory.CostructuredArrow.proj_faithful","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nT : D\nS : CategoryTheory.Functor C D\n‚ä¢ (CategoryTheory.CostructuredArrow.proj S T).Faithful","decl":"instance proj_faithful : (proj S T).Faithful where map_injective {_ _} := ext\n\n"}
{"name":"CategoryTheory.CostructuredArrow.mono_of_mono_left","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nT : D\nS : CategoryTheory.Functor C D\nA B : CategoryTheory.CostructuredArrow S T\nf : Quiver.Hom A B\nh : CategoryTheory.Mono f.left\n‚ä¢ CategoryTheory.Mono f","decl":"theorem mono_of_mono_left {A B : CostructuredArrow S T} (f : A ‚ü∂ B) [h : Mono f.left] : Mono f :=\n  (proj S T).mono_of_mono_map h\n\n"}
{"name":"CategoryTheory.CostructuredArrow.epi_of_epi_left","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nT : D\nS : CategoryTheory.Functor C D\nA B : CategoryTheory.CostructuredArrow S T\nf : Quiver.Hom A B\nh : CategoryTheory.Epi f.left\n‚ä¢ CategoryTheory.Epi f","decl":"/-- The converse of this is true with additional assumptions, see `epi_iff_epi_left`. -/\ntheorem epi_of_epi_left {A B : CostructuredArrow S T} (f : A ‚ü∂ B) [h : Epi f.left] : Epi f :=\n  (proj S T).epi_of_epi_map h\n\n"}
{"name":"CategoryTheory.CostructuredArrow.mono_homMk","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nT : D\nS : CategoryTheory.Functor C D\nA B : CategoryTheory.CostructuredArrow S T\nf : Quiver.Hom A.left B.left\nw : Eq (CategoryTheory.CategoryStruct.comp (S.map f) B.hom) A.hom\nh : CategoryTheory.Mono f\n‚ä¢ CategoryTheory.Mono (CategoryTheory.CostructuredArrow.homMk f w)","decl":"instance mono_homMk {A B : CostructuredArrow S T} (f : A.left ‚ü∂ B.left) (w) [h : Mono f] :\n    Mono (homMk f w) :=\n  (proj S T).mono_of_mono_map h\n\n"}
{"name":"CategoryTheory.CostructuredArrow.epi_homMk","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nT : D\nS : CategoryTheory.Functor C D\nA B : CategoryTheory.CostructuredArrow S T\nf : Quiver.Hom A.left B.left\nw : Eq (CategoryTheory.CategoryStruct.comp (S.map f) B.hom) A.hom\nh : CategoryTheory.Epi f\n‚ä¢ CategoryTheory.Epi (CategoryTheory.CostructuredArrow.homMk f w)","decl":"instance epi_homMk {A B : CostructuredArrow S T} (f : A.left ‚ü∂ B.left) (w) [h : Epi f] :\n    Epi (homMk f w) :=\n  (proj S T).epi_of_epi_map h\n\n"}
{"name":"CategoryTheory.CostructuredArrow.eq_mk","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nT : D\nS : CategoryTheory.Functor C D\nf : CategoryTheory.CostructuredArrow S T\n‚ä¢ Eq f (CategoryTheory.CostructuredArrow.mk f.hom)","decl":"/-- Eta rule for costructured arrows. Prefer `CostructuredArrow.eta` for rewriting, as equality of\n    objects tends to cause problems. -/\ntheorem eq_mk (f : CostructuredArrow S T) : f = mk f.hom :=\n  rfl\n\n"}
{"name":"CategoryTheory.CostructuredArrow.eta_hom_left","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nT : D\nS : CategoryTheory.Functor C D\nf : CategoryTheory.CostructuredArrow S T\n‚ä¢ Eq f.eta.hom.left (CategoryTheory.CategoryStruct.id f.left)","decl":"/-- Eta rule for costructured arrows. -/\n@[simps! hom_left inv_left]\ndef eta (f : CostructuredArrow S T) : f ‚âÖ mk f.hom :=\n  isoMk (Iso.refl _)\n\n"}
{"name":"CategoryTheory.CostructuredArrow.eta_inv_left","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nT : D\nS : CategoryTheory.Functor C D\nf : CategoryTheory.CostructuredArrow S T\n‚ä¢ Eq f.eta.inv.left (CategoryTheory.CategoryStruct.id f.left)","decl":"/-- Eta rule for costructured arrows. -/\n@[simps! hom_left inv_left]\ndef eta (f : CostructuredArrow S T) : f ‚âÖ mk f.hom :=\n  isoMk (Iso.refl _)\n\n"}
{"name":"CategoryTheory.CostructuredArrow.mk_surjective","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nT : D\nS : CategoryTheory.Functor C D\nf : CategoryTheory.CostructuredArrow S T\n‚ä¢ Exists fun Y => Exists fun g => Eq f (CategoryTheory.CostructuredArrow.mk g)","decl":"lemma mk_surjective (f : CostructuredArrow S T) :\n    ‚àÉ (Y : C) (g : S.obj Y ‚ü∂ T), f = mk g :=\n  ‚ü®_, _, eq_mk f‚ü©\n\n"}
{"name":"CategoryTheory.CostructuredArrow.map_map_left","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nT T' : D\nS : CategoryTheory.Functor C D\nf‚úù : Quiver.Hom T T'\nX‚úù Y‚úù : CategoryTheory.Comma S (CategoryTheory.Functor.fromPUnit T)\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.CostructuredArrow.map f‚úù).map f).left f.left","decl":"/-- A morphism between target objects `T ‚ü∂ T'`\ncovariantly induces a functor between costructured arrows,\n`CostructuredArrow S T ‚•§ CostructuredArrow S T'`.\n\nIdeally this would be described as a 2-functor from `D`\n(promoted to a 2-category with equations as 2-morphisms)\nto `Cat`.\n-/\n@[simps!]\ndef map (f : T ‚ü∂ T') : CostructuredArrow S T ‚•§ CostructuredArrow S T' :=\n  Comma.mapRight _ ((Functor.const _).map f)\n\n"}
{"name":"CategoryTheory.CostructuredArrow.map_map_right","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nT T' : D\nS : CategoryTheory.Functor C D\nf‚úù : Quiver.Hom T T'\nX‚úù Y‚úù : CategoryTheory.Comma S (CategoryTheory.Functor.fromPUnit T)\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.CostructuredArrow.map f‚úù).map f).right (CategoryTheory.CategoryStruct.id X‚úù.right)","decl":"/-- A morphism between target objects `T ‚ü∂ T'`\ncovariantly induces a functor between costructured arrows,\n`CostructuredArrow S T ‚•§ CostructuredArrow S T'`.\n\nIdeally this would be described as a 2-functor from `D`\n(promoted to a 2-category with equations as 2-morphisms)\nto `Cat`.\n-/\n@[simps!]\ndef map (f : T ‚ü∂ T') : CostructuredArrow S T ‚•§ CostructuredArrow S T' :=\n  Comma.mapRight _ ((Functor.const _).map f)\n\n"}
{"name":"CategoryTheory.CostructuredArrow.map_obj_left","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nT T' : D\nS : CategoryTheory.Functor C D\nf : Quiver.Hom T T'\nX : CategoryTheory.Comma S (CategoryTheory.Functor.fromPUnit T)\n‚ä¢ Eq ((CategoryTheory.CostructuredArrow.map f).obj X).left X.left","decl":"/-- A morphism between target objects `T ‚ü∂ T'`\ncovariantly induces a functor between costructured arrows,\n`CostructuredArrow S T ‚•§ CostructuredArrow S T'`.\n\nIdeally this would be described as a 2-functor from `D`\n(promoted to a 2-category with equations as 2-morphisms)\nto `Cat`.\n-/\n@[simps!]\ndef map (f : T ‚ü∂ T') : CostructuredArrow S T ‚•§ CostructuredArrow S T' :=\n  Comma.mapRight _ ((Functor.const _).map f)\n\n"}
{"name":"CategoryTheory.CostructuredArrow.map_obj_right","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nT T' : D\nS : CategoryTheory.Functor C D\nf : Quiver.Hom T T'\nX : CategoryTheory.Comma S (CategoryTheory.Functor.fromPUnit T)\n‚ä¢ Eq ((CategoryTheory.CostructuredArrow.map f).obj X).right X.right","decl":"/-- A morphism between target objects `T ‚ü∂ T'`\ncovariantly induces a functor between costructured arrows,\n`CostructuredArrow S T ‚•§ CostructuredArrow S T'`.\n\nIdeally this would be described as a 2-functor from `D`\n(promoted to a 2-category with equations as 2-morphisms)\nto `Cat`.\n-/\n@[simps!]\ndef map (f : T ‚ü∂ T') : CostructuredArrow S T ‚•§ CostructuredArrow S T' :=\n  Comma.mapRight _ ((Functor.const _).map f)\n\n"}
{"name":"CategoryTheory.CostructuredArrow.map_obj_hom","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nT T' : D\nS : CategoryTheory.Functor C D\nf : Quiver.Hom T T'\nX : CategoryTheory.Comma S (CategoryTheory.Functor.fromPUnit T)\n‚ä¢ Eq ((CategoryTheory.CostructuredArrow.map f).obj X).hom (CategoryTheory.CategoryStruct.comp X.hom f)","decl":"/-- A morphism between target objects `T ‚ü∂ T'`\ncovariantly induces a functor between costructured arrows,\n`CostructuredArrow S T ‚•§ CostructuredArrow S T'`.\n\nIdeally this would be described as a 2-functor from `D`\n(promoted to a 2-category with equations as 2-morphisms)\nto `Cat`.\n-/\n@[simps!]\ndef map (f : T ‚ü∂ T') : CostructuredArrow S T ‚•§ CostructuredArrow S T' :=\n  Comma.mapRight _ ((Functor.const _).map f)\n\n"}
{"name":"CategoryTheory.CostructuredArrow.map_mk","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nT T' : D\nY : C\nS : CategoryTheory.Functor C D\nf : Quiver.Hom (S.obj Y) T\ng : Quiver.Hom T T'\n‚ä¢ Eq ((CategoryTheory.CostructuredArrow.map g).obj (CategoryTheory.CostructuredArrow.mk f)) (CategoryTheory.CostructuredArrow.mk (CategoryTheory.CategoryStruct.comp f g))","decl":"@[simp]\ntheorem map_mk {f : S.obj Y ‚ü∂ T} (g : T ‚ü∂ T') : (map g).obj (mk f) = mk (f ‚â´ g) :=\n  rfl\n\n"}
{"name":"CategoryTheory.CostructuredArrow.map_id","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nT : D\nS : CategoryTheory.Functor C D\nf : CategoryTheory.CostructuredArrow S T\n‚ä¢ Eq ((CategoryTheory.CostructuredArrow.map (CategoryTheory.CategoryStruct.id T)).obj f) f","decl":"@[simp]\ntheorem map_id {f : CostructuredArrow S T} : (map (ùüô T)).obj f = f := by\n  rw [eq_mk f]\n  simp\n\n"}
{"name":"CategoryTheory.CostructuredArrow.map_comp","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nT T' T'' : D\nS : CategoryTheory.Functor C D\nf : Quiver.Hom T T'\nf' : Quiver.Hom T' T''\nh : CategoryTheory.CostructuredArrow S T\n‚ä¢ Eq ((CategoryTheory.CostructuredArrow.map (CategoryTheory.CategoryStruct.comp f f')).obj h) ((CategoryTheory.CostructuredArrow.map f').obj ((CategoryTheory.CostructuredArrow.map f).obj h))","decl":"@[simp]\ntheorem map_comp {f : T ‚ü∂ T'} {f' : T' ‚ü∂ T''} {h : CostructuredArrow S T} :\n    (map (f ‚â´ f')).obj h = (map f').obj ((map f).obj h) := by\n  rw [eq_mk h]\n  simp\n\n"}
{"name":"CategoryTheory.CostructuredArrow.proj_reflectsIsomorphisms","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nT : D\nS : CategoryTheory.Functor C D\n‚ä¢ (CategoryTheory.CostructuredArrow.proj S T).ReflectsIsomorphisms","decl":"instance proj_reflectsIsomorphisms : (proj S T).ReflectsIsomorphisms where\n  reflects {Y Z} f t :=\n    ‚ü®‚ü®CostructuredArrow.homMk\n        (inv ((proj S T).map f))\n        (by rw [Functor.map_inv, IsIso.inv_comp_eq]; simp),\n      by constructor <;> ext <;> dsimp at t ‚ä¢ <;> simp‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.CostructuredArrow.pre_map_left","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nB : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} B\nF : CategoryTheory.Functor B C\nG : CategoryTheory.Functor C D\nS : D\nX‚úù Y‚úù : CategoryTheory.Comma (F.comp G) (CategoryTheory.Functor.fromPUnit S)\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.CostructuredArrow.pre F G S).map f).left (F.map f.left)","decl":"/-- The functor `(F ‚ãô G, S) ‚•§ (G, S)`. -/\n@[simps!]\ndef pre (F : B ‚•§ C) (G : C ‚•§ D) (S : D) : CostructuredArrow (F ‚ãô G) S ‚•§ CostructuredArrow G S :=\n  Comma.preLeft F G _\n\n"}
{"name":"CategoryTheory.CostructuredArrow.pre_obj_hom","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nB : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} B\nF : CategoryTheory.Functor B C\nG : CategoryTheory.Functor C D\nS : D\nX : CategoryTheory.Comma (F.comp G) (CategoryTheory.Functor.fromPUnit S)\n‚ä¢ Eq ((CategoryTheory.CostructuredArrow.pre F G S).obj X).hom X.hom","decl":"/-- The functor `(F ‚ãô G, S) ‚•§ (G, S)`. -/\n@[simps!]\ndef pre (F : B ‚•§ C) (G : C ‚•§ D) (S : D) : CostructuredArrow (F ‚ãô G) S ‚•§ CostructuredArrow G S :=\n  Comma.preLeft F G _\n\n"}
{"name":"CategoryTheory.CostructuredArrow.pre_obj_right","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nB : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} B\nF : CategoryTheory.Functor B C\nG : CategoryTheory.Functor C D\nS : D\nX : CategoryTheory.Comma (F.comp G) (CategoryTheory.Functor.fromPUnit S)\n‚ä¢ Eq ((CategoryTheory.CostructuredArrow.pre F G S).obj X).right X.right","decl":"/-- The functor `(F ‚ãô G, S) ‚•§ (G, S)`. -/\n@[simps!]\ndef pre (F : B ‚•§ C) (G : C ‚•§ D) (S : D) : CostructuredArrow (F ‚ãô G) S ‚•§ CostructuredArrow G S :=\n  Comma.preLeft F G _\n\n"}
{"name":"CategoryTheory.CostructuredArrow.pre_obj_left","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nB : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} B\nF : CategoryTheory.Functor B C\nG : CategoryTheory.Functor C D\nS : D\nX : CategoryTheory.Comma (F.comp G) (CategoryTheory.Functor.fromPUnit S)\n‚ä¢ Eq ((CategoryTheory.CostructuredArrow.pre F G S).obj X).left (F.obj X.left)","decl":"/-- The functor `(F ‚ãô G, S) ‚•§ (G, S)`. -/\n@[simps!]\ndef pre (F : B ‚•§ C) (G : C ‚•§ D) (S : D) : CostructuredArrow (F ‚ãô G) S ‚•§ CostructuredArrow G S :=\n  Comma.preLeft F G _\n\n"}
{"name":"CategoryTheory.CostructuredArrow.pre_map_right","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nB : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} B\nF : CategoryTheory.Functor B C\nG : CategoryTheory.Functor C D\nS : D\nX‚úù Y‚úù : CategoryTheory.Comma (F.comp G) (CategoryTheory.Functor.fromPUnit S)\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.CostructuredArrow.pre F G S).map f).right (CategoryTheory.CategoryStruct.id X‚úù.right)","decl":"/-- The functor `(F ‚ãô G, S) ‚•§ (G, S)`. -/\n@[simps!]\ndef pre (F : B ‚•§ C) (G : C ‚•§ D) (S : D) : CostructuredArrow (F ‚ãô G) S ‚•§ CostructuredArrow G S :=\n  Comma.preLeft F G _\n\n"}
{"name":"CategoryTheory.CostructuredArrow.instFaithfulCompPre","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nB : Type u‚ÇÑ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} B\nF : CategoryTheory.Functor B C\nG : CategoryTheory.Functor C D\nS : D\ninst‚úù : F.Faithful\n‚ä¢ (CategoryTheory.CostructuredArrow.pre F G S).Faithful","decl":"instance (F : B ‚•§ C) (G : C ‚•§ D) (S : D) [F.Faithful] : (pre F G S).Faithful :=\n  show (Comma.preLeft _ _ _).Faithful from inferInstance\n\n"}
{"name":"CategoryTheory.CostructuredArrow.instFullCompPre","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nB : Type u‚ÇÑ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} B\nF : CategoryTheory.Functor B C\nG : CategoryTheory.Functor C D\nS : D\ninst‚úù : F.Full\n‚ä¢ (CategoryTheory.CostructuredArrow.pre F G S).Full","decl":"instance (F : B ‚•§ C) (G : C ‚•§ D) (S : D) [F.Full] : (pre F G S).Full :=\n  show (Comma.preLeft _ _ _).Full from inferInstance\n\n"}
{"name":"CategoryTheory.CostructuredArrow.instEssSurjCompPre","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nB : Type u‚ÇÑ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} B\nF : CategoryTheory.Functor B C\nG : CategoryTheory.Functor C D\nS : D\ninst‚úù : F.EssSurj\n‚ä¢ (CategoryTheory.CostructuredArrow.pre F G S).EssSurj","decl":"instance (F : B ‚•§ C) (G : C ‚•§ D) (S : D) [F.EssSurj] : (pre F G S).EssSurj :=\n  show (Comma.preLeft _ _ _).EssSurj from inferInstance\n\n"}
{"name":"CategoryTheory.CostructuredArrow.isEquivalence_pre","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nB : Type u‚ÇÑ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} B\nF : CategoryTheory.Functor B C\nG : CategoryTheory.Functor C D\nS : D\ninst‚úù : F.IsEquivalence\n‚ä¢ (CategoryTheory.CostructuredArrow.pre F G S).IsEquivalence","decl":"/-- If `F` is an equivalence, then so is the functor `(F ‚ãô G, S) ‚•§ (G, S)`. -/\ninstance isEquivalence_pre (F : B ‚•§ C) (G : C ‚•§ D) (S : D) [F.IsEquivalence] :\n    (pre F G S).IsEquivalence :=\n  Comma.isEquivalence_preLeft _ _ _\n\n"}
{"name":"CategoryTheory.CostructuredArrow.post_map","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nB : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} B\nF : CategoryTheory.Functor B C\nG : CategoryTheory.Functor C D\nS : C\nX‚úù Y‚úù : CategoryTheory.CostructuredArrow F S\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.CostructuredArrow.post F G S).map f) (CategoryTheory.CostructuredArrow.homMk f.left ‚ãØ)","decl":"/-- The functor `(F, S) ‚•§ (F ‚ãô G, G(S))`. -/\n@[simps]\ndef post (F : B ‚•§ C) (G : C ‚•§ D) (S : C) :\n    CostructuredArrow F S ‚•§ CostructuredArrow (F ‚ãô G) (G.obj S) where\n  obj X := CostructuredArrow.mk (G.map X.hom)\n  map f := CostructuredArrow.homMk f.left (by simp [Functor.comp_map, ‚Üê G.map_comp, ‚Üê f.w])\n\n"}
{"name":"CategoryTheory.CostructuredArrow.post_obj","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nB : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} B\nF : CategoryTheory.Functor B C\nG : CategoryTheory.Functor C D\nS : C\nX : CategoryTheory.CostructuredArrow F S\n‚ä¢ Eq ((CategoryTheory.CostructuredArrow.post F G S).obj X) (CategoryTheory.CostructuredArrow.mk (G.map X.hom))","decl":"/-- The functor `(F, S) ‚•§ (F ‚ãô G, G(S))`. -/\n@[simps]\ndef post (F : B ‚•§ C) (G : C ‚•§ D) (S : C) :\n    CostructuredArrow F S ‚•§ CostructuredArrow (F ‚ãô G) (G.obj S) where\n  obj X := CostructuredArrow.mk (G.map X.hom)\n  map f := CostructuredArrow.homMk f.left (by simp [Functor.comp_map, ‚Üê G.map_comp, ‚Üê f.w])\n\n"}
{"name":"CategoryTheory.CostructuredArrow.instFaithfulCompObjPost","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nB : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} B\nF : CategoryTheory.Functor B C\nG : CategoryTheory.Functor C D\nS : C\n‚ä¢ (CategoryTheory.CostructuredArrow.post F G S).Faithful","decl":"instance (F : B ‚•§ C) (G : C ‚•§ D) (S : C) : (post F G S).Faithful where\n  map_injective {_ _} _ _ h := by simpa [ext_iff] using h\n\n"}
{"name":"CategoryTheory.CostructuredArrow.instFullCompObjPostOfFaithful","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nB : Type u‚ÇÑ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} B\nF : CategoryTheory.Functor B C\nG : CategoryTheory.Functor C D\nS : C\ninst‚úù : G.Faithful\n‚ä¢ (CategoryTheory.CostructuredArrow.post F G S).Full","decl":"instance (F : B ‚•§ C) (G : C ‚•§ D) (S : C) [G.Faithful] : (post F G S).Full where\n  map_surjective f := ‚ü®homMk f.left (G.map_injective (by simpa using f.w)), by simp‚ü©\n\n"}
{"name":"CategoryTheory.CostructuredArrow.instEssSurjCompObjPostOfFull","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nB : Type u‚ÇÑ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} B\nF : CategoryTheory.Functor B C\nG : CategoryTheory.Functor C D\nS : C\ninst‚úù : G.Full\n‚ä¢ (CategoryTheory.CostructuredArrow.post F G S).EssSurj","decl":"instance (F : B ‚•§ C) (G : C ‚•§ D) (S : C) [G.Full] : (post F G S).EssSurj where\n  mem_essImage h := ‚ü®mk (G.preimage h.hom), ‚ü®isoMk (Iso.refl _) (by simp)‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.CostructuredArrow.isEquivalence_post","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nB : Type u‚ÇÑ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} B\nS : C\nF : CategoryTheory.Functor B C\nG : CategoryTheory.Functor C D\ninst‚úù¬π : G.Full\ninst‚úù : G.Faithful\n‚ä¢ (CategoryTheory.CostructuredArrow.post F G S).IsEquivalence","decl":"/-- If `G` is fully faithful, then `post F G S : (F, S) ‚•§ (F ‚ãô G, G(S))` is an equivalence. -/\ninstance isEquivalence_post (S : C) (F : B ‚•§ C) (G : C ‚•§ D) [G.Full] [G.Faithful] :\n    (post F G S).IsEquivalence where\n\n"}
{"name":"CategoryTheory.CostructuredArrow.map‚ÇÇ_map_right","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nT : D\nS : CategoryTheory.Functor C D\nA : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} A\nB : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} B\nU : CategoryTheory.Functor A B\nV : B\nF : CategoryTheory.Functor C A\nG : CategoryTheory.Functor D B\nŒ± : Quiver.Hom (F.comp U) (S.comp G)\nŒ≤ : Quiver.Hom (G.obj T) V\nX Y : CategoryTheory.Comma S (CategoryTheory.Functor.fromPUnit T)\nœÜ : Quiver.Hom X Y\n‚ä¢ Eq ((CategoryTheory.CostructuredArrow.map‚ÇÇ Œ± Œ≤).map œÜ).right (CategoryTheory.CategoryStruct.id X.right)","decl":"/-- The functor `CostructuredArrow S T ‚•§ CostructuredArrow U V` that is deduced from\na natural transformation `F ‚ãô U ‚ü∂ S ‚ãô G` and a morphism `G.obj T ‚ü∂ V` -/\n@[simps!]\ndef map‚ÇÇ : CostructuredArrow S T ‚•§ CostructuredArrow U V :=\n  Comma.map (F‚ÇÇ := ùü≠ (Discrete PUnit)) Œ± (Discrete.natTrans (fun _ => Œ≤))\n\n"}
{"name":"CategoryTheory.CostructuredArrow.map‚ÇÇ_obj_hom","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nT : D\nS : CategoryTheory.Functor C D\nA : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} A\nB : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} B\nU : CategoryTheory.Functor A B\nV : B\nF : CategoryTheory.Functor C A\nG : CategoryTheory.Functor D B\nŒ± : Quiver.Hom (F.comp U) (S.comp G)\nŒ≤ : Quiver.Hom (G.obj T) V\nX : CategoryTheory.Comma S (CategoryTheory.Functor.fromPUnit T)\n‚ä¢ Eq ((CategoryTheory.CostructuredArrow.map‚ÇÇ Œ± Œ≤).obj X).hom (CategoryTheory.CategoryStruct.comp (Œ±.app X.left) (CategoryTheory.CategoryStruct.comp (G.map X.hom) Œ≤))","decl":"/-- The functor `CostructuredArrow S T ‚•§ CostructuredArrow U V` that is deduced from\na natural transformation `F ‚ãô U ‚ü∂ S ‚ãô G` and a morphism `G.obj T ‚ü∂ V` -/\n@[simps!]\ndef map‚ÇÇ : CostructuredArrow S T ‚•§ CostructuredArrow U V :=\n  Comma.map (F‚ÇÇ := ùü≠ (Discrete PUnit)) Œ± (Discrete.natTrans (fun _ => Œ≤))\n\n"}
{"name":"CategoryTheory.CostructuredArrow.map‚ÇÇ_map_left","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nT : D\nS : CategoryTheory.Functor C D\nA : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} A\nB : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} B\nU : CategoryTheory.Functor A B\nV : B\nF : CategoryTheory.Functor C A\nG : CategoryTheory.Functor D B\nŒ± : Quiver.Hom (F.comp U) (S.comp G)\nŒ≤ : Quiver.Hom (G.obj T) V\nX Y : CategoryTheory.Comma S (CategoryTheory.Functor.fromPUnit T)\nœÜ : Quiver.Hom X Y\n‚ä¢ Eq ((CategoryTheory.CostructuredArrow.map‚ÇÇ Œ± Œ≤).map œÜ).left (F.map œÜ.left)","decl":"/-- The functor `CostructuredArrow S T ‚•§ CostructuredArrow U V` that is deduced from\na natural transformation `F ‚ãô U ‚ü∂ S ‚ãô G` and a morphism `G.obj T ‚ü∂ V` -/\n@[simps!]\ndef map‚ÇÇ : CostructuredArrow S T ‚•§ CostructuredArrow U V :=\n  Comma.map (F‚ÇÇ := ùü≠ (Discrete PUnit)) Œ± (Discrete.natTrans (fun _ => Œ≤))\n\n"}
{"name":"CategoryTheory.CostructuredArrow.map‚ÇÇ_obj_right","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nT : D\nS : CategoryTheory.Functor C D\nA : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} A\nB : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} B\nU : CategoryTheory.Functor A B\nV : B\nF : CategoryTheory.Functor C A\nG : CategoryTheory.Functor D B\nŒ± : Quiver.Hom (F.comp U) (S.comp G)\nŒ≤ : Quiver.Hom (G.obj T) V\nX : CategoryTheory.Comma S (CategoryTheory.Functor.fromPUnit T)\n‚ä¢ Eq ((CategoryTheory.CostructuredArrow.map‚ÇÇ Œ± Œ≤).obj X).right X.right","decl":"/-- The functor `CostructuredArrow S T ‚•§ CostructuredArrow U V` that is deduced from\na natural transformation `F ‚ãô U ‚ü∂ S ‚ãô G` and a morphism `G.obj T ‚ü∂ V` -/\n@[simps!]\ndef map‚ÇÇ : CostructuredArrow S T ‚•§ CostructuredArrow U V :=\n  Comma.map (F‚ÇÇ := ùü≠ (Discrete PUnit)) Œ± (Discrete.natTrans (fun _ => Œ≤))\n\n"}
{"name":"CategoryTheory.CostructuredArrow.map‚ÇÇ_obj_left","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nT : D\nS : CategoryTheory.Functor C D\nA : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} A\nB : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} B\nU : CategoryTheory.Functor A B\nV : B\nF : CategoryTheory.Functor C A\nG : CategoryTheory.Functor D B\nŒ± : Quiver.Hom (F.comp U) (S.comp G)\nŒ≤ : Quiver.Hom (G.obj T) V\nX : CategoryTheory.Comma S (CategoryTheory.Functor.fromPUnit T)\n‚ä¢ Eq ((CategoryTheory.CostructuredArrow.map‚ÇÇ Œ± Œ≤).obj X).left (F.obj X.left)","decl":"/-- The functor `CostructuredArrow S T ‚•§ CostructuredArrow U V` that is deduced from\na natural transformation `F ‚ãô U ‚ü∂ S ‚ãô G` and a morphism `G.obj T ‚ü∂ V` -/\n@[simps!]\ndef map‚ÇÇ : CostructuredArrow S T ‚•§ CostructuredArrow U V :=\n  Comma.map (F‚ÇÇ := ùü≠ (Discrete PUnit)) Œ± (Discrete.natTrans (fun _ => Œ≤))\n\n"}
{"name":"CategoryTheory.CostructuredArrow.faithful_map‚ÇÇ","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nT : D\nS : CategoryTheory.Functor C D\nA : Type u‚ÇÉ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} A\nB : Type u‚ÇÑ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} B\nU : CategoryTheory.Functor A B\nV : B\nF : CategoryTheory.Functor C A\nG : CategoryTheory.Functor D B\nŒ± : Quiver.Hom (F.comp U) (S.comp G)\nŒ≤ : Quiver.Hom (G.obj T) V\ninst‚úù : F.Faithful\n‚ä¢ (CategoryTheory.CostructuredArrow.map‚ÇÇ Œ± Œ≤).Faithful","decl":"instance faithful_map‚ÇÇ [F.Faithful] : (map‚ÇÇ Œ± Œ≤).Faithful := by\n  apply Comma.faithful_map\n\n"}
{"name":"CategoryTheory.CostructuredArrow.full_map‚ÇÇ","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å∑ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù‚Å∂ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nT : D\nS : CategoryTheory.Functor C D\nA : Type u‚ÇÉ\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} A\nB : Type u‚ÇÑ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} B\nU : CategoryTheory.Functor A B\nV : B\nF : CategoryTheory.Functor C A\nG : CategoryTheory.Functor D B\nŒ± : Quiver.Hom (F.comp U) (S.comp G)\nŒ≤ : Quiver.Hom (G.obj T) V\ninst‚úù¬≥ : G.Faithful\ninst‚úù¬≤ : F.Full\ninst‚úù¬π : CategoryTheory.IsIso Œ±\ninst‚úù : CategoryTheory.IsIso Œ≤\n‚ä¢ (CategoryTheory.CostructuredArrow.map‚ÇÇ Œ± Œ≤).Full","decl":"instance full_map‚ÇÇ [G.Faithful] [F.Full] [IsIso Œ±] [IsIso Œ≤] : (map‚ÇÇ Œ± Œ≤).Full := by\n  apply Comma.full_map\n\n"}
{"name":"CategoryTheory.CostructuredArrow.essSurj_map‚ÇÇ","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å∑ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù‚Å∂ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nT : D\nS : CategoryTheory.Functor C D\nA : Type u‚ÇÉ\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} A\nB : Type u‚ÇÑ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} B\nU : CategoryTheory.Functor A B\nV : B\nF : CategoryTheory.Functor C A\nG : CategoryTheory.Functor D B\nŒ± : Quiver.Hom (F.comp U) (S.comp G)\nŒ≤ : Quiver.Hom (G.obj T) V\ninst‚úù¬≥ : F.EssSurj\ninst‚úù¬≤ : G.Full\ninst‚úù¬π : CategoryTheory.IsIso Œ±\ninst‚úù : CategoryTheory.IsIso Œ≤\n‚ä¢ (CategoryTheory.CostructuredArrow.map‚ÇÇ Œ± Œ≤).EssSurj","decl":"instance essSurj_map‚ÇÇ [F.EssSurj] [G.Full] [IsIso Œ±] [IsIso Œ≤] : (map‚ÇÇ Œ± Œ≤).EssSurj := by\n  apply Comma.essSurj_map\n\n"}
{"name":"CategoryTheory.CostructuredArrow.isEquivalenceMap‚ÇÇ","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å∏ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù‚Å∑ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nT : D\nS : CategoryTheory.Functor C D\nA : Type u‚ÇÉ\ninst‚úù‚Å∂ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} A\nB : Type u‚ÇÑ\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} B\nU : CategoryTheory.Functor A B\nV : B\nF : CategoryTheory.Functor C A\nG : CategoryTheory.Functor D B\nŒ± : Quiver.Hom (F.comp U) (S.comp G)\nŒ≤ : Quiver.Hom (G.obj T) V\ninst‚úù‚Å¥ : F.IsEquivalence\ninst‚úù¬≥ : G.Faithful\ninst‚úù¬≤ : G.Full\ninst‚úù¬π : CategoryTheory.IsIso Œ±\ninst‚úù : CategoryTheory.IsIso Œ≤\n‚ä¢ (CategoryTheory.CostructuredArrow.map‚ÇÇ Œ± Œ≤).IsEquivalence","decl":"noncomputable instance isEquivalenceMap‚ÇÇ\n    [F.IsEquivalence] [G.Faithful] [G.Full] [IsIso Œ±] [IsIso Œ≤] :\n    (map‚ÇÇ Œ± Œ≤).IsEquivalence := by\n  apply Comma.isEquivalenceMap\n\n"}
{"name":"CategoryTheory.CostructuredArrow.IsUniversal.uniq","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nT : D\nS : CategoryTheory.Functor C D\nf g : CategoryTheory.CostructuredArrow S T\nh : f.IsUniversal\nŒ∑ : Quiver.Hom g f\n‚ä¢ Eq Œ∑ (CategoryTheory.Limits.IsTerminal.from h g)","decl":"theorem uniq (h : IsUniversal f) (Œ∑ : g ‚ü∂ f) : Œ∑ = h.from g :=\n  h.hom_ext Œ∑ (h.from g)\n\n"}
{"name":"CategoryTheory.CostructuredArrow.IsUniversal.fac_assoc","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nT : D\nS : CategoryTheory.Functor C D\nf : CategoryTheory.CostructuredArrow S T\nh‚úù : f.IsUniversal\ng : CategoryTheory.CostructuredArrow S T\nZ : D\nh : Quiver.Hom ((CategoryTheory.Functor.fromPUnit T).obj f.right) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (S.map (h‚úù.lift g)) (CategoryTheory.CategoryStruct.comp f.hom h)) (CategoryTheory.CategoryStruct.comp g.hom h)","decl":"/-- Any costructured arrow factors through a universal arrow. -/\n@[reassoc (attr := simp)]\ntheorem fac (h : IsUniversal f) (g : CostructuredArrow S T) :\n    S.map (h.lift g) ‚â´ f.hom = g.hom :=\n  Category.comp_id g.hom ‚ñ∏ (h.from g).w\n\n"}
{"name":"CategoryTheory.CostructuredArrow.IsUniversal.fac","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nT : D\nS : CategoryTheory.Functor C D\nf : CategoryTheory.CostructuredArrow S T\nh : f.IsUniversal\ng : CategoryTheory.CostructuredArrow S T\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (S.map (h.lift g)) f.hom) g.hom","decl":"/-- Any costructured arrow factors through a universal arrow. -/\n@[reassoc (attr := simp)]\ntheorem fac (h : IsUniversal f) (g : CostructuredArrow S T) :\n    S.map (h.lift g) ‚â´ f.hom = g.hom :=\n  Category.comp_id g.hom ‚ñ∏ (h.from g).w\n\n"}
{"name":"CategoryTheory.CostructuredArrow.IsUniversal.hom_desc","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nT : D\nS : CategoryTheory.Functor C D\nf : CategoryTheory.CostructuredArrow S T\nh : f.IsUniversal\nc : C\nŒ∑ : Quiver.Hom c f.left\n‚ä¢ Eq Œ∑ (h.lift (CategoryTheory.CostructuredArrow.mk (CategoryTheory.CategoryStruct.comp (S.map Œ∑) f.hom)))","decl":"theorem hom_desc (h : IsUniversal f) {c : C} (Œ∑ : c ‚ü∂ f.left) :\n    Œ∑ = h.lift (mk <| S.map Œ∑ ‚â´ f.hom) :=\n  let g := mk <| S.map Œ∑ ‚â´ f.hom\n  congrArg CommaMorphism.left (h.hom_ext (homMk Œ∑ rfl : g ‚ü∂ f) (h.from g))\n\n"}
{"name":"CategoryTheory.CostructuredArrow.IsUniversal.hom_ext","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nT : D\nS : CategoryTheory.Functor C D\nf : CategoryTheory.CostructuredArrow S T\nh : f.IsUniversal\nc : C\nŒ∑ Œ∑' : Quiver.Hom c f.left\nw : Eq (CategoryTheory.CategoryStruct.comp (S.map Œ∑) f.hom) (CategoryTheory.CategoryStruct.comp (S.map Œ∑') f.hom)\n‚ä¢ Eq Œ∑ Œ∑'","decl":"/-- Two morphisms into a universal `S`-costructured arrow are equal if their image under `S` are\nequal after postcomposing the universal arrow. -/\ntheorem hom_ext (h : IsUniversal f) {c : C} {Œ∑ Œ∑' : c ‚ü∂ f.left}\n    (w : S.map Œ∑ ‚â´ f.hom = S.map Œ∑' ‚â´ f.hom) : Œ∑ = Œ∑' := by\n  rw [h.hom_desc Œ∑, h.hom_desc Œ∑', w]\n\n"}
{"name":"CategoryTheory.CostructuredArrow.IsUniversal.existsUnique","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nT : D\nS : CategoryTheory.Functor C D\nf : CategoryTheory.CostructuredArrow S T\nh : f.IsUniversal\ng : CategoryTheory.CostructuredArrow S T\n‚ä¢ ExistsUnique fun Œ∑ => Eq (CategoryTheory.CategoryStruct.comp (S.map Œ∑) f.hom) g.hom","decl":"theorem existsUnique (h : IsUniversal f) (g : CostructuredArrow S T) :\n    ‚àÉ! Œ∑ : g.left ‚ü∂ f.left, S.map Œ∑ ‚â´ f.hom = g.hom :=\n  ‚ü®h.lift g, h.fac g, fun f w ‚Ü¶ h.hom_ext <| by simp [w]‚ü©\n\n"}
{"name":"CategoryTheory.Functor.toStructuredArrow_obj","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nG : CategoryTheory.Functor E C\nX : D\nF : CategoryTheory.Functor C D\nf : (Y : E) ‚Üí Quiver.Hom X (F.obj (G.obj Y))\nh : ‚àÄ {Y Z : E} (g : Quiver.Hom Y Z), Eq (CategoryTheory.CategoryStruct.comp (f Y) (F.map (G.map g))) (f Z)\nY : E\n‚ä¢ Eq ((G.toStructuredArrow X F f h).obj Y) (CategoryTheory.StructuredArrow.mk (f Y))","decl":"/-- Given `X : D` and `F : C ‚•§ D`, to upgrade a functor `G : E ‚•§ C` to a functor\n    `E ‚•§ StructuredArrow X F`, it suffices to provide maps `X ‚ü∂ F.obj (G.obj Y)` for all `Y` making\n    the obvious triangles involving all `F.map (G.map g)` commute.\n\n    This is of course the same as providing a cone over `F ‚ãô G` with cone point `X`, see\n    `Functor.toStructuredArrowIsoToStructuredArrow`. -/\n@[simps]\ndef toStructuredArrow (G : E ‚•§ C) (X : D) (F : C ‚•§ D) (f : (Y : E) ‚Üí X ‚ü∂ F.obj (G.obj Y))\n    (h : ‚àÄ {Y Z : E} (g : Y ‚ü∂ Z), f Y ‚â´ F.map (G.map g) = f Z) : E ‚•§ StructuredArrow X F where\n  obj Y := StructuredArrow.mk (f Y)\n  map g := StructuredArrow.homMk (G.map g) (h g)\n\n"}
{"name":"CategoryTheory.Functor.toStructuredArrow_map","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nG : CategoryTheory.Functor E C\nX : D\nF : CategoryTheory.Functor C D\nf : (Y : E) ‚Üí Quiver.Hom X (F.obj (G.obj Y))\nh : ‚àÄ {Y Z : E} (g : Quiver.Hom Y Z), Eq (CategoryTheory.CategoryStruct.comp (f Y) (F.map (G.map g))) (f Z)\nX‚úù Y‚úù : E\ng : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((G.toStructuredArrow X F f h).map g) (CategoryTheory.StructuredArrow.homMk (G.map g) ‚ãØ)","decl":"/-- Given `X : D` and `F : C ‚•§ D`, to upgrade a functor `G : E ‚•§ C` to a functor\n    `E ‚•§ StructuredArrow X F`, it suffices to provide maps `X ‚ü∂ F.obj (G.obj Y)` for all `Y` making\n    the obvious triangles involving all `F.map (G.map g)` commute.\n\n    This is of course the same as providing a cone over `F ‚ãô G` with cone point `X`, see\n    `Functor.toStructuredArrowIsoToStructuredArrow`. -/\n@[simps]\ndef toStructuredArrow (G : E ‚•§ C) (X : D) (F : C ‚•§ D) (f : (Y : E) ‚Üí X ‚ü∂ F.obj (G.obj Y))\n    (h : ‚àÄ {Y Z : E} (g : Y ‚ü∂ Z), f Y ‚â´ F.map (G.map g) = f Z) : E ‚•§ StructuredArrow X F where\n  obj Y := StructuredArrow.mk (f Y)\n  map g := StructuredArrow.homMk (G.map g) (h g)\n\n"}
{"name":"CategoryTheory.Functor.toStructuredArrow_comp_proj","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nG : CategoryTheory.Functor E C\nX : D\nF : CategoryTheory.Functor C D\nf : (Y : E) ‚Üí Quiver.Hom X (F.obj (G.obj Y))\nh : ‚àÄ {Y Z : E} (g : Quiver.Hom Y Z), Eq (CategoryTheory.CategoryStruct.comp (f Y) (F.map (G.map g))) (f Z)\n‚ä¢ Eq ((G.toStructuredArrow X F f ‚ãØ).comp (CategoryTheory.StructuredArrow.proj X F)) G","decl":"@[simp]\nlemma toStructuredArrow_comp_proj (G : E ‚•§ C) (X : D) (F : C ‚•§ D)\n    (f : (Y : E) ‚Üí X ‚ü∂ F.obj (G.obj Y)) (h : ‚àÄ {Y Z : E} (g : Y ‚ü∂ Z), f Y ‚â´ F.map (G.map g) = f Z) :\n    G.toStructuredArrow X F f h ‚ãô StructuredArrow.proj _ _ = G :=\n  rfl\n\n"}
{"name":"CategoryTheory.Functor.toCostructuredArrow_map","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nG : CategoryTheory.Functor E C\nF : CategoryTheory.Functor C D\nX : D\nf : (Y : E) ‚Üí Quiver.Hom (F.obj (G.obj Y)) X\nh : ‚àÄ {Y Z : E} (g : Quiver.Hom Y Z), Eq (CategoryTheory.CategoryStruct.comp (F.map (G.map g)) (f Z)) (f Y)\nX‚úù Y‚úù : E\ng : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((G.toCostructuredArrow F X f h).map g) (CategoryTheory.CostructuredArrow.homMk (G.map g) ‚ãØ)","decl":"/-- Given `F : C ‚•§ D` and `X : D`, to upgrade a functor `G : E ‚•§ C` to a functor\n    `E ‚•§ CostructuredArrow F X`, it suffices to provide maps `F.obj (G.obj Y) ‚ü∂ X` for all `Y`\n    making the obvious triangles involving all `F.map (G.map g)` commute.\n\n    This is of course the same as providing a cocone over `F ‚ãô G` with cocone point `X`, see\n    `Functor.toCostructuredArrowIsoToCostructuredArrow`. -/\n@[simps]\ndef toCostructuredArrow (G : E ‚•§ C) (F : C ‚•§ D) (X : D) (f : (Y : E) ‚Üí F.obj (G.obj Y) ‚ü∂ X)\n    (h : ‚àÄ {Y Z : E} (g : Y ‚ü∂ Z), F.map (G.map g) ‚â´ f Z = f Y) : E ‚•§ CostructuredArrow F X where\n  obj Y := CostructuredArrow.mk (f Y)\n  map g := CostructuredArrow.homMk (G.map g) (h g)\n\n"}
{"name":"CategoryTheory.Functor.toCostructuredArrow_obj","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nG : CategoryTheory.Functor E C\nF : CategoryTheory.Functor C D\nX : D\nf : (Y : E) ‚Üí Quiver.Hom (F.obj (G.obj Y)) X\nh : ‚àÄ {Y Z : E} (g : Quiver.Hom Y Z), Eq (CategoryTheory.CategoryStruct.comp (F.map (G.map g)) (f Z)) (f Y)\nY : E\n‚ä¢ Eq ((G.toCostructuredArrow F X f h).obj Y) (CategoryTheory.CostructuredArrow.mk (f Y))","decl":"/-- Given `F : C ‚•§ D` and `X : D`, to upgrade a functor `G : E ‚•§ C` to a functor\n    `E ‚•§ CostructuredArrow F X`, it suffices to provide maps `F.obj (G.obj Y) ‚ü∂ X` for all `Y`\n    making the obvious triangles involving all `F.map (G.map g)` commute.\n\n    This is of course the same as providing a cocone over `F ‚ãô G` with cocone point `X`, see\n    `Functor.toCostructuredArrowIsoToCostructuredArrow`. -/\n@[simps]\ndef toCostructuredArrow (G : E ‚•§ C) (F : C ‚•§ D) (X : D) (f : (Y : E) ‚Üí F.obj (G.obj Y) ‚ü∂ X)\n    (h : ‚àÄ {Y Z : E} (g : Y ‚ü∂ Z), F.map (G.map g) ‚â´ f Z = f Y) : E ‚•§ CostructuredArrow F X where\n  obj Y := CostructuredArrow.mk (f Y)\n  map g := CostructuredArrow.homMk (G.map g) (h g)\n\n"}
{"name":"CategoryTheory.Functor.toCostructuredArrow_comp_proj","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nG : CategoryTheory.Functor E C\nF : CategoryTheory.Functor C D\nX : D\nf : (Y : E) ‚Üí Quiver.Hom (F.obj (G.obj Y)) X\nh : ‚àÄ {Y Z : E} (g : Quiver.Hom Y Z), Eq (CategoryTheory.CategoryStruct.comp (F.map (G.map g)) (f Z)) (f Y)\n‚ä¢ Eq ((G.toCostructuredArrow F X f ‚ãØ).comp (CategoryTheory.CostructuredArrow.proj F X)) G","decl":"@[simp]\nlemma toCostructuredArrow_comp_proj (G : E ‚•§ C) (F : C ‚•§ D) (X : D)\n    (f : (Y : E) ‚Üí F.obj (G.obj Y) ‚ü∂ X) (h : ‚àÄ {Y Z : E} (g : Y ‚ü∂ Z), F.map (G.map g) ‚â´ f Z = f Y) :\n    G.toCostructuredArrow F X f h ‚ãô CostructuredArrow.proj _ _ = G :=\nrfl\n\n"}
{"name":"CategoryTheory.StructuredArrow.toCostructuredArrow_map","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nd : D\nX‚úù Y‚úù : Opposite (CategoryTheory.StructuredArrow d F)\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.StructuredArrow.toCostructuredArrow F d).map f) (CategoryTheory.CostructuredArrow.homMk f.unop.right.op ‚ãØ)","decl":"/-- For a functor `F : C ‚•§ D` and an object `d : D`, we obtain a contravariant functor from the\ncategory of structured arrows `d ‚ü∂ F.obj c` to the category of costructured arrows\n`F.op.obj c ‚ü∂ (op d)`.\n-/\n@[simps]\ndef toCostructuredArrow (F : C ‚•§ D) (d : D) :\n    (StructuredArrow d F)·µí·µñ ‚•§ CostructuredArrow F.op (op d) where\n  obj X := @CostructuredArrow.mk _ _ _ _ _ (op X.unop.right) F.op X.unop.hom.op\n  map f := CostructuredArrow.homMk f.unop.right.op (by simp [‚Üê op_comp])\n\n"}
{"name":"CategoryTheory.StructuredArrow.toCostructuredArrow_obj","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nd : D\nX : Opposite (CategoryTheory.StructuredArrow d F)\n‚ä¢ Eq ((CategoryTheory.StructuredArrow.toCostructuredArrow F d).obj X) (CategoryTheory.CostructuredArrow.mk (Opposite.unop X).hom.op)","decl":"/-- For a functor `F : C ‚•§ D` and an object `d : D`, we obtain a contravariant functor from the\ncategory of structured arrows `d ‚ü∂ F.obj c` to the category of costructured arrows\n`F.op.obj c ‚ü∂ (op d)`.\n-/\n@[simps]\ndef toCostructuredArrow (F : C ‚•§ D) (d : D) :\n    (StructuredArrow d F)·µí·µñ ‚•§ CostructuredArrow F.op (op d) where\n  obj X := @CostructuredArrow.mk _ _ _ _ _ (op X.unop.right) F.op X.unop.hom.op\n  map f := CostructuredArrow.homMk f.unop.right.op (by simp [‚Üê op_comp])\n\n"}
{"name":"CategoryTheory.StructuredArrow.toCostructuredArrow'_map","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nd : D\nX‚úù Y‚úù : Opposite (CategoryTheory.StructuredArrow { unop := d } F.op)\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.StructuredArrow.toCostructuredArrow' F d).map f) (CategoryTheory.CostructuredArrow.homMk f.unop.right.unop ‚ãØ)","decl":"/-- For a functor `F : C ‚•§ D` and an object `d : D`, we obtain a contravariant functor from the\ncategory of structured arrows `op d ‚ü∂ F.op.obj c` to the category of costructured arrows\n`F.obj c ‚ü∂ d`.\n-/\n@[simps]\ndef toCostructuredArrow' (F : C ‚•§ D) (d : D) :\n    (StructuredArrow (op d) F.op)·µí·µñ ‚•§ CostructuredArrow F d where\n  obj X := @CostructuredArrow.mk _ _ _ _ _ (unop X.unop.right) F X.unop.hom.unop\n  map f :=\n    CostructuredArrow.homMk f.unop.right.unop\n      (by\n        dsimp\n        rw [‚Üê Quiver.Hom.unop_op (F.map (Quiver.Hom.unop f.unop.right)), ‚Üê unop_comp, ‚Üê F.op_map, ‚Üê\n          f.unop.w]\n        simp)\n\n"}
{"name":"CategoryTheory.StructuredArrow.toCostructuredArrow'_obj","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nd : D\nX : Opposite (CategoryTheory.StructuredArrow { unop := d } F.op)\n‚ä¢ Eq ((CategoryTheory.StructuredArrow.toCostructuredArrow' F d).obj X) (CategoryTheory.CostructuredArrow.mk (Opposite.unop X).hom.unop)","decl":"/-- For a functor `F : C ‚•§ D` and an object `d : D`, we obtain a contravariant functor from the\ncategory of structured arrows `op d ‚ü∂ F.op.obj c` to the category of costructured arrows\n`F.obj c ‚ü∂ d`.\n-/\n@[simps]\ndef toCostructuredArrow' (F : C ‚•§ D) (d : D) :\n    (StructuredArrow (op d) F.op)·µí·µñ ‚•§ CostructuredArrow F d where\n  obj X := @CostructuredArrow.mk _ _ _ _ _ (unop X.unop.right) F X.unop.hom.unop\n  map f :=\n    CostructuredArrow.homMk f.unop.right.unop\n      (by\n        dsimp\n        rw [‚Üê Quiver.Hom.unop_op (F.map (Quiver.Hom.unop f.unop.right)), ‚Üê unop_comp, ‚Üê F.op_map, ‚Üê\n          f.unop.w]\n        simp)\n\n"}
{"name":"CategoryTheory.CostructuredArrow.toStructuredArrow_map","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nd : D\nX‚úù Y‚úù : Opposite (CategoryTheory.CostructuredArrow F d)\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.CostructuredArrow.toStructuredArrow F d).map f) (CategoryTheory.StructuredArrow.homMk f.unop.left.op ‚ãØ)","decl":"/-- For a functor `F : C ‚•§ D` and an object `d : D`, we obtain a contravariant functor from the\ncategory of costructured arrows `F.obj c ‚ü∂ d` to the category of structured arrows\n`op d ‚ü∂ F.op.obj c`.\n-/\n@[simps]\ndef toStructuredArrow (F : C ‚•§ D) (d : D) :\n    (CostructuredArrow F d)·µí·µñ ‚•§ StructuredArrow (op d) F.op where\n  obj X := @StructuredArrow.mk _ _ _ _ _ (op X.unop.left) F.op X.unop.hom.op\n  map f := StructuredArrow.homMk f.unop.left.op (by simp [‚Üê op_comp])\n\n"}
{"name":"CategoryTheory.CostructuredArrow.toStructuredArrow_obj","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nd : D\nX : Opposite (CategoryTheory.CostructuredArrow F d)\n‚ä¢ Eq ((CategoryTheory.CostructuredArrow.toStructuredArrow F d).obj X) (CategoryTheory.StructuredArrow.mk (Opposite.unop X).hom.op)","decl":"/-- For a functor `F : C ‚•§ D` and an object `d : D`, we obtain a contravariant functor from the\ncategory of costructured arrows `F.obj c ‚ü∂ d` to the category of structured arrows\n`op d ‚ü∂ F.op.obj c`.\n-/\n@[simps]\ndef toStructuredArrow (F : C ‚•§ D) (d : D) :\n    (CostructuredArrow F d)·µí·µñ ‚•§ StructuredArrow (op d) F.op where\n  obj X := @StructuredArrow.mk _ _ _ _ _ (op X.unop.left) F.op X.unop.hom.op\n  map f := StructuredArrow.homMk f.unop.left.op (by simp [‚Üê op_comp])\n\n"}
{"name":"CategoryTheory.CostructuredArrow.toStructuredArrow'_map","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nd : D\nX‚úù Y‚úù : Opposite (CategoryTheory.CostructuredArrow F.op { unop := d })\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.CostructuredArrow.toStructuredArrow' F d).map f) (CategoryTheory.StructuredArrow.homMk f.unop.left.unop ‚ãØ)","decl":"/-- For a functor `F : C ‚•§ D` and an object `d : D`, we obtain a contravariant functor from the\ncategory of costructured arrows `F.op.obj c ‚ü∂ op d` to the category of structured arrows\n`d ‚ü∂ F.obj c`.\n-/\n@[simps]\ndef toStructuredArrow' (F : C ‚•§ D) (d : D) :\n    (CostructuredArrow F.op (op d))·µí·µñ ‚•§ StructuredArrow d F where\n  obj X := @StructuredArrow.mk _ _ _ _ _ (unop X.unop.left) F X.unop.hom.unop\n  map f :=\n    StructuredArrow.homMk f.unop.left.unop\n      (by\n        dsimp\n        rw [‚Üê Quiver.Hom.unop_op (F.map f.unop.left.unop), ‚Üê unop_comp, ‚Üê F.op_map, f.unop.w,\n          Functor.const_obj_map]\n        simp)\n\n"}
{"name":"CategoryTheory.CostructuredArrow.toStructuredArrow'_obj","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nd : D\nX : Opposite (CategoryTheory.CostructuredArrow F.op { unop := d })\n‚ä¢ Eq ((CategoryTheory.CostructuredArrow.toStructuredArrow' F d).obj X) (CategoryTheory.StructuredArrow.mk (Opposite.unop X).hom.unop)","decl":"/-- For a functor `F : C ‚•§ D` and an object `d : D`, we obtain a contravariant functor from the\ncategory of costructured arrows `F.op.obj c ‚ü∂ op d` to the category of structured arrows\n`d ‚ü∂ F.obj c`.\n-/\n@[simps]\ndef toStructuredArrow' (F : C ‚•§ D) (d : D) :\n    (CostructuredArrow F.op (op d))·µí·µñ ‚•§ StructuredArrow d F where\n  obj X := @StructuredArrow.mk _ _ _ _ _ (unop X.unop.left) F X.unop.hom.unop\n  map f :=\n    StructuredArrow.homMk f.unop.left.unop\n      (by\n        dsimp\n        rw [‚Üê Quiver.Hom.unop_op (F.map f.unop.left.unop), ‚Üê unop_comp, ‚Üê F.op_map, f.unop.w,\n          Functor.const_obj_map]\n        simp)\n\n"}
{"name":"CategoryTheory.StructuredArrow.preEquivalenceFunctor_obj_right","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ne : E\nf : CategoryTheory.StructuredArrow e G\ng : CategoryTheory.StructuredArrow f (CategoryTheory.StructuredArrow.pre e F G)\n‚ä¢ Eq ((CategoryTheory.StructuredArrow.preEquivalenceFunctor F f).obj g).right g.right.right","decl":"/-- The functor establishing the equivalence `StructuredArrow.preEquivalence`. -/\n@[simps!]\ndef StructuredArrow.preEquivalenceFunctor (f : StructuredArrow e G) :\n    StructuredArrow f (pre e F G) ‚•§ StructuredArrow f.right F where\n  obj g := mk g.hom.right\n  map œÜ := homMk œÜ.right.right <| by\n    have := w œÜ\n    simp only [Functor.const_obj_obj] at this ‚ä¢\n    rw [‚Üê this, comp_right]\n    simp\n\n"}
{"name":"CategoryTheory.StructuredArrow.preEquivalenceFunctor_obj_left_as","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ne : E\nf : CategoryTheory.StructuredArrow e G\ng : CategoryTheory.StructuredArrow f (CategoryTheory.StructuredArrow.pre e F G)\n‚ä¢ Eq ((CategoryTheory.StructuredArrow.preEquivalenceFunctor F f).obj g).left.as PUnit.unit","decl":"/-- The functor establishing the equivalence `StructuredArrow.preEquivalence`. -/\n@[simps!]\ndef StructuredArrow.preEquivalenceFunctor (f : StructuredArrow e G) :\n    StructuredArrow f (pre e F G) ‚•§ StructuredArrow f.right F where\n  obj g := mk g.hom.right\n  map œÜ := homMk œÜ.right.right <| by\n    have := w œÜ\n    simp only [Functor.const_obj_obj] at this ‚ä¢\n    rw [‚Üê this, comp_right]\n    simp\n\n"}
{"name":"CategoryTheory.StructuredArrow.preEquivalenceFunctor_map_right","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ne : E\nf : CategoryTheory.StructuredArrow e G\nX‚úù Y‚úù : CategoryTheory.StructuredArrow f (CategoryTheory.StructuredArrow.pre e F G)\nœÜ : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.StructuredArrow.preEquivalenceFunctor F f).map œÜ).right œÜ.right.right","decl":"/-- The functor establishing the equivalence `StructuredArrow.preEquivalence`. -/\n@[simps!]\ndef StructuredArrow.preEquivalenceFunctor (f : StructuredArrow e G) :\n    StructuredArrow f (pre e F G) ‚•§ StructuredArrow f.right F where\n  obj g := mk g.hom.right\n  map œÜ := homMk œÜ.right.right <| by\n    have := w œÜ\n    simp only [Functor.const_obj_obj] at this ‚ä¢\n    rw [‚Üê this, comp_right]\n    simp\n\n"}
{"name":"CategoryTheory.StructuredArrow.preEquivalenceFunctor_map_left_down_down","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ne : E\nf : CategoryTheory.StructuredArrow e G\nX‚úù Y‚úù : CategoryTheory.StructuredArrow f (CategoryTheory.StructuredArrow.pre e F G)\nœÜ : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ‚ãØ ‚ãØ","decl":"/-- The functor establishing the equivalence `StructuredArrow.preEquivalence`. -/\n@[simps!]\ndef StructuredArrow.preEquivalenceFunctor (f : StructuredArrow e G) :\n    StructuredArrow f (pre e F G) ‚•§ StructuredArrow f.right F where\n  obj g := mk g.hom.right\n  map œÜ := homMk œÜ.right.right <| by\n    have := w œÜ\n    simp only [Functor.const_obj_obj] at this ‚ä¢\n    rw [‚Üê this, comp_right]\n    simp\n\n"}
{"name":"CategoryTheory.StructuredArrow.preEquivalenceFunctor_obj_hom","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ne : E\nf : CategoryTheory.StructuredArrow e G\ng : CategoryTheory.StructuredArrow f (CategoryTheory.StructuredArrow.pre e F G)\n‚ä¢ Eq ((CategoryTheory.StructuredArrow.preEquivalenceFunctor F f).obj g).hom g.hom.right","decl":"/-- The functor establishing the equivalence `StructuredArrow.preEquivalence`. -/\n@[simps!]\ndef StructuredArrow.preEquivalenceFunctor (f : StructuredArrow e G) :\n    StructuredArrow f (pre e F G) ‚•§ StructuredArrow f.right F where\n  obj g := mk g.hom.right\n  map œÜ := homMk œÜ.right.right <| by\n    have := w œÜ\n    simp only [Functor.const_obj_obj] at this ‚ä¢\n    rw [‚Üê this, comp_right]\n    simp\n\n"}
{"name":"CategoryTheory.StructuredArrow.preEquivalenceInverse_obj_hom_left_down_down","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ne : E\nf : CategoryTheory.StructuredArrow e G\ng : CategoryTheory.StructuredArrow f.right F\n‚ä¢ Eq ‚ãØ ‚ãØ","decl":"/-- The inverse functor establishing the equivalence `StructuredArrow.preEquivalence`. -/\n@[simps!]\ndef StructuredArrow.preEquivalenceInverse (f : StructuredArrow e G) :\n    StructuredArrow f.right F ‚•§ StructuredArrow f (pre e F G) where\n  obj g := mk\n            (Y := mk (Y := g.right)\n              (f.hom ‚â´ (G.map g.hom : G.obj f.right ‚ü∂ (F ‚ãô G).obj g.right)))\n            (homMk g.hom)\n  map œÜ := homMk <| homMk œÜ.right <| by\n    simp only [Functor.const_obj_obj, Functor.comp_obj, mk_right, mk_left, mk_hom_eq_self,\n      Functor.comp_map, Category.assoc, ‚Üê w œÜ, Functor.map_comp]\n\n"}
{"name":"CategoryTheory.StructuredArrow.preEquivalenceInverse_map_right_right","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ne : E\nf : CategoryTheory.StructuredArrow e G\nX‚úù Y‚úù : CategoryTheory.StructuredArrow f.right F\nœÜ : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.StructuredArrow.preEquivalenceInverse F f).map œÜ).right.right œÜ.right","decl":"/-- The inverse functor establishing the equivalence `StructuredArrow.preEquivalence`. -/\n@[simps!]\ndef StructuredArrow.preEquivalenceInverse (f : StructuredArrow e G) :\n    StructuredArrow f.right F ‚•§ StructuredArrow f (pre e F G) where\n  obj g := mk\n            (Y := mk (Y := g.right)\n              (f.hom ‚â´ (G.map g.hom : G.obj f.right ‚ü∂ (F ‚ãô G).obj g.right)))\n            (homMk g.hom)\n  map œÜ := homMk <| homMk œÜ.right <| by\n    simp only [Functor.const_obj_obj, Functor.comp_obj, mk_right, mk_left, mk_hom_eq_self,\n      Functor.comp_map, Category.assoc, ‚Üê w œÜ, Functor.map_comp]\n\n"}
{"name":"CategoryTheory.StructuredArrow.preEquivalenceInverse_map_left_down_down","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ne : E\nf : CategoryTheory.StructuredArrow e G\nX‚úù Y‚úù : CategoryTheory.StructuredArrow f.right F\nœÜ : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ‚ãØ ‚ãØ","decl":"/-- The inverse functor establishing the equivalence `StructuredArrow.preEquivalence`. -/\n@[simps!]\ndef StructuredArrow.preEquivalenceInverse (f : StructuredArrow e G) :\n    StructuredArrow f.right F ‚•§ StructuredArrow f (pre e F G) where\n  obj g := mk\n            (Y := mk (Y := g.right)\n              (f.hom ‚â´ (G.map g.hom : G.obj f.right ‚ü∂ (F ‚ãô G).obj g.right)))\n            (homMk g.hom)\n  map œÜ := homMk <| homMk œÜ.right <| by\n    simp only [Functor.const_obj_obj, Functor.comp_obj, mk_right, mk_left, mk_hom_eq_self,\n      Functor.comp_map, Category.assoc, ‚Üê w œÜ, Functor.map_comp]\n\n"}
{"name":"CategoryTheory.StructuredArrow.preEquivalenceInverse_map_right_left_down_down","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ne : E\nf : CategoryTheory.StructuredArrow e G\nX‚úù Y‚úù : CategoryTheory.StructuredArrow f.right F\nœÜ : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ‚ãØ ‚ãØ","decl":"/-- The inverse functor establishing the equivalence `StructuredArrow.preEquivalence`. -/\n@[simps!]\ndef StructuredArrow.preEquivalenceInverse (f : StructuredArrow e G) :\n    StructuredArrow f.right F ‚•§ StructuredArrow f (pre e F G) where\n  obj g := mk\n            (Y := mk (Y := g.right)\n              (f.hom ‚â´ (G.map g.hom : G.obj f.right ‚ü∂ (F ‚ãô G).obj g.right)))\n            (homMk g.hom)\n  map œÜ := homMk <| homMk œÜ.right <| by\n    simp only [Functor.const_obj_obj, Functor.comp_obj, mk_right, mk_left, mk_hom_eq_self,\n      Functor.comp_map, Category.assoc, ‚Üê w œÜ, Functor.map_comp]\n\n"}
{"name":"CategoryTheory.StructuredArrow.preEquivalenceInverse_obj_left_as","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ne : E\nf : CategoryTheory.StructuredArrow e G\ng : CategoryTheory.StructuredArrow f.right F\n‚ä¢ Eq ((CategoryTheory.StructuredArrow.preEquivalenceInverse F f).obj g).left.as PUnit.unit","decl":"/-- The inverse functor establishing the equivalence `StructuredArrow.preEquivalence`. -/\n@[simps!]\ndef StructuredArrow.preEquivalenceInverse (f : StructuredArrow e G) :\n    StructuredArrow f.right F ‚•§ StructuredArrow f (pre e F G) where\n  obj g := mk\n            (Y := mk (Y := g.right)\n              (f.hom ‚â´ (G.map g.hom : G.obj f.right ‚ü∂ (F ‚ãô G).obj g.right)))\n            (homMk g.hom)\n  map œÜ := homMk <| homMk œÜ.right <| by\n    simp only [Functor.const_obj_obj, Functor.comp_obj, mk_right, mk_left, mk_hom_eq_self,\n      Functor.comp_map, Category.assoc, ‚Üê w œÜ, Functor.map_comp]\n\n"}
{"name":"CategoryTheory.StructuredArrow.preEquivalenceInverse_obj_hom_right","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ne : E\nf : CategoryTheory.StructuredArrow e G\ng : CategoryTheory.StructuredArrow f.right F\n‚ä¢ Eq ((CategoryTheory.StructuredArrow.preEquivalenceInverse F f).obj g).hom.right g.hom","decl":"/-- The inverse functor establishing the equivalence `StructuredArrow.preEquivalence`. -/\n@[simps!]\ndef StructuredArrow.preEquivalenceInverse (f : StructuredArrow e G) :\n    StructuredArrow f.right F ‚•§ StructuredArrow f (pre e F G) where\n  obj g := mk\n            (Y := mk (Y := g.right)\n              (f.hom ‚â´ (G.map g.hom : G.obj f.right ‚ü∂ (F ‚ãô G).obj g.right)))\n            (homMk g.hom)\n  map œÜ := homMk <| homMk œÜ.right <| by\n    simp only [Functor.const_obj_obj, Functor.comp_obj, mk_right, mk_left, mk_hom_eq_self,\n      Functor.comp_map, Category.assoc, ‚Üê w œÜ, Functor.map_comp]\n\n"}
{"name":"CategoryTheory.StructuredArrow.preEquivalenceInverse_obj_right_left_as","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ne : E\nf : CategoryTheory.StructuredArrow e G\ng : CategoryTheory.StructuredArrow f.right F\n‚ä¢ Eq ((CategoryTheory.StructuredArrow.preEquivalenceInverse F f).obj g).right.left.as PUnit.unit","decl":"/-- The inverse functor establishing the equivalence `StructuredArrow.preEquivalence`. -/\n@[simps!]\ndef StructuredArrow.preEquivalenceInverse (f : StructuredArrow e G) :\n    StructuredArrow f.right F ‚•§ StructuredArrow f (pre e F G) where\n  obj g := mk\n            (Y := mk (Y := g.right)\n              (f.hom ‚â´ (G.map g.hom : G.obj f.right ‚ü∂ (F ‚ãô G).obj g.right)))\n            (homMk g.hom)\n  map œÜ := homMk <| homMk œÜ.right <| by\n    simp only [Functor.const_obj_obj, Functor.comp_obj, mk_right, mk_left, mk_hom_eq_self,\n      Functor.comp_map, Category.assoc, ‚Üê w œÜ, Functor.map_comp]\n\n"}
{"name":"CategoryTheory.StructuredArrow.preEquivalenceInverse_obj_right_right","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ne : E\nf : CategoryTheory.StructuredArrow e G\ng : CategoryTheory.StructuredArrow f.right F\n‚ä¢ Eq ((CategoryTheory.StructuredArrow.preEquivalenceInverse F f).obj g).right.right g.right","decl":"/-- The inverse functor establishing the equivalence `StructuredArrow.preEquivalence`. -/\n@[simps!]\ndef StructuredArrow.preEquivalenceInverse (f : StructuredArrow e G) :\n    StructuredArrow f.right F ‚•§ StructuredArrow f (pre e F G) where\n  obj g := mk\n            (Y := mk (Y := g.right)\n              (f.hom ‚â´ (G.map g.hom : G.obj f.right ‚ü∂ (F ‚ãô G).obj g.right)))\n            (homMk g.hom)\n  map œÜ := homMk <| homMk œÜ.right <| by\n    simp only [Functor.const_obj_obj, Functor.comp_obj, mk_right, mk_left, mk_hom_eq_self,\n      Functor.comp_map, Category.assoc, ‚Üê w œÜ, Functor.map_comp]\n\n"}
{"name":"CategoryTheory.StructuredArrow.preEquivalenceInverse_obj_right_hom","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ne : E\nf : CategoryTheory.StructuredArrow e G\ng : CategoryTheory.StructuredArrow f.right F\n‚ä¢ Eq ((CategoryTheory.StructuredArrow.preEquivalenceInverse F f).obj g).right.hom (CategoryTheory.CategoryStruct.comp f.hom (G.map g.hom))","decl":"/-- The inverse functor establishing the equivalence `StructuredArrow.preEquivalence`. -/\n@[simps!]\ndef StructuredArrow.preEquivalenceInverse (f : StructuredArrow e G) :\n    StructuredArrow f.right F ‚•§ StructuredArrow f (pre e F G) where\n  obj g := mk\n            (Y := mk (Y := g.right)\n              (f.hom ‚â´ (G.map g.hom : G.obj f.right ‚ü∂ (F ‚ãô G).obj g.right)))\n            (homMk g.hom)\n  map œÜ := homMk <| homMk œÜ.right <| by\n    simp only [Functor.const_obj_obj, Functor.comp_obj, mk_right, mk_left, mk_hom_eq_self,\n      Functor.comp_map, Category.assoc, ‚Üê w œÜ, Functor.map_comp]\n\n"}
{"name":"CategoryTheory.StructuredArrow.preEquivalence_unitIso","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ne : E\nf : CategoryTheory.StructuredArrow e G\n‚ä¢ Eq (CategoryTheory.StructuredArrow.preEquivalence F f).unitIso (CategoryTheory.NatIso.ofComponents (fun x => CategoryTheory.StructuredArrow.isoMk (CategoryTheory.StructuredArrow.isoMk (CategoryTheory.Iso.refl ((CategoryTheory.Functor.id (CategoryTheory.StructuredArrow f (CategoryTheory.StructuredArrow.pre e F G))).obj x).right.right) ‚ãØ) ‚ãØ) ‚ãØ)","decl":"/-- A structured arrow category on a `StructuredArrow.pre e F G` functor is equivalent to the\nstructured arrow category on F -/\n@[simps]\ndef StructuredArrow.preEquivalence (f : StructuredArrow e G) :\n    StructuredArrow f (pre e F G) ‚âå StructuredArrow f.right F where\n  functor := preEquivalenceFunctor F f\n  inverse := preEquivalenceInverse F f\n  unitIso := NatIso.ofComponents (fun _ => isoMk (isoMk (Iso.refl _)))\n  counitIso := NatIso.ofComponents (fun _ => isoMk (Iso.refl _))\n\n"}
{"name":"CategoryTheory.StructuredArrow.preEquivalence_functor","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ne : E\nf : CategoryTheory.StructuredArrow e G\n‚ä¢ Eq (CategoryTheory.StructuredArrow.preEquivalence F f).functor (CategoryTheory.StructuredArrow.preEquivalenceFunctor F f)","decl":"/-- A structured arrow category on a `StructuredArrow.pre e F G` functor is equivalent to the\nstructured arrow category on F -/\n@[simps]\ndef StructuredArrow.preEquivalence (f : StructuredArrow e G) :\n    StructuredArrow f (pre e F G) ‚âå StructuredArrow f.right F where\n  functor := preEquivalenceFunctor F f\n  inverse := preEquivalenceInverse F f\n  unitIso := NatIso.ofComponents (fun _ => isoMk (isoMk (Iso.refl _)))\n  counitIso := NatIso.ofComponents (fun _ => isoMk (Iso.refl _))\n\n"}
{"name":"CategoryTheory.StructuredArrow.preEquivalence_counitIso","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ne : E\nf : CategoryTheory.StructuredArrow e G\n‚ä¢ Eq (CategoryTheory.StructuredArrow.preEquivalence F f).counitIso (CategoryTheory.NatIso.ofComponents (fun x => CategoryTheory.StructuredArrow.isoMk (CategoryTheory.Iso.refl (((CategoryTheory.StructuredArrow.preEquivalenceInverse F f).comp (CategoryTheory.StructuredArrow.preEquivalenceFunctor F f)).obj x).right) ‚ãØ) ‚ãØ)","decl":"/-- A structured arrow category on a `StructuredArrow.pre e F G` functor is equivalent to the\nstructured arrow category on F -/\n@[simps]\ndef StructuredArrow.preEquivalence (f : StructuredArrow e G) :\n    StructuredArrow f (pre e F G) ‚âå StructuredArrow f.right F where\n  functor := preEquivalenceFunctor F f\n  inverse := preEquivalenceInverse F f\n  unitIso := NatIso.ofComponents (fun _ => isoMk (isoMk (Iso.refl _)))\n  counitIso := NatIso.ofComponents (fun _ => isoMk (Iso.refl _))\n\n"}
{"name":"CategoryTheory.StructuredArrow.preEquivalence_inverse","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ne : E\nf : CategoryTheory.StructuredArrow e G\n‚ä¢ Eq (CategoryTheory.StructuredArrow.preEquivalence F f).inverse (CategoryTheory.StructuredArrow.preEquivalenceInverse F f)","decl":"/-- A structured arrow category on a `StructuredArrow.pre e F G` functor is equivalent to the\nstructured arrow category on F -/\n@[simps]\ndef StructuredArrow.preEquivalence (f : StructuredArrow e G) :\n    StructuredArrow f (pre e F G) ‚âå StructuredArrow f.right F where\n  functor := preEquivalenceFunctor F f\n  inverse := preEquivalenceInverse F f\n  unitIso := NatIso.ofComponents (fun _ => isoMk (isoMk (Iso.refl _)))\n  counitIso := NatIso.ofComponents (fun _ => isoMk (Iso.refl _))\n\n"}
{"name":"CategoryTheory.CostructuredArrow.preEquivalence.functor_map_right_down_down","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ne : E\nf : CategoryTheory.CostructuredArrow G e\nX‚úù Y‚úù : CategoryTheory.CostructuredArrow (CategoryTheory.CostructuredArrow.pre F G e) f\nœÜ : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ‚ãØ ‚ãØ","decl":"/-- The functor establishing the equivalence `CostructuredArrow.preEquivalence`. -/\n@[simps!]\ndef CostructuredArrow.preEquivalence.functor (f : CostructuredArrow G e) :\n    CostructuredArrow (pre F G e) f ‚•§ CostructuredArrow F f.left where\n  obj g := mk g.hom.left\n  map œÜ := homMk œÜ.left.left <| by\n    have := w œÜ\n    simp only [Functor.const_obj_obj] at this ‚ä¢\n    rw [‚Üê this, comp_left]\n    simp\n\n"}
{"name":"CategoryTheory.CostructuredArrow.preEquivalence.functor_obj_right_as","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ne : E\nf : CategoryTheory.CostructuredArrow G e\ng : CategoryTheory.CostructuredArrow (CategoryTheory.CostructuredArrow.pre F G e) f\n‚ä¢ Eq ((CategoryTheory.CostructuredArrow.preEquivalence.functor F f).obj g).right.as PUnit.unit","decl":"/-- The functor establishing the equivalence `CostructuredArrow.preEquivalence`. -/\n@[simps!]\ndef CostructuredArrow.preEquivalence.functor (f : CostructuredArrow G e) :\n    CostructuredArrow (pre F G e) f ‚•§ CostructuredArrow F f.left where\n  obj g := mk g.hom.left\n  map œÜ := homMk œÜ.left.left <| by\n    have := w œÜ\n    simp only [Functor.const_obj_obj] at this ‚ä¢\n    rw [‚Üê this, comp_left]\n    simp\n\n"}
{"name":"CategoryTheory.CostructuredArrow.preEquivalence.functor_map_left","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ne : E\nf : CategoryTheory.CostructuredArrow G e\nX‚úù Y‚úù : CategoryTheory.CostructuredArrow (CategoryTheory.CostructuredArrow.pre F G e) f\nœÜ : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.CostructuredArrow.preEquivalence.functor F f).map œÜ).left œÜ.left.left","decl":"/-- The functor establishing the equivalence `CostructuredArrow.preEquivalence`. -/\n@[simps!]\ndef CostructuredArrow.preEquivalence.functor (f : CostructuredArrow G e) :\n    CostructuredArrow (pre F G e) f ‚•§ CostructuredArrow F f.left where\n  obj g := mk g.hom.left\n  map œÜ := homMk œÜ.left.left <| by\n    have := w œÜ\n    simp only [Functor.const_obj_obj] at this ‚ä¢\n    rw [‚Üê this, comp_left]\n    simp\n\n"}
{"name":"CategoryTheory.CostructuredArrow.preEquivalence.functor_obj_left","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ne : E\nf : CategoryTheory.CostructuredArrow G e\ng : CategoryTheory.CostructuredArrow (CategoryTheory.CostructuredArrow.pre F G e) f\n‚ä¢ Eq ((CategoryTheory.CostructuredArrow.preEquivalence.functor F f).obj g).left g.left.left","decl":"/-- The functor establishing the equivalence `CostructuredArrow.preEquivalence`. -/\n@[simps!]\ndef CostructuredArrow.preEquivalence.functor (f : CostructuredArrow G e) :\n    CostructuredArrow (pre F G e) f ‚•§ CostructuredArrow F f.left where\n  obj g := mk g.hom.left\n  map œÜ := homMk œÜ.left.left <| by\n    have := w œÜ\n    simp only [Functor.const_obj_obj] at this ‚ä¢\n    rw [‚Üê this, comp_left]\n    simp\n\n"}
{"name":"CategoryTheory.CostructuredArrow.preEquivalence.functor_obj_hom","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ne : E\nf : CategoryTheory.CostructuredArrow G e\ng : CategoryTheory.CostructuredArrow (CategoryTheory.CostructuredArrow.pre F G e) f\n‚ä¢ Eq ((CategoryTheory.CostructuredArrow.preEquivalence.functor F f).obj g).hom g.hom.left","decl":"/-- The functor establishing the equivalence `CostructuredArrow.preEquivalence`. -/\n@[simps!]\ndef CostructuredArrow.preEquivalence.functor (f : CostructuredArrow G e) :\n    CostructuredArrow (pre F G e) f ‚•§ CostructuredArrow F f.left where\n  obj g := mk g.hom.left\n  map œÜ := homMk œÜ.left.left <| by\n    have := w œÜ\n    simp only [Functor.const_obj_obj] at this ‚ä¢\n    rw [‚Üê this, comp_left]\n    simp\n\n"}
{"name":"CategoryTheory.CostructuredArrow.preEquivalence.inverse_map_right_down_down","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ne : E\nf : CategoryTheory.CostructuredArrow G e\nX‚úù Y‚úù : CategoryTheory.CostructuredArrow F f.left\nœÜ : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ‚ãØ ‚ãØ","decl":"/-- The inverse functor establishing the equivalence `CostructuredArrow.preEquivalence`. -/\n@[simps!]\ndef CostructuredArrow.preEquivalence.inverse (f : CostructuredArrow G e) :\n    CostructuredArrow F f.left ‚•§ CostructuredArrow (pre F G e) f where\n  obj g := mk (Y := mk (Y := g.left) (G.map g.hom ‚â´ f.hom)) (homMk g.hom)\n  map œÜ := homMk <| homMk œÜ.left <| by\n    simp only [Functor.const_obj_obj, Functor.comp_obj, mk_left, Functor.comp_map, mk_hom_eq_self,\n      ‚Üê w œÜ, Functor.map_comp, Category.assoc]\n\n"}
{"name":"CategoryTheory.CostructuredArrow.preEquivalence.inverse_obj_left_hom","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ne : E\nf : CategoryTheory.CostructuredArrow G e\ng : CategoryTheory.CostructuredArrow F f.left\n‚ä¢ Eq ((CategoryTheory.CostructuredArrow.preEquivalence.inverse F f).obj g).left.hom (CategoryTheory.CategoryStruct.comp (G.map g.hom) f.hom)","decl":"/-- The inverse functor establishing the equivalence `CostructuredArrow.preEquivalence`. -/\n@[simps!]\ndef CostructuredArrow.preEquivalence.inverse (f : CostructuredArrow G e) :\n    CostructuredArrow F f.left ‚•§ CostructuredArrow (pre F G e) f where\n  obj g := mk (Y := mk (Y := g.left) (G.map g.hom ‚â´ f.hom)) (homMk g.hom)\n  map œÜ := homMk <| homMk œÜ.left <| by\n    simp only [Functor.const_obj_obj, Functor.comp_obj, mk_left, Functor.comp_map, mk_hom_eq_self,\n      ‚Üê w œÜ, Functor.map_comp, Category.assoc]\n\n"}
{"name":"CategoryTheory.CostructuredArrow.preEquivalence.inverse_obj_hom_left","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ne : E\nf : CategoryTheory.CostructuredArrow G e\ng : CategoryTheory.CostructuredArrow F f.left\n‚ä¢ Eq ((CategoryTheory.CostructuredArrow.preEquivalence.inverse F f).obj g).hom.left g.hom","decl":"/-- The inverse functor establishing the equivalence `CostructuredArrow.preEquivalence`. -/\n@[simps!]\ndef CostructuredArrow.preEquivalence.inverse (f : CostructuredArrow G e) :\n    CostructuredArrow F f.left ‚•§ CostructuredArrow (pre F G e) f where\n  obj g := mk (Y := mk (Y := g.left) (G.map g.hom ‚â´ f.hom)) (homMk g.hom)\n  map œÜ := homMk <| homMk œÜ.left <| by\n    simp only [Functor.const_obj_obj, Functor.comp_obj, mk_left, Functor.comp_map, mk_hom_eq_self,\n      ‚Üê w œÜ, Functor.map_comp, Category.assoc]\n\n"}
{"name":"CategoryTheory.CostructuredArrow.preEquivalence.inverse_obj_hom_right_down_down","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ne : E\nf : CategoryTheory.CostructuredArrow G e\ng : CategoryTheory.CostructuredArrow F f.left\n‚ä¢ Eq ‚ãØ ‚ãØ","decl":"/-- The inverse functor establishing the equivalence `CostructuredArrow.preEquivalence`. -/\n@[simps!]\ndef CostructuredArrow.preEquivalence.inverse (f : CostructuredArrow G e) :\n    CostructuredArrow F f.left ‚•§ CostructuredArrow (pre F G e) f where\n  obj g := mk (Y := mk (Y := g.left) (G.map g.hom ‚â´ f.hom)) (homMk g.hom)\n  map œÜ := homMk <| homMk œÜ.left <| by\n    simp only [Functor.const_obj_obj, Functor.comp_obj, mk_left, Functor.comp_map, mk_hom_eq_self,\n      ‚Üê w œÜ, Functor.map_comp, Category.assoc]\n\n"}
{"name":"CategoryTheory.CostructuredArrow.preEquivalence.inverse_obj_right_as","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ne : E\nf : CategoryTheory.CostructuredArrow G e\ng : CategoryTheory.CostructuredArrow F f.left\n‚ä¢ Eq ((CategoryTheory.CostructuredArrow.preEquivalence.inverse F f).obj g).right.as PUnit.unit","decl":"/-- The inverse functor establishing the equivalence `CostructuredArrow.preEquivalence`. -/\n@[simps!]\ndef CostructuredArrow.preEquivalence.inverse (f : CostructuredArrow G e) :\n    CostructuredArrow F f.left ‚•§ CostructuredArrow (pre F G e) f where\n  obj g := mk (Y := mk (Y := g.left) (G.map g.hom ‚â´ f.hom)) (homMk g.hom)\n  map œÜ := homMk <| homMk œÜ.left <| by\n    simp only [Functor.const_obj_obj, Functor.comp_obj, mk_left, Functor.comp_map, mk_hom_eq_self,\n      ‚Üê w œÜ, Functor.map_comp, Category.assoc]\n\n"}
{"name":"CategoryTheory.CostructuredArrow.preEquivalence.inverse_map_left_left","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ne : E\nf : CategoryTheory.CostructuredArrow G e\nX‚úù Y‚úù : CategoryTheory.CostructuredArrow F f.left\nœÜ : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.CostructuredArrow.preEquivalence.inverse F f).map œÜ).left.left œÜ.left","decl":"/-- The inverse functor establishing the equivalence `CostructuredArrow.preEquivalence`. -/\n@[simps!]\ndef CostructuredArrow.preEquivalence.inverse (f : CostructuredArrow G e) :\n    CostructuredArrow F f.left ‚•§ CostructuredArrow (pre F G e) f where\n  obj g := mk (Y := mk (Y := g.left) (G.map g.hom ‚â´ f.hom)) (homMk g.hom)\n  map œÜ := homMk <| homMk œÜ.left <| by\n    simp only [Functor.const_obj_obj, Functor.comp_obj, mk_left, Functor.comp_map, mk_hom_eq_self,\n      ‚Üê w œÜ, Functor.map_comp, Category.assoc]\n\n"}
{"name":"CategoryTheory.CostructuredArrow.preEquivalence.inverse_map_left_right_down_down","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ne : E\nf : CategoryTheory.CostructuredArrow G e\nX‚úù Y‚úù : CategoryTheory.CostructuredArrow F f.left\nœÜ : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ‚ãØ ‚ãØ","decl":"/-- The inverse functor establishing the equivalence `CostructuredArrow.preEquivalence`. -/\n@[simps!]\ndef CostructuredArrow.preEquivalence.inverse (f : CostructuredArrow G e) :\n    CostructuredArrow F f.left ‚•§ CostructuredArrow (pre F G e) f where\n  obj g := mk (Y := mk (Y := g.left) (G.map g.hom ‚â´ f.hom)) (homMk g.hom)\n  map œÜ := homMk <| homMk œÜ.left <| by\n    simp only [Functor.const_obj_obj, Functor.comp_obj, mk_left, Functor.comp_map, mk_hom_eq_self,\n      ‚Üê w œÜ, Functor.map_comp, Category.assoc]\n\n"}
{"name":"CategoryTheory.CostructuredArrow.preEquivalence.inverse_obj_left_right_as","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ne : E\nf : CategoryTheory.CostructuredArrow G e\ng : CategoryTheory.CostructuredArrow F f.left\n‚ä¢ Eq ((CategoryTheory.CostructuredArrow.preEquivalence.inverse F f).obj g).left.right.as PUnit.unit","decl":"/-- The inverse functor establishing the equivalence `CostructuredArrow.preEquivalence`. -/\n@[simps!]\ndef CostructuredArrow.preEquivalence.inverse (f : CostructuredArrow G e) :\n    CostructuredArrow F f.left ‚•§ CostructuredArrow (pre F G e) f where\n  obj g := mk (Y := mk (Y := g.left) (G.map g.hom ‚â´ f.hom)) (homMk g.hom)\n  map œÜ := homMk <| homMk œÜ.left <| by\n    simp only [Functor.const_obj_obj, Functor.comp_obj, mk_left, Functor.comp_map, mk_hom_eq_self,\n      ‚Üê w œÜ, Functor.map_comp, Category.assoc]\n\n"}
{"name":"CategoryTheory.CostructuredArrow.preEquivalence.inverse_obj_left_left","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ne : E\nf : CategoryTheory.CostructuredArrow G e\ng : CategoryTheory.CostructuredArrow F f.left\n‚ä¢ Eq ((CategoryTheory.CostructuredArrow.preEquivalence.inverse F f).obj g).left.left g.left","decl":"/-- The inverse functor establishing the equivalence `CostructuredArrow.preEquivalence`. -/\n@[simps!]\ndef CostructuredArrow.preEquivalence.inverse (f : CostructuredArrow G e) :\n    CostructuredArrow F f.left ‚•§ CostructuredArrow (pre F G e) f where\n  obj g := mk (Y := mk (Y := g.left) (G.map g.hom ‚â´ f.hom)) (homMk g.hom)\n  map œÜ := homMk <| homMk œÜ.left <| by\n    simp only [Functor.const_obj_obj, Functor.comp_obj, mk_left, Functor.comp_map, mk_hom_eq_self,\n      ‚Üê w œÜ, Functor.map_comp, Category.assoc]\n\n"}
{"name":"CategoryTheory.StructuredArrow.w_prod_fst_assoc","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nC' : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C'\nD' : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D'\nS : D\nS' : D'\nT : CategoryTheory.Functor C D\nT' : CategoryTheory.Functor C' D'\nX Y : CategoryTheory.StructuredArrow { fst := S, snd := S' } (T.prod T')\nf : Quiver.Hom X Y\nZ : D\nh : Quiver.Hom (T.obj Y.right.1) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp X.hom.1 (CategoryTheory.CategoryStruct.comp (T.map f.right.1) h)) (CategoryTheory.CategoryStruct.comp Y.hom.1 h)","decl":"@[reassoc (attr := simp)]\ntheorem StructuredArrow.w_prod_fst {X Y : StructuredArrow (S, S') (T.prod T')}\n    (f : X ‚ü∂ Y) : X.hom.1 ‚â´ T.map f.right.1 = Y.hom.1 :=\n  congr_arg _root_.Prod.fst (StructuredArrow.w f)\n\n"}
{"name":"CategoryTheory.StructuredArrow.w_prod_fst","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nC' : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C'\nD' : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D'\nS : D\nS' : D'\nT : CategoryTheory.Functor C D\nT' : CategoryTheory.Functor C' D'\nX Y : CategoryTheory.StructuredArrow { fst := S, snd := S' } (T.prod T')\nf : Quiver.Hom X Y\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp X.hom.1 (T.map f.right.1)) Y.hom.1","decl":"@[reassoc (attr := simp)]\ntheorem StructuredArrow.w_prod_fst {X Y : StructuredArrow (S, S') (T.prod T')}\n    (f : X ‚ü∂ Y) : X.hom.1 ‚â´ T.map f.right.1 = Y.hom.1 :=\n  congr_arg _root_.Prod.fst (StructuredArrow.w f)\n\n"}
{"name":"CategoryTheory.StructuredArrow.w_prod_snd_assoc","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nC' : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C'\nD' : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D'\nS : D\nS' : D'\nT : CategoryTheory.Functor C D\nT' : CategoryTheory.Functor C' D'\nX Y : CategoryTheory.StructuredArrow { fst := S, snd := S' } (T.prod T')\nf : Quiver.Hom X Y\nZ : D'\nh : Quiver.Hom (T'.obj Y.right.2) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp X.hom.2 (CategoryTheory.CategoryStruct.comp (T'.map f.right.2) h)) (CategoryTheory.CategoryStruct.comp Y.hom.2 h)","decl":"@[reassoc (attr := simp)]\ntheorem StructuredArrow.w_prod_snd {X Y : StructuredArrow (S, S') (T.prod T')}\n    (f : X ‚ü∂ Y) : X.hom.2 ‚â´ T'.map f.right.2 = Y.hom.2 :=\n  congr_arg _root_.Prod.snd (StructuredArrow.w f)\n\n"}
{"name":"CategoryTheory.StructuredArrow.w_prod_snd","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nC' : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C'\nD' : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D'\nS : D\nS' : D'\nT : CategoryTheory.Functor C D\nT' : CategoryTheory.Functor C' D'\nX Y : CategoryTheory.StructuredArrow { fst := S, snd := S' } (T.prod T')\nf : Quiver.Hom X Y\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp X.hom.2 (T'.map f.right.2)) Y.hom.2","decl":"@[reassoc (attr := simp)]\ntheorem StructuredArrow.w_prod_snd {X Y : StructuredArrow (S, S') (T.prod T')}\n    (f : X ‚ü∂ Y) : X.hom.2 ‚â´ T'.map f.right.2 = Y.hom.2 :=\n  congr_arg _root_.Prod.snd (StructuredArrow.w f)\n\n"}
{"name":"CategoryTheory.StructuredArrow.prodFunctor_obj","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nC' : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C'\nD' : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D'\nS : D\nS' : D'\nT : CategoryTheory.Functor C D\nT' : CategoryTheory.Functor C' D'\nf : CategoryTheory.StructuredArrow { fst := S, snd := S' } (T.prod T')\n‚ä¢ Eq ((CategoryTheory.StructuredArrow.prodFunctor S S' T T').obj f) { fst := CategoryTheory.StructuredArrow.mk f.hom.1, snd := CategoryTheory.StructuredArrow.mk f.hom.2 }","decl":"/-- Implementation; see `StructuredArrow.prodEquivalence`. -/\n@[simps]\ndef StructuredArrow.prodFunctor :\n    StructuredArrow (S, S') (T.prod T') ‚•§ StructuredArrow S T √ó StructuredArrow S' T' where\n  obj f := ‚ü®.mk f.hom.1, .mk f.hom.2‚ü©\n  map Œ∑ := ‚ü®StructuredArrow.homMk Œ∑.right.1 (by simp),\n            StructuredArrow.homMk Œ∑.right.2 (by simp)‚ü©\n\n"}
{"name":"CategoryTheory.StructuredArrow.prodFunctor_map","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nC' : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C'\nD' : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D'\nS : D\nS' : D'\nT : CategoryTheory.Functor C D\nT' : CategoryTheory.Functor C' D'\nX‚úù Y‚úù : CategoryTheory.StructuredArrow { fst := S, snd := S' } (T.prod T')\nŒ∑ : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.StructuredArrow.prodFunctor S S' T T').map Œ∑) { fst := CategoryTheory.StructuredArrow.homMk Œ∑.right.1 ‚ãØ, snd := CategoryTheory.StructuredArrow.homMk Œ∑.right.2 ‚ãØ }","decl":"/-- Implementation; see `StructuredArrow.prodEquivalence`. -/\n@[simps]\ndef StructuredArrow.prodFunctor :\n    StructuredArrow (S, S') (T.prod T') ‚•§ StructuredArrow S T √ó StructuredArrow S' T' where\n  obj f := ‚ü®.mk f.hom.1, .mk f.hom.2‚ü©\n  map Œ∑ := ‚ü®StructuredArrow.homMk Œ∑.right.1 (by simp),\n            StructuredArrow.homMk Œ∑.right.2 (by simp)‚ü©\n\n"}
{"name":"CategoryTheory.StructuredArrow.prodInverse_obj","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nC' : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C'\nD' : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D'\nS : D\nS' : D'\nT : CategoryTheory.Functor C D\nT' : CategoryTheory.Functor C' D'\nf : Prod (CategoryTheory.StructuredArrow S T) (CategoryTheory.StructuredArrow S' T')\n‚ä¢ Eq ((CategoryTheory.StructuredArrow.prodInverse S S' T T').obj f) (CategoryTheory.StructuredArrow.mk { fst := f.1.hom, snd := f.2.hom })","decl":"/-- Implementation; see `StructuredArrow.prodEquivalence`. -/\n@[simps]\ndef StructuredArrow.prodInverse :\n    StructuredArrow S T √ó StructuredArrow S' T' ‚•§ StructuredArrow (S, S') (T.prod T') where\n  obj f := .mk (Y := (f.1.right, f.2.right)) ‚ü®f.1.hom, f.2.hom‚ü©\n  map Œ∑ := StructuredArrow.homMk ‚ü®Œ∑.1.right, Œ∑.2.right‚ü© (by simp)\n\n"}
{"name":"CategoryTheory.StructuredArrow.prodInverse_map","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nC' : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C'\nD' : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D'\nS : D\nS' : D'\nT : CategoryTheory.Functor C D\nT' : CategoryTheory.Functor C' D'\nX‚úù Y‚úù : Prod (CategoryTheory.StructuredArrow S T) (CategoryTheory.StructuredArrow S' T')\nŒ∑ : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.StructuredArrow.prodInverse S S' T T').map Œ∑) (CategoryTheory.StructuredArrow.homMk { fst := Œ∑.1.right, snd := Œ∑.2.right } ‚ãØ)","decl":"/-- Implementation; see `StructuredArrow.prodEquivalence`. -/\n@[simps]\ndef StructuredArrow.prodInverse :\n    StructuredArrow S T √ó StructuredArrow S' T' ‚•§ StructuredArrow (S, S') (T.prod T') where\n  obj f := .mk (Y := (f.1.right, f.2.right)) ‚ü®f.1.hom, f.2.hom‚ü©\n  map Œ∑ := StructuredArrow.homMk ‚ü®Œ∑.1.right, Œ∑.2.right‚ü© (by simp)\n\n"}
{"name":"CategoryTheory.StructuredArrow.prodEquivalence_functor","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nC' : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C'\nD' : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D'\nS : D\nS' : D'\nT : CategoryTheory.Functor C D\nT' : CategoryTheory.Functor C' D'\n‚ä¢ Eq (CategoryTheory.StructuredArrow.prodEquivalence S S' T T').functor (CategoryTheory.StructuredArrow.prodFunctor S S' T T')","decl":"/-- The natural equivalence\n`StructuredArrow (S, S') (T.prod T') ‚âå StructuredArrow S T √ó StructuredArrow S' T'`. -/\n@[simps]\ndef StructuredArrow.prodEquivalence :\n    StructuredArrow (S, S') (T.prod T') ‚âå StructuredArrow S T √ó StructuredArrow S' T' where\n  functor := StructuredArrow.prodFunctor S S' T T'\n  inverse := StructuredArrow.prodInverse S S' T T'\n  unitIso := NatIso.ofComponents (fun f => Iso.refl _) (by simp)\n  counitIso := NatIso.ofComponents (fun f => Iso.refl _) (by simp)\n\n"}
{"name":"CategoryTheory.StructuredArrow.prodEquivalence_unitIso","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nC' : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C'\nD' : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D'\nS : D\nS' : D'\nT : CategoryTheory.Functor C D\nT' : CategoryTheory.Functor C' D'\n‚ä¢ Eq (CategoryTheory.StructuredArrow.prodEquivalence S S' T T').unitIso (CategoryTheory.NatIso.ofComponents (fun f => CategoryTheory.Iso.refl ((CategoryTheory.Functor.id (CategoryTheory.StructuredArrow { fst := S, snd := S' } (T.prod T'))).obj f)) ‚ãØ)","decl":"/-- The natural equivalence\n`StructuredArrow (S, S') (T.prod T') ‚âå StructuredArrow S T √ó StructuredArrow S' T'`. -/\n@[simps]\ndef StructuredArrow.prodEquivalence :\n    StructuredArrow (S, S') (T.prod T') ‚âå StructuredArrow S T √ó StructuredArrow S' T' where\n  functor := StructuredArrow.prodFunctor S S' T T'\n  inverse := StructuredArrow.prodInverse S S' T T'\n  unitIso := NatIso.ofComponents (fun f => Iso.refl _) (by simp)\n  counitIso := NatIso.ofComponents (fun f => Iso.refl _) (by simp)\n\n"}
{"name":"CategoryTheory.StructuredArrow.prodEquivalence_inverse","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nC' : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C'\nD' : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D'\nS : D\nS' : D'\nT : CategoryTheory.Functor C D\nT' : CategoryTheory.Functor C' D'\n‚ä¢ Eq (CategoryTheory.StructuredArrow.prodEquivalence S S' T T').inverse (CategoryTheory.StructuredArrow.prodInverse S S' T T')","decl":"/-- The natural equivalence\n`StructuredArrow (S, S') (T.prod T') ‚âå StructuredArrow S T √ó StructuredArrow S' T'`. -/\n@[simps]\ndef StructuredArrow.prodEquivalence :\n    StructuredArrow (S, S') (T.prod T') ‚âå StructuredArrow S T √ó StructuredArrow S' T' where\n  functor := StructuredArrow.prodFunctor S S' T T'\n  inverse := StructuredArrow.prodInverse S S' T T'\n  unitIso := NatIso.ofComponents (fun f => Iso.refl _) (by simp)\n  counitIso := NatIso.ofComponents (fun f => Iso.refl _) (by simp)\n\n"}
{"name":"CategoryTheory.StructuredArrow.prodEquivalence_counitIso","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nC' : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C'\nD' : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D'\nS : D\nS' : D'\nT : CategoryTheory.Functor C D\nT' : CategoryTheory.Functor C' D'\n‚ä¢ Eq (CategoryTheory.StructuredArrow.prodEquivalence S S' T T').counitIso (CategoryTheory.NatIso.ofComponents (fun f => CategoryTheory.Iso.refl (((CategoryTheory.StructuredArrow.prodInverse S S' T T').comp (CategoryTheory.StructuredArrow.prodFunctor S S' T T')).obj f)) ‚ãØ)","decl":"/-- The natural equivalence\n`StructuredArrow (S, S') (T.prod T') ‚âå StructuredArrow S T √ó StructuredArrow S' T'`. -/\n@[simps]\ndef StructuredArrow.prodEquivalence :\n    StructuredArrow (S, S') (T.prod T') ‚âå StructuredArrow S T √ó StructuredArrow S' T' where\n  functor := StructuredArrow.prodFunctor S S' T T'\n  inverse := StructuredArrow.prodInverse S S' T T'\n  unitIso := NatIso.ofComponents (fun f => Iso.refl _) (by simp)\n  counitIso := NatIso.ofComponents (fun f => Iso.refl _) (by simp)\n\n"}
{"name":"CategoryTheory.CostructuredArrow.w_prod_fst_assoc","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nC' : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C'\nD' : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D'\nS : CategoryTheory.Functor C D\nS' : CategoryTheory.Functor C' D'\nT : D\nT' : D'\nA B : CategoryTheory.CostructuredArrow (S.prod S') { fst := T, snd := T' }\nf : Quiver.Hom A B\nZ : D\nh : Quiver.Hom ((CategoryTheory.Functor.fromPUnit { fst := T, snd := T' }).obj B.right).1 Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (S.map f.left.1) (CategoryTheory.CategoryStruct.comp B.hom.1 h)) (CategoryTheory.CategoryStruct.comp A.hom.1 h)","decl":"@[reassoc (attr := simp)]\ntheorem CostructuredArrow.w_prod_fst {A B : CostructuredArrow (S.prod S') (T, T')} (f : A ‚ü∂ B) :\n    S.map f.left.1 ‚â´ B.hom.1 = A.hom.1 :=\n  congr_arg _root_.Prod.fst (CostructuredArrow.w f)\n\n"}
{"name":"CategoryTheory.CostructuredArrow.w_prod_fst","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nC' : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C'\nD' : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D'\nS : CategoryTheory.Functor C D\nS' : CategoryTheory.Functor C' D'\nT : D\nT' : D'\nA B : CategoryTheory.CostructuredArrow (S.prod S') { fst := T, snd := T' }\nf : Quiver.Hom A B\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (S.map f.left.1) B.hom.1) A.hom.1","decl":"@[reassoc (attr := simp)]\ntheorem CostructuredArrow.w_prod_fst {A B : CostructuredArrow (S.prod S') (T, T')} (f : A ‚ü∂ B) :\n    S.map f.left.1 ‚â´ B.hom.1 = A.hom.1 :=\n  congr_arg _root_.Prod.fst (CostructuredArrow.w f)\n\n"}
{"name":"CategoryTheory.CostructuredArrow.w_prod_snd","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nC' : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C'\nD' : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D'\nS : CategoryTheory.Functor C D\nS' : CategoryTheory.Functor C' D'\nT : D\nT' : D'\nA B : CategoryTheory.CostructuredArrow (S.prod S') { fst := T, snd := T' }\nf : Quiver.Hom A B\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (S'.map f.left.2) B.hom.2) A.hom.2","decl":"@[reassoc (attr := simp)]\ntheorem CostructuredArrow.w_prod_snd {A B : CostructuredArrow (S.prod S') (T, T')} (f : A ‚ü∂ B) :\n    S'.map f.left.2 ‚â´ B.hom.2 = A.hom.2 :=\n  congr_arg _root_.Prod.snd (CostructuredArrow.w f)\n\n"}
{"name":"CategoryTheory.CostructuredArrow.w_prod_snd_assoc","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nC' : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C'\nD' : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D'\nS : CategoryTheory.Functor C D\nS' : CategoryTheory.Functor C' D'\nT : D\nT' : D'\nA B : CategoryTheory.CostructuredArrow (S.prod S') { fst := T, snd := T' }\nf : Quiver.Hom A B\nZ : D'\nh : Quiver.Hom ((CategoryTheory.Functor.fromPUnit { fst := T, snd := T' }).obj B.right).2 Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (S'.map f.left.2) (CategoryTheory.CategoryStruct.comp B.hom.2 h)) (CategoryTheory.CategoryStruct.comp A.hom.2 h)","decl":"@[reassoc (attr := simp)]\ntheorem CostructuredArrow.w_prod_snd {A B : CostructuredArrow (S.prod S') (T, T')} (f : A ‚ü∂ B) :\n    S'.map f.left.2 ‚â´ B.hom.2 = A.hom.2 :=\n  congr_arg _root_.Prod.snd (CostructuredArrow.w f)\n\n"}
{"name":"CategoryTheory.CostructuredArrow.prodFunctor_obj","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nC' : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C'\nD' : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D'\nS : CategoryTheory.Functor C D\nS' : CategoryTheory.Functor C' D'\nT : D\nT' : D'\nf : CategoryTheory.CostructuredArrow (S.prod S') { fst := T, snd := T' }\n‚ä¢ Eq ((CategoryTheory.CostructuredArrow.prodFunctor S S' T T').obj f) { fst := CategoryTheory.CostructuredArrow.mk f.hom.1, snd := CategoryTheory.CostructuredArrow.mk f.hom.2 }","decl":"/-- Implementation; see `CostructuredArrow.prodEquivalence`. -/\n@[simps]\ndef CostructuredArrow.prodFunctor :\n    CostructuredArrow (S.prod S') (T, T') ‚•§ CostructuredArrow S T √ó CostructuredArrow S' T' where\n  obj f := ‚ü®.mk f.hom.1, .mk f.hom.2‚ü©\n  map Œ∑ := ‚ü®CostructuredArrow.homMk Œ∑.left.1 (by simp),\n            CostructuredArrow.homMk Œ∑.left.2 (by simp)‚ü©\n\n"}
{"name":"CategoryTheory.CostructuredArrow.prodFunctor_map","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nC' : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C'\nD' : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D'\nS : CategoryTheory.Functor C D\nS' : CategoryTheory.Functor C' D'\nT : D\nT' : D'\nX‚úù Y‚úù : CategoryTheory.CostructuredArrow (S.prod S') { fst := T, snd := T' }\nŒ∑ : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.CostructuredArrow.prodFunctor S S' T T').map Œ∑) { fst := CategoryTheory.CostructuredArrow.homMk Œ∑.left.1 ‚ãØ, snd := CategoryTheory.CostructuredArrow.homMk Œ∑.left.2 ‚ãØ }","decl":"/-- Implementation; see `CostructuredArrow.prodEquivalence`. -/\n@[simps]\ndef CostructuredArrow.prodFunctor :\n    CostructuredArrow (S.prod S') (T, T') ‚•§ CostructuredArrow S T √ó CostructuredArrow S' T' where\n  obj f := ‚ü®.mk f.hom.1, .mk f.hom.2‚ü©\n  map Œ∑ := ‚ü®CostructuredArrow.homMk Œ∑.left.1 (by simp),\n            CostructuredArrow.homMk Œ∑.left.2 (by simp)‚ü©\n\n"}
{"name":"CategoryTheory.CostructuredArrow.prodInverse_map","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nC' : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C'\nD' : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D'\nS : CategoryTheory.Functor C D\nS' : CategoryTheory.Functor C' D'\nT : D\nT' : D'\nX‚úù Y‚úù : Prod (CategoryTheory.CostructuredArrow S T) (CategoryTheory.CostructuredArrow S' T')\nŒ∑ : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.CostructuredArrow.prodInverse S S' T T').map Œ∑) (CategoryTheory.CostructuredArrow.homMk { fst := Œ∑.1.left, snd := Œ∑.2.left } ‚ãØ)","decl":"/-- Implementation; see `CostructuredArrow.prodEquivalence`. -/\n@[simps]\ndef CostructuredArrow.prodInverse :\n    CostructuredArrow S T √ó CostructuredArrow S' T' ‚•§ CostructuredArrow (S.prod S') (T, T') where\n  obj f := .mk (Y := (f.1.left, f.2.left)) ‚ü®f.1.hom, f.2.hom‚ü©\n  map Œ∑ := CostructuredArrow.homMk ‚ü®Œ∑.1.left, Œ∑.2.left‚ü© (by simp)\n\n"}
{"name":"CategoryTheory.CostructuredArrow.prodInverse_obj","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nC' : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C'\nD' : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D'\nS : CategoryTheory.Functor C D\nS' : CategoryTheory.Functor C' D'\nT : D\nT' : D'\nf : Prod (CategoryTheory.CostructuredArrow S T) (CategoryTheory.CostructuredArrow S' T')\n‚ä¢ Eq ((CategoryTheory.CostructuredArrow.prodInverse S S' T T').obj f) (CategoryTheory.CostructuredArrow.mk { fst := f.1.hom, snd := f.2.hom })","decl":"/-- Implementation; see `CostructuredArrow.prodEquivalence`. -/\n@[simps]\ndef CostructuredArrow.prodInverse :\n    CostructuredArrow S T √ó CostructuredArrow S' T' ‚•§ CostructuredArrow (S.prod S') (T, T') where\n  obj f := .mk (Y := (f.1.left, f.2.left)) ‚ü®f.1.hom, f.2.hom‚ü©\n  map Œ∑ := CostructuredArrow.homMk ‚ü®Œ∑.1.left, Œ∑.2.left‚ü© (by simp)\n\n"}
{"name":"CategoryTheory.CostructuredArrow.prodEquivalence_unitIso","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nC' : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C'\nD' : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D'\nS : CategoryTheory.Functor C D\nS' : CategoryTheory.Functor C' D'\nT : D\nT' : D'\n‚ä¢ Eq (CategoryTheory.CostructuredArrow.prodEquivalence S S' T T').unitIso (CategoryTheory.NatIso.ofComponents (fun f => CategoryTheory.Iso.refl ((CategoryTheory.Functor.id (CategoryTheory.CostructuredArrow (S.prod S') { fst := T, snd := T' })).obj f)) ‚ãØ)","decl":"/-- The natural equivalence\n`CostructuredArrow (S.prod S') (T, T') ‚âå CostructuredArrow S T √ó CostructuredArrow S' T'`. -/\n@[simps]\ndef CostructuredArrow.prodEquivalence :\n    CostructuredArrow (S.prod S') (T, T') ‚âå CostructuredArrow S T √ó CostructuredArrow S' T' where\n  functor := CostructuredArrow.prodFunctor S S' T T'\n  inverse := CostructuredArrow.prodInverse S S' T T'\n  unitIso := NatIso.ofComponents (fun f => Iso.refl _) (by simp)\n  counitIso := NatIso.ofComponents (fun f => Iso.refl _) (by simp)\n\n"}
{"name":"CategoryTheory.CostructuredArrow.prodEquivalence_functor","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nC' : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C'\nD' : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D'\nS : CategoryTheory.Functor C D\nS' : CategoryTheory.Functor C' D'\nT : D\nT' : D'\n‚ä¢ Eq (CategoryTheory.CostructuredArrow.prodEquivalence S S' T T').functor (CategoryTheory.CostructuredArrow.prodFunctor S S' T T')","decl":"/-- The natural equivalence\n`CostructuredArrow (S.prod S') (T, T') ‚âå CostructuredArrow S T √ó CostructuredArrow S' T'`. -/\n@[simps]\ndef CostructuredArrow.prodEquivalence :\n    CostructuredArrow (S.prod S') (T, T') ‚âå CostructuredArrow S T √ó CostructuredArrow S' T' where\n  functor := CostructuredArrow.prodFunctor S S' T T'\n  inverse := CostructuredArrow.prodInverse S S' T T'\n  unitIso := NatIso.ofComponents (fun f => Iso.refl _) (by simp)\n  counitIso := NatIso.ofComponents (fun f => Iso.refl _) (by simp)\n\n"}
{"name":"CategoryTheory.CostructuredArrow.prodEquivalence_counitIso","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nC' : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C'\nD' : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D'\nS : CategoryTheory.Functor C D\nS' : CategoryTheory.Functor C' D'\nT : D\nT' : D'\n‚ä¢ Eq (CategoryTheory.CostructuredArrow.prodEquivalence S S' T T').counitIso (CategoryTheory.NatIso.ofComponents (fun f => CategoryTheory.Iso.refl (((CategoryTheory.CostructuredArrow.prodInverse S S' T T').comp (CategoryTheory.CostructuredArrow.prodFunctor S S' T T')).obj f)) ‚ãØ)","decl":"/-- The natural equivalence\n`CostructuredArrow (S.prod S') (T, T') ‚âå CostructuredArrow S T √ó CostructuredArrow S' T'`. -/\n@[simps]\ndef CostructuredArrow.prodEquivalence :\n    CostructuredArrow (S.prod S') (T, T') ‚âå CostructuredArrow S T √ó CostructuredArrow S' T' where\n  functor := CostructuredArrow.prodFunctor S S' T T'\n  inverse := CostructuredArrow.prodInverse S S' T T'\n  unitIso := NatIso.ofComponents (fun f => Iso.refl _) (by simp)\n  counitIso := NatIso.ofComponents (fun f => Iso.refl _) (by simp)\n\n"}
{"name":"CategoryTheory.CostructuredArrow.prodEquivalence_inverse","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nC' : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C'\nD' : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D'\nS : CategoryTheory.Functor C D\nS' : CategoryTheory.Functor C' D'\nT : D\nT' : D'\n‚ä¢ Eq (CategoryTheory.CostructuredArrow.prodEquivalence S S' T T').inverse (CategoryTheory.CostructuredArrow.prodInverse S S' T T')","decl":"/-- The natural equivalence\n`CostructuredArrow (S.prod S') (T, T') ‚âå CostructuredArrow S T √ó CostructuredArrow S' T'`. -/\n@[simps]\ndef CostructuredArrow.prodEquivalence :\n    CostructuredArrow (S.prod S') (T, T') ‚âå CostructuredArrow S T √ó CostructuredArrow S' T' where\n  functor := CostructuredArrow.prodFunctor S S' T T'\n  inverse := CostructuredArrow.prodInverse S S' T T'\n  unitIso := NatIso.ofComponents (fun f => Iso.refl _) (by simp)\n  counitIso := NatIso.ofComponents (fun f => Iso.refl _) (by simp)\n\n"}
