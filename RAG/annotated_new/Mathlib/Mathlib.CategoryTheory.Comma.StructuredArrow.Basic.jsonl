{"name":"CategoryTheory.StructuredArrow.proj_obj","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nS : D\nT : CategoryTheory.Functor C D\nX : CategoryTheory.Comma (CategoryTheory.Functor.fromPUnit S) T\n⊢ Eq ((CategoryTheory.StructuredArrow.proj S T).obj X) X.right","decl":"/-- The obvious projection functor from structured arrows. -/\n@[simps!]\ndef proj (S : D) (T : C ⥤ D) : StructuredArrow S T ⥤ C :=\n  Comma.snd _ _\n\n"}
{"name":"CategoryTheory.StructuredArrow.proj_map","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nS : D\nT : CategoryTheory.Functor C D\nX✝ Y✝ : CategoryTheory.Comma (CategoryTheory.Functor.fromPUnit S) T\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.StructuredArrow.proj S T).map f) f.right","decl":"/-- The obvious projection functor from structured arrows. -/\n@[simps!]\ndef proj (S : D) (T : C ⥤ D) : StructuredArrow S T ⥤ C :=\n  Comma.snd _ _\n\n"}
{"name":"CategoryTheory.StructuredArrow.hom_ext","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nS : D\nT : CategoryTheory.Functor C D\nX Y : CategoryTheory.StructuredArrow S T\nf g : Quiver.Hom X Y\nh : Eq f.right g.right\n⊢ Eq f g","decl":"@[ext]\nlemma hom_ext {X Y : StructuredArrow S T} (f g : X ⟶ Y) (h : f.right = g.right) : f = g :=\n  CommaMorphism.ext (Subsingleton.elim _ _) h\n\n"}
{"name":"CategoryTheory.StructuredArrow.hom_ext_iff","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nS : D\nT : CategoryTheory.Functor C D\nX Y : CategoryTheory.StructuredArrow S T\nf g : Quiver.Hom X Y\n⊢ Iff (Eq f g) (Eq f.right g.right)","decl":"@[ext]\nlemma hom_ext {X Y : StructuredArrow S T} (f g : X ⟶ Y) (h : f.right = g.right) : f = g :=\n  CommaMorphism.ext (Subsingleton.elim _ _) h\n\n"}
{"name":"CategoryTheory.StructuredArrow.hom_eq_iff","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nS : D\nT : CategoryTheory.Functor C D\nX Y : CategoryTheory.StructuredArrow S T\nf g : Quiver.Hom X Y\n⊢ Iff (Eq f g) (Eq f.right g.right)","decl":"@[simp]\ntheorem hom_eq_iff {X Y : StructuredArrow S T} (f g : X ⟶ Y) : f = g ↔ f.right = g.right :=\n  ⟨fun h ↦ by rw [h], hom_ext _ _⟩\n\n"}
{"name":"CategoryTheory.StructuredArrow.mk_left","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nS : D\nY : C\nT : CategoryTheory.Functor C D\nf : Quiver.Hom S (T.obj Y)\n⊢ Eq (CategoryTheory.StructuredArrow.mk f).left { as := PUnit.unit }","decl":"@[simp]\ntheorem mk_left (f : S ⟶ T.obj Y) : (mk f).left = ⟨⟨⟩⟩ :=\n  rfl\n\n"}
{"name":"CategoryTheory.StructuredArrow.mk_right","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nS : D\nY : C\nT : CategoryTheory.Functor C D\nf : Quiver.Hom S (T.obj Y)\n⊢ Eq (CategoryTheory.StructuredArrow.mk f).right Y","decl":"@[simp]\ntheorem mk_right (f : S ⟶ T.obj Y) : (mk f).right = Y :=\n  rfl\n\n"}
{"name":"CategoryTheory.StructuredArrow.mk_hom_eq_self","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nS : D\nY : C\nT : CategoryTheory.Functor C D\nf : Quiver.Hom S (T.obj Y)\n⊢ Eq (CategoryTheory.StructuredArrow.mk f).hom f","decl":"@[simp]\ntheorem mk_hom_eq_self (f : S ⟶ T.obj Y) : (mk f).hom = f :=\n  rfl\n\n"}
{"name":"CategoryTheory.StructuredArrow.w_assoc","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nS : D\nT : CategoryTheory.Functor C D\nA B : CategoryTheory.StructuredArrow S T\nf : Quiver.Hom A B\nZ : D\nh : Quiver.Hom (T.obj B.right) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp A.hom (CategoryTheory.CategoryStruct.comp (T.map f.right) h)) (CategoryTheory.CategoryStruct.comp B.hom h)","decl":"@[reassoc (attr := simp)]\ntheorem w {A B : StructuredArrow S T} (f : A ⟶ B) : A.hom ≫ T.map f.right = B.hom := by\n  have := f.w; aesop_cat\n\n"}
{"name":"CategoryTheory.StructuredArrow.w","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nS : D\nT : CategoryTheory.Functor C D\nA B : CategoryTheory.StructuredArrow S T\nf : Quiver.Hom A B\n⊢ Eq (CategoryTheory.CategoryStruct.comp A.hom (T.map f.right)) B.hom","decl":"@[reassoc (attr := simp)]\ntheorem w {A B : StructuredArrow S T} (f : A ⟶ B) : A.hom ≫ T.map f.right = B.hom := by\n  have := f.w; aesop_cat\n\n"}
{"name":"CategoryTheory.StructuredArrow.comp_right","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nS : D\nT : CategoryTheory.Functor C D\nX Y Z : CategoryTheory.StructuredArrow S T\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp f g).right (CategoryTheory.CategoryStruct.comp f.right g.right)","decl":"@[simp]\ntheorem comp_right {X Y Z : StructuredArrow S T} (f : X ⟶ Y) (g : Y ⟶ Z) :\n    (f ≫ g).right = f.right ≫ g.right := rfl\n\n"}
{"name":"CategoryTheory.StructuredArrow.id_right","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nS : D\nT : CategoryTheory.Functor C D\nX : CategoryTheory.StructuredArrow S T\n⊢ Eq (CategoryTheory.CategoryStruct.id X).right (CategoryTheory.CategoryStruct.id X.right)","decl":"@[simp]\ntheorem id_right (X : StructuredArrow S T) : (𝟙 X : X ⟶ X).right = 𝟙 X.right := rfl\n\n"}
{"name":"CategoryTheory.StructuredArrow.eqToHom_right","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nS : D\nT : CategoryTheory.Functor C D\nX Y : CategoryTheory.StructuredArrow S T\nh : Eq X Y\n⊢ Eq (CategoryTheory.eqToHom h).right (CategoryTheory.eqToHom ⋯)","decl":"@[simp]\ntheorem eqToHom_right {X Y : StructuredArrow S T} (h : X = Y) :\n    (eqToHom h).right = eqToHom (by rw [h]) := by\n  subst h\n  simp only [eqToHom_refl, id_right]\n\n"}
{"name":"CategoryTheory.StructuredArrow.left_eq_id","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nS : D\nT : CategoryTheory.Functor C D\nX Y : CategoryTheory.StructuredArrow S T\nf : Quiver.Hom X Y\n⊢ Eq f.left (CategoryTheory.CategoryStruct.id X.left)","decl":"@[simp]\ntheorem left_eq_id {X Y : StructuredArrow S T} (f : X ⟶ Y) : f.left = 𝟙 X.left := rfl\n\n"}
{"name":"CategoryTheory.StructuredArrow.homMk_right","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nS : D\nT : CategoryTheory.Functor C D\nf f' : CategoryTheory.StructuredArrow S T\ng : Quiver.Hom f.right f'.right\nw : autoParam (Eq (CategoryTheory.CategoryStruct.comp f.hom (T.map g)) f'.hom) _auto✝\n⊢ Eq (CategoryTheory.StructuredArrow.homMk g w).right g","decl":"/-- To construct a morphism of structured arrows,\nwe need a morphism of the objects underlying the target,\nand to check that the triangle commutes.\n-/\n@[simps right]\ndef homMk {f f' : StructuredArrow S T} (g : f.right ⟶ f'.right)\n    (w : f.hom ≫ T.map g = f'.hom := by aesop_cat) : f ⟶ f' where\n  left := 𝟙 f.left\n  right := g\n  w := by\n    dsimp\n    simpa using w.symm\n\n"}
{"name":"CategoryTheory.StructuredArrow.homMk_surjective","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nS : D\nT : CategoryTheory.Functor C D\nf f' : CategoryTheory.StructuredArrow S T\nφ : Quiver.Hom f f'\n⊢ Exists fun ψ => Exists fun hψ => Eq φ (CategoryTheory.StructuredArrow.homMk ψ hψ)","decl":"theorem homMk_surjective {f f' : StructuredArrow S T} (φ : f ⟶ f') :\n    ∃ (ψ : f.right ⟶ f'.right) (hψ : f.hom ≫ T.map ψ = f'.hom),\n      φ = StructuredArrow.homMk ψ hψ :=\n  ⟨φ.right, StructuredArrow.w φ, rfl⟩\n\n"}
{"name":"CategoryTheory.StructuredArrow.homMk'_right","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nS : D\nY' : C\nT : CategoryTheory.Functor C D\nf : CategoryTheory.StructuredArrow S T\ng : Quiver.Hom f.right Y'\n⊢ Eq (f.homMk' g).right g","decl":"/-- Given a structured arrow `X ⟶ T(Y)`, and an arrow `Y ⟶ Y'`, we can construct a morphism of\n    structured arrows given by `(X ⟶ T(Y)) ⟶ (X ⟶ T(Y) ⟶ T(Y'))`. -/\n@[simps]\ndef homMk' (f : StructuredArrow S T) (g : f.right ⟶ Y') : f ⟶ mk (f.hom ≫ T.map g) where\n  left := 𝟙 _\n  right := g\n\n"}
{"name":"CategoryTheory.StructuredArrow.homMk'_left","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nS : D\nY' : C\nT : CategoryTheory.Functor C D\nf : CategoryTheory.StructuredArrow S T\ng : Quiver.Hom f.right Y'\n⊢ Eq (f.homMk' g).left (CategoryTheory.CategoryStruct.id f.left)","decl":"/-- Given a structured arrow `X ⟶ T(Y)`, and an arrow `Y ⟶ Y'`, we can construct a morphism of\n    structured arrows given by `(X ⟶ T(Y)) ⟶ (X ⟶ T(Y) ⟶ T(Y'))`. -/\n@[simps]\ndef homMk' (f : StructuredArrow S T) (g : f.right ⟶ Y') : f ⟶ mk (f.hom ≫ T.map g) where\n  left := 𝟙 _\n  right := g\n\n"}
{"name":"CategoryTheory.StructuredArrow.homMk'_id","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nS : D\nT : CategoryTheory.Functor C D\nf : CategoryTheory.StructuredArrow S T\n⊢ Eq (f.homMk' (CategoryTheory.CategoryStruct.id f.right)) (CategoryTheory.eqToHom ⋯)","decl":"lemma homMk'_id (f : StructuredArrow S T) : homMk' f (𝟙 f.right) = eqToHom (by aesop_cat) := by\n  ext\n  simp [eqToHom_right]\n\n"}
{"name":"CategoryTheory.StructuredArrow.homMk'_mk_id","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nS : D\nY : C\nT : CategoryTheory.Functor C D\nf : Quiver.Hom S (T.obj Y)\n⊢ Eq ((CategoryTheory.StructuredArrow.mk f).homMk' (CategoryTheory.CategoryStruct.id Y)) (CategoryTheory.eqToHom ⋯)","decl":"lemma homMk'_mk_id (f : S ⟶ T.obj Y) : homMk' (mk f) (𝟙 Y) = eqToHom (by simp) :=\n  homMk'_id _\n\n"}
{"name":"CategoryTheory.StructuredArrow.homMk'_comp","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nS : D\nY' Y'' : C\nT : CategoryTheory.Functor C D\nf : CategoryTheory.StructuredArrow S T\ng : Quiver.Hom f.right Y'\ng' : Quiver.Hom Y' Y''\n⊢ Eq (f.homMk' (CategoryTheory.CategoryStruct.comp g g')) (CategoryTheory.CategoryStruct.comp (f.homMk' g) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.StructuredArrow.mk (CategoryTheory.CategoryStruct.comp f.hom (T.map g))).homMk' g') (CategoryTheory.eqToHom ⋯)))","decl":"lemma homMk'_comp (f : StructuredArrow S T) (g : f.right ⟶ Y') (g' : Y' ⟶ Y'') :\n    homMk' f (g ≫ g') = homMk' f g ≫ homMk' (mk (f.hom ≫ T.map g)) g' ≫ eqToHom (by simp) := by\n  ext\n  simp [eqToHom_right]\n\n"}
{"name":"CategoryTheory.StructuredArrow.homMk'_mk_comp","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nS : D\nY Y' Y'' : C\nT : CategoryTheory.Functor C D\nf : Quiver.Hom S (T.obj Y)\ng : Quiver.Hom Y Y'\ng' : Quiver.Hom Y' Y''\n⊢ Eq ((CategoryTheory.StructuredArrow.mk f).homMk' (CategoryTheory.CategoryStruct.comp g g')) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.StructuredArrow.mk f).homMk' g) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.StructuredArrow.mk (CategoryTheory.CategoryStruct.comp f (T.map g))).homMk' g') (CategoryTheory.eqToHom ⋯)))","decl":"lemma homMk'_mk_comp (f : S ⟶ T.obj Y) (g : Y ⟶ Y') (g' : Y' ⟶ Y'') :\n    homMk' (mk f) (g ≫ g') = homMk' (mk f) g ≫ homMk' (mk (f ≫ T.map g)) g' ≫ eqToHom (by simp) :=\n  homMk'_comp _ _ _\n\n"}
{"name":"CategoryTheory.StructuredArrow.mkPostcomp_right","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nS : D\nY Y' : C\nT : CategoryTheory.Functor C D\nf : Quiver.Hom S (T.obj Y)\ng : Quiver.Hom Y Y'\n⊢ Eq (CategoryTheory.StructuredArrow.mkPostcomp f g).right g","decl":"/-- Variant of `homMk'` where both objects are applications of `mk`. -/\n@[simps]\ndef mkPostcomp (f : S ⟶ T.obj Y) (g : Y ⟶ Y') : mk f ⟶ mk (f ≫ T.map g) where\n  left := 𝟙 _\n  right := g\n\n"}
{"name":"CategoryTheory.StructuredArrow.mkPostcomp_left","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nS : D\nY Y' : C\nT : CategoryTheory.Functor C D\nf : Quiver.Hom S (T.obj Y)\ng : Quiver.Hom Y Y'\n⊢ Eq (CategoryTheory.StructuredArrow.mkPostcomp f g).left (CategoryTheory.CategoryStruct.id (CategoryTheory.StructuredArrow.mk f).left)","decl":"/-- Variant of `homMk'` where both objects are applications of `mk`. -/\n@[simps]\ndef mkPostcomp (f : S ⟶ T.obj Y) (g : Y ⟶ Y') : mk f ⟶ mk (f ≫ T.map g) where\n  left := 𝟙 _\n  right := g\n\n"}
{"name":"CategoryTheory.StructuredArrow.mkPostcomp_id","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nS : D\nY : C\nT : CategoryTheory.Functor C D\nf : Quiver.Hom S (T.obj Y)\n⊢ Eq (CategoryTheory.StructuredArrow.mkPostcomp f (CategoryTheory.CategoryStruct.id Y)) (CategoryTheory.eqToHom ⋯)","decl":"lemma mkPostcomp_id (f : S ⟶ T.obj Y) : mkPostcomp f (𝟙 Y) = eqToHom (by simp) := by simp\n"}
{"name":"CategoryTheory.StructuredArrow.mkPostcomp_comp","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nS : D\nY Y' Y'' : C\nT : CategoryTheory.Functor C D\nf : Quiver.Hom S (T.obj Y)\ng : Quiver.Hom Y Y'\ng' : Quiver.Hom Y' Y''\n⊢ Eq (CategoryTheory.StructuredArrow.mkPostcomp f (CategoryTheory.CategoryStruct.comp g g')) (CategoryTheory.CategoryStruct.comp (CategoryTheory.StructuredArrow.mkPostcomp f g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.StructuredArrow.mkPostcomp (CategoryTheory.CategoryStruct.comp f (T.map g)) g') (CategoryTheory.eqToHom ⋯)))","decl":"lemma mkPostcomp_comp (f : S ⟶ T.obj Y) (g : Y ⟶ Y') (g' : Y' ⟶ Y'') :\n    mkPostcomp f (g ≫ g') = mkPostcomp f g ≫ mkPostcomp (f ≫ T.map g) g' ≫ eqToHom (by simp) := by\n  simp\n\n"}
{"name":"CategoryTheory.StructuredArrow.isoMk_hom_right","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nS : D\nT : CategoryTheory.Functor C D\nf f' : CategoryTheory.StructuredArrow S T\ng : CategoryTheory.Iso f.right f'.right\nw : autoParam (Eq (CategoryTheory.CategoryStruct.comp f.hom (T.map g.hom)) f'.hom) _auto✝\n⊢ Eq (CategoryTheory.StructuredArrow.isoMk g w).hom.right g.hom","decl":"/-- To construct an isomorphism of structured arrows,\nwe need an isomorphism of the objects underlying the target,\nand to check that the triangle commutes.\n-/\n@[simps! hom_right inv_right]\ndef isoMk {f f' : StructuredArrow S T} (g : f.right ≅ f'.right)\n    (w : f.hom ≫ T.map g.hom = f'.hom := by aesop_cat) :\n    f ≅ f' :=\n  Comma.isoMk (eqToIso (by ext)) g (by simpa using w.symm)\n\n"}
{"name":"CategoryTheory.StructuredArrow.isoMk_inv_right","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nS : D\nT : CategoryTheory.Functor C D\nf f' : CategoryTheory.StructuredArrow S T\ng : CategoryTheory.Iso f.right f'.right\nw : autoParam (Eq (CategoryTheory.CategoryStruct.comp f.hom (T.map g.hom)) f'.hom) _auto✝\n⊢ Eq (CategoryTheory.StructuredArrow.isoMk g w).inv.right g.inv","decl":"/-- To construct an isomorphism of structured arrows,\nwe need an isomorphism of the objects underlying the target,\nand to check that the triangle commutes.\n-/\n@[simps! hom_right inv_right]\ndef isoMk {f f' : StructuredArrow S T} (g : f.right ≅ f'.right)\n    (w : f.hom ≫ T.map g.hom = f'.hom := by aesop_cat) :\n    f ≅ f' :=\n  Comma.isoMk (eqToIso (by ext)) g (by simpa using w.symm)\n\n"}
{"name":"CategoryTheory.StructuredArrow.ext","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nS : D\nT : CategoryTheory.Functor C D\nA B : CategoryTheory.StructuredArrow S T\nf g : Quiver.Hom A B\na✝ : Eq f.right g.right\n⊢ Eq f g","decl":"theorem ext {A B : StructuredArrow S T} (f g : A ⟶ B) : f.right = g.right → f = g :=\n  CommaMorphism.ext (Subsingleton.elim _ _)\n\n"}
{"name":"CategoryTheory.StructuredArrow.ext_iff","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nS : D\nT : CategoryTheory.Functor C D\nA B : CategoryTheory.StructuredArrow S T\nf g : Quiver.Hom A B\n⊢ Iff (Eq f g) (Eq f.right g.right)","decl":"theorem ext_iff {A B : StructuredArrow S T} (f g : A ⟶ B) : f = g ↔ f.right = g.right :=\n  ⟨fun h => h ▸ rfl, ext f g⟩\n\n"}
{"name":"CategoryTheory.StructuredArrow.proj_faithful","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nS : D\nT : CategoryTheory.Functor C D\n⊢ (CategoryTheory.StructuredArrow.proj S T).Faithful","decl":"instance proj_faithful : (proj S T).Faithful where\n  map_injective {_ _} := ext\n\n"}
{"name":"CategoryTheory.StructuredArrow.mono_of_mono_right","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nS : D\nT : CategoryTheory.Functor C D\nA B : CategoryTheory.StructuredArrow S T\nf : Quiver.Hom A B\nh : CategoryTheory.Mono f.right\n⊢ CategoryTheory.Mono f","decl":"/-- The converse of this is true with additional assumptions, see `mono_iff_mono_right`. -/\ntheorem mono_of_mono_right {A B : StructuredArrow S T} (f : A ⟶ B) [h : Mono f.right] : Mono f :=\n  (proj S T).mono_of_mono_map h\n\n"}
{"name":"CategoryTheory.StructuredArrow.epi_of_epi_right","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nS : D\nT : CategoryTheory.Functor C D\nA B : CategoryTheory.StructuredArrow S T\nf : Quiver.Hom A B\nh : CategoryTheory.Epi f.right\n⊢ CategoryTheory.Epi f","decl":"theorem epi_of_epi_right {A B : StructuredArrow S T} (f : A ⟶ B) [h : Epi f.right] : Epi f :=\n  (proj S T).epi_of_epi_map h\n\n"}
{"name":"CategoryTheory.StructuredArrow.mono_homMk","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nS : D\nT : CategoryTheory.Functor C D\nA B : CategoryTheory.StructuredArrow S T\nf : Quiver.Hom A.right B.right\nw : Eq (CategoryTheory.CategoryStruct.comp A.hom (T.map f)) B.hom\nh : CategoryTheory.Mono f\n⊢ CategoryTheory.Mono (CategoryTheory.StructuredArrow.homMk f w)","decl":"instance mono_homMk {A B : StructuredArrow S T} (f : A.right ⟶ B.right) (w) [h : Mono f] :\n    Mono (homMk f w) :=\n  (proj S T).mono_of_mono_map h\n\n"}
{"name":"CategoryTheory.StructuredArrow.epi_homMk","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nS : D\nT : CategoryTheory.Functor C D\nA B : CategoryTheory.StructuredArrow S T\nf : Quiver.Hom A.right B.right\nw : Eq (CategoryTheory.CategoryStruct.comp A.hom (T.map f)) B.hom\nh : CategoryTheory.Epi f\n⊢ CategoryTheory.Epi (CategoryTheory.StructuredArrow.homMk f w)","decl":"instance epi_homMk {A B : StructuredArrow S T} (f : A.right ⟶ B.right) (w) [h : Epi f] :\n    Epi (homMk f w) :=\n  (proj S T).epi_of_epi_map h\n\n"}
{"name":"CategoryTheory.StructuredArrow.eq_mk","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nS : D\nT : CategoryTheory.Functor C D\nf : CategoryTheory.StructuredArrow S T\n⊢ Eq f (CategoryTheory.StructuredArrow.mk f.hom)","decl":"/-- Eta rule for structured arrows. Prefer `StructuredArrow.eta` for rewriting, since equality of\n    objects tends to cause problems. -/\ntheorem eq_mk (f : StructuredArrow S T) : f = mk f.hom :=\n  rfl\n\n"}
{"name":"CategoryTheory.StructuredArrow.eta_inv_right","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nS : D\nT : CategoryTheory.Functor C D\nf : CategoryTheory.StructuredArrow S T\n⊢ Eq f.eta.inv.right (CategoryTheory.CategoryStruct.id f.right)","decl":"/-- Eta rule for structured arrows. -/\n@[simps! hom_right inv_right]\ndef eta (f : StructuredArrow S T) : f ≅ mk f.hom :=\n  isoMk (Iso.refl _)\n\n"}
{"name":"CategoryTheory.StructuredArrow.eta_hom_right","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nS : D\nT : CategoryTheory.Functor C D\nf : CategoryTheory.StructuredArrow S T\n⊢ Eq f.eta.hom.right (CategoryTheory.CategoryStruct.id f.right)","decl":"/-- Eta rule for structured arrows. -/\n@[simps! hom_right inv_right]\ndef eta (f : StructuredArrow S T) : f ≅ mk f.hom :=\n  isoMk (Iso.refl _)\n\n"}
{"name":"CategoryTheory.StructuredArrow.mk_surjective","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nS : D\nT : CategoryTheory.Functor C D\nf : CategoryTheory.StructuredArrow S T\n⊢ Exists fun Y => Exists fun g => Eq f (CategoryTheory.StructuredArrow.mk g)","decl":"lemma mk_surjective (f : StructuredArrow S T) :\n    ∃ (Y : C) (g : S ⟶ T.obj Y), f = mk g :=\n  ⟨_, _, eq_mk f⟩\n\n"}
{"name":"CategoryTheory.StructuredArrow.map_obj_hom","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nS S' : D\nT : CategoryTheory.Functor C D\nf : Quiver.Hom S S'\nX : CategoryTheory.Comma (CategoryTheory.Functor.fromPUnit S') T\n⊢ Eq ((CategoryTheory.StructuredArrow.map f).obj X).hom (CategoryTheory.CategoryStruct.comp f X.hom)","decl":"/-- A morphism between source objects `S ⟶ S'`\ncontravariantly induces a functor between structured arrows,\n`StructuredArrow S' T ⥤ StructuredArrow S T`.\n\nIdeally this would be described as a 2-functor from `D`\n(promoted to a 2-category with equations as 2-morphisms)\nto `Cat`.\n-/\n@[simps!]\ndef map (f : S ⟶ S') : StructuredArrow S' T ⥤ StructuredArrow S T :=\n  Comma.mapLeft _ ((Functor.const _).map f)\n\n"}
{"name":"CategoryTheory.StructuredArrow.map_map_right","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nS S' : D\nT : CategoryTheory.Functor C D\nf✝ : Quiver.Hom S S'\nX✝ Y✝ : CategoryTheory.Comma (CategoryTheory.Functor.fromPUnit S') T\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.StructuredArrow.map f✝).map f).right f.right","decl":"/-- A morphism between source objects `S ⟶ S'`\ncontravariantly induces a functor between structured arrows,\n`StructuredArrow S' T ⥤ StructuredArrow S T`.\n\nIdeally this would be described as a 2-functor from `D`\n(promoted to a 2-category with equations as 2-morphisms)\nto `Cat`.\n-/\n@[simps!]\ndef map (f : S ⟶ S') : StructuredArrow S' T ⥤ StructuredArrow S T :=\n  Comma.mapLeft _ ((Functor.const _).map f)\n\n"}
{"name":"CategoryTheory.StructuredArrow.map_map_left","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nS S' : D\nT : CategoryTheory.Functor C D\nf✝ : Quiver.Hom S S'\nX✝ Y✝ : CategoryTheory.Comma (CategoryTheory.Functor.fromPUnit S') T\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.StructuredArrow.map f✝).map f).left (CategoryTheory.CategoryStruct.id X✝.left)","decl":"/-- A morphism between source objects `S ⟶ S'`\ncontravariantly induces a functor between structured arrows,\n`StructuredArrow S' T ⥤ StructuredArrow S T`.\n\nIdeally this would be described as a 2-functor from `D`\n(promoted to a 2-category with equations as 2-morphisms)\nto `Cat`.\n-/\n@[simps!]\ndef map (f : S ⟶ S') : StructuredArrow S' T ⥤ StructuredArrow S T :=\n  Comma.mapLeft _ ((Functor.const _).map f)\n\n"}
{"name":"CategoryTheory.StructuredArrow.map_obj_right","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nS S' : D\nT : CategoryTheory.Functor C D\nf : Quiver.Hom S S'\nX : CategoryTheory.Comma (CategoryTheory.Functor.fromPUnit S') T\n⊢ Eq ((CategoryTheory.StructuredArrow.map f).obj X).right X.right","decl":"/-- A morphism between source objects `S ⟶ S'`\ncontravariantly induces a functor between structured arrows,\n`StructuredArrow S' T ⥤ StructuredArrow S T`.\n\nIdeally this would be described as a 2-functor from `D`\n(promoted to a 2-category with equations as 2-morphisms)\nto `Cat`.\n-/\n@[simps!]\ndef map (f : S ⟶ S') : StructuredArrow S' T ⥤ StructuredArrow S T :=\n  Comma.mapLeft _ ((Functor.const _).map f)\n\n"}
{"name":"CategoryTheory.StructuredArrow.map_obj_left","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nS S' : D\nT : CategoryTheory.Functor C D\nf : Quiver.Hom S S'\nX : CategoryTheory.Comma (CategoryTheory.Functor.fromPUnit S') T\n⊢ Eq ((CategoryTheory.StructuredArrow.map f).obj X).left X.left","decl":"/-- A morphism between source objects `S ⟶ S'`\ncontravariantly induces a functor between structured arrows,\n`StructuredArrow S' T ⥤ StructuredArrow S T`.\n\nIdeally this would be described as a 2-functor from `D`\n(promoted to a 2-category with equations as 2-morphisms)\nto `Cat`.\n-/\n@[simps!]\ndef map (f : S ⟶ S') : StructuredArrow S' T ⥤ StructuredArrow S T :=\n  Comma.mapLeft _ ((Functor.const _).map f)\n\n"}
{"name":"CategoryTheory.StructuredArrow.map_mk","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nS S' : D\nY : C\nT : CategoryTheory.Functor C D\nf : Quiver.Hom S' (T.obj Y)\ng : Quiver.Hom S S'\n⊢ Eq ((CategoryTheory.StructuredArrow.map g).obj (CategoryTheory.StructuredArrow.mk f)) (CategoryTheory.StructuredArrow.mk (CategoryTheory.CategoryStruct.comp g f))","decl":"@[simp]\ntheorem map_mk {f : S' ⟶ T.obj Y} (g : S ⟶ S') : (map g).obj (mk f) = mk (g ≫ f) :=\n  rfl\n\n"}
{"name":"CategoryTheory.StructuredArrow.map_id","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nS : D\nT : CategoryTheory.Functor C D\nf : CategoryTheory.StructuredArrow S T\n⊢ Eq ((CategoryTheory.StructuredArrow.map (CategoryTheory.CategoryStruct.id S)).obj f) f","decl":"@[simp]\ntheorem map_id {f : StructuredArrow S T} : (map (𝟙 S)).obj f = f := by\n  rw [eq_mk f]\n  simp\n\n"}
{"name":"CategoryTheory.StructuredArrow.map_comp","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nS S' S'' : D\nT : CategoryTheory.Functor C D\nf : Quiver.Hom S S'\nf' : Quiver.Hom S' S''\nh : CategoryTheory.StructuredArrow S'' T\n⊢ Eq ((CategoryTheory.StructuredArrow.map (CategoryTheory.CategoryStruct.comp f f')).obj h) ((CategoryTheory.StructuredArrow.map f).obj ((CategoryTheory.StructuredArrow.map f').obj h))","decl":"@[simp]\ntheorem map_comp {f : S ⟶ S'} {f' : S' ⟶ S''} {h : StructuredArrow S'' T} :\n    (map (f ≫ f')).obj h = (map f).obj ((map f').obj h) := by\n  rw [eq_mk h]\n  simp\n\n"}
{"name":"CategoryTheory.StructuredArrow.proj_reflectsIsomorphisms","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nS : D\nT : CategoryTheory.Functor C D\n⊢ (CategoryTheory.StructuredArrow.proj S T).ReflectsIsomorphisms","decl":"instance proj_reflectsIsomorphisms : (proj S T).ReflectsIsomorphisms where\n  reflects {Y Z} f t :=\n    ⟨⟨StructuredArrow.homMk\n        (inv ((proj S T).map f))\n        (by rw [Functor.map_inv, IsIso.comp_inv_eq]; simp),\n      by constructor <;> apply CommaMorphism.ext <;> dsimp at t ⊢ <;> simp⟩⟩\n\n"}
{"name":"CategoryTheory.StructuredArrow.pre_obj_right","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nB : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} B\nS : D\nF : CategoryTheory.Functor B C\nG : CategoryTheory.Functor C D\nX : CategoryTheory.Comma (CategoryTheory.Functor.fromPUnit S) (F.comp G)\n⊢ Eq ((CategoryTheory.StructuredArrow.pre S F G).obj X).right (F.obj X.right)","decl":"/-- The functor `(S, F ⋙ G) ⥤ (S, G)`. -/\n@[simps!]\ndef pre (S : D) (F : B ⥤ C) (G : C ⥤ D) : StructuredArrow S (F ⋙ G) ⥤ StructuredArrow S G :=\n  Comma.preRight _ F G\n\n"}
{"name":"CategoryTheory.StructuredArrow.pre_map_left","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nB : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} B\nS : D\nF : CategoryTheory.Functor B C\nG : CategoryTheory.Functor C D\nX✝ Y✝ : CategoryTheory.Comma (CategoryTheory.Functor.fromPUnit S) (F.comp G)\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.StructuredArrow.pre S F G).map f).left (CategoryTheory.CategoryStruct.id X✝.left)","decl":"/-- The functor `(S, F ⋙ G) ⥤ (S, G)`. -/\n@[simps!]\ndef pre (S : D) (F : B ⥤ C) (G : C ⥤ D) : StructuredArrow S (F ⋙ G) ⥤ StructuredArrow S G :=\n  Comma.preRight _ F G\n\n"}
{"name":"CategoryTheory.StructuredArrow.pre_obj_hom","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nB : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} B\nS : D\nF : CategoryTheory.Functor B C\nG : CategoryTheory.Functor C D\nX : CategoryTheory.Comma (CategoryTheory.Functor.fromPUnit S) (F.comp G)\n⊢ Eq ((CategoryTheory.StructuredArrow.pre S F G).obj X).hom X.hom","decl":"/-- The functor `(S, F ⋙ G) ⥤ (S, G)`. -/\n@[simps!]\ndef pre (S : D) (F : B ⥤ C) (G : C ⥤ D) : StructuredArrow S (F ⋙ G) ⥤ StructuredArrow S G :=\n  Comma.preRight _ F G\n\n"}
{"name":"CategoryTheory.StructuredArrow.pre_map_right","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nB : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} B\nS : D\nF : CategoryTheory.Functor B C\nG : CategoryTheory.Functor C D\nX✝ Y✝ : CategoryTheory.Comma (CategoryTheory.Functor.fromPUnit S) (F.comp G)\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.StructuredArrow.pre S F G).map f).right (F.map f.right)","decl":"/-- The functor `(S, F ⋙ G) ⥤ (S, G)`. -/\n@[simps!]\ndef pre (S : D) (F : B ⥤ C) (G : C ⥤ D) : StructuredArrow S (F ⋙ G) ⥤ StructuredArrow S G :=\n  Comma.preRight _ F G\n\n"}
{"name":"CategoryTheory.StructuredArrow.pre_obj_left","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nB : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} B\nS : D\nF : CategoryTheory.Functor B C\nG : CategoryTheory.Functor C D\nX : CategoryTheory.Comma (CategoryTheory.Functor.fromPUnit S) (F.comp G)\n⊢ Eq ((CategoryTheory.StructuredArrow.pre S F G).obj X).left X.left","decl":"/-- The functor `(S, F ⋙ G) ⥤ (S, G)`. -/\n@[simps!]\ndef pre (S : D) (F : B ⥤ C) (G : C ⥤ D) : StructuredArrow S (F ⋙ G) ⥤ StructuredArrow S G :=\n  Comma.preRight _ F G\n\n"}
{"name":"CategoryTheory.StructuredArrow.instFaithfulCompPre","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nB : Type u₄\ninst✝¹ : CategoryTheory.Category.{v₄, u₄} B\nS : D\nF : CategoryTheory.Functor B C\nG : CategoryTheory.Functor C D\ninst✝ : F.Faithful\n⊢ (CategoryTheory.StructuredArrow.pre S F G).Faithful","decl":"instance (S : D) (F : B ⥤ C) (G : C ⥤ D) [F.Faithful] : (pre S F G).Faithful :=\n  show (Comma.preRight _ _ _).Faithful from inferInstance\n\n"}
{"name":"CategoryTheory.StructuredArrow.instFullCompPre","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nB : Type u₄\ninst✝¹ : CategoryTheory.Category.{v₄, u₄} B\nS : D\nF : CategoryTheory.Functor B C\nG : CategoryTheory.Functor C D\ninst✝ : F.Full\n⊢ (CategoryTheory.StructuredArrow.pre S F G).Full","decl":"instance (S : D) (F : B ⥤ C) (G : C ⥤ D) [F.Full] : (pre S F G).Full :=\n  show (Comma.preRight _ _ _).Full from inferInstance\n\n"}
{"name":"CategoryTheory.StructuredArrow.instEssSurjCompPre","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nB : Type u₄\ninst✝¹ : CategoryTheory.Category.{v₄, u₄} B\nS : D\nF : CategoryTheory.Functor B C\nG : CategoryTheory.Functor C D\ninst✝ : F.EssSurj\n⊢ (CategoryTheory.StructuredArrow.pre S F G).EssSurj","decl":"instance (S : D) (F : B ⥤ C) (G : C ⥤ D) [F.EssSurj] : (pre S F G).EssSurj :=\n  show (Comma.preRight _ _ _).EssSurj from inferInstance\n\n"}
{"name":"CategoryTheory.StructuredArrow.isEquivalence_pre","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nB : Type u₄\ninst✝¹ : CategoryTheory.Category.{v₄, u₄} B\nS : D\nF : CategoryTheory.Functor B C\nG : CategoryTheory.Functor C D\ninst✝ : F.IsEquivalence\n⊢ (CategoryTheory.StructuredArrow.pre S F G).IsEquivalence","decl":"/-- If `F` is an equivalence, then so is the functor `(S, F ⋙ G) ⥤ (S, G)`. -/\ninstance isEquivalence_pre (S : D) (F : B ⥤ C) (G : C ⥤ D) [F.IsEquivalence] :\n    (pre S F G).IsEquivalence :=\n  Comma.isEquivalence_preRight _ _ _\n\n"}
{"name":"CategoryTheory.StructuredArrow.post_obj","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nB : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} B\nS : C\nF : CategoryTheory.Functor B C\nG : CategoryTheory.Functor C D\nX : CategoryTheory.StructuredArrow S F\n⊢ Eq ((CategoryTheory.StructuredArrow.post S F G).obj X) (CategoryTheory.StructuredArrow.mk (G.map X.hom))","decl":"/-- The functor `(S, F) ⥤ (G(S), F ⋙ G)`. -/\n@[simps]\ndef post (S : C) (F : B ⥤ C) (G : C ⥤ D) :\n    StructuredArrow S F ⥤ StructuredArrow (G.obj S) (F ⋙ G) where\n  obj X := StructuredArrow.mk (G.map X.hom)\n  map f := StructuredArrow.homMk f.right (by simp [Functor.comp_map, ← G.map_comp, ← f.w])\n\n"}
{"name":"CategoryTheory.StructuredArrow.post_map","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nB : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} B\nS : C\nF : CategoryTheory.Functor B C\nG : CategoryTheory.Functor C D\nX✝ Y✝ : CategoryTheory.StructuredArrow S F\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.StructuredArrow.post S F G).map f) (CategoryTheory.StructuredArrow.homMk f.right ⋯)","decl":"/-- The functor `(S, F) ⥤ (G(S), F ⋙ G)`. -/\n@[simps]\ndef post (S : C) (F : B ⥤ C) (G : C ⥤ D) :\n    StructuredArrow S F ⥤ StructuredArrow (G.obj S) (F ⋙ G) where\n  obj X := StructuredArrow.mk (G.map X.hom)\n  map f := StructuredArrow.homMk f.right (by simp [Functor.comp_map, ← G.map_comp, ← f.w])\n\n"}
{"name":"CategoryTheory.StructuredArrow.instFaithfulObjCompPost","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nB : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} B\nS : C\nF : CategoryTheory.Functor B C\nG : CategoryTheory.Functor C D\n⊢ (CategoryTheory.StructuredArrow.post S F G).Faithful","decl":"instance (S : C) (F : B ⥤ C) (G : C ⥤ D) : (post S F G).Faithful where\n  map_injective {_ _} _ _ h := by simpa [ext_iff] using h\n\n"}
{"name":"CategoryTheory.StructuredArrow.instFullObjCompPostOfFaithful","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nB : Type u₄\ninst✝¹ : CategoryTheory.Category.{v₄, u₄} B\nS : C\nF : CategoryTheory.Functor B C\nG : CategoryTheory.Functor C D\ninst✝ : G.Faithful\n⊢ (CategoryTheory.StructuredArrow.post S F G).Full","decl":"instance (S : C) (F : B ⥤ C) (G : C ⥤ D) [G.Faithful] : (post S F G).Full where\n  map_surjective f := ⟨homMk f.right (G.map_injective (by simpa using f.w.symm)), by simp⟩\n\n"}
{"name":"CategoryTheory.StructuredArrow.instEssSurjObjCompPostOfFull","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nB : Type u₄\ninst✝¹ : CategoryTheory.Category.{v₄, u₄} B\nS : C\nF : CategoryTheory.Functor B C\nG : CategoryTheory.Functor C D\ninst✝ : G.Full\n⊢ (CategoryTheory.StructuredArrow.post S F G).EssSurj","decl":"instance (S : C) (F : B ⥤ C) (G : C ⥤ D) [G.Full] : (post S F G).EssSurj where\n  mem_essImage h := ⟨mk (G.preimage h.hom), ⟨isoMk (Iso.refl _) (by simp)⟩⟩\n\n"}
{"name":"CategoryTheory.StructuredArrow.isEquivalence_post","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nB : Type u₄\ninst✝² : CategoryTheory.Category.{v₄, u₄} B\nS : C\nF : CategoryTheory.Functor B C\nG : CategoryTheory.Functor C D\ninst✝¹ : G.Full\ninst✝ : G.Faithful\n⊢ (CategoryTheory.StructuredArrow.post S F G).IsEquivalence","decl":"/-- If `G` is fully faithful, then `post S F G : (S, F) ⥤ (G(S), F ⋙ G)` is an equivalence. -/\ninstance isEquivalence_post (S : C) (F : B ⥤ C) (G : C ⥤ D) [G.Full] [G.Faithful] :\n    (post S F G).IsEquivalence where\n\n"}
{"name":"CategoryTheory.StructuredArrow.map₂_map_left","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nA : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} A\nB : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} B\nL : D\nR : CategoryTheory.Functor C D\nL' : B\nR' : CategoryTheory.Functor A B\nF : CategoryTheory.Functor C A\nG : CategoryTheory.Functor D B\nα : Quiver.Hom L' (G.obj L)\nβ : Quiver.Hom (R.comp G) (F.comp R')\nX Y : CategoryTheory.Comma (CategoryTheory.Functor.fromPUnit L) R\nφ : Quiver.Hom X Y\n⊢ Eq ((CategoryTheory.StructuredArrow.map₂ α β).map φ).left (CategoryTheory.CategoryStruct.id X.left)","decl":"/-- The functor `StructuredArrow L R ⥤ StructuredArrow L' R'` that is deduced from\na natural transformation `R ⋙ G ⟶ F ⋙ R'` and a morphism `L' ⟶ G.obj L.` -/\n@[simps!]\ndef map₂ : StructuredArrow L R ⥤ StructuredArrow L' R' :=\n  Comma.map (F₁ := 𝟭 (Discrete PUnit)) (Discrete.natTrans (fun _ => α)) β\n\n"}
{"name":"CategoryTheory.StructuredArrow.map₂_map_right","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nA : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} A\nB : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} B\nL : D\nR : CategoryTheory.Functor C D\nL' : B\nR' : CategoryTheory.Functor A B\nF : CategoryTheory.Functor C A\nG : CategoryTheory.Functor D B\nα : Quiver.Hom L' (G.obj L)\nβ : Quiver.Hom (R.comp G) (F.comp R')\nX Y : CategoryTheory.Comma (CategoryTheory.Functor.fromPUnit L) R\nφ : Quiver.Hom X Y\n⊢ Eq ((CategoryTheory.StructuredArrow.map₂ α β).map φ).right (F.map φ.right)","decl":"/-- The functor `StructuredArrow L R ⥤ StructuredArrow L' R'` that is deduced from\na natural transformation `R ⋙ G ⟶ F ⋙ R'` and a morphism `L' ⟶ G.obj L.` -/\n@[simps!]\ndef map₂ : StructuredArrow L R ⥤ StructuredArrow L' R' :=\n  Comma.map (F₁ := 𝟭 (Discrete PUnit)) (Discrete.natTrans (fun _ => α)) β\n\n"}
{"name":"CategoryTheory.StructuredArrow.map₂_obj_hom","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nA : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} A\nB : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} B\nL : D\nR : CategoryTheory.Functor C D\nL' : B\nR' : CategoryTheory.Functor A B\nF : CategoryTheory.Functor C A\nG : CategoryTheory.Functor D B\nα : Quiver.Hom L' (G.obj L)\nβ : Quiver.Hom (R.comp G) (F.comp R')\nX : CategoryTheory.Comma (CategoryTheory.Functor.fromPUnit L) R\n⊢ Eq ((CategoryTheory.StructuredArrow.map₂ α β).obj X).hom (CategoryTheory.CategoryStruct.comp α (CategoryTheory.CategoryStruct.comp (G.map X.hom) (β.app X.right)))","decl":"/-- The functor `StructuredArrow L R ⥤ StructuredArrow L' R'` that is deduced from\na natural transformation `R ⋙ G ⟶ F ⋙ R'` and a morphism `L' ⟶ G.obj L.` -/\n@[simps!]\ndef map₂ : StructuredArrow L R ⥤ StructuredArrow L' R' :=\n  Comma.map (F₁ := 𝟭 (Discrete PUnit)) (Discrete.natTrans (fun _ => α)) β\n\n"}
{"name":"CategoryTheory.StructuredArrow.map₂_obj_left","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nA : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} A\nB : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} B\nL : D\nR : CategoryTheory.Functor C D\nL' : B\nR' : CategoryTheory.Functor A B\nF : CategoryTheory.Functor C A\nG : CategoryTheory.Functor D B\nα : Quiver.Hom L' (G.obj L)\nβ : Quiver.Hom (R.comp G) (F.comp R')\nX : CategoryTheory.Comma (CategoryTheory.Functor.fromPUnit L) R\n⊢ Eq ((CategoryTheory.StructuredArrow.map₂ α β).obj X).left X.left","decl":"/-- The functor `StructuredArrow L R ⥤ StructuredArrow L' R'` that is deduced from\na natural transformation `R ⋙ G ⟶ F ⋙ R'` and a morphism `L' ⟶ G.obj L.` -/\n@[simps!]\ndef map₂ : StructuredArrow L R ⥤ StructuredArrow L' R' :=\n  Comma.map (F₁ := 𝟭 (Discrete PUnit)) (Discrete.natTrans (fun _ => α)) β\n\n"}
{"name":"CategoryTheory.StructuredArrow.map₂_obj_right","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nA : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} A\nB : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} B\nL : D\nR : CategoryTheory.Functor C D\nL' : B\nR' : CategoryTheory.Functor A B\nF : CategoryTheory.Functor C A\nG : CategoryTheory.Functor D B\nα : Quiver.Hom L' (G.obj L)\nβ : Quiver.Hom (R.comp G) (F.comp R')\nX : CategoryTheory.Comma (CategoryTheory.Functor.fromPUnit L) R\n⊢ Eq ((CategoryTheory.StructuredArrow.map₂ α β).obj X).right (F.obj X.right)","decl":"/-- The functor `StructuredArrow L R ⥤ StructuredArrow L' R'` that is deduced from\na natural transformation `R ⋙ G ⟶ F ⋙ R'` and a morphism `L' ⟶ G.obj L.` -/\n@[simps!]\ndef map₂ : StructuredArrow L R ⥤ StructuredArrow L' R' :=\n  Comma.map (F₁ := 𝟭 (Discrete PUnit)) (Discrete.natTrans (fun _ => α)) β\n\n"}
{"name":"CategoryTheory.StructuredArrow.faithful_map₂","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nA : Type u₃\ninst✝² : CategoryTheory.Category.{v₃, u₃} A\nB : Type u₄\ninst✝¹ : CategoryTheory.Category.{v₄, u₄} B\nL : D\nR : CategoryTheory.Functor C D\nL' : B\nR' : CategoryTheory.Functor A B\nF : CategoryTheory.Functor C A\nG : CategoryTheory.Functor D B\nα : Quiver.Hom L' (G.obj L)\nβ : Quiver.Hom (R.comp G) (F.comp R')\ninst✝ : F.Faithful\n⊢ (CategoryTheory.StructuredArrow.map₂ α β).Faithful","decl":"instance faithful_map₂ [F.Faithful] : (map₂ α β).Faithful := by\n  apply Comma.faithful_map\n\n"}
{"name":"CategoryTheory.StructuredArrow.full_map₂","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝⁷ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝⁶ : CategoryTheory.Category.{v₂, u₂} D\nA : Type u₃\ninst✝⁵ : CategoryTheory.Category.{v₃, u₃} A\nB : Type u₄\ninst✝⁴ : CategoryTheory.Category.{v₄, u₄} B\nL : D\nR : CategoryTheory.Functor C D\nL' : B\nR' : CategoryTheory.Functor A B\nF : CategoryTheory.Functor C A\nG : CategoryTheory.Functor D B\nα : Quiver.Hom L' (G.obj L)\nβ : Quiver.Hom (R.comp G) (F.comp R')\ninst✝³ : G.Faithful\ninst✝² : F.Full\ninst✝¹ : CategoryTheory.IsIso α\ninst✝ : CategoryTheory.IsIso β\n⊢ (CategoryTheory.StructuredArrow.map₂ α β).Full","decl":"instance full_map₂ [G.Faithful] [F.Full] [IsIso α] [IsIso β] : (map₂ α β).Full := by\n  apply Comma.full_map\n\n"}
{"name":"CategoryTheory.StructuredArrow.essSurj_map₂","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝⁷ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝⁶ : CategoryTheory.Category.{v₂, u₂} D\nA : Type u₃\ninst✝⁵ : CategoryTheory.Category.{v₃, u₃} A\nB : Type u₄\ninst✝⁴ : CategoryTheory.Category.{v₄, u₄} B\nL : D\nR : CategoryTheory.Functor C D\nL' : B\nR' : CategoryTheory.Functor A B\nF : CategoryTheory.Functor C A\nG : CategoryTheory.Functor D B\nα : Quiver.Hom L' (G.obj L)\nβ : Quiver.Hom (R.comp G) (F.comp R')\ninst✝³ : F.EssSurj\ninst✝² : G.Full\ninst✝¹ : CategoryTheory.IsIso α\ninst✝ : CategoryTheory.IsIso β\n⊢ (CategoryTheory.StructuredArrow.map₂ α β).EssSurj","decl":"instance essSurj_map₂ [F.EssSurj] [G.Full] [IsIso α] [IsIso β] : (map₂ α β).EssSurj := by\n  apply Comma.essSurj_map\n\n"}
{"name":"CategoryTheory.StructuredArrow.isEquivalenceMap₂","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝⁸ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝⁷ : CategoryTheory.Category.{v₂, u₂} D\nA : Type u₃\ninst✝⁶ : CategoryTheory.Category.{v₃, u₃} A\nB : Type u₄\ninst✝⁵ : CategoryTheory.Category.{v₄, u₄} B\nL : D\nR : CategoryTheory.Functor C D\nL' : B\nR' : CategoryTheory.Functor A B\nF : CategoryTheory.Functor C A\nG : CategoryTheory.Functor D B\nα : Quiver.Hom L' (G.obj L)\nβ : Quiver.Hom (R.comp G) (F.comp R')\ninst✝⁴ : F.IsEquivalence\ninst✝³ : G.Faithful\ninst✝² : G.Full\ninst✝¹ : CategoryTheory.IsIso α\ninst✝ : CategoryTheory.IsIso β\n⊢ (CategoryTheory.StructuredArrow.map₂ α β).IsEquivalence","decl":"noncomputable instance isEquivalenceMap₂\n    [F.IsEquivalence] [G.Faithful] [G.Full] [IsIso α] [IsIso β] :\n    (map₂ α β).IsEquivalence := by\n  apply Comma.isEquivalenceMap\n\n"}
{"name":"CategoryTheory.StructuredArrow.IsUniversal.uniq","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nS : D\nT : CategoryTheory.Functor C D\nf g : CategoryTheory.StructuredArrow S T\nh : f.IsUniversal\nη : Quiver.Hom f g\n⊢ Eq η (CategoryTheory.Limits.IsInitial.to h g)","decl":"theorem uniq (h : IsUniversal f) (η : f ⟶ g) : η = h.to g :=\n  h.hom_ext η (h.to g)\n\n"}
{"name":"CategoryTheory.StructuredArrow.IsUniversal.fac_assoc","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nS : D\nT : CategoryTheory.Functor C D\nf : CategoryTheory.StructuredArrow S T\nh✝ : f.IsUniversal\ng : CategoryTheory.StructuredArrow S T\nZ : D\nh : Quiver.Hom (T.obj g.right) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp f.hom (CategoryTheory.CategoryStruct.comp (T.map (h✝.desc g)) h)) (CategoryTheory.CategoryStruct.comp g.hom h)","decl":"/-- Any structured arrow factors through a universal arrow. -/\n@[reassoc (attr := simp)]\ntheorem fac (h : IsUniversal f) (g : StructuredArrow S T) :\n    f.hom ≫ T.map (h.desc g) = g.hom :=\n  Category.id_comp g.hom ▸ (h.to g).w.symm\n\n"}
{"name":"CategoryTheory.StructuredArrow.IsUniversal.fac","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nS : D\nT : CategoryTheory.Functor C D\nf : CategoryTheory.StructuredArrow S T\nh : f.IsUniversal\ng : CategoryTheory.StructuredArrow S T\n⊢ Eq (CategoryTheory.CategoryStruct.comp f.hom (T.map (h.desc g))) g.hom","decl":"/-- Any structured arrow factors through a universal arrow. -/\n@[reassoc (attr := simp)]\ntheorem fac (h : IsUniversal f) (g : StructuredArrow S T) :\n    f.hom ≫ T.map (h.desc g) = g.hom :=\n  Category.id_comp g.hom ▸ (h.to g).w.symm\n\n"}
{"name":"CategoryTheory.StructuredArrow.IsUniversal.hom_desc","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nS : D\nT : CategoryTheory.Functor C D\nf : CategoryTheory.StructuredArrow S T\nh : f.IsUniversal\nc : C\nη : Quiver.Hom f.right c\n⊢ Eq η (h.desc (CategoryTheory.StructuredArrow.mk (CategoryTheory.CategoryStruct.comp f.hom (T.map η))))","decl":"theorem hom_desc (h : IsUniversal f) {c : C} (η : f.right ⟶ c) :\n    η = h.desc (mk <| f.hom ≫ T.map η) :=\n  let g := mk <| f.hom ≫ T.map η\n  congrArg CommaMorphism.right (h.hom_ext (homMk η rfl : f ⟶ g) (h.to g))\n\n"}
{"name":"CategoryTheory.StructuredArrow.IsUniversal.hom_ext","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nS : D\nT : CategoryTheory.Functor C D\nf : CategoryTheory.StructuredArrow S T\nh : f.IsUniversal\nc : C\nη η' : Quiver.Hom f.right c\nw : Eq (CategoryTheory.CategoryStruct.comp f.hom (T.map η)) (CategoryTheory.CategoryStruct.comp f.hom (T.map η'))\n⊢ Eq η η'","decl":"/-- Two morphisms out of a universal `T`-structured arrow are equal if their image under `T` are\nequal after precomposing the universal arrow. -/\ntheorem hom_ext (h : IsUniversal f) {c : C} {η η' : f.right ⟶ c}\n    (w : f.hom ≫ T.map η = f.hom ≫ T.map η') : η = η' := by\n  rw [h.hom_desc η, h.hom_desc η', w]\n\n"}
{"name":"CategoryTheory.StructuredArrow.IsUniversal.existsUnique","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nS : D\nT : CategoryTheory.Functor C D\nf : CategoryTheory.StructuredArrow S T\nh : f.IsUniversal\ng : CategoryTheory.StructuredArrow S T\n⊢ ExistsUnique fun η => Eq (CategoryTheory.CategoryStruct.comp f.hom (T.map η)) g.hom","decl":"theorem existsUnique (h : IsUniversal f) (g : StructuredArrow S T) :\n    ∃! η : f.right ⟶ g.right, f.hom ≫ T.map η = g.hom :=\n  ⟨h.desc g, h.fac g, fun f w ↦ h.hom_ext <| by simp [w]⟩\n\n"}
{"name":"CategoryTheory.CostructuredArrow.proj_obj","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nS : CategoryTheory.Functor C D\nT : D\nX : CategoryTheory.Comma S (CategoryTheory.Functor.fromPUnit T)\n⊢ Eq ((CategoryTheory.CostructuredArrow.proj S T).obj X) X.left","decl":"/-- The obvious projection functor from costructured arrows. -/\n@[simps!]\ndef proj (S : C ⥤ D) (T : D) : CostructuredArrow S T ⥤ C :=\n  Comma.fst _ _\n\n"}
{"name":"CategoryTheory.CostructuredArrow.proj_map","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nS : CategoryTheory.Functor C D\nT : D\nX✝ Y✝ : CategoryTheory.Comma S (CategoryTheory.Functor.fromPUnit T)\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.CostructuredArrow.proj S T).map f) f.left","decl":"/-- The obvious projection functor from costructured arrows. -/\n@[simps!]\ndef proj (S : C ⥤ D) (T : D) : CostructuredArrow S T ⥤ C :=\n  Comma.fst _ _\n\n"}
{"name":"CategoryTheory.CostructuredArrow.hom_ext_iff","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nT : D\nS : CategoryTheory.Functor C D\nX Y : CategoryTheory.CostructuredArrow S T\nf g : Quiver.Hom X Y\n⊢ Iff (Eq f g) (Eq f.left g.left)","decl":"@[ext]\nlemma hom_ext {X Y : CostructuredArrow S T} (f g : X ⟶ Y) (h : f.left = g.left) : f = g :=\n  CommaMorphism.ext h (Subsingleton.elim _ _)\n\n"}
{"name":"CategoryTheory.CostructuredArrow.hom_ext","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nT : D\nS : CategoryTheory.Functor C D\nX Y : CategoryTheory.CostructuredArrow S T\nf g : Quiver.Hom X Y\nh : Eq f.left g.left\n⊢ Eq f g","decl":"@[ext]\nlemma hom_ext {X Y : CostructuredArrow S T} (f g : X ⟶ Y) (h : f.left = g.left) : f = g :=\n  CommaMorphism.ext h (Subsingleton.elim _ _)\n\n"}
{"name":"CategoryTheory.CostructuredArrow.hom_eq_iff","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nT : D\nS : CategoryTheory.Functor C D\nX Y : CategoryTheory.CostructuredArrow S T\nf g : Quiver.Hom X Y\n⊢ Iff (Eq f g) (Eq f.left g.left)","decl":"@[simp]\ntheorem hom_eq_iff {X Y : CostructuredArrow S T} (f g : X ⟶ Y) : f = g ↔ f.left = g.left :=\n  ⟨fun h ↦ by rw [h], hom_ext _ _⟩\n\n"}
{"name":"CategoryTheory.CostructuredArrow.mk_left","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nT : D\nY : C\nS : CategoryTheory.Functor C D\nf : Quiver.Hom (S.obj Y) T\n⊢ Eq (CategoryTheory.CostructuredArrow.mk f).left Y","decl":"@[simp]\ntheorem mk_left (f : S.obj Y ⟶ T) : (mk f).left = Y :=\n  rfl\n\n"}
{"name":"CategoryTheory.CostructuredArrow.mk_right","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nT : D\nY : C\nS : CategoryTheory.Functor C D\nf : Quiver.Hom (S.obj Y) T\n⊢ Eq (CategoryTheory.CostructuredArrow.mk f).right { as := PUnit.unit }","decl":"@[simp]\ntheorem mk_right (f : S.obj Y ⟶ T) : (mk f).right = ⟨⟨⟩⟩ :=\n  rfl\n\n"}
{"name":"CategoryTheory.CostructuredArrow.mk_hom_eq_self","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nT : D\nY : C\nS : CategoryTheory.Functor C D\nf : Quiver.Hom (S.obj Y) T\n⊢ Eq (CategoryTheory.CostructuredArrow.mk f).hom f","decl":"@[simp]\ntheorem mk_hom_eq_self (f : S.obj Y ⟶ T) : (mk f).hom = f :=\n  rfl\n\n-- @[reassoc (attr := simp)] Porting note: simp can solve these\n"}
{"name":"CategoryTheory.CostructuredArrow.w","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nT : D\nS : CategoryTheory.Functor C D\nA B : CategoryTheory.CostructuredArrow S T\nf : Quiver.Hom A B\n⊢ Eq (CategoryTheory.CategoryStruct.comp (S.map f.left) B.hom) A.hom","decl":"@[reassoc]\ntheorem w {A B : CostructuredArrow S T} (f : A ⟶ B) : S.map f.left ≫ B.hom = A.hom := by simp\n\n"}
{"name":"CategoryTheory.CostructuredArrow.w_assoc","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nT : D\nS : CategoryTheory.Functor C D\nA B : CategoryTheory.CostructuredArrow S T\nf : Quiver.Hom A B\nZ : D\nh : Quiver.Hom ((CategoryTheory.Functor.fromPUnit T).obj B.right) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (S.map f.left) (CategoryTheory.CategoryStruct.comp B.hom h)) (CategoryTheory.CategoryStruct.comp A.hom h)","decl":"@[reassoc]\ntheorem w {A B : CostructuredArrow S T} (f : A ⟶ B) : S.map f.left ≫ B.hom = A.hom := by simp\n\n"}
{"name":"CategoryTheory.CostructuredArrow.comp_left","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nT : D\nS : CategoryTheory.Functor C D\nX Y Z : CategoryTheory.CostructuredArrow S T\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp f g).left (CategoryTheory.CategoryStruct.comp f.left g.left)","decl":"@[simp]\ntheorem comp_left {X Y Z : CostructuredArrow S T} (f : X ⟶ Y) (g : Y ⟶ Z) :\n    (f ≫ g).left = f.left ≫ g.left := rfl\n\n"}
{"name":"CategoryTheory.CostructuredArrow.id_left","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nT : D\nS : CategoryTheory.Functor C D\nX : CategoryTheory.CostructuredArrow S T\n⊢ Eq (CategoryTheory.CategoryStruct.id X).left (CategoryTheory.CategoryStruct.id X.left)","decl":"@[simp]\ntheorem id_left (X : CostructuredArrow S T) : (𝟙 X : X ⟶ X).left = 𝟙 X.left := rfl\n\n"}
{"name":"CategoryTheory.CostructuredArrow.eqToHom_left","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nT : D\nS : CategoryTheory.Functor C D\nX Y : CategoryTheory.CostructuredArrow S T\nh : Eq X Y\n⊢ Eq (CategoryTheory.eqToHom h).left (CategoryTheory.eqToHom ⋯)","decl":"@[simp]\ntheorem eqToHom_left {X Y : CostructuredArrow S T} (h : X = Y) :\n    (eqToHom h).left = eqToHom (by rw [h]) := by\n  subst h\n  simp only [eqToHom_refl, id_left]\n\n"}
{"name":"CategoryTheory.CostructuredArrow.right_eq_id","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nT : D\nS : CategoryTheory.Functor C D\nX Y : CategoryTheory.CostructuredArrow S T\nf : Quiver.Hom X Y\n⊢ Eq f.right (CategoryTheory.CategoryStruct.id X.right)","decl":"@[simp]\ntheorem right_eq_id {X Y : CostructuredArrow S T} (f : X ⟶ Y) : f.right = 𝟙 X.right := rfl\n\n"}
{"name":"CategoryTheory.CostructuredArrow.homMk_left","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nT : D\nS : CategoryTheory.Functor C D\nf f' : CategoryTheory.CostructuredArrow S T\ng : Quiver.Hom f.left f'.left\nw : autoParam (Eq (CategoryTheory.CategoryStruct.comp (S.map g) f'.hom) f.hom) _auto✝\n⊢ Eq (CategoryTheory.CostructuredArrow.homMk g w).left g","decl":"/-- To construct a morphism of costructured arrows,\nwe need a morphism of the objects underlying the source,\nand to check that the triangle commutes.\n-/\n@[simps! left]\ndef homMk {f f' : CostructuredArrow S T} (g : f.left ⟶ f'.left)\n    (w : S.map g ≫ f'.hom = f.hom := by aesop_cat) : f ⟶ f' where\n  left := g\n  right := 𝟙 f.right\n\n"}
{"name":"CategoryTheory.CostructuredArrow.homMk_surjective","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nT : D\nS : CategoryTheory.Functor C D\nf f' : CategoryTheory.CostructuredArrow S T\nφ : Quiver.Hom f f'\n⊢ Exists fun ψ => Exists fun hψ => Eq φ (CategoryTheory.CostructuredArrow.homMk ψ hψ)","decl":"theorem homMk_surjective {f f' : CostructuredArrow S T} (φ : f ⟶ f') :\n    ∃ (ψ : f.left ⟶ f'.left) (hψ : S.map ψ ≫ f'.hom = f.hom),\n      φ = CostructuredArrow.homMk ψ hψ :=\n  ⟨φ.left, CostructuredArrow.w φ, rfl⟩\n\n"}
{"name":"CategoryTheory.CostructuredArrow.homMk'_left","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nT : D\nY' : C\nS : CategoryTheory.Functor C D\nf : CategoryTheory.CostructuredArrow S T\ng : Quiver.Hom Y' f.left\n⊢ Eq (f.homMk' g).left g","decl":"/-- Given a costructured arrow `S(Y) ⟶ X`, and an arrow `Y' ⟶ Y'`, we can construct a morphism of\n    costructured arrows given by `(S(Y) ⟶ X) ⟶ (S(Y') ⟶ S(Y) ⟶ X)`. -/\n@[simps]\ndef homMk' (f : CostructuredArrow S T) (g : Y' ⟶ f.left) : mk (S.map g ≫ f.hom) ⟶ f where\n  left := g\n  right := 𝟙 _\n\n"}
{"name":"CategoryTheory.CostructuredArrow.homMk'_right","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nT : D\nY' : C\nS : CategoryTheory.Functor C D\nf : CategoryTheory.CostructuredArrow S T\ng : Quiver.Hom Y' f.left\n⊢ Eq (f.homMk' g).right (CategoryTheory.CategoryStruct.id (CategoryTheory.CostructuredArrow.mk (CategoryTheory.CategoryStruct.comp (S.map g) f.hom)).right)","decl":"/-- Given a costructured arrow `S(Y) ⟶ X`, and an arrow `Y' ⟶ Y'`, we can construct a morphism of\n    costructured arrows given by `(S(Y) ⟶ X) ⟶ (S(Y') ⟶ S(Y) ⟶ X)`. -/\n@[simps]\ndef homMk' (f : CostructuredArrow S T) (g : Y' ⟶ f.left) : mk (S.map g ≫ f.hom) ⟶ f where\n  left := g\n  right := 𝟙 _\n\n"}
{"name":"CategoryTheory.CostructuredArrow.homMk'_id","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nT : D\nS : CategoryTheory.Functor C D\nf : CategoryTheory.CostructuredArrow S T\n⊢ Eq (f.homMk' (CategoryTheory.CategoryStruct.id f.left)) (CategoryTheory.eqToHom ⋯)","decl":"lemma homMk'_id (f : CostructuredArrow S T) : homMk' f (𝟙 f.left) = eqToHom (by aesop_cat) := by\n  ext\n  simp [eqToHom_left]\n\n"}
{"name":"CategoryTheory.CostructuredArrow.homMk'_mk_id","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nT : D\nY : C\nS : CategoryTheory.Functor C D\nf : Quiver.Hom (S.obj Y) T\n⊢ Eq ((CategoryTheory.CostructuredArrow.mk f).homMk' (CategoryTheory.CategoryStruct.id Y)) (CategoryTheory.eqToHom ⋯)","decl":"lemma homMk'_mk_id (f : S.obj Y ⟶ T) : homMk' (mk f) (𝟙 Y) = eqToHom (by simp) :=\n  homMk'_id _\n\n"}
{"name":"CategoryTheory.CostructuredArrow.homMk'_comp","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nT : D\nY' Y'' : C\nS : CategoryTheory.Functor C D\nf : CategoryTheory.CostructuredArrow S T\ng : Quiver.Hom Y' f.left\ng' : Quiver.Hom Y'' Y'\n⊢ Eq (f.homMk' (CategoryTheory.CategoryStruct.comp g' g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ⋯) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.CostructuredArrow.mk (CategoryTheory.CategoryStruct.comp (S.map g) f.hom)).homMk' g') (f.homMk' g)))","decl":"lemma homMk'_comp (f : CostructuredArrow S T) (g : Y' ⟶ f.left) (g' : Y'' ⟶ Y') :\n    homMk' f (g' ≫ g) = eqToHom (by simp) ≫ homMk' (mk (S.map g ≫ f.hom)) g' ≫ homMk' f g := by\n  ext\n  simp [eqToHom_left]\n\n"}
{"name":"CategoryTheory.CostructuredArrow.homMk'_mk_comp","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nT : D\nY Y' Y'' : C\nS : CategoryTheory.Functor C D\nf : Quiver.Hom (S.obj Y) T\ng : Quiver.Hom Y' Y\ng' : Quiver.Hom Y'' Y'\n⊢ Eq ((CategoryTheory.CostructuredArrow.mk f).homMk' (CategoryTheory.CategoryStruct.comp g' g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ⋯) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.CostructuredArrow.mk (CategoryTheory.CategoryStruct.comp (S.map g) f)).homMk' g') ((CategoryTheory.CostructuredArrow.mk f).homMk' g)))","decl":"lemma homMk'_mk_comp (f : S.obj Y ⟶ T) (g : Y' ⟶ Y) (g' : Y'' ⟶ Y') :\n    homMk' (mk f) (g' ≫ g) = eqToHom (by simp) ≫ homMk' (mk (S.map g ≫ f)) g' ≫ homMk' (mk f) g :=\n  homMk'_comp _ _ _\n\n"}
{"name":"CategoryTheory.CostructuredArrow.mkPrecomp_left","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nT : D\nY Y' : C\nS : CategoryTheory.Functor C D\nf : Quiver.Hom (S.obj Y) T\ng : Quiver.Hom Y' Y\n⊢ Eq (CategoryTheory.CostructuredArrow.mkPrecomp f g).left g","decl":"/-- Variant of `homMk'` where both objects are applications of `mk`. -/\n@[simps]\ndef mkPrecomp (f : S.obj Y ⟶ T) (g : Y' ⟶ Y) : mk (S.map g ≫ f) ⟶ mk f where\n  left := g\n  right := 𝟙 _\n\n"}
{"name":"CategoryTheory.CostructuredArrow.mkPrecomp_right","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nT : D\nY Y' : C\nS : CategoryTheory.Functor C D\nf : Quiver.Hom (S.obj Y) T\ng : Quiver.Hom Y' Y\n⊢ Eq (CategoryTheory.CostructuredArrow.mkPrecomp f g).right (CategoryTheory.CategoryStruct.id (CategoryTheory.CostructuredArrow.mk (CategoryTheory.CategoryStruct.comp (S.map g) f)).right)","decl":"/-- Variant of `homMk'` where both objects are applications of `mk`. -/\n@[simps]\ndef mkPrecomp (f : S.obj Y ⟶ T) (g : Y' ⟶ Y) : mk (S.map g ≫ f) ⟶ mk f where\n  left := g\n  right := 𝟙 _\n\n"}
{"name":"CategoryTheory.CostructuredArrow.mkPrecomp_id","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nT : D\nY : C\nS : CategoryTheory.Functor C D\nf : Quiver.Hom (S.obj Y) T\n⊢ Eq (CategoryTheory.CostructuredArrow.mkPrecomp f (CategoryTheory.CategoryStruct.id Y)) (CategoryTheory.eqToHom ⋯)","decl":"lemma mkPrecomp_id (f : S.obj Y ⟶ T) : mkPrecomp f (𝟙 Y) = eqToHom (by simp) := by simp\n"}
{"name":"CategoryTheory.CostructuredArrow.mkPrecomp_comp","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nT : D\nY Y' Y'' : C\nS : CategoryTheory.Functor C D\nf : Quiver.Hom (S.obj Y) T\ng : Quiver.Hom Y' Y\ng' : Quiver.Hom Y'' Y'\n⊢ Eq (CategoryTheory.CostructuredArrow.mkPrecomp f (CategoryTheory.CategoryStruct.comp g' g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ⋯) (CategoryTheory.CategoryStruct.comp (CategoryTheory.CostructuredArrow.mkPrecomp (CategoryTheory.CategoryStruct.comp (S.map g) f) g') (CategoryTheory.CostructuredArrow.mkPrecomp f g)))","decl":"lemma mkPrecomp_comp (f : S.obj Y ⟶ T) (g : Y' ⟶ Y) (g' : Y'' ⟶ Y') :\n    mkPrecomp f (g' ≫ g) = eqToHom (by simp) ≫ mkPrecomp (S.map g ≫ f) g' ≫ mkPrecomp f g := by\n  simp\n\n"}
{"name":"CategoryTheory.CostructuredArrow.isoMk_hom_left","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nT : D\nS : CategoryTheory.Functor C D\nf f' : CategoryTheory.CostructuredArrow S T\ng : CategoryTheory.Iso f.left f'.left\nw : autoParam (Eq (CategoryTheory.CategoryStruct.comp (S.map g.hom) f'.hom) f.hom) _auto✝\n⊢ Eq (CategoryTheory.CostructuredArrow.isoMk g w).hom.left g.hom","decl":"/-- To construct an isomorphism of costructured arrows,\nwe need an isomorphism of the objects underlying the source,\nand to check that the triangle commutes.\n-/\n@[simps! hom_left inv_left]\ndef isoMk {f f' : CostructuredArrow S T} (g : f.left ≅ f'.left)\n    (w : S.map g.hom ≫ f'.hom = f.hom := by aesop_cat) : f ≅ f' :=\n  Comma.isoMk g (eqToIso (by ext)) (by simpa using w)\n\n"}
{"name":"CategoryTheory.CostructuredArrow.isoMk_inv_left","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nT : D\nS : CategoryTheory.Functor C D\nf f' : CategoryTheory.CostructuredArrow S T\ng : CategoryTheory.Iso f.left f'.left\nw : autoParam (Eq (CategoryTheory.CategoryStruct.comp (S.map g.hom) f'.hom) f.hom) _auto✝\n⊢ Eq (CategoryTheory.CostructuredArrow.isoMk g w).inv.left g.inv","decl":"/-- To construct an isomorphism of costructured arrows,\nwe need an isomorphism of the objects underlying the source,\nand to check that the triangle commutes.\n-/\n@[simps! hom_left inv_left]\ndef isoMk {f f' : CostructuredArrow S T} (g : f.left ≅ f'.left)\n    (w : S.map g.hom ≫ f'.hom = f.hom := by aesop_cat) : f ≅ f' :=\n  Comma.isoMk g (eqToIso (by ext)) (by simpa using w)\n\n"}
{"name":"CategoryTheory.CostructuredArrow.ext","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nT : D\nS : CategoryTheory.Functor C D\nA B : CategoryTheory.CostructuredArrow S T\nf g : Quiver.Hom A B\nh : Eq f.left g.left\n⊢ Eq f g","decl":"theorem ext {A B : CostructuredArrow S T} (f g : A ⟶ B) (h : f.left = g.left) : f = g :=\n  CommaMorphism.ext h (Subsingleton.elim _ _)\n\n"}
{"name":"CategoryTheory.CostructuredArrow.ext_iff","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nT : D\nS : CategoryTheory.Functor C D\nA B : CategoryTheory.CostructuredArrow S T\nf g : Quiver.Hom A B\n⊢ Iff (Eq f g) (Eq f.left g.left)","decl":"theorem ext_iff {A B : CostructuredArrow S T} (f g : A ⟶ B) : f = g ↔ f.left = g.left :=\n  ⟨fun h => h ▸ rfl, ext f g⟩\n\n"}
{"name":"CategoryTheory.CostructuredArrow.proj_faithful","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nT : D\nS : CategoryTheory.Functor C D\n⊢ (CategoryTheory.CostructuredArrow.proj S T).Faithful","decl":"instance proj_faithful : (proj S T).Faithful where map_injective {_ _} := ext\n\n"}
{"name":"CategoryTheory.CostructuredArrow.mono_of_mono_left","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nT : D\nS : CategoryTheory.Functor C D\nA B : CategoryTheory.CostructuredArrow S T\nf : Quiver.Hom A B\nh : CategoryTheory.Mono f.left\n⊢ CategoryTheory.Mono f","decl":"theorem mono_of_mono_left {A B : CostructuredArrow S T} (f : A ⟶ B) [h : Mono f.left] : Mono f :=\n  (proj S T).mono_of_mono_map h\n\n"}
{"name":"CategoryTheory.CostructuredArrow.epi_of_epi_left","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nT : D\nS : CategoryTheory.Functor C D\nA B : CategoryTheory.CostructuredArrow S T\nf : Quiver.Hom A B\nh : CategoryTheory.Epi f.left\n⊢ CategoryTheory.Epi f","decl":"/-- The converse of this is true with additional assumptions, see `epi_iff_epi_left`. -/\ntheorem epi_of_epi_left {A B : CostructuredArrow S T} (f : A ⟶ B) [h : Epi f.left] : Epi f :=\n  (proj S T).epi_of_epi_map h\n\n"}
{"name":"CategoryTheory.CostructuredArrow.mono_homMk","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nT : D\nS : CategoryTheory.Functor C D\nA B : CategoryTheory.CostructuredArrow S T\nf : Quiver.Hom A.left B.left\nw : Eq (CategoryTheory.CategoryStruct.comp (S.map f) B.hom) A.hom\nh : CategoryTheory.Mono f\n⊢ CategoryTheory.Mono (CategoryTheory.CostructuredArrow.homMk f w)","decl":"instance mono_homMk {A B : CostructuredArrow S T} (f : A.left ⟶ B.left) (w) [h : Mono f] :\n    Mono (homMk f w) :=\n  (proj S T).mono_of_mono_map h\n\n"}
{"name":"CategoryTheory.CostructuredArrow.epi_homMk","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nT : D\nS : CategoryTheory.Functor C D\nA B : CategoryTheory.CostructuredArrow S T\nf : Quiver.Hom A.left B.left\nw : Eq (CategoryTheory.CategoryStruct.comp (S.map f) B.hom) A.hom\nh : CategoryTheory.Epi f\n⊢ CategoryTheory.Epi (CategoryTheory.CostructuredArrow.homMk f w)","decl":"instance epi_homMk {A B : CostructuredArrow S T} (f : A.left ⟶ B.left) (w) [h : Epi f] :\n    Epi (homMk f w) :=\n  (proj S T).epi_of_epi_map h\n\n"}
{"name":"CategoryTheory.CostructuredArrow.eq_mk","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nT : D\nS : CategoryTheory.Functor C D\nf : CategoryTheory.CostructuredArrow S T\n⊢ Eq f (CategoryTheory.CostructuredArrow.mk f.hom)","decl":"/-- Eta rule for costructured arrows. Prefer `CostructuredArrow.eta` for rewriting, as equality of\n    objects tends to cause problems. -/\ntheorem eq_mk (f : CostructuredArrow S T) : f = mk f.hom :=\n  rfl\n\n"}
{"name":"CategoryTheory.CostructuredArrow.eta_hom_left","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nT : D\nS : CategoryTheory.Functor C D\nf : CategoryTheory.CostructuredArrow S T\n⊢ Eq f.eta.hom.left (CategoryTheory.CategoryStruct.id f.left)","decl":"/-- Eta rule for costructured arrows. -/\n@[simps! hom_left inv_left]\ndef eta (f : CostructuredArrow S T) : f ≅ mk f.hom :=\n  isoMk (Iso.refl _)\n\n"}
{"name":"CategoryTheory.CostructuredArrow.eta_inv_left","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nT : D\nS : CategoryTheory.Functor C D\nf : CategoryTheory.CostructuredArrow S T\n⊢ Eq f.eta.inv.left (CategoryTheory.CategoryStruct.id f.left)","decl":"/-- Eta rule for costructured arrows. -/\n@[simps! hom_left inv_left]\ndef eta (f : CostructuredArrow S T) : f ≅ mk f.hom :=\n  isoMk (Iso.refl _)\n\n"}
{"name":"CategoryTheory.CostructuredArrow.mk_surjective","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nT : D\nS : CategoryTheory.Functor C D\nf : CategoryTheory.CostructuredArrow S T\n⊢ Exists fun Y => Exists fun g => Eq f (CategoryTheory.CostructuredArrow.mk g)","decl":"lemma mk_surjective (f : CostructuredArrow S T) :\n    ∃ (Y : C) (g : S.obj Y ⟶ T), f = mk g :=\n  ⟨_, _, eq_mk f⟩\n\n"}
{"name":"CategoryTheory.CostructuredArrow.map_map_left","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nT T' : D\nS : CategoryTheory.Functor C D\nf✝ : Quiver.Hom T T'\nX✝ Y✝ : CategoryTheory.Comma S (CategoryTheory.Functor.fromPUnit T)\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.CostructuredArrow.map f✝).map f).left f.left","decl":"/-- A morphism between target objects `T ⟶ T'`\ncovariantly induces a functor between costructured arrows,\n`CostructuredArrow S T ⥤ CostructuredArrow S T'`.\n\nIdeally this would be described as a 2-functor from `D`\n(promoted to a 2-category with equations as 2-morphisms)\nto `Cat`.\n-/\n@[simps!]\ndef map (f : T ⟶ T') : CostructuredArrow S T ⥤ CostructuredArrow S T' :=\n  Comma.mapRight _ ((Functor.const _).map f)\n\n"}
{"name":"CategoryTheory.CostructuredArrow.map_map_right","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nT T' : D\nS : CategoryTheory.Functor C D\nf✝ : Quiver.Hom T T'\nX✝ Y✝ : CategoryTheory.Comma S (CategoryTheory.Functor.fromPUnit T)\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.CostructuredArrow.map f✝).map f).right (CategoryTheory.CategoryStruct.id X✝.right)","decl":"/-- A morphism between target objects `T ⟶ T'`\ncovariantly induces a functor between costructured arrows,\n`CostructuredArrow S T ⥤ CostructuredArrow S T'`.\n\nIdeally this would be described as a 2-functor from `D`\n(promoted to a 2-category with equations as 2-morphisms)\nto `Cat`.\n-/\n@[simps!]\ndef map (f : T ⟶ T') : CostructuredArrow S T ⥤ CostructuredArrow S T' :=\n  Comma.mapRight _ ((Functor.const _).map f)\n\n"}
{"name":"CategoryTheory.CostructuredArrow.map_obj_left","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nT T' : D\nS : CategoryTheory.Functor C D\nf : Quiver.Hom T T'\nX : CategoryTheory.Comma S (CategoryTheory.Functor.fromPUnit T)\n⊢ Eq ((CategoryTheory.CostructuredArrow.map f).obj X).left X.left","decl":"/-- A morphism between target objects `T ⟶ T'`\ncovariantly induces a functor between costructured arrows,\n`CostructuredArrow S T ⥤ CostructuredArrow S T'`.\n\nIdeally this would be described as a 2-functor from `D`\n(promoted to a 2-category with equations as 2-morphisms)\nto `Cat`.\n-/\n@[simps!]\ndef map (f : T ⟶ T') : CostructuredArrow S T ⥤ CostructuredArrow S T' :=\n  Comma.mapRight _ ((Functor.const _).map f)\n\n"}
{"name":"CategoryTheory.CostructuredArrow.map_obj_right","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nT T' : D\nS : CategoryTheory.Functor C D\nf : Quiver.Hom T T'\nX : CategoryTheory.Comma S (CategoryTheory.Functor.fromPUnit T)\n⊢ Eq ((CategoryTheory.CostructuredArrow.map f).obj X).right X.right","decl":"/-- A morphism between target objects `T ⟶ T'`\ncovariantly induces a functor between costructured arrows,\n`CostructuredArrow S T ⥤ CostructuredArrow S T'`.\n\nIdeally this would be described as a 2-functor from `D`\n(promoted to a 2-category with equations as 2-morphisms)\nto `Cat`.\n-/\n@[simps!]\ndef map (f : T ⟶ T') : CostructuredArrow S T ⥤ CostructuredArrow S T' :=\n  Comma.mapRight _ ((Functor.const _).map f)\n\n"}
{"name":"CategoryTheory.CostructuredArrow.map_obj_hom","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nT T' : D\nS : CategoryTheory.Functor C D\nf : Quiver.Hom T T'\nX : CategoryTheory.Comma S (CategoryTheory.Functor.fromPUnit T)\n⊢ Eq ((CategoryTheory.CostructuredArrow.map f).obj X).hom (CategoryTheory.CategoryStruct.comp X.hom f)","decl":"/-- A morphism between target objects `T ⟶ T'`\ncovariantly induces a functor between costructured arrows,\n`CostructuredArrow S T ⥤ CostructuredArrow S T'`.\n\nIdeally this would be described as a 2-functor from `D`\n(promoted to a 2-category with equations as 2-morphisms)\nto `Cat`.\n-/\n@[simps!]\ndef map (f : T ⟶ T') : CostructuredArrow S T ⥤ CostructuredArrow S T' :=\n  Comma.mapRight _ ((Functor.const _).map f)\n\n"}
{"name":"CategoryTheory.CostructuredArrow.map_mk","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nT T' : D\nY : C\nS : CategoryTheory.Functor C D\nf : Quiver.Hom (S.obj Y) T\ng : Quiver.Hom T T'\n⊢ Eq ((CategoryTheory.CostructuredArrow.map g).obj (CategoryTheory.CostructuredArrow.mk f)) (CategoryTheory.CostructuredArrow.mk (CategoryTheory.CategoryStruct.comp f g))","decl":"@[simp]\ntheorem map_mk {f : S.obj Y ⟶ T} (g : T ⟶ T') : (map g).obj (mk f) = mk (f ≫ g) :=\n  rfl\n\n"}
{"name":"CategoryTheory.CostructuredArrow.map_id","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nT : D\nS : CategoryTheory.Functor C D\nf : CategoryTheory.CostructuredArrow S T\n⊢ Eq ((CategoryTheory.CostructuredArrow.map (CategoryTheory.CategoryStruct.id T)).obj f) f","decl":"@[simp]\ntheorem map_id {f : CostructuredArrow S T} : (map (𝟙 T)).obj f = f := by\n  rw [eq_mk f]\n  simp\n\n"}
{"name":"CategoryTheory.CostructuredArrow.map_comp","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nT T' T'' : D\nS : CategoryTheory.Functor C D\nf : Quiver.Hom T T'\nf' : Quiver.Hom T' T''\nh : CategoryTheory.CostructuredArrow S T\n⊢ Eq ((CategoryTheory.CostructuredArrow.map (CategoryTheory.CategoryStruct.comp f f')).obj h) ((CategoryTheory.CostructuredArrow.map f').obj ((CategoryTheory.CostructuredArrow.map f).obj h))","decl":"@[simp]\ntheorem map_comp {f : T ⟶ T'} {f' : T' ⟶ T''} {h : CostructuredArrow S T} :\n    (map (f ≫ f')).obj h = (map f').obj ((map f).obj h) := by\n  rw [eq_mk h]\n  simp\n\n"}
{"name":"CategoryTheory.CostructuredArrow.proj_reflectsIsomorphisms","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nT : D\nS : CategoryTheory.Functor C D\n⊢ (CategoryTheory.CostructuredArrow.proj S T).ReflectsIsomorphisms","decl":"instance proj_reflectsIsomorphisms : (proj S T).ReflectsIsomorphisms where\n  reflects {Y Z} f t :=\n    ⟨⟨CostructuredArrow.homMk\n        (inv ((proj S T).map f))\n        (by rw [Functor.map_inv, IsIso.inv_comp_eq]; simp),\n      by constructor <;> ext <;> dsimp at t ⊢ <;> simp⟩⟩\n\n"}
{"name":"CategoryTheory.CostructuredArrow.pre_map_left","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nB : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} B\nF : CategoryTheory.Functor B C\nG : CategoryTheory.Functor C D\nS : D\nX✝ Y✝ : CategoryTheory.Comma (F.comp G) (CategoryTheory.Functor.fromPUnit S)\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.CostructuredArrow.pre F G S).map f).left (F.map f.left)","decl":"/-- The functor `(F ⋙ G, S) ⥤ (G, S)`. -/\n@[simps!]\ndef pre (F : B ⥤ C) (G : C ⥤ D) (S : D) : CostructuredArrow (F ⋙ G) S ⥤ CostructuredArrow G S :=\n  Comma.preLeft F G _\n\n"}
{"name":"CategoryTheory.CostructuredArrow.pre_obj_hom","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nB : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} B\nF : CategoryTheory.Functor B C\nG : CategoryTheory.Functor C D\nS : D\nX : CategoryTheory.Comma (F.comp G) (CategoryTheory.Functor.fromPUnit S)\n⊢ Eq ((CategoryTheory.CostructuredArrow.pre F G S).obj X).hom X.hom","decl":"/-- The functor `(F ⋙ G, S) ⥤ (G, S)`. -/\n@[simps!]\ndef pre (F : B ⥤ C) (G : C ⥤ D) (S : D) : CostructuredArrow (F ⋙ G) S ⥤ CostructuredArrow G S :=\n  Comma.preLeft F G _\n\n"}
{"name":"CategoryTheory.CostructuredArrow.pre_obj_right","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nB : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} B\nF : CategoryTheory.Functor B C\nG : CategoryTheory.Functor C D\nS : D\nX : CategoryTheory.Comma (F.comp G) (CategoryTheory.Functor.fromPUnit S)\n⊢ Eq ((CategoryTheory.CostructuredArrow.pre F G S).obj X).right X.right","decl":"/-- The functor `(F ⋙ G, S) ⥤ (G, S)`. -/\n@[simps!]\ndef pre (F : B ⥤ C) (G : C ⥤ D) (S : D) : CostructuredArrow (F ⋙ G) S ⥤ CostructuredArrow G S :=\n  Comma.preLeft F G _\n\n"}
{"name":"CategoryTheory.CostructuredArrow.pre_obj_left","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nB : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} B\nF : CategoryTheory.Functor B C\nG : CategoryTheory.Functor C D\nS : D\nX : CategoryTheory.Comma (F.comp G) (CategoryTheory.Functor.fromPUnit S)\n⊢ Eq ((CategoryTheory.CostructuredArrow.pre F G S).obj X).left (F.obj X.left)","decl":"/-- The functor `(F ⋙ G, S) ⥤ (G, S)`. -/\n@[simps!]\ndef pre (F : B ⥤ C) (G : C ⥤ D) (S : D) : CostructuredArrow (F ⋙ G) S ⥤ CostructuredArrow G S :=\n  Comma.preLeft F G _\n\n"}
{"name":"CategoryTheory.CostructuredArrow.pre_map_right","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nB : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} B\nF : CategoryTheory.Functor B C\nG : CategoryTheory.Functor C D\nS : D\nX✝ Y✝ : CategoryTheory.Comma (F.comp G) (CategoryTheory.Functor.fromPUnit S)\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.CostructuredArrow.pre F G S).map f).right (CategoryTheory.CategoryStruct.id X✝.right)","decl":"/-- The functor `(F ⋙ G, S) ⥤ (G, S)`. -/\n@[simps!]\ndef pre (F : B ⥤ C) (G : C ⥤ D) (S : D) : CostructuredArrow (F ⋙ G) S ⥤ CostructuredArrow G S :=\n  Comma.preLeft F G _\n\n"}
{"name":"CategoryTheory.CostructuredArrow.instFaithfulCompPre","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nB : Type u₄\ninst✝¹ : CategoryTheory.Category.{v₄, u₄} B\nF : CategoryTheory.Functor B C\nG : CategoryTheory.Functor C D\nS : D\ninst✝ : F.Faithful\n⊢ (CategoryTheory.CostructuredArrow.pre F G S).Faithful","decl":"instance (F : B ⥤ C) (G : C ⥤ D) (S : D) [F.Faithful] : (pre F G S).Faithful :=\n  show (Comma.preLeft _ _ _).Faithful from inferInstance\n\n"}
{"name":"CategoryTheory.CostructuredArrow.instFullCompPre","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nB : Type u₄\ninst✝¹ : CategoryTheory.Category.{v₄, u₄} B\nF : CategoryTheory.Functor B C\nG : CategoryTheory.Functor C D\nS : D\ninst✝ : F.Full\n⊢ (CategoryTheory.CostructuredArrow.pre F G S).Full","decl":"instance (F : B ⥤ C) (G : C ⥤ D) (S : D) [F.Full] : (pre F G S).Full :=\n  show (Comma.preLeft _ _ _).Full from inferInstance\n\n"}
{"name":"CategoryTheory.CostructuredArrow.instEssSurjCompPre","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nB : Type u₄\ninst✝¹ : CategoryTheory.Category.{v₄, u₄} B\nF : CategoryTheory.Functor B C\nG : CategoryTheory.Functor C D\nS : D\ninst✝ : F.EssSurj\n⊢ (CategoryTheory.CostructuredArrow.pre F G S).EssSurj","decl":"instance (F : B ⥤ C) (G : C ⥤ D) (S : D) [F.EssSurj] : (pre F G S).EssSurj :=\n  show (Comma.preLeft _ _ _).EssSurj from inferInstance\n\n"}
{"name":"CategoryTheory.CostructuredArrow.isEquivalence_pre","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nB : Type u₄\ninst✝¹ : CategoryTheory.Category.{v₄, u₄} B\nF : CategoryTheory.Functor B C\nG : CategoryTheory.Functor C D\nS : D\ninst✝ : F.IsEquivalence\n⊢ (CategoryTheory.CostructuredArrow.pre F G S).IsEquivalence","decl":"/-- If `F` is an equivalence, then so is the functor `(F ⋙ G, S) ⥤ (G, S)`. -/\ninstance isEquivalence_pre (F : B ⥤ C) (G : C ⥤ D) (S : D) [F.IsEquivalence] :\n    (pre F G S).IsEquivalence :=\n  Comma.isEquivalence_preLeft _ _ _\n\n"}
{"name":"CategoryTheory.CostructuredArrow.post_map","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nB : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} B\nF : CategoryTheory.Functor B C\nG : CategoryTheory.Functor C D\nS : C\nX✝ Y✝ : CategoryTheory.CostructuredArrow F S\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.CostructuredArrow.post F G S).map f) (CategoryTheory.CostructuredArrow.homMk f.left ⋯)","decl":"/-- The functor `(F, S) ⥤ (F ⋙ G, G(S))`. -/\n@[simps]\ndef post (F : B ⥤ C) (G : C ⥤ D) (S : C) :\n    CostructuredArrow F S ⥤ CostructuredArrow (F ⋙ G) (G.obj S) where\n  obj X := CostructuredArrow.mk (G.map X.hom)\n  map f := CostructuredArrow.homMk f.left (by simp [Functor.comp_map, ← G.map_comp, ← f.w])\n\n"}
{"name":"CategoryTheory.CostructuredArrow.post_obj","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nB : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} B\nF : CategoryTheory.Functor B C\nG : CategoryTheory.Functor C D\nS : C\nX : CategoryTheory.CostructuredArrow F S\n⊢ Eq ((CategoryTheory.CostructuredArrow.post F G S).obj X) (CategoryTheory.CostructuredArrow.mk (G.map X.hom))","decl":"/-- The functor `(F, S) ⥤ (F ⋙ G, G(S))`. -/\n@[simps]\ndef post (F : B ⥤ C) (G : C ⥤ D) (S : C) :\n    CostructuredArrow F S ⥤ CostructuredArrow (F ⋙ G) (G.obj S) where\n  obj X := CostructuredArrow.mk (G.map X.hom)\n  map f := CostructuredArrow.homMk f.left (by simp [Functor.comp_map, ← G.map_comp, ← f.w])\n\n"}
{"name":"CategoryTheory.CostructuredArrow.instFaithfulCompObjPost","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nB : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} B\nF : CategoryTheory.Functor B C\nG : CategoryTheory.Functor C D\nS : C\n⊢ (CategoryTheory.CostructuredArrow.post F G S).Faithful","decl":"instance (F : B ⥤ C) (G : C ⥤ D) (S : C) : (post F G S).Faithful where\n  map_injective {_ _} _ _ h := by simpa [ext_iff] using h\n\n"}
{"name":"CategoryTheory.CostructuredArrow.instFullCompObjPostOfFaithful","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nB : Type u₄\ninst✝¹ : CategoryTheory.Category.{v₄, u₄} B\nF : CategoryTheory.Functor B C\nG : CategoryTheory.Functor C D\nS : C\ninst✝ : G.Faithful\n⊢ (CategoryTheory.CostructuredArrow.post F G S).Full","decl":"instance (F : B ⥤ C) (G : C ⥤ D) (S : C) [G.Faithful] : (post F G S).Full where\n  map_surjective f := ⟨homMk f.left (G.map_injective (by simpa using f.w)), by simp⟩\n\n"}
{"name":"CategoryTheory.CostructuredArrow.instEssSurjCompObjPostOfFull","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nB : Type u₄\ninst✝¹ : CategoryTheory.Category.{v₄, u₄} B\nF : CategoryTheory.Functor B C\nG : CategoryTheory.Functor C D\nS : C\ninst✝ : G.Full\n⊢ (CategoryTheory.CostructuredArrow.post F G S).EssSurj","decl":"instance (F : B ⥤ C) (G : C ⥤ D) (S : C) [G.Full] : (post F G S).EssSurj where\n  mem_essImage h := ⟨mk (G.preimage h.hom), ⟨isoMk (Iso.refl _) (by simp)⟩⟩\n\n"}
{"name":"CategoryTheory.CostructuredArrow.isEquivalence_post","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nB : Type u₄\ninst✝² : CategoryTheory.Category.{v₄, u₄} B\nS : C\nF : CategoryTheory.Functor B C\nG : CategoryTheory.Functor C D\ninst✝¹ : G.Full\ninst✝ : G.Faithful\n⊢ (CategoryTheory.CostructuredArrow.post F G S).IsEquivalence","decl":"/-- If `G` is fully faithful, then `post F G S : (F, S) ⥤ (F ⋙ G, G(S))` is an equivalence. -/\ninstance isEquivalence_post (S : C) (F : B ⥤ C) (G : C ⥤ D) [G.Full] [G.Faithful] :\n    (post F G S).IsEquivalence where\n\n"}
{"name":"CategoryTheory.CostructuredArrow.map₂_map_right","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nT : D\nS : CategoryTheory.Functor C D\nA : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} A\nB : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} B\nU : CategoryTheory.Functor A B\nV : B\nF : CategoryTheory.Functor C A\nG : CategoryTheory.Functor D B\nα : Quiver.Hom (F.comp U) (S.comp G)\nβ : Quiver.Hom (G.obj T) V\nX Y : CategoryTheory.Comma S (CategoryTheory.Functor.fromPUnit T)\nφ : Quiver.Hom X Y\n⊢ Eq ((CategoryTheory.CostructuredArrow.map₂ α β).map φ).right (CategoryTheory.CategoryStruct.id X.right)","decl":"/-- The functor `CostructuredArrow S T ⥤ CostructuredArrow U V` that is deduced from\na natural transformation `F ⋙ U ⟶ S ⋙ G` and a morphism `G.obj T ⟶ V` -/\n@[simps!]\ndef map₂ : CostructuredArrow S T ⥤ CostructuredArrow U V :=\n  Comma.map (F₂ := 𝟭 (Discrete PUnit)) α (Discrete.natTrans (fun _ => β))\n\n"}
{"name":"CategoryTheory.CostructuredArrow.map₂_obj_hom","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nT : D\nS : CategoryTheory.Functor C D\nA : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} A\nB : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} B\nU : CategoryTheory.Functor A B\nV : B\nF : CategoryTheory.Functor C A\nG : CategoryTheory.Functor D B\nα : Quiver.Hom (F.comp U) (S.comp G)\nβ : Quiver.Hom (G.obj T) V\nX : CategoryTheory.Comma S (CategoryTheory.Functor.fromPUnit T)\n⊢ Eq ((CategoryTheory.CostructuredArrow.map₂ α β).obj X).hom (CategoryTheory.CategoryStruct.comp (α.app X.left) (CategoryTheory.CategoryStruct.comp (G.map X.hom) β))","decl":"/-- The functor `CostructuredArrow S T ⥤ CostructuredArrow U V` that is deduced from\na natural transformation `F ⋙ U ⟶ S ⋙ G` and a morphism `G.obj T ⟶ V` -/\n@[simps!]\ndef map₂ : CostructuredArrow S T ⥤ CostructuredArrow U V :=\n  Comma.map (F₂ := 𝟭 (Discrete PUnit)) α (Discrete.natTrans (fun _ => β))\n\n"}
{"name":"CategoryTheory.CostructuredArrow.map₂_map_left","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nT : D\nS : CategoryTheory.Functor C D\nA : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} A\nB : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} B\nU : CategoryTheory.Functor A B\nV : B\nF : CategoryTheory.Functor C A\nG : CategoryTheory.Functor D B\nα : Quiver.Hom (F.comp U) (S.comp G)\nβ : Quiver.Hom (G.obj T) V\nX Y : CategoryTheory.Comma S (CategoryTheory.Functor.fromPUnit T)\nφ : Quiver.Hom X Y\n⊢ Eq ((CategoryTheory.CostructuredArrow.map₂ α β).map φ).left (F.map φ.left)","decl":"/-- The functor `CostructuredArrow S T ⥤ CostructuredArrow U V` that is deduced from\na natural transformation `F ⋙ U ⟶ S ⋙ G` and a morphism `G.obj T ⟶ V` -/\n@[simps!]\ndef map₂ : CostructuredArrow S T ⥤ CostructuredArrow U V :=\n  Comma.map (F₂ := 𝟭 (Discrete PUnit)) α (Discrete.natTrans (fun _ => β))\n\n"}
{"name":"CategoryTheory.CostructuredArrow.map₂_obj_right","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nT : D\nS : CategoryTheory.Functor C D\nA : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} A\nB : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} B\nU : CategoryTheory.Functor A B\nV : B\nF : CategoryTheory.Functor C A\nG : CategoryTheory.Functor D B\nα : Quiver.Hom (F.comp U) (S.comp G)\nβ : Quiver.Hom (G.obj T) V\nX : CategoryTheory.Comma S (CategoryTheory.Functor.fromPUnit T)\n⊢ Eq ((CategoryTheory.CostructuredArrow.map₂ α β).obj X).right X.right","decl":"/-- The functor `CostructuredArrow S T ⥤ CostructuredArrow U V` that is deduced from\na natural transformation `F ⋙ U ⟶ S ⋙ G` and a morphism `G.obj T ⟶ V` -/\n@[simps!]\ndef map₂ : CostructuredArrow S T ⥤ CostructuredArrow U V :=\n  Comma.map (F₂ := 𝟭 (Discrete PUnit)) α (Discrete.natTrans (fun _ => β))\n\n"}
{"name":"CategoryTheory.CostructuredArrow.map₂_obj_left","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nT : D\nS : CategoryTheory.Functor C D\nA : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} A\nB : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} B\nU : CategoryTheory.Functor A B\nV : B\nF : CategoryTheory.Functor C A\nG : CategoryTheory.Functor D B\nα : Quiver.Hom (F.comp U) (S.comp G)\nβ : Quiver.Hom (G.obj T) V\nX : CategoryTheory.Comma S (CategoryTheory.Functor.fromPUnit T)\n⊢ Eq ((CategoryTheory.CostructuredArrow.map₂ α β).obj X).left (F.obj X.left)","decl":"/-- The functor `CostructuredArrow S T ⥤ CostructuredArrow U V` that is deduced from\na natural transformation `F ⋙ U ⟶ S ⋙ G` and a morphism `G.obj T ⟶ V` -/\n@[simps!]\ndef map₂ : CostructuredArrow S T ⥤ CostructuredArrow U V :=\n  Comma.map (F₂ := 𝟭 (Discrete PUnit)) α (Discrete.natTrans (fun _ => β))\n\n"}
{"name":"CategoryTheory.CostructuredArrow.faithful_map₂","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nT : D\nS : CategoryTheory.Functor C D\nA : Type u₃\ninst✝² : CategoryTheory.Category.{v₃, u₃} A\nB : Type u₄\ninst✝¹ : CategoryTheory.Category.{v₄, u₄} B\nU : CategoryTheory.Functor A B\nV : B\nF : CategoryTheory.Functor C A\nG : CategoryTheory.Functor D B\nα : Quiver.Hom (F.comp U) (S.comp G)\nβ : Quiver.Hom (G.obj T) V\ninst✝ : F.Faithful\n⊢ (CategoryTheory.CostructuredArrow.map₂ α β).Faithful","decl":"instance faithful_map₂ [F.Faithful] : (map₂ α β).Faithful := by\n  apply Comma.faithful_map\n\n"}
{"name":"CategoryTheory.CostructuredArrow.full_map₂","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝⁷ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝⁶ : CategoryTheory.Category.{v₂, u₂} D\nT : D\nS : CategoryTheory.Functor C D\nA : Type u₃\ninst✝⁵ : CategoryTheory.Category.{v₃, u₃} A\nB : Type u₄\ninst✝⁴ : CategoryTheory.Category.{v₄, u₄} B\nU : CategoryTheory.Functor A B\nV : B\nF : CategoryTheory.Functor C A\nG : CategoryTheory.Functor D B\nα : Quiver.Hom (F.comp U) (S.comp G)\nβ : Quiver.Hom (G.obj T) V\ninst✝³ : G.Faithful\ninst✝² : F.Full\ninst✝¹ : CategoryTheory.IsIso α\ninst✝ : CategoryTheory.IsIso β\n⊢ (CategoryTheory.CostructuredArrow.map₂ α β).Full","decl":"instance full_map₂ [G.Faithful] [F.Full] [IsIso α] [IsIso β] : (map₂ α β).Full := by\n  apply Comma.full_map\n\n"}
{"name":"CategoryTheory.CostructuredArrow.essSurj_map₂","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝⁷ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝⁶ : CategoryTheory.Category.{v₂, u₂} D\nT : D\nS : CategoryTheory.Functor C D\nA : Type u₃\ninst✝⁵ : CategoryTheory.Category.{v₃, u₃} A\nB : Type u₄\ninst✝⁴ : CategoryTheory.Category.{v₄, u₄} B\nU : CategoryTheory.Functor A B\nV : B\nF : CategoryTheory.Functor C A\nG : CategoryTheory.Functor D B\nα : Quiver.Hom (F.comp U) (S.comp G)\nβ : Quiver.Hom (G.obj T) V\ninst✝³ : F.EssSurj\ninst✝² : G.Full\ninst✝¹ : CategoryTheory.IsIso α\ninst✝ : CategoryTheory.IsIso β\n⊢ (CategoryTheory.CostructuredArrow.map₂ α β).EssSurj","decl":"instance essSurj_map₂ [F.EssSurj] [G.Full] [IsIso α] [IsIso β] : (map₂ α β).EssSurj := by\n  apply Comma.essSurj_map\n\n"}
{"name":"CategoryTheory.CostructuredArrow.isEquivalenceMap₂","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝⁸ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝⁷ : CategoryTheory.Category.{v₂, u₂} D\nT : D\nS : CategoryTheory.Functor C D\nA : Type u₃\ninst✝⁶ : CategoryTheory.Category.{v₃, u₃} A\nB : Type u₄\ninst✝⁵ : CategoryTheory.Category.{v₄, u₄} B\nU : CategoryTheory.Functor A B\nV : B\nF : CategoryTheory.Functor C A\nG : CategoryTheory.Functor D B\nα : Quiver.Hom (F.comp U) (S.comp G)\nβ : Quiver.Hom (G.obj T) V\ninst✝⁴ : F.IsEquivalence\ninst✝³ : G.Faithful\ninst✝² : G.Full\ninst✝¹ : CategoryTheory.IsIso α\ninst✝ : CategoryTheory.IsIso β\n⊢ (CategoryTheory.CostructuredArrow.map₂ α β).IsEquivalence","decl":"noncomputable instance isEquivalenceMap₂\n    [F.IsEquivalence] [G.Faithful] [G.Full] [IsIso α] [IsIso β] :\n    (map₂ α β).IsEquivalence := by\n  apply Comma.isEquivalenceMap\n\n"}
{"name":"CategoryTheory.CostructuredArrow.IsUniversal.uniq","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nT : D\nS : CategoryTheory.Functor C D\nf g : CategoryTheory.CostructuredArrow S T\nh : f.IsUniversal\nη : Quiver.Hom g f\n⊢ Eq η (CategoryTheory.Limits.IsTerminal.from h g)","decl":"theorem uniq (h : IsUniversal f) (η : g ⟶ f) : η = h.from g :=\n  h.hom_ext η (h.from g)\n\n"}
{"name":"CategoryTheory.CostructuredArrow.IsUniversal.fac_assoc","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nT : D\nS : CategoryTheory.Functor C D\nf : CategoryTheory.CostructuredArrow S T\nh✝ : f.IsUniversal\ng : CategoryTheory.CostructuredArrow S T\nZ : D\nh : Quiver.Hom ((CategoryTheory.Functor.fromPUnit T).obj f.right) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (S.map (h✝.lift g)) (CategoryTheory.CategoryStruct.comp f.hom h)) (CategoryTheory.CategoryStruct.comp g.hom h)","decl":"/-- Any costructured arrow factors through a universal arrow. -/\n@[reassoc (attr := simp)]\ntheorem fac (h : IsUniversal f) (g : CostructuredArrow S T) :\n    S.map (h.lift g) ≫ f.hom = g.hom :=\n  Category.comp_id g.hom ▸ (h.from g).w\n\n"}
{"name":"CategoryTheory.CostructuredArrow.IsUniversal.fac","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nT : D\nS : CategoryTheory.Functor C D\nf : CategoryTheory.CostructuredArrow S T\nh : f.IsUniversal\ng : CategoryTheory.CostructuredArrow S T\n⊢ Eq (CategoryTheory.CategoryStruct.comp (S.map (h.lift g)) f.hom) g.hom","decl":"/-- Any costructured arrow factors through a universal arrow. -/\n@[reassoc (attr := simp)]\ntheorem fac (h : IsUniversal f) (g : CostructuredArrow S T) :\n    S.map (h.lift g) ≫ f.hom = g.hom :=\n  Category.comp_id g.hom ▸ (h.from g).w\n\n"}
{"name":"CategoryTheory.CostructuredArrow.IsUniversal.hom_desc","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nT : D\nS : CategoryTheory.Functor C D\nf : CategoryTheory.CostructuredArrow S T\nh : f.IsUniversal\nc : C\nη : Quiver.Hom c f.left\n⊢ Eq η (h.lift (CategoryTheory.CostructuredArrow.mk (CategoryTheory.CategoryStruct.comp (S.map η) f.hom)))","decl":"theorem hom_desc (h : IsUniversal f) {c : C} (η : c ⟶ f.left) :\n    η = h.lift (mk <| S.map η ≫ f.hom) :=\n  let g := mk <| S.map η ≫ f.hom\n  congrArg CommaMorphism.left (h.hom_ext (homMk η rfl : g ⟶ f) (h.from g))\n\n"}
{"name":"CategoryTheory.CostructuredArrow.IsUniversal.hom_ext","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nT : D\nS : CategoryTheory.Functor C D\nf : CategoryTheory.CostructuredArrow S T\nh : f.IsUniversal\nc : C\nη η' : Quiver.Hom c f.left\nw : Eq (CategoryTheory.CategoryStruct.comp (S.map η) f.hom) (CategoryTheory.CategoryStruct.comp (S.map η') f.hom)\n⊢ Eq η η'","decl":"/-- Two morphisms into a universal `S`-costructured arrow are equal if their image under `S` are\nequal after postcomposing the universal arrow. -/\ntheorem hom_ext (h : IsUniversal f) {c : C} {η η' : c ⟶ f.left}\n    (w : S.map η ≫ f.hom = S.map η' ≫ f.hom) : η = η' := by\n  rw [h.hom_desc η, h.hom_desc η', w]\n\n"}
{"name":"CategoryTheory.CostructuredArrow.IsUniversal.existsUnique","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nT : D\nS : CategoryTheory.Functor C D\nf : CategoryTheory.CostructuredArrow S T\nh : f.IsUniversal\ng : CategoryTheory.CostructuredArrow S T\n⊢ ExistsUnique fun η => Eq (CategoryTheory.CategoryStruct.comp (S.map η) f.hom) g.hom","decl":"theorem existsUnique (h : IsUniversal f) (g : CostructuredArrow S T) :\n    ∃! η : g.left ⟶ f.left, S.map η ≫ f.hom = g.hom :=\n  ⟨h.lift g, h.fac g, fun f w ↦ h.hom_ext <| by simp [w]⟩\n\n"}
{"name":"CategoryTheory.Functor.toStructuredArrow_obj","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nG : CategoryTheory.Functor E C\nX : D\nF : CategoryTheory.Functor C D\nf : (Y : E) → Quiver.Hom X (F.obj (G.obj Y))\nh : ∀ {Y Z : E} (g : Quiver.Hom Y Z), Eq (CategoryTheory.CategoryStruct.comp (f Y) (F.map (G.map g))) (f Z)\nY : E\n⊢ Eq ((G.toStructuredArrow X F f h).obj Y) (CategoryTheory.StructuredArrow.mk (f Y))","decl":"/-- Given `X : D` and `F : C ⥤ D`, to upgrade a functor `G : E ⥤ C` to a functor\n    `E ⥤ StructuredArrow X F`, it suffices to provide maps `X ⟶ F.obj (G.obj Y)` for all `Y` making\n    the obvious triangles involving all `F.map (G.map g)` commute.\n\n    This is of course the same as providing a cone over `F ⋙ G` with cone point `X`, see\n    `Functor.toStructuredArrowIsoToStructuredArrow`. -/\n@[simps]\ndef toStructuredArrow (G : E ⥤ C) (X : D) (F : C ⥤ D) (f : (Y : E) → X ⟶ F.obj (G.obj Y))\n    (h : ∀ {Y Z : E} (g : Y ⟶ Z), f Y ≫ F.map (G.map g) = f Z) : E ⥤ StructuredArrow X F where\n  obj Y := StructuredArrow.mk (f Y)\n  map g := StructuredArrow.homMk (G.map g) (h g)\n\n"}
{"name":"CategoryTheory.Functor.toStructuredArrow_map","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nG : CategoryTheory.Functor E C\nX : D\nF : CategoryTheory.Functor C D\nf : (Y : E) → Quiver.Hom X (F.obj (G.obj Y))\nh : ∀ {Y Z : E} (g : Quiver.Hom Y Z), Eq (CategoryTheory.CategoryStruct.comp (f Y) (F.map (G.map g))) (f Z)\nX✝ Y✝ : E\ng : Quiver.Hom X✝ Y✝\n⊢ Eq ((G.toStructuredArrow X F f h).map g) (CategoryTheory.StructuredArrow.homMk (G.map g) ⋯)","decl":"/-- Given `X : D` and `F : C ⥤ D`, to upgrade a functor `G : E ⥤ C` to a functor\n    `E ⥤ StructuredArrow X F`, it suffices to provide maps `X ⟶ F.obj (G.obj Y)` for all `Y` making\n    the obvious triangles involving all `F.map (G.map g)` commute.\n\n    This is of course the same as providing a cone over `F ⋙ G` with cone point `X`, see\n    `Functor.toStructuredArrowIsoToStructuredArrow`. -/\n@[simps]\ndef toStructuredArrow (G : E ⥤ C) (X : D) (F : C ⥤ D) (f : (Y : E) → X ⟶ F.obj (G.obj Y))\n    (h : ∀ {Y Z : E} (g : Y ⟶ Z), f Y ≫ F.map (G.map g) = f Z) : E ⥤ StructuredArrow X F where\n  obj Y := StructuredArrow.mk (f Y)\n  map g := StructuredArrow.homMk (G.map g) (h g)\n\n"}
{"name":"CategoryTheory.Functor.toStructuredArrow_comp_proj","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nG : CategoryTheory.Functor E C\nX : D\nF : CategoryTheory.Functor C D\nf : (Y : E) → Quiver.Hom X (F.obj (G.obj Y))\nh : ∀ {Y Z : E} (g : Quiver.Hom Y Z), Eq (CategoryTheory.CategoryStruct.comp (f Y) (F.map (G.map g))) (f Z)\n⊢ Eq ((G.toStructuredArrow X F f ⋯).comp (CategoryTheory.StructuredArrow.proj X F)) G","decl":"@[simp]\nlemma toStructuredArrow_comp_proj (G : E ⥤ C) (X : D) (F : C ⥤ D)\n    (f : (Y : E) → X ⟶ F.obj (G.obj Y)) (h : ∀ {Y Z : E} (g : Y ⟶ Z), f Y ≫ F.map (G.map g) = f Z) :\n    G.toStructuredArrow X F f h ⋙ StructuredArrow.proj _ _ = G :=\n  rfl\n\n"}
{"name":"CategoryTheory.Functor.toCostructuredArrow_map","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nG : CategoryTheory.Functor E C\nF : CategoryTheory.Functor C D\nX : D\nf : (Y : E) → Quiver.Hom (F.obj (G.obj Y)) X\nh : ∀ {Y Z : E} (g : Quiver.Hom Y Z), Eq (CategoryTheory.CategoryStruct.comp (F.map (G.map g)) (f Z)) (f Y)\nX✝ Y✝ : E\ng : Quiver.Hom X✝ Y✝\n⊢ Eq ((G.toCostructuredArrow F X f h).map g) (CategoryTheory.CostructuredArrow.homMk (G.map g) ⋯)","decl":"/-- Given `F : C ⥤ D` and `X : D`, to upgrade a functor `G : E ⥤ C` to a functor\n    `E ⥤ CostructuredArrow F X`, it suffices to provide maps `F.obj (G.obj Y) ⟶ X` for all `Y`\n    making the obvious triangles involving all `F.map (G.map g)` commute.\n\n    This is of course the same as providing a cocone over `F ⋙ G` with cocone point `X`, see\n    `Functor.toCostructuredArrowIsoToCostructuredArrow`. -/\n@[simps]\ndef toCostructuredArrow (G : E ⥤ C) (F : C ⥤ D) (X : D) (f : (Y : E) → F.obj (G.obj Y) ⟶ X)\n    (h : ∀ {Y Z : E} (g : Y ⟶ Z), F.map (G.map g) ≫ f Z = f Y) : E ⥤ CostructuredArrow F X where\n  obj Y := CostructuredArrow.mk (f Y)\n  map g := CostructuredArrow.homMk (G.map g) (h g)\n\n"}
{"name":"CategoryTheory.Functor.toCostructuredArrow_obj","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nG : CategoryTheory.Functor E C\nF : CategoryTheory.Functor C D\nX : D\nf : (Y : E) → Quiver.Hom (F.obj (G.obj Y)) X\nh : ∀ {Y Z : E} (g : Quiver.Hom Y Z), Eq (CategoryTheory.CategoryStruct.comp (F.map (G.map g)) (f Z)) (f Y)\nY : E\n⊢ Eq ((G.toCostructuredArrow F X f h).obj Y) (CategoryTheory.CostructuredArrow.mk (f Y))","decl":"/-- Given `F : C ⥤ D` and `X : D`, to upgrade a functor `G : E ⥤ C` to a functor\n    `E ⥤ CostructuredArrow F X`, it suffices to provide maps `F.obj (G.obj Y) ⟶ X` for all `Y`\n    making the obvious triangles involving all `F.map (G.map g)` commute.\n\n    This is of course the same as providing a cocone over `F ⋙ G` with cocone point `X`, see\n    `Functor.toCostructuredArrowIsoToCostructuredArrow`. -/\n@[simps]\ndef toCostructuredArrow (G : E ⥤ C) (F : C ⥤ D) (X : D) (f : (Y : E) → F.obj (G.obj Y) ⟶ X)\n    (h : ∀ {Y Z : E} (g : Y ⟶ Z), F.map (G.map g) ≫ f Z = f Y) : E ⥤ CostructuredArrow F X where\n  obj Y := CostructuredArrow.mk (f Y)\n  map g := CostructuredArrow.homMk (G.map g) (h g)\n\n"}
{"name":"CategoryTheory.Functor.toCostructuredArrow_comp_proj","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nG : CategoryTheory.Functor E C\nF : CategoryTheory.Functor C D\nX : D\nf : (Y : E) → Quiver.Hom (F.obj (G.obj Y)) X\nh : ∀ {Y Z : E} (g : Quiver.Hom Y Z), Eq (CategoryTheory.CategoryStruct.comp (F.map (G.map g)) (f Z)) (f Y)\n⊢ Eq ((G.toCostructuredArrow F X f ⋯).comp (CategoryTheory.CostructuredArrow.proj F X)) G","decl":"@[simp]\nlemma toCostructuredArrow_comp_proj (G : E ⥤ C) (F : C ⥤ D) (X : D)\n    (f : (Y : E) → F.obj (G.obj Y) ⟶ X) (h : ∀ {Y Z : E} (g : Y ⟶ Z), F.map (G.map g) ≫ f Z = f Y) :\n    G.toCostructuredArrow F X f h ⋙ CostructuredArrow.proj _ _ = G :=\nrfl\n\n"}
{"name":"CategoryTheory.StructuredArrow.toCostructuredArrow_map","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nd : D\nX✝ Y✝ : Opposite (CategoryTheory.StructuredArrow d F)\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.StructuredArrow.toCostructuredArrow F d).map f) (CategoryTheory.CostructuredArrow.homMk f.unop.right.op ⋯)","decl":"/-- For a functor `F : C ⥤ D` and an object `d : D`, we obtain a contravariant functor from the\ncategory of structured arrows `d ⟶ F.obj c` to the category of costructured arrows\n`F.op.obj c ⟶ (op d)`.\n-/\n@[simps]\ndef toCostructuredArrow (F : C ⥤ D) (d : D) :\n    (StructuredArrow d F)ᵒᵖ ⥤ CostructuredArrow F.op (op d) where\n  obj X := @CostructuredArrow.mk _ _ _ _ _ (op X.unop.right) F.op X.unop.hom.op\n  map f := CostructuredArrow.homMk f.unop.right.op (by simp [← op_comp])\n\n"}
{"name":"CategoryTheory.StructuredArrow.toCostructuredArrow_obj","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nd : D\nX : Opposite (CategoryTheory.StructuredArrow d F)\n⊢ Eq ((CategoryTheory.StructuredArrow.toCostructuredArrow F d).obj X) (CategoryTheory.CostructuredArrow.mk (Opposite.unop X).hom.op)","decl":"/-- For a functor `F : C ⥤ D` and an object `d : D`, we obtain a contravariant functor from the\ncategory of structured arrows `d ⟶ F.obj c` to the category of costructured arrows\n`F.op.obj c ⟶ (op d)`.\n-/\n@[simps]\ndef toCostructuredArrow (F : C ⥤ D) (d : D) :\n    (StructuredArrow d F)ᵒᵖ ⥤ CostructuredArrow F.op (op d) where\n  obj X := @CostructuredArrow.mk _ _ _ _ _ (op X.unop.right) F.op X.unop.hom.op\n  map f := CostructuredArrow.homMk f.unop.right.op (by simp [← op_comp])\n\n"}
{"name":"CategoryTheory.StructuredArrow.toCostructuredArrow'_map","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nd : D\nX✝ Y✝ : Opposite (CategoryTheory.StructuredArrow { unop := d } F.op)\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.StructuredArrow.toCostructuredArrow' F d).map f) (CategoryTheory.CostructuredArrow.homMk f.unop.right.unop ⋯)","decl":"/-- For a functor `F : C ⥤ D` and an object `d : D`, we obtain a contravariant functor from the\ncategory of structured arrows `op d ⟶ F.op.obj c` to the category of costructured arrows\n`F.obj c ⟶ d`.\n-/\n@[simps]\ndef toCostructuredArrow' (F : C ⥤ D) (d : D) :\n    (StructuredArrow (op d) F.op)ᵒᵖ ⥤ CostructuredArrow F d where\n  obj X := @CostructuredArrow.mk _ _ _ _ _ (unop X.unop.right) F X.unop.hom.unop\n  map f :=\n    CostructuredArrow.homMk f.unop.right.unop\n      (by\n        dsimp\n        rw [← Quiver.Hom.unop_op (F.map (Quiver.Hom.unop f.unop.right)), ← unop_comp, ← F.op_map, ←\n          f.unop.w]\n        simp)\n\n"}
{"name":"CategoryTheory.StructuredArrow.toCostructuredArrow'_obj","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nd : D\nX : Opposite (CategoryTheory.StructuredArrow { unop := d } F.op)\n⊢ Eq ((CategoryTheory.StructuredArrow.toCostructuredArrow' F d).obj X) (CategoryTheory.CostructuredArrow.mk (Opposite.unop X).hom.unop)","decl":"/-- For a functor `F : C ⥤ D` and an object `d : D`, we obtain a contravariant functor from the\ncategory of structured arrows `op d ⟶ F.op.obj c` to the category of costructured arrows\n`F.obj c ⟶ d`.\n-/\n@[simps]\ndef toCostructuredArrow' (F : C ⥤ D) (d : D) :\n    (StructuredArrow (op d) F.op)ᵒᵖ ⥤ CostructuredArrow F d where\n  obj X := @CostructuredArrow.mk _ _ _ _ _ (unop X.unop.right) F X.unop.hom.unop\n  map f :=\n    CostructuredArrow.homMk f.unop.right.unop\n      (by\n        dsimp\n        rw [← Quiver.Hom.unop_op (F.map (Quiver.Hom.unop f.unop.right)), ← unop_comp, ← F.op_map, ←\n          f.unop.w]\n        simp)\n\n"}
{"name":"CategoryTheory.CostructuredArrow.toStructuredArrow_map","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nd : D\nX✝ Y✝ : Opposite (CategoryTheory.CostructuredArrow F d)\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.CostructuredArrow.toStructuredArrow F d).map f) (CategoryTheory.StructuredArrow.homMk f.unop.left.op ⋯)","decl":"/-- For a functor `F : C ⥤ D` and an object `d : D`, we obtain a contravariant functor from the\ncategory of costructured arrows `F.obj c ⟶ d` to the category of structured arrows\n`op d ⟶ F.op.obj c`.\n-/\n@[simps]\ndef toStructuredArrow (F : C ⥤ D) (d : D) :\n    (CostructuredArrow F d)ᵒᵖ ⥤ StructuredArrow (op d) F.op where\n  obj X := @StructuredArrow.mk _ _ _ _ _ (op X.unop.left) F.op X.unop.hom.op\n  map f := StructuredArrow.homMk f.unop.left.op (by simp [← op_comp])\n\n"}
{"name":"CategoryTheory.CostructuredArrow.toStructuredArrow_obj","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nd : D\nX : Opposite (CategoryTheory.CostructuredArrow F d)\n⊢ Eq ((CategoryTheory.CostructuredArrow.toStructuredArrow F d).obj X) (CategoryTheory.StructuredArrow.mk (Opposite.unop X).hom.op)","decl":"/-- For a functor `F : C ⥤ D` and an object `d : D`, we obtain a contravariant functor from the\ncategory of costructured arrows `F.obj c ⟶ d` to the category of structured arrows\n`op d ⟶ F.op.obj c`.\n-/\n@[simps]\ndef toStructuredArrow (F : C ⥤ D) (d : D) :\n    (CostructuredArrow F d)ᵒᵖ ⥤ StructuredArrow (op d) F.op where\n  obj X := @StructuredArrow.mk _ _ _ _ _ (op X.unop.left) F.op X.unop.hom.op\n  map f := StructuredArrow.homMk f.unop.left.op (by simp [← op_comp])\n\n"}
{"name":"CategoryTheory.CostructuredArrow.toStructuredArrow'_map","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nd : D\nX✝ Y✝ : Opposite (CategoryTheory.CostructuredArrow F.op { unop := d })\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.CostructuredArrow.toStructuredArrow' F d).map f) (CategoryTheory.StructuredArrow.homMk f.unop.left.unop ⋯)","decl":"/-- For a functor `F : C ⥤ D` and an object `d : D`, we obtain a contravariant functor from the\ncategory of costructured arrows `F.op.obj c ⟶ op d` to the category of structured arrows\n`d ⟶ F.obj c`.\n-/\n@[simps]\ndef toStructuredArrow' (F : C ⥤ D) (d : D) :\n    (CostructuredArrow F.op (op d))ᵒᵖ ⥤ StructuredArrow d F where\n  obj X := @StructuredArrow.mk _ _ _ _ _ (unop X.unop.left) F X.unop.hom.unop\n  map f :=\n    StructuredArrow.homMk f.unop.left.unop\n      (by\n        dsimp\n        rw [← Quiver.Hom.unop_op (F.map f.unop.left.unop), ← unop_comp, ← F.op_map, f.unop.w,\n          Functor.const_obj_map]\n        simp)\n\n"}
{"name":"CategoryTheory.CostructuredArrow.toStructuredArrow'_obj","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nd : D\nX : Opposite (CategoryTheory.CostructuredArrow F.op { unop := d })\n⊢ Eq ((CategoryTheory.CostructuredArrow.toStructuredArrow' F d).obj X) (CategoryTheory.StructuredArrow.mk (Opposite.unop X).hom.unop)","decl":"/-- For a functor `F : C ⥤ D` and an object `d : D`, we obtain a contravariant functor from the\ncategory of costructured arrows `F.op.obj c ⟶ op d` to the category of structured arrows\n`d ⟶ F.obj c`.\n-/\n@[simps]\ndef toStructuredArrow' (F : C ⥤ D) (d : D) :\n    (CostructuredArrow F.op (op d))ᵒᵖ ⥤ StructuredArrow d F where\n  obj X := @StructuredArrow.mk _ _ _ _ _ (unop X.unop.left) F X.unop.hom.unop\n  map f :=\n    StructuredArrow.homMk f.unop.left.unop\n      (by\n        dsimp\n        rw [← Quiver.Hom.unop_op (F.map f.unop.left.unop), ← unop_comp, ← F.op_map, f.unop.w,\n          Functor.const_obj_map]\n        simp)\n\n"}
{"name":"CategoryTheory.StructuredArrow.preEquivalenceFunctor_obj_right","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ne : E\nf : CategoryTheory.StructuredArrow e G\ng : CategoryTheory.StructuredArrow f (CategoryTheory.StructuredArrow.pre e F G)\n⊢ Eq ((CategoryTheory.StructuredArrow.preEquivalenceFunctor F f).obj g).right g.right.right","decl":"/-- The functor establishing the equivalence `StructuredArrow.preEquivalence`. -/\n@[simps!]\ndef StructuredArrow.preEquivalenceFunctor (f : StructuredArrow e G) :\n    StructuredArrow f (pre e F G) ⥤ StructuredArrow f.right F where\n  obj g := mk g.hom.right\n  map φ := homMk φ.right.right <| by\n    have := w φ\n    simp only [Functor.const_obj_obj] at this ⊢\n    rw [← this, comp_right]\n    simp\n\n"}
{"name":"CategoryTheory.StructuredArrow.preEquivalenceFunctor_obj_left_as","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ne : E\nf : CategoryTheory.StructuredArrow e G\ng : CategoryTheory.StructuredArrow f (CategoryTheory.StructuredArrow.pre e F G)\n⊢ Eq ((CategoryTheory.StructuredArrow.preEquivalenceFunctor F f).obj g).left.as PUnit.unit","decl":"/-- The functor establishing the equivalence `StructuredArrow.preEquivalence`. -/\n@[simps!]\ndef StructuredArrow.preEquivalenceFunctor (f : StructuredArrow e G) :\n    StructuredArrow f (pre e F G) ⥤ StructuredArrow f.right F where\n  obj g := mk g.hom.right\n  map φ := homMk φ.right.right <| by\n    have := w φ\n    simp only [Functor.const_obj_obj] at this ⊢\n    rw [← this, comp_right]\n    simp\n\n"}
{"name":"CategoryTheory.StructuredArrow.preEquivalenceFunctor_map_right","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ne : E\nf : CategoryTheory.StructuredArrow e G\nX✝ Y✝ : CategoryTheory.StructuredArrow f (CategoryTheory.StructuredArrow.pre e F G)\nφ : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.StructuredArrow.preEquivalenceFunctor F f).map φ).right φ.right.right","decl":"/-- The functor establishing the equivalence `StructuredArrow.preEquivalence`. -/\n@[simps!]\ndef StructuredArrow.preEquivalenceFunctor (f : StructuredArrow e G) :\n    StructuredArrow f (pre e F G) ⥤ StructuredArrow f.right F where\n  obj g := mk g.hom.right\n  map φ := homMk φ.right.right <| by\n    have := w φ\n    simp only [Functor.const_obj_obj] at this ⊢\n    rw [← this, comp_right]\n    simp\n\n"}
{"name":"CategoryTheory.StructuredArrow.preEquivalenceFunctor_map_left_down_down","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ne : E\nf : CategoryTheory.StructuredArrow e G\nX✝ Y✝ : CategoryTheory.StructuredArrow f (CategoryTheory.StructuredArrow.pre e F G)\nφ : Quiver.Hom X✝ Y✝\n⊢ Eq ⋯ ⋯","decl":"/-- The functor establishing the equivalence `StructuredArrow.preEquivalence`. -/\n@[simps!]\ndef StructuredArrow.preEquivalenceFunctor (f : StructuredArrow e G) :\n    StructuredArrow f (pre e F G) ⥤ StructuredArrow f.right F where\n  obj g := mk g.hom.right\n  map φ := homMk φ.right.right <| by\n    have := w φ\n    simp only [Functor.const_obj_obj] at this ⊢\n    rw [← this, comp_right]\n    simp\n\n"}
{"name":"CategoryTheory.StructuredArrow.preEquivalenceFunctor_obj_hom","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ne : E\nf : CategoryTheory.StructuredArrow e G\ng : CategoryTheory.StructuredArrow f (CategoryTheory.StructuredArrow.pre e F G)\n⊢ Eq ((CategoryTheory.StructuredArrow.preEquivalenceFunctor F f).obj g).hom g.hom.right","decl":"/-- The functor establishing the equivalence `StructuredArrow.preEquivalence`. -/\n@[simps!]\ndef StructuredArrow.preEquivalenceFunctor (f : StructuredArrow e G) :\n    StructuredArrow f (pre e F G) ⥤ StructuredArrow f.right F where\n  obj g := mk g.hom.right\n  map φ := homMk φ.right.right <| by\n    have := w φ\n    simp only [Functor.const_obj_obj] at this ⊢\n    rw [← this, comp_right]\n    simp\n\n"}
{"name":"CategoryTheory.StructuredArrow.preEquivalenceInverse_obj_hom_left_down_down","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ne : E\nf : CategoryTheory.StructuredArrow e G\ng : CategoryTheory.StructuredArrow f.right F\n⊢ Eq ⋯ ⋯","decl":"/-- The inverse functor establishing the equivalence `StructuredArrow.preEquivalence`. -/\n@[simps!]\ndef StructuredArrow.preEquivalenceInverse (f : StructuredArrow e G) :\n    StructuredArrow f.right F ⥤ StructuredArrow f (pre e F G) where\n  obj g := mk\n            (Y := mk (Y := g.right)\n              (f.hom ≫ (G.map g.hom : G.obj f.right ⟶ (F ⋙ G).obj g.right)))\n            (homMk g.hom)\n  map φ := homMk <| homMk φ.right <| by\n    simp only [Functor.const_obj_obj, Functor.comp_obj, mk_right, mk_left, mk_hom_eq_self,\n      Functor.comp_map, Category.assoc, ← w φ, Functor.map_comp]\n\n"}
{"name":"CategoryTheory.StructuredArrow.preEquivalenceInverse_map_right_right","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ne : E\nf : CategoryTheory.StructuredArrow e G\nX✝ Y✝ : CategoryTheory.StructuredArrow f.right F\nφ : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.StructuredArrow.preEquivalenceInverse F f).map φ).right.right φ.right","decl":"/-- The inverse functor establishing the equivalence `StructuredArrow.preEquivalence`. -/\n@[simps!]\ndef StructuredArrow.preEquivalenceInverse (f : StructuredArrow e G) :\n    StructuredArrow f.right F ⥤ StructuredArrow f (pre e F G) where\n  obj g := mk\n            (Y := mk (Y := g.right)\n              (f.hom ≫ (G.map g.hom : G.obj f.right ⟶ (F ⋙ G).obj g.right)))\n            (homMk g.hom)\n  map φ := homMk <| homMk φ.right <| by\n    simp only [Functor.const_obj_obj, Functor.comp_obj, mk_right, mk_left, mk_hom_eq_self,\n      Functor.comp_map, Category.assoc, ← w φ, Functor.map_comp]\n\n"}
{"name":"CategoryTheory.StructuredArrow.preEquivalenceInverse_map_left_down_down","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ne : E\nf : CategoryTheory.StructuredArrow e G\nX✝ Y✝ : CategoryTheory.StructuredArrow f.right F\nφ : Quiver.Hom X✝ Y✝\n⊢ Eq ⋯ ⋯","decl":"/-- The inverse functor establishing the equivalence `StructuredArrow.preEquivalence`. -/\n@[simps!]\ndef StructuredArrow.preEquivalenceInverse (f : StructuredArrow e G) :\n    StructuredArrow f.right F ⥤ StructuredArrow f (pre e F G) where\n  obj g := mk\n            (Y := mk (Y := g.right)\n              (f.hom ≫ (G.map g.hom : G.obj f.right ⟶ (F ⋙ G).obj g.right)))\n            (homMk g.hom)\n  map φ := homMk <| homMk φ.right <| by\n    simp only [Functor.const_obj_obj, Functor.comp_obj, mk_right, mk_left, mk_hom_eq_self,\n      Functor.comp_map, Category.assoc, ← w φ, Functor.map_comp]\n\n"}
{"name":"CategoryTheory.StructuredArrow.preEquivalenceInverse_map_right_left_down_down","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ne : E\nf : CategoryTheory.StructuredArrow e G\nX✝ Y✝ : CategoryTheory.StructuredArrow f.right F\nφ : Quiver.Hom X✝ Y✝\n⊢ Eq ⋯ ⋯","decl":"/-- The inverse functor establishing the equivalence `StructuredArrow.preEquivalence`. -/\n@[simps!]\ndef StructuredArrow.preEquivalenceInverse (f : StructuredArrow e G) :\n    StructuredArrow f.right F ⥤ StructuredArrow f (pre e F G) where\n  obj g := mk\n            (Y := mk (Y := g.right)\n              (f.hom ≫ (G.map g.hom : G.obj f.right ⟶ (F ⋙ G).obj g.right)))\n            (homMk g.hom)\n  map φ := homMk <| homMk φ.right <| by\n    simp only [Functor.const_obj_obj, Functor.comp_obj, mk_right, mk_left, mk_hom_eq_self,\n      Functor.comp_map, Category.assoc, ← w φ, Functor.map_comp]\n\n"}
{"name":"CategoryTheory.StructuredArrow.preEquivalenceInverse_obj_left_as","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ne : E\nf : CategoryTheory.StructuredArrow e G\ng : CategoryTheory.StructuredArrow f.right F\n⊢ Eq ((CategoryTheory.StructuredArrow.preEquivalenceInverse F f).obj g).left.as PUnit.unit","decl":"/-- The inverse functor establishing the equivalence `StructuredArrow.preEquivalence`. -/\n@[simps!]\ndef StructuredArrow.preEquivalenceInverse (f : StructuredArrow e G) :\n    StructuredArrow f.right F ⥤ StructuredArrow f (pre e F G) where\n  obj g := mk\n            (Y := mk (Y := g.right)\n              (f.hom ≫ (G.map g.hom : G.obj f.right ⟶ (F ⋙ G).obj g.right)))\n            (homMk g.hom)\n  map φ := homMk <| homMk φ.right <| by\n    simp only [Functor.const_obj_obj, Functor.comp_obj, mk_right, mk_left, mk_hom_eq_self,\n      Functor.comp_map, Category.assoc, ← w φ, Functor.map_comp]\n\n"}
{"name":"CategoryTheory.StructuredArrow.preEquivalenceInverse_obj_hom_right","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ne : E\nf : CategoryTheory.StructuredArrow e G\ng : CategoryTheory.StructuredArrow f.right F\n⊢ Eq ((CategoryTheory.StructuredArrow.preEquivalenceInverse F f).obj g).hom.right g.hom","decl":"/-- The inverse functor establishing the equivalence `StructuredArrow.preEquivalence`. -/\n@[simps!]\ndef StructuredArrow.preEquivalenceInverse (f : StructuredArrow e G) :\n    StructuredArrow f.right F ⥤ StructuredArrow f (pre e F G) where\n  obj g := mk\n            (Y := mk (Y := g.right)\n              (f.hom ≫ (G.map g.hom : G.obj f.right ⟶ (F ⋙ G).obj g.right)))\n            (homMk g.hom)\n  map φ := homMk <| homMk φ.right <| by\n    simp only [Functor.const_obj_obj, Functor.comp_obj, mk_right, mk_left, mk_hom_eq_self,\n      Functor.comp_map, Category.assoc, ← w φ, Functor.map_comp]\n\n"}
{"name":"CategoryTheory.StructuredArrow.preEquivalenceInverse_obj_right_left_as","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ne : E\nf : CategoryTheory.StructuredArrow e G\ng : CategoryTheory.StructuredArrow f.right F\n⊢ Eq ((CategoryTheory.StructuredArrow.preEquivalenceInverse F f).obj g).right.left.as PUnit.unit","decl":"/-- The inverse functor establishing the equivalence `StructuredArrow.preEquivalence`. -/\n@[simps!]\ndef StructuredArrow.preEquivalenceInverse (f : StructuredArrow e G) :\n    StructuredArrow f.right F ⥤ StructuredArrow f (pre e F G) where\n  obj g := mk\n            (Y := mk (Y := g.right)\n              (f.hom ≫ (G.map g.hom : G.obj f.right ⟶ (F ⋙ G).obj g.right)))\n            (homMk g.hom)\n  map φ := homMk <| homMk φ.right <| by\n    simp only [Functor.const_obj_obj, Functor.comp_obj, mk_right, mk_left, mk_hom_eq_self,\n      Functor.comp_map, Category.assoc, ← w φ, Functor.map_comp]\n\n"}
{"name":"CategoryTheory.StructuredArrow.preEquivalenceInverse_obj_right_right","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ne : E\nf : CategoryTheory.StructuredArrow e G\ng : CategoryTheory.StructuredArrow f.right F\n⊢ Eq ((CategoryTheory.StructuredArrow.preEquivalenceInverse F f).obj g).right.right g.right","decl":"/-- The inverse functor establishing the equivalence `StructuredArrow.preEquivalence`. -/\n@[simps!]\ndef StructuredArrow.preEquivalenceInverse (f : StructuredArrow e G) :\n    StructuredArrow f.right F ⥤ StructuredArrow f (pre e F G) where\n  obj g := mk\n            (Y := mk (Y := g.right)\n              (f.hom ≫ (G.map g.hom : G.obj f.right ⟶ (F ⋙ G).obj g.right)))\n            (homMk g.hom)\n  map φ := homMk <| homMk φ.right <| by\n    simp only [Functor.const_obj_obj, Functor.comp_obj, mk_right, mk_left, mk_hom_eq_self,\n      Functor.comp_map, Category.assoc, ← w φ, Functor.map_comp]\n\n"}
{"name":"CategoryTheory.StructuredArrow.preEquivalenceInverse_obj_right_hom","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ne : E\nf : CategoryTheory.StructuredArrow e G\ng : CategoryTheory.StructuredArrow f.right F\n⊢ Eq ((CategoryTheory.StructuredArrow.preEquivalenceInverse F f).obj g).right.hom (CategoryTheory.CategoryStruct.comp f.hom (G.map g.hom))","decl":"/-- The inverse functor establishing the equivalence `StructuredArrow.preEquivalence`. -/\n@[simps!]\ndef StructuredArrow.preEquivalenceInverse (f : StructuredArrow e G) :\n    StructuredArrow f.right F ⥤ StructuredArrow f (pre e F G) where\n  obj g := mk\n            (Y := mk (Y := g.right)\n              (f.hom ≫ (G.map g.hom : G.obj f.right ⟶ (F ⋙ G).obj g.right)))\n            (homMk g.hom)\n  map φ := homMk <| homMk φ.right <| by\n    simp only [Functor.const_obj_obj, Functor.comp_obj, mk_right, mk_left, mk_hom_eq_self,\n      Functor.comp_map, Category.assoc, ← w φ, Functor.map_comp]\n\n"}
{"name":"CategoryTheory.StructuredArrow.preEquivalence_unitIso","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ne : E\nf : CategoryTheory.StructuredArrow e G\n⊢ Eq (CategoryTheory.StructuredArrow.preEquivalence F f).unitIso (CategoryTheory.NatIso.ofComponents (fun x => CategoryTheory.StructuredArrow.isoMk (CategoryTheory.StructuredArrow.isoMk (CategoryTheory.Iso.refl ((CategoryTheory.Functor.id (CategoryTheory.StructuredArrow f (CategoryTheory.StructuredArrow.pre e F G))).obj x).right.right) ⋯) ⋯) ⋯)","decl":"/-- A structured arrow category on a `StructuredArrow.pre e F G` functor is equivalent to the\nstructured arrow category on F -/\n@[simps]\ndef StructuredArrow.preEquivalence (f : StructuredArrow e G) :\n    StructuredArrow f (pre e F G) ≌ StructuredArrow f.right F where\n  functor := preEquivalenceFunctor F f\n  inverse := preEquivalenceInverse F f\n  unitIso := NatIso.ofComponents (fun _ => isoMk (isoMk (Iso.refl _)))\n  counitIso := NatIso.ofComponents (fun _ => isoMk (Iso.refl _))\n\n"}
{"name":"CategoryTheory.StructuredArrow.preEquivalence_functor","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ne : E\nf : CategoryTheory.StructuredArrow e G\n⊢ Eq (CategoryTheory.StructuredArrow.preEquivalence F f).functor (CategoryTheory.StructuredArrow.preEquivalenceFunctor F f)","decl":"/-- A structured arrow category on a `StructuredArrow.pre e F G` functor is equivalent to the\nstructured arrow category on F -/\n@[simps]\ndef StructuredArrow.preEquivalence (f : StructuredArrow e G) :\n    StructuredArrow f (pre e F G) ≌ StructuredArrow f.right F where\n  functor := preEquivalenceFunctor F f\n  inverse := preEquivalenceInverse F f\n  unitIso := NatIso.ofComponents (fun _ => isoMk (isoMk (Iso.refl _)))\n  counitIso := NatIso.ofComponents (fun _ => isoMk (Iso.refl _))\n\n"}
{"name":"CategoryTheory.StructuredArrow.preEquivalence_counitIso","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ne : E\nf : CategoryTheory.StructuredArrow e G\n⊢ Eq (CategoryTheory.StructuredArrow.preEquivalence F f).counitIso (CategoryTheory.NatIso.ofComponents (fun x => CategoryTheory.StructuredArrow.isoMk (CategoryTheory.Iso.refl (((CategoryTheory.StructuredArrow.preEquivalenceInverse F f).comp (CategoryTheory.StructuredArrow.preEquivalenceFunctor F f)).obj x).right) ⋯) ⋯)","decl":"/-- A structured arrow category on a `StructuredArrow.pre e F G` functor is equivalent to the\nstructured arrow category on F -/\n@[simps]\ndef StructuredArrow.preEquivalence (f : StructuredArrow e G) :\n    StructuredArrow f (pre e F G) ≌ StructuredArrow f.right F where\n  functor := preEquivalenceFunctor F f\n  inverse := preEquivalenceInverse F f\n  unitIso := NatIso.ofComponents (fun _ => isoMk (isoMk (Iso.refl _)))\n  counitIso := NatIso.ofComponents (fun _ => isoMk (Iso.refl _))\n\n"}
{"name":"CategoryTheory.StructuredArrow.preEquivalence_inverse","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ne : E\nf : CategoryTheory.StructuredArrow e G\n⊢ Eq (CategoryTheory.StructuredArrow.preEquivalence F f).inverse (CategoryTheory.StructuredArrow.preEquivalenceInverse F f)","decl":"/-- A structured arrow category on a `StructuredArrow.pre e F G` functor is equivalent to the\nstructured arrow category on F -/\n@[simps]\ndef StructuredArrow.preEquivalence (f : StructuredArrow e G) :\n    StructuredArrow f (pre e F G) ≌ StructuredArrow f.right F where\n  functor := preEquivalenceFunctor F f\n  inverse := preEquivalenceInverse F f\n  unitIso := NatIso.ofComponents (fun _ => isoMk (isoMk (Iso.refl _)))\n  counitIso := NatIso.ofComponents (fun _ => isoMk (Iso.refl _))\n\n"}
{"name":"CategoryTheory.CostructuredArrow.preEquivalence.functor_map_right_down_down","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ne : E\nf : CategoryTheory.CostructuredArrow G e\nX✝ Y✝ : CategoryTheory.CostructuredArrow (CategoryTheory.CostructuredArrow.pre F G e) f\nφ : Quiver.Hom X✝ Y✝\n⊢ Eq ⋯ ⋯","decl":"/-- The functor establishing the equivalence `CostructuredArrow.preEquivalence`. -/\n@[simps!]\ndef CostructuredArrow.preEquivalence.functor (f : CostructuredArrow G e) :\n    CostructuredArrow (pre F G e) f ⥤ CostructuredArrow F f.left where\n  obj g := mk g.hom.left\n  map φ := homMk φ.left.left <| by\n    have := w φ\n    simp only [Functor.const_obj_obj] at this ⊢\n    rw [← this, comp_left]\n    simp\n\n"}
{"name":"CategoryTheory.CostructuredArrow.preEquivalence.functor_obj_right_as","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ne : E\nf : CategoryTheory.CostructuredArrow G e\ng : CategoryTheory.CostructuredArrow (CategoryTheory.CostructuredArrow.pre F G e) f\n⊢ Eq ((CategoryTheory.CostructuredArrow.preEquivalence.functor F f).obj g).right.as PUnit.unit","decl":"/-- The functor establishing the equivalence `CostructuredArrow.preEquivalence`. -/\n@[simps!]\ndef CostructuredArrow.preEquivalence.functor (f : CostructuredArrow G e) :\n    CostructuredArrow (pre F G e) f ⥤ CostructuredArrow F f.left where\n  obj g := mk g.hom.left\n  map φ := homMk φ.left.left <| by\n    have := w φ\n    simp only [Functor.const_obj_obj] at this ⊢\n    rw [← this, comp_left]\n    simp\n\n"}
{"name":"CategoryTheory.CostructuredArrow.preEquivalence.functor_map_left","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ne : E\nf : CategoryTheory.CostructuredArrow G e\nX✝ Y✝ : CategoryTheory.CostructuredArrow (CategoryTheory.CostructuredArrow.pre F G e) f\nφ : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.CostructuredArrow.preEquivalence.functor F f).map φ).left φ.left.left","decl":"/-- The functor establishing the equivalence `CostructuredArrow.preEquivalence`. -/\n@[simps!]\ndef CostructuredArrow.preEquivalence.functor (f : CostructuredArrow G e) :\n    CostructuredArrow (pre F G e) f ⥤ CostructuredArrow F f.left where\n  obj g := mk g.hom.left\n  map φ := homMk φ.left.left <| by\n    have := w φ\n    simp only [Functor.const_obj_obj] at this ⊢\n    rw [← this, comp_left]\n    simp\n\n"}
{"name":"CategoryTheory.CostructuredArrow.preEquivalence.functor_obj_left","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ne : E\nf : CategoryTheory.CostructuredArrow G e\ng : CategoryTheory.CostructuredArrow (CategoryTheory.CostructuredArrow.pre F G e) f\n⊢ Eq ((CategoryTheory.CostructuredArrow.preEquivalence.functor F f).obj g).left g.left.left","decl":"/-- The functor establishing the equivalence `CostructuredArrow.preEquivalence`. -/\n@[simps!]\ndef CostructuredArrow.preEquivalence.functor (f : CostructuredArrow G e) :\n    CostructuredArrow (pre F G e) f ⥤ CostructuredArrow F f.left where\n  obj g := mk g.hom.left\n  map φ := homMk φ.left.left <| by\n    have := w φ\n    simp only [Functor.const_obj_obj] at this ⊢\n    rw [← this, comp_left]\n    simp\n\n"}
{"name":"CategoryTheory.CostructuredArrow.preEquivalence.functor_obj_hom","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ne : E\nf : CategoryTheory.CostructuredArrow G e\ng : CategoryTheory.CostructuredArrow (CategoryTheory.CostructuredArrow.pre F G e) f\n⊢ Eq ((CategoryTheory.CostructuredArrow.preEquivalence.functor F f).obj g).hom g.hom.left","decl":"/-- The functor establishing the equivalence `CostructuredArrow.preEquivalence`. -/\n@[simps!]\ndef CostructuredArrow.preEquivalence.functor (f : CostructuredArrow G e) :\n    CostructuredArrow (pre F G e) f ⥤ CostructuredArrow F f.left where\n  obj g := mk g.hom.left\n  map φ := homMk φ.left.left <| by\n    have := w φ\n    simp only [Functor.const_obj_obj] at this ⊢\n    rw [← this, comp_left]\n    simp\n\n"}
{"name":"CategoryTheory.CostructuredArrow.preEquivalence.inverse_map_right_down_down","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ne : E\nf : CategoryTheory.CostructuredArrow G e\nX✝ Y✝ : CategoryTheory.CostructuredArrow F f.left\nφ : Quiver.Hom X✝ Y✝\n⊢ Eq ⋯ ⋯","decl":"/-- The inverse functor establishing the equivalence `CostructuredArrow.preEquivalence`. -/\n@[simps!]\ndef CostructuredArrow.preEquivalence.inverse (f : CostructuredArrow G e) :\n    CostructuredArrow F f.left ⥤ CostructuredArrow (pre F G e) f where\n  obj g := mk (Y := mk (Y := g.left) (G.map g.hom ≫ f.hom)) (homMk g.hom)\n  map φ := homMk <| homMk φ.left <| by\n    simp only [Functor.const_obj_obj, Functor.comp_obj, mk_left, Functor.comp_map, mk_hom_eq_self,\n      ← w φ, Functor.map_comp, Category.assoc]\n\n"}
{"name":"CategoryTheory.CostructuredArrow.preEquivalence.inverse_obj_left_hom","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ne : E\nf : CategoryTheory.CostructuredArrow G e\ng : CategoryTheory.CostructuredArrow F f.left\n⊢ Eq ((CategoryTheory.CostructuredArrow.preEquivalence.inverse F f).obj g).left.hom (CategoryTheory.CategoryStruct.comp (G.map g.hom) f.hom)","decl":"/-- The inverse functor establishing the equivalence `CostructuredArrow.preEquivalence`. -/\n@[simps!]\ndef CostructuredArrow.preEquivalence.inverse (f : CostructuredArrow G e) :\n    CostructuredArrow F f.left ⥤ CostructuredArrow (pre F G e) f where\n  obj g := mk (Y := mk (Y := g.left) (G.map g.hom ≫ f.hom)) (homMk g.hom)\n  map φ := homMk <| homMk φ.left <| by\n    simp only [Functor.const_obj_obj, Functor.comp_obj, mk_left, Functor.comp_map, mk_hom_eq_self,\n      ← w φ, Functor.map_comp, Category.assoc]\n\n"}
{"name":"CategoryTheory.CostructuredArrow.preEquivalence.inverse_obj_hom_left","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ne : E\nf : CategoryTheory.CostructuredArrow G e\ng : CategoryTheory.CostructuredArrow F f.left\n⊢ Eq ((CategoryTheory.CostructuredArrow.preEquivalence.inverse F f).obj g).hom.left g.hom","decl":"/-- The inverse functor establishing the equivalence `CostructuredArrow.preEquivalence`. -/\n@[simps!]\ndef CostructuredArrow.preEquivalence.inverse (f : CostructuredArrow G e) :\n    CostructuredArrow F f.left ⥤ CostructuredArrow (pre F G e) f where\n  obj g := mk (Y := mk (Y := g.left) (G.map g.hom ≫ f.hom)) (homMk g.hom)\n  map φ := homMk <| homMk φ.left <| by\n    simp only [Functor.const_obj_obj, Functor.comp_obj, mk_left, Functor.comp_map, mk_hom_eq_self,\n      ← w φ, Functor.map_comp, Category.assoc]\n\n"}
{"name":"CategoryTheory.CostructuredArrow.preEquivalence.inverse_obj_hom_right_down_down","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ne : E\nf : CategoryTheory.CostructuredArrow G e\ng : CategoryTheory.CostructuredArrow F f.left\n⊢ Eq ⋯ ⋯","decl":"/-- The inverse functor establishing the equivalence `CostructuredArrow.preEquivalence`. -/\n@[simps!]\ndef CostructuredArrow.preEquivalence.inverse (f : CostructuredArrow G e) :\n    CostructuredArrow F f.left ⥤ CostructuredArrow (pre F G e) f where\n  obj g := mk (Y := mk (Y := g.left) (G.map g.hom ≫ f.hom)) (homMk g.hom)\n  map φ := homMk <| homMk φ.left <| by\n    simp only [Functor.const_obj_obj, Functor.comp_obj, mk_left, Functor.comp_map, mk_hom_eq_self,\n      ← w φ, Functor.map_comp, Category.assoc]\n\n"}
{"name":"CategoryTheory.CostructuredArrow.preEquivalence.inverse_obj_right_as","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ne : E\nf : CategoryTheory.CostructuredArrow G e\ng : CategoryTheory.CostructuredArrow F f.left\n⊢ Eq ((CategoryTheory.CostructuredArrow.preEquivalence.inverse F f).obj g).right.as PUnit.unit","decl":"/-- The inverse functor establishing the equivalence `CostructuredArrow.preEquivalence`. -/\n@[simps!]\ndef CostructuredArrow.preEquivalence.inverse (f : CostructuredArrow G e) :\n    CostructuredArrow F f.left ⥤ CostructuredArrow (pre F G e) f where\n  obj g := mk (Y := mk (Y := g.left) (G.map g.hom ≫ f.hom)) (homMk g.hom)\n  map φ := homMk <| homMk φ.left <| by\n    simp only [Functor.const_obj_obj, Functor.comp_obj, mk_left, Functor.comp_map, mk_hom_eq_self,\n      ← w φ, Functor.map_comp, Category.assoc]\n\n"}
{"name":"CategoryTheory.CostructuredArrow.preEquivalence.inverse_map_left_left","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ne : E\nf : CategoryTheory.CostructuredArrow G e\nX✝ Y✝ : CategoryTheory.CostructuredArrow F f.left\nφ : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.CostructuredArrow.preEquivalence.inverse F f).map φ).left.left φ.left","decl":"/-- The inverse functor establishing the equivalence `CostructuredArrow.preEquivalence`. -/\n@[simps!]\ndef CostructuredArrow.preEquivalence.inverse (f : CostructuredArrow G e) :\n    CostructuredArrow F f.left ⥤ CostructuredArrow (pre F G e) f where\n  obj g := mk (Y := mk (Y := g.left) (G.map g.hom ≫ f.hom)) (homMk g.hom)\n  map φ := homMk <| homMk φ.left <| by\n    simp only [Functor.const_obj_obj, Functor.comp_obj, mk_left, Functor.comp_map, mk_hom_eq_self,\n      ← w φ, Functor.map_comp, Category.assoc]\n\n"}
{"name":"CategoryTheory.CostructuredArrow.preEquivalence.inverse_map_left_right_down_down","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ne : E\nf : CategoryTheory.CostructuredArrow G e\nX✝ Y✝ : CategoryTheory.CostructuredArrow F f.left\nφ : Quiver.Hom X✝ Y✝\n⊢ Eq ⋯ ⋯","decl":"/-- The inverse functor establishing the equivalence `CostructuredArrow.preEquivalence`. -/\n@[simps!]\ndef CostructuredArrow.preEquivalence.inverse (f : CostructuredArrow G e) :\n    CostructuredArrow F f.left ⥤ CostructuredArrow (pre F G e) f where\n  obj g := mk (Y := mk (Y := g.left) (G.map g.hom ≫ f.hom)) (homMk g.hom)\n  map φ := homMk <| homMk φ.left <| by\n    simp only [Functor.const_obj_obj, Functor.comp_obj, mk_left, Functor.comp_map, mk_hom_eq_self,\n      ← w φ, Functor.map_comp, Category.assoc]\n\n"}
{"name":"CategoryTheory.CostructuredArrow.preEquivalence.inverse_obj_left_right_as","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ne : E\nf : CategoryTheory.CostructuredArrow G e\ng : CategoryTheory.CostructuredArrow F f.left\n⊢ Eq ((CategoryTheory.CostructuredArrow.preEquivalence.inverse F f).obj g).left.right.as PUnit.unit","decl":"/-- The inverse functor establishing the equivalence `CostructuredArrow.preEquivalence`. -/\n@[simps!]\ndef CostructuredArrow.preEquivalence.inverse (f : CostructuredArrow G e) :\n    CostructuredArrow F f.left ⥤ CostructuredArrow (pre F G e) f where\n  obj g := mk (Y := mk (Y := g.left) (G.map g.hom ≫ f.hom)) (homMk g.hom)\n  map φ := homMk <| homMk φ.left <| by\n    simp only [Functor.const_obj_obj, Functor.comp_obj, mk_left, Functor.comp_map, mk_hom_eq_self,\n      ← w φ, Functor.map_comp, Category.assoc]\n\n"}
{"name":"CategoryTheory.CostructuredArrow.preEquivalence.inverse_obj_left_left","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ne : E\nf : CategoryTheory.CostructuredArrow G e\ng : CategoryTheory.CostructuredArrow F f.left\n⊢ Eq ((CategoryTheory.CostructuredArrow.preEquivalence.inverse F f).obj g).left.left g.left","decl":"/-- The inverse functor establishing the equivalence `CostructuredArrow.preEquivalence`. -/\n@[simps!]\ndef CostructuredArrow.preEquivalence.inverse (f : CostructuredArrow G e) :\n    CostructuredArrow F f.left ⥤ CostructuredArrow (pre F G e) f where\n  obj g := mk (Y := mk (Y := g.left) (G.map g.hom ≫ f.hom)) (homMk g.hom)\n  map φ := homMk <| homMk φ.left <| by\n    simp only [Functor.const_obj_obj, Functor.comp_obj, mk_left, Functor.comp_map, mk_hom_eq_self,\n      ← w φ, Functor.map_comp, Category.assoc]\n\n"}
{"name":"CategoryTheory.StructuredArrow.w_prod_fst_assoc","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nC' : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} C'\nD' : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} D'\nS : D\nS' : D'\nT : CategoryTheory.Functor C D\nT' : CategoryTheory.Functor C' D'\nX Y : CategoryTheory.StructuredArrow { fst := S, snd := S' } (T.prod T')\nf : Quiver.Hom X Y\nZ : D\nh : Quiver.Hom (T.obj Y.right.1) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp X.hom.1 (CategoryTheory.CategoryStruct.comp (T.map f.right.1) h)) (CategoryTheory.CategoryStruct.comp Y.hom.1 h)","decl":"@[reassoc (attr := simp)]\ntheorem StructuredArrow.w_prod_fst {X Y : StructuredArrow (S, S') (T.prod T')}\n    (f : X ⟶ Y) : X.hom.1 ≫ T.map f.right.1 = Y.hom.1 :=\n  congr_arg _root_.Prod.fst (StructuredArrow.w f)\n\n"}
{"name":"CategoryTheory.StructuredArrow.w_prod_fst","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nC' : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} C'\nD' : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} D'\nS : D\nS' : D'\nT : CategoryTheory.Functor C D\nT' : CategoryTheory.Functor C' D'\nX Y : CategoryTheory.StructuredArrow { fst := S, snd := S' } (T.prod T')\nf : Quiver.Hom X Y\n⊢ Eq (CategoryTheory.CategoryStruct.comp X.hom.1 (T.map f.right.1)) Y.hom.1","decl":"@[reassoc (attr := simp)]\ntheorem StructuredArrow.w_prod_fst {X Y : StructuredArrow (S, S') (T.prod T')}\n    (f : X ⟶ Y) : X.hom.1 ≫ T.map f.right.1 = Y.hom.1 :=\n  congr_arg _root_.Prod.fst (StructuredArrow.w f)\n\n"}
{"name":"CategoryTheory.StructuredArrow.w_prod_snd_assoc","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nC' : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} C'\nD' : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} D'\nS : D\nS' : D'\nT : CategoryTheory.Functor C D\nT' : CategoryTheory.Functor C' D'\nX Y : CategoryTheory.StructuredArrow { fst := S, snd := S' } (T.prod T')\nf : Quiver.Hom X Y\nZ : D'\nh : Quiver.Hom (T'.obj Y.right.2) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp X.hom.2 (CategoryTheory.CategoryStruct.comp (T'.map f.right.2) h)) (CategoryTheory.CategoryStruct.comp Y.hom.2 h)","decl":"@[reassoc (attr := simp)]\ntheorem StructuredArrow.w_prod_snd {X Y : StructuredArrow (S, S') (T.prod T')}\n    (f : X ⟶ Y) : X.hom.2 ≫ T'.map f.right.2 = Y.hom.2 :=\n  congr_arg _root_.Prod.snd (StructuredArrow.w f)\n\n"}
{"name":"CategoryTheory.StructuredArrow.w_prod_snd","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nC' : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} C'\nD' : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} D'\nS : D\nS' : D'\nT : CategoryTheory.Functor C D\nT' : CategoryTheory.Functor C' D'\nX Y : CategoryTheory.StructuredArrow { fst := S, snd := S' } (T.prod T')\nf : Quiver.Hom X Y\n⊢ Eq (CategoryTheory.CategoryStruct.comp X.hom.2 (T'.map f.right.2)) Y.hom.2","decl":"@[reassoc (attr := simp)]\ntheorem StructuredArrow.w_prod_snd {X Y : StructuredArrow (S, S') (T.prod T')}\n    (f : X ⟶ Y) : X.hom.2 ≫ T'.map f.right.2 = Y.hom.2 :=\n  congr_arg _root_.Prod.snd (StructuredArrow.w f)\n\n"}
{"name":"CategoryTheory.StructuredArrow.prodFunctor_obj","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nC' : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} C'\nD' : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} D'\nS : D\nS' : D'\nT : CategoryTheory.Functor C D\nT' : CategoryTheory.Functor C' D'\nf : CategoryTheory.StructuredArrow { fst := S, snd := S' } (T.prod T')\n⊢ Eq ((CategoryTheory.StructuredArrow.prodFunctor S S' T T').obj f) { fst := CategoryTheory.StructuredArrow.mk f.hom.1, snd := CategoryTheory.StructuredArrow.mk f.hom.2 }","decl":"/-- Implementation; see `StructuredArrow.prodEquivalence`. -/\n@[simps]\ndef StructuredArrow.prodFunctor :\n    StructuredArrow (S, S') (T.prod T') ⥤ StructuredArrow S T × StructuredArrow S' T' where\n  obj f := ⟨.mk f.hom.1, .mk f.hom.2⟩\n  map η := ⟨StructuredArrow.homMk η.right.1 (by simp),\n            StructuredArrow.homMk η.right.2 (by simp)⟩\n\n"}
{"name":"CategoryTheory.StructuredArrow.prodFunctor_map","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nC' : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} C'\nD' : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} D'\nS : D\nS' : D'\nT : CategoryTheory.Functor C D\nT' : CategoryTheory.Functor C' D'\nX✝ Y✝ : CategoryTheory.StructuredArrow { fst := S, snd := S' } (T.prod T')\nη : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.StructuredArrow.prodFunctor S S' T T').map η) { fst := CategoryTheory.StructuredArrow.homMk η.right.1 ⋯, snd := CategoryTheory.StructuredArrow.homMk η.right.2 ⋯ }","decl":"/-- Implementation; see `StructuredArrow.prodEquivalence`. -/\n@[simps]\ndef StructuredArrow.prodFunctor :\n    StructuredArrow (S, S') (T.prod T') ⥤ StructuredArrow S T × StructuredArrow S' T' where\n  obj f := ⟨.mk f.hom.1, .mk f.hom.2⟩\n  map η := ⟨StructuredArrow.homMk η.right.1 (by simp),\n            StructuredArrow.homMk η.right.2 (by simp)⟩\n\n"}
{"name":"CategoryTheory.StructuredArrow.prodInverse_obj","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nC' : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} C'\nD' : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} D'\nS : D\nS' : D'\nT : CategoryTheory.Functor C D\nT' : CategoryTheory.Functor C' D'\nf : Prod (CategoryTheory.StructuredArrow S T) (CategoryTheory.StructuredArrow S' T')\n⊢ Eq ((CategoryTheory.StructuredArrow.prodInverse S S' T T').obj f) (CategoryTheory.StructuredArrow.mk { fst := f.1.hom, snd := f.2.hom })","decl":"/-- Implementation; see `StructuredArrow.prodEquivalence`. -/\n@[simps]\ndef StructuredArrow.prodInverse :\n    StructuredArrow S T × StructuredArrow S' T' ⥤ StructuredArrow (S, S') (T.prod T') where\n  obj f := .mk (Y := (f.1.right, f.2.right)) ⟨f.1.hom, f.2.hom⟩\n  map η := StructuredArrow.homMk ⟨η.1.right, η.2.right⟩ (by simp)\n\n"}
{"name":"CategoryTheory.StructuredArrow.prodInverse_map","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nC' : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} C'\nD' : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} D'\nS : D\nS' : D'\nT : CategoryTheory.Functor C D\nT' : CategoryTheory.Functor C' D'\nX✝ Y✝ : Prod (CategoryTheory.StructuredArrow S T) (CategoryTheory.StructuredArrow S' T')\nη : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.StructuredArrow.prodInverse S S' T T').map η) (CategoryTheory.StructuredArrow.homMk { fst := η.1.right, snd := η.2.right } ⋯)","decl":"/-- Implementation; see `StructuredArrow.prodEquivalence`. -/\n@[simps]\ndef StructuredArrow.prodInverse :\n    StructuredArrow S T × StructuredArrow S' T' ⥤ StructuredArrow (S, S') (T.prod T') where\n  obj f := .mk (Y := (f.1.right, f.2.right)) ⟨f.1.hom, f.2.hom⟩\n  map η := StructuredArrow.homMk ⟨η.1.right, η.2.right⟩ (by simp)\n\n"}
{"name":"CategoryTheory.StructuredArrow.prodEquivalence_functor","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nC' : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} C'\nD' : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} D'\nS : D\nS' : D'\nT : CategoryTheory.Functor C D\nT' : CategoryTheory.Functor C' D'\n⊢ Eq (CategoryTheory.StructuredArrow.prodEquivalence S S' T T').functor (CategoryTheory.StructuredArrow.prodFunctor S S' T T')","decl":"/-- The natural equivalence\n`StructuredArrow (S, S') (T.prod T') ≌ StructuredArrow S T × StructuredArrow S' T'`. -/\n@[simps]\ndef StructuredArrow.prodEquivalence :\n    StructuredArrow (S, S') (T.prod T') ≌ StructuredArrow S T × StructuredArrow S' T' where\n  functor := StructuredArrow.prodFunctor S S' T T'\n  inverse := StructuredArrow.prodInverse S S' T T'\n  unitIso := NatIso.ofComponents (fun f => Iso.refl _) (by simp)\n  counitIso := NatIso.ofComponents (fun f => Iso.refl _) (by simp)\n\n"}
{"name":"CategoryTheory.StructuredArrow.prodEquivalence_unitIso","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nC' : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} C'\nD' : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} D'\nS : D\nS' : D'\nT : CategoryTheory.Functor C D\nT' : CategoryTheory.Functor C' D'\n⊢ Eq (CategoryTheory.StructuredArrow.prodEquivalence S S' T T').unitIso (CategoryTheory.NatIso.ofComponents (fun f => CategoryTheory.Iso.refl ((CategoryTheory.Functor.id (CategoryTheory.StructuredArrow { fst := S, snd := S' } (T.prod T'))).obj f)) ⋯)","decl":"/-- The natural equivalence\n`StructuredArrow (S, S') (T.prod T') ≌ StructuredArrow S T × StructuredArrow S' T'`. -/\n@[simps]\ndef StructuredArrow.prodEquivalence :\n    StructuredArrow (S, S') (T.prod T') ≌ StructuredArrow S T × StructuredArrow S' T' where\n  functor := StructuredArrow.prodFunctor S S' T T'\n  inverse := StructuredArrow.prodInverse S S' T T'\n  unitIso := NatIso.ofComponents (fun f => Iso.refl _) (by simp)\n  counitIso := NatIso.ofComponents (fun f => Iso.refl _) (by simp)\n\n"}
{"name":"CategoryTheory.StructuredArrow.prodEquivalence_inverse","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nC' : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} C'\nD' : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} D'\nS : D\nS' : D'\nT : CategoryTheory.Functor C D\nT' : CategoryTheory.Functor C' D'\n⊢ Eq (CategoryTheory.StructuredArrow.prodEquivalence S S' T T').inverse (CategoryTheory.StructuredArrow.prodInverse S S' T T')","decl":"/-- The natural equivalence\n`StructuredArrow (S, S') (T.prod T') ≌ StructuredArrow S T × StructuredArrow S' T'`. -/\n@[simps]\ndef StructuredArrow.prodEquivalence :\n    StructuredArrow (S, S') (T.prod T') ≌ StructuredArrow S T × StructuredArrow S' T' where\n  functor := StructuredArrow.prodFunctor S S' T T'\n  inverse := StructuredArrow.prodInverse S S' T T'\n  unitIso := NatIso.ofComponents (fun f => Iso.refl _) (by simp)\n  counitIso := NatIso.ofComponents (fun f => Iso.refl _) (by simp)\n\n"}
{"name":"CategoryTheory.StructuredArrow.prodEquivalence_counitIso","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nC' : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} C'\nD' : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} D'\nS : D\nS' : D'\nT : CategoryTheory.Functor C D\nT' : CategoryTheory.Functor C' D'\n⊢ Eq (CategoryTheory.StructuredArrow.prodEquivalence S S' T T').counitIso (CategoryTheory.NatIso.ofComponents (fun f => CategoryTheory.Iso.refl (((CategoryTheory.StructuredArrow.prodInverse S S' T T').comp (CategoryTheory.StructuredArrow.prodFunctor S S' T T')).obj f)) ⋯)","decl":"/-- The natural equivalence\n`StructuredArrow (S, S') (T.prod T') ≌ StructuredArrow S T × StructuredArrow S' T'`. -/\n@[simps]\ndef StructuredArrow.prodEquivalence :\n    StructuredArrow (S, S') (T.prod T') ≌ StructuredArrow S T × StructuredArrow S' T' where\n  functor := StructuredArrow.prodFunctor S S' T T'\n  inverse := StructuredArrow.prodInverse S S' T T'\n  unitIso := NatIso.ofComponents (fun f => Iso.refl _) (by simp)\n  counitIso := NatIso.ofComponents (fun f => Iso.refl _) (by simp)\n\n"}
{"name":"CategoryTheory.CostructuredArrow.w_prod_fst_assoc","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nC' : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} C'\nD' : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} D'\nS : CategoryTheory.Functor C D\nS' : CategoryTheory.Functor C' D'\nT : D\nT' : D'\nA B : CategoryTheory.CostructuredArrow (S.prod S') { fst := T, snd := T' }\nf : Quiver.Hom A B\nZ : D\nh : Quiver.Hom ((CategoryTheory.Functor.fromPUnit { fst := T, snd := T' }).obj B.right).1 Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (S.map f.left.1) (CategoryTheory.CategoryStruct.comp B.hom.1 h)) (CategoryTheory.CategoryStruct.comp A.hom.1 h)","decl":"@[reassoc (attr := simp)]\ntheorem CostructuredArrow.w_prod_fst {A B : CostructuredArrow (S.prod S') (T, T')} (f : A ⟶ B) :\n    S.map f.left.1 ≫ B.hom.1 = A.hom.1 :=\n  congr_arg _root_.Prod.fst (CostructuredArrow.w f)\n\n"}
{"name":"CategoryTheory.CostructuredArrow.w_prod_fst","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nC' : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} C'\nD' : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} D'\nS : CategoryTheory.Functor C D\nS' : CategoryTheory.Functor C' D'\nT : D\nT' : D'\nA B : CategoryTheory.CostructuredArrow (S.prod S') { fst := T, snd := T' }\nf : Quiver.Hom A B\n⊢ Eq (CategoryTheory.CategoryStruct.comp (S.map f.left.1) B.hom.1) A.hom.1","decl":"@[reassoc (attr := simp)]\ntheorem CostructuredArrow.w_prod_fst {A B : CostructuredArrow (S.prod S') (T, T')} (f : A ⟶ B) :\n    S.map f.left.1 ≫ B.hom.1 = A.hom.1 :=\n  congr_arg _root_.Prod.fst (CostructuredArrow.w f)\n\n"}
{"name":"CategoryTheory.CostructuredArrow.w_prod_snd","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nC' : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} C'\nD' : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} D'\nS : CategoryTheory.Functor C D\nS' : CategoryTheory.Functor C' D'\nT : D\nT' : D'\nA B : CategoryTheory.CostructuredArrow (S.prod S') { fst := T, snd := T' }\nf : Quiver.Hom A B\n⊢ Eq (CategoryTheory.CategoryStruct.comp (S'.map f.left.2) B.hom.2) A.hom.2","decl":"@[reassoc (attr := simp)]\ntheorem CostructuredArrow.w_prod_snd {A B : CostructuredArrow (S.prod S') (T, T')} (f : A ⟶ B) :\n    S'.map f.left.2 ≫ B.hom.2 = A.hom.2 :=\n  congr_arg _root_.Prod.snd (CostructuredArrow.w f)\n\n"}
{"name":"CategoryTheory.CostructuredArrow.w_prod_snd_assoc","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nC' : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} C'\nD' : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} D'\nS : CategoryTheory.Functor C D\nS' : CategoryTheory.Functor C' D'\nT : D\nT' : D'\nA B : CategoryTheory.CostructuredArrow (S.prod S') { fst := T, snd := T' }\nf : Quiver.Hom A B\nZ : D'\nh : Quiver.Hom ((CategoryTheory.Functor.fromPUnit { fst := T, snd := T' }).obj B.right).2 Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (S'.map f.left.2) (CategoryTheory.CategoryStruct.comp B.hom.2 h)) (CategoryTheory.CategoryStruct.comp A.hom.2 h)","decl":"@[reassoc (attr := simp)]\ntheorem CostructuredArrow.w_prod_snd {A B : CostructuredArrow (S.prod S') (T, T')} (f : A ⟶ B) :\n    S'.map f.left.2 ≫ B.hom.2 = A.hom.2 :=\n  congr_arg _root_.Prod.snd (CostructuredArrow.w f)\n\n"}
{"name":"CategoryTheory.CostructuredArrow.prodFunctor_obj","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nC' : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} C'\nD' : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} D'\nS : CategoryTheory.Functor C D\nS' : CategoryTheory.Functor C' D'\nT : D\nT' : D'\nf : CategoryTheory.CostructuredArrow (S.prod S') { fst := T, snd := T' }\n⊢ Eq ((CategoryTheory.CostructuredArrow.prodFunctor S S' T T').obj f) { fst := CategoryTheory.CostructuredArrow.mk f.hom.1, snd := CategoryTheory.CostructuredArrow.mk f.hom.2 }","decl":"/-- Implementation; see `CostructuredArrow.prodEquivalence`. -/\n@[simps]\ndef CostructuredArrow.prodFunctor :\n    CostructuredArrow (S.prod S') (T, T') ⥤ CostructuredArrow S T × CostructuredArrow S' T' where\n  obj f := ⟨.mk f.hom.1, .mk f.hom.2⟩\n  map η := ⟨CostructuredArrow.homMk η.left.1 (by simp),\n            CostructuredArrow.homMk η.left.2 (by simp)⟩\n\n"}
{"name":"CategoryTheory.CostructuredArrow.prodFunctor_map","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nC' : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} C'\nD' : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} D'\nS : CategoryTheory.Functor C D\nS' : CategoryTheory.Functor C' D'\nT : D\nT' : D'\nX✝ Y✝ : CategoryTheory.CostructuredArrow (S.prod S') { fst := T, snd := T' }\nη : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.CostructuredArrow.prodFunctor S S' T T').map η) { fst := CategoryTheory.CostructuredArrow.homMk η.left.1 ⋯, snd := CategoryTheory.CostructuredArrow.homMk η.left.2 ⋯ }","decl":"/-- Implementation; see `CostructuredArrow.prodEquivalence`. -/\n@[simps]\ndef CostructuredArrow.prodFunctor :\n    CostructuredArrow (S.prod S') (T, T') ⥤ CostructuredArrow S T × CostructuredArrow S' T' where\n  obj f := ⟨.mk f.hom.1, .mk f.hom.2⟩\n  map η := ⟨CostructuredArrow.homMk η.left.1 (by simp),\n            CostructuredArrow.homMk η.left.2 (by simp)⟩\n\n"}
{"name":"CategoryTheory.CostructuredArrow.prodInverse_map","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nC' : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} C'\nD' : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} D'\nS : CategoryTheory.Functor C D\nS' : CategoryTheory.Functor C' D'\nT : D\nT' : D'\nX✝ Y✝ : Prod (CategoryTheory.CostructuredArrow S T) (CategoryTheory.CostructuredArrow S' T')\nη : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.CostructuredArrow.prodInverse S S' T T').map η) (CategoryTheory.CostructuredArrow.homMk { fst := η.1.left, snd := η.2.left } ⋯)","decl":"/-- Implementation; see `CostructuredArrow.prodEquivalence`. -/\n@[simps]\ndef CostructuredArrow.prodInverse :\n    CostructuredArrow S T × CostructuredArrow S' T' ⥤ CostructuredArrow (S.prod S') (T, T') where\n  obj f := .mk (Y := (f.1.left, f.2.left)) ⟨f.1.hom, f.2.hom⟩\n  map η := CostructuredArrow.homMk ⟨η.1.left, η.2.left⟩ (by simp)\n\n"}
{"name":"CategoryTheory.CostructuredArrow.prodInverse_obj","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nC' : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} C'\nD' : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} D'\nS : CategoryTheory.Functor C D\nS' : CategoryTheory.Functor C' D'\nT : D\nT' : D'\nf : Prod (CategoryTheory.CostructuredArrow S T) (CategoryTheory.CostructuredArrow S' T')\n⊢ Eq ((CategoryTheory.CostructuredArrow.prodInverse S S' T T').obj f) (CategoryTheory.CostructuredArrow.mk { fst := f.1.hom, snd := f.2.hom })","decl":"/-- Implementation; see `CostructuredArrow.prodEquivalence`. -/\n@[simps]\ndef CostructuredArrow.prodInverse :\n    CostructuredArrow S T × CostructuredArrow S' T' ⥤ CostructuredArrow (S.prod S') (T, T') where\n  obj f := .mk (Y := (f.1.left, f.2.left)) ⟨f.1.hom, f.2.hom⟩\n  map η := CostructuredArrow.homMk ⟨η.1.left, η.2.left⟩ (by simp)\n\n"}
{"name":"CategoryTheory.CostructuredArrow.prodEquivalence_unitIso","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nC' : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} C'\nD' : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} D'\nS : CategoryTheory.Functor C D\nS' : CategoryTheory.Functor C' D'\nT : D\nT' : D'\n⊢ Eq (CategoryTheory.CostructuredArrow.prodEquivalence S S' T T').unitIso (CategoryTheory.NatIso.ofComponents (fun f => CategoryTheory.Iso.refl ((CategoryTheory.Functor.id (CategoryTheory.CostructuredArrow (S.prod S') { fst := T, snd := T' })).obj f)) ⋯)","decl":"/-- The natural equivalence\n`CostructuredArrow (S.prod S') (T, T') ≌ CostructuredArrow S T × CostructuredArrow S' T'`. -/\n@[simps]\ndef CostructuredArrow.prodEquivalence :\n    CostructuredArrow (S.prod S') (T, T') ≌ CostructuredArrow S T × CostructuredArrow S' T' where\n  functor := CostructuredArrow.prodFunctor S S' T T'\n  inverse := CostructuredArrow.prodInverse S S' T T'\n  unitIso := NatIso.ofComponents (fun f => Iso.refl _) (by simp)\n  counitIso := NatIso.ofComponents (fun f => Iso.refl _) (by simp)\n\n"}
{"name":"CategoryTheory.CostructuredArrow.prodEquivalence_functor","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nC' : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} C'\nD' : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} D'\nS : CategoryTheory.Functor C D\nS' : CategoryTheory.Functor C' D'\nT : D\nT' : D'\n⊢ Eq (CategoryTheory.CostructuredArrow.prodEquivalence S S' T T').functor (CategoryTheory.CostructuredArrow.prodFunctor S S' T T')","decl":"/-- The natural equivalence\n`CostructuredArrow (S.prod S') (T, T') ≌ CostructuredArrow S T × CostructuredArrow S' T'`. -/\n@[simps]\ndef CostructuredArrow.prodEquivalence :\n    CostructuredArrow (S.prod S') (T, T') ≌ CostructuredArrow S T × CostructuredArrow S' T' where\n  functor := CostructuredArrow.prodFunctor S S' T T'\n  inverse := CostructuredArrow.prodInverse S S' T T'\n  unitIso := NatIso.ofComponents (fun f => Iso.refl _) (by simp)\n  counitIso := NatIso.ofComponents (fun f => Iso.refl _) (by simp)\n\n"}
{"name":"CategoryTheory.CostructuredArrow.prodEquivalence_counitIso","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nC' : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} C'\nD' : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} D'\nS : CategoryTheory.Functor C D\nS' : CategoryTheory.Functor C' D'\nT : D\nT' : D'\n⊢ Eq (CategoryTheory.CostructuredArrow.prodEquivalence S S' T T').counitIso (CategoryTheory.NatIso.ofComponents (fun f => CategoryTheory.Iso.refl (((CategoryTheory.CostructuredArrow.prodInverse S S' T T').comp (CategoryTheory.CostructuredArrow.prodFunctor S S' T T')).obj f)) ⋯)","decl":"/-- The natural equivalence\n`CostructuredArrow (S.prod S') (T, T') ≌ CostructuredArrow S T × CostructuredArrow S' T'`. -/\n@[simps]\ndef CostructuredArrow.prodEquivalence :\n    CostructuredArrow (S.prod S') (T, T') ≌ CostructuredArrow S T × CostructuredArrow S' T' where\n  functor := CostructuredArrow.prodFunctor S S' T T'\n  inverse := CostructuredArrow.prodInverse S S' T T'\n  unitIso := NatIso.ofComponents (fun f => Iso.refl _) (by simp)\n  counitIso := NatIso.ofComponents (fun f => Iso.refl _) (by simp)\n\n"}
{"name":"CategoryTheory.CostructuredArrow.prodEquivalence_inverse","module":"Mathlib.CategoryTheory.Comma.StructuredArrow.Basic","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nC' : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} C'\nD' : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} D'\nS : CategoryTheory.Functor C D\nS' : CategoryTheory.Functor C' D'\nT : D\nT' : D'\n⊢ Eq (CategoryTheory.CostructuredArrow.prodEquivalence S S' T T').inverse (CategoryTheory.CostructuredArrow.prodInverse S S' T T')","decl":"/-- The natural equivalence\n`CostructuredArrow (S.prod S') (T, T') ≌ CostructuredArrow S T × CostructuredArrow S' T'`. -/\n@[simps]\ndef CostructuredArrow.prodEquivalence :\n    CostructuredArrow (S.prod S') (T, T') ≌ CostructuredArrow S T × CostructuredArrow S' T' where\n  functor := CostructuredArrow.prodFunctor S S' T T'\n  inverse := CostructuredArrow.prodInverse S S' T T'\n  unitIso := NatIso.ofComponents (fun f => Iso.refl _) (by simp)\n  counitIso := NatIso.ofComponents (fun f => Iso.refl _) (by simp)\n\n"}
