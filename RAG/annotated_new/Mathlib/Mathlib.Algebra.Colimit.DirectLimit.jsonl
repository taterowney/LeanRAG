{"name":"DirectLimit.zero_def","module":"Mathlib.Algebra.Colimit.DirectLimit","initialProofState":"ι : Type u_2\ninst✝⁶ : Preorder ι\nG : ι → Type u_3\nT : ⦃i j : ι⦄ → LE.le i j → Type u_4\nf : (x x_1 : ι) → (h : LE.le x x_1) → T h\ninst✝⁵ : (i j : ι) → (h : LE.le i j) → FunLike (T h) (G i) (G j)\ninst✝⁴ : DirectedSystem G fun x1 x2 x3 => ⇑(f x1 x2 x3)\ninst✝³ : IsDirected ι fun x1 x2 => LE.le x1 x2\ninst✝² : Nonempty ι\ninst✝¹ : (i : ι) → Zero (G i)\ninst✝ : ∀ (i j : ι) (h : LE.le i j), ZeroHomClass (T h) (G i) (G j)\ni : ι\n⊢ Eq 0 (Quotient.mk (DirectLimit.setoid f) ⟨i, 0⟩)","decl":"@[to_additive] theorem one_def (i) : (1 : DirectLimit G f) = ⟦⟨i, 1⟩⟧ :=\n  map₀_def _ _ (fun _ _ _ ↦ map_one _) _\n\n"}
{"name":"DirectLimit.one_def","module":"Mathlib.Algebra.Colimit.DirectLimit","initialProofState":"ι : Type u_2\ninst✝⁶ : Preorder ι\nG : ι → Type u_3\nT : ⦃i j : ι⦄ → LE.le i j → Type u_4\nf : (x x_1 : ι) → (h : LE.le x x_1) → T h\ninst✝⁵ : (i j : ι) → (h : LE.le i j) → FunLike (T h) (G i) (G j)\ninst✝⁴ : DirectedSystem G fun x1 x2 x3 => ⇑(f x1 x2 x3)\ninst✝³ : IsDirected ι fun x1 x2 => LE.le x1 x2\ninst✝² : Nonempty ι\ninst✝¹ : (i : ι) → One (G i)\ninst✝ : ∀ (i j : ι) (h : LE.le i j), OneHomClass (T h) (G i) (G j)\ni : ι\n⊢ Eq 1 (Quotient.mk (DirectLimit.setoid f) ⟨i, 1⟩)","decl":"@[to_additive] theorem one_def (i) : (1 : DirectLimit G f) = ⟦⟨i, 1⟩⟧ :=\n  map₀_def _ _ (fun _ _ _ ↦ map_one _) _\n\n"}
{"name":"DirectLimit.exists_eq_one","module":"Mathlib.Algebra.Colimit.DirectLimit","initialProofState":"ι : Type u_2\ninst✝⁶ : Preorder ι\nG : ι → Type u_3\nT : ⦃i j : ι⦄ → LE.le i j → Type u_4\nf : (x x_1 : ι) → (h : LE.le x x_1) → T h\ninst✝⁵ : (i j : ι) → (h : LE.le i j) → FunLike (T h) (G i) (G j)\ninst✝⁴ : DirectedSystem G fun x1 x2 x3 => ⇑(f x1 x2 x3)\ninst✝³ : IsDirected ι fun x1 x2 => LE.le x1 x2\ninst✝² : Nonempty ι\ninst✝¹ : (i : ι) → One (G i)\ninst✝ : ∀ (i j : ι) (h : LE.le i j), OneHomClass (T h) (G i) (G j)\nx : Sigma fun i => G i\n⊢ Iff (Eq (Quotient.mk (DirectLimit.setoid f) x) 1) (Exists fun i => Exists fun h => Eq ((f x.fst i h) x.snd) 1)","decl":"@[to_additive] theorem exists_eq_one (x) :\n    ⟦x⟧ = (1 : DirectLimit G f) ↔ ∃ i h, f x.1 i h x.2 = 1 := by\n  rw [one_def x.1, Quotient.eq]\n  exact ⟨fun ⟨i, h, _, eq⟩ ↦ ⟨i, h, eq.trans (map_one _)⟩,\n    fun ⟨i, h, eq⟩ ↦ ⟨i, h, h, eq.trans (map_one _).symm⟩⟩\n\n"}
{"name":"DirectLimit.exists_eq_zero","module":"Mathlib.Algebra.Colimit.DirectLimit","initialProofState":"ι : Type u_2\ninst✝⁶ : Preorder ι\nG : ι → Type u_3\nT : ⦃i j : ι⦄ → LE.le i j → Type u_4\nf : (x x_1 : ι) → (h : LE.le x x_1) → T h\ninst✝⁵ : (i j : ι) → (h : LE.le i j) → FunLike (T h) (G i) (G j)\ninst✝⁴ : DirectedSystem G fun x1 x2 x3 => ⇑(f x1 x2 x3)\ninst✝³ : IsDirected ι fun x1 x2 => LE.le x1 x2\ninst✝² : Nonempty ι\ninst✝¹ : (i : ι) → Zero (G i)\ninst✝ : ∀ (i j : ι) (h : LE.le i j), ZeroHomClass (T h) (G i) (G j)\nx : Sigma fun i => G i\n⊢ Iff (Eq (Quotient.mk (DirectLimit.setoid f) x) 0) (Exists fun i => Exists fun h => Eq ((f x.fst i h) x.snd) 0)","decl":"@[to_additive] theorem exists_eq_one (x) :\n    ⟦x⟧ = (1 : DirectLimit G f) ↔ ∃ i h, f x.1 i h x.2 = 1 := by\n  rw [one_def x.1, Quotient.eq]\n  exact ⟨fun ⟨i, h, _, eq⟩ ↦ ⟨i, h, eq.trans (map_one _)⟩,\n    fun ⟨i, h, eq⟩ ↦ ⟨i, h, h, eq.trans (map_one _).symm⟩⟩\n\n"}
{"name":"DirectLimit.add_def","module":"Mathlib.Algebra.Colimit.DirectLimit","initialProofState":"ι : Type u_2\ninst✝⁵ : Preorder ι\nG : ι → Type u_3\nT : ⦃i j : ι⦄ → LE.le i j → Type u_4\nf : (x x_1 : ι) → (h : LE.le x x_1) → T h\ninst✝⁴ : (i j : ι) → (h : LE.le i j) → FunLike (T h) (G i) (G j)\ninst✝³ : DirectedSystem G fun x1 x2 x3 => ⇑(f x1 x2 x3)\ninst✝² : IsDirected ι fun x1 x2 => LE.le x1 x2\ninst✝¹ : (i : ι) → Add (G i)\ninst✝ : ∀ (i j : ι) (h : LE.le i j), AddHomClass (T h) (G i) (G j)\ni : ι\nx y : G i\n⊢ Eq (HAdd.hAdd (Quotient.mk (DirectLimit.setoid f) ⟨i, x⟩) (Quotient.mk (DirectLimit.setoid f) ⟨i, y⟩)) (Quotient.mk (DirectLimit.setoid f) ⟨i, HAdd.hAdd x y⟩)","decl":"@[to_additive] theorem mul_def (i) (x y : G i) :\n    ⟦⟨i, x⟩⟧ * ⟦⟨i, y⟩⟧ = (⟦⟨i, x * y⟩⟧ : DirectLimit G f) :=\n  map₂_def ..\n\n"}
{"name":"DirectLimit.mul_def","module":"Mathlib.Algebra.Colimit.DirectLimit","initialProofState":"ι : Type u_2\ninst✝⁵ : Preorder ι\nG : ι → Type u_3\nT : ⦃i j : ι⦄ → LE.le i j → Type u_4\nf : (x x_1 : ι) → (h : LE.le x x_1) → T h\ninst✝⁴ : (i j : ι) → (h : LE.le i j) → FunLike (T h) (G i) (G j)\ninst✝³ : DirectedSystem G fun x1 x2 x3 => ⇑(f x1 x2 x3)\ninst✝² : IsDirected ι fun x1 x2 => LE.le x1 x2\ninst✝¹ : (i : ι) → Mul (G i)\ninst✝ : ∀ (i j : ι) (h : LE.le i j), MulHomClass (T h) (G i) (G j)\ni : ι\nx y : G i\n⊢ Eq (HMul.hMul (Quotient.mk (DirectLimit.setoid f) ⟨i, x⟩) (Quotient.mk (DirectLimit.setoid f) ⟨i, y⟩)) (Quotient.mk (DirectLimit.setoid f) ⟨i, HMul.hMul x y⟩)","decl":"@[to_additive] theorem mul_def (i) (x y : G i) :\n    ⟦⟨i, x⟩⟧ * ⟦⟨i, y⟩⟧ = (⟦⟨i, x * y⟩⟧ : DirectLimit G f) :=\n  map₂_def ..\n\n"}
{"name":"DirectLimit.vadd_def","module":"Mathlib.Algebra.Colimit.DirectLimit","initialProofState":"R : Type u_1\nι : Type u_2\ninst✝⁵ : Preorder ι\nG : ι → Type u_3\nT : ⦃i j : ι⦄ → LE.le i j → Type u_4\nf : (x x_1 : ι) → (h : LE.le x x_1) → T h\ninst✝⁴ : (i j : ι) → (h : LE.le i j) → FunLike (T h) (G i) (G j)\ninst✝³ : DirectedSystem G fun x1 x2 x3 => ⇑(f x1 x2 x3)\ninst✝² : IsDirected ι fun x1 x2 => LE.le x1 x2\ninst✝¹ : (i : ι) → VAdd R (G i)\ninst✝ : ∀ (i j : ι) (h : LE.le i j), AddActionHomClass (T h) R (G i) (G j)\ni : ι\nx : G i\nr : R\n⊢ Eq (HVAdd.hVAdd r (Quotient.mk (DirectLimit.setoid f) ⟨i, x⟩)) (Quotient.mk (DirectLimit.setoid f) ⟨i, HVAdd.hVAdd r x⟩)","decl":"@[to_additive] theorem smul_def (i x) (r : R) : r • ⟦⟨i, x⟩⟧ = (⟦⟨i, r • x⟩⟧ : DirectLimit G f) :=\n  rfl\n\n"}
{"name":"DirectLimit.smul_def","module":"Mathlib.Algebra.Colimit.DirectLimit","initialProofState":"R : Type u_1\nι : Type u_2\ninst✝⁵ : Preorder ι\nG : ι → Type u_3\nT : ⦃i j : ι⦄ → LE.le i j → Type u_4\nf : (x x_1 : ι) → (h : LE.le x x_1) → T h\ninst✝⁴ : (i j : ι) → (h : LE.le i j) → FunLike (T h) (G i) (G j)\ninst✝³ : DirectedSystem G fun x1 x2 x3 => ⇑(f x1 x2 x3)\ninst✝² : IsDirected ι fun x1 x2 => LE.le x1 x2\ninst✝¹ : (i : ι) → SMul R (G i)\ninst✝ : ∀ (i j : ι) (h : LE.le i j), MulActionHomClass (T h) R (G i) (G j)\ni : ι\nx : G i\nr : R\n⊢ Eq (HSMul.hSMul r (Quotient.mk (DirectLimit.setoid f) ⟨i, x⟩)) (Quotient.mk (DirectLimit.setoid f) ⟨i, HSMul.hSMul r x⟩)","decl":"@[to_additive] theorem smul_def (i x) (r : R) : r • ⟦⟨i, x⟩⟧ = (⟦⟨i, r • x⟩⟧ : DirectLimit G f) :=\n  rfl\n\n"}
{"name":"DirectLimit.npow_def","module":"Mathlib.Algebra.Colimit.DirectLimit","initialProofState":"ι : Type u_2\ninst✝⁶ : Preorder ι\nG : ι → Type u_3\nT : ⦃i j : ι⦄ → LE.le i j → Type u_4\nf : (x x_1 : ι) → (h : LE.le x x_1) → T h\ninst✝⁵ : (i j : ι) → (h : LE.le i j) → FunLike (T h) (G i) (G j)\ninst✝⁴ : DirectedSystem G fun x1 x2 x3 => ⇑(f x1 x2 x3)\ninst✝³ : IsDirected ι fun x1 x2 => LE.le x1 x2\ninst✝² : Nonempty ι\ninst✝¹ : (i : ι) → Monoid (G i)\ninst✝ : ∀ (i j : ι) (h : LE.le i j), MonoidHomClass (T h) (G i) (G j)\ni : ι\nx : G i\nn : Nat\n⊢ Eq (HPow.hPow (Quotient.mk (DirectLimit.setoid f) ⟨i, x⟩) n) (Quotient.mk (DirectLimit.setoid f) ⟨i, HPow.hPow x n⟩)","decl":"@[to_additive] theorem npow_def (i x) (n : ℕ) : ⟦⟨i, x⟩⟧ ^ n = (⟦⟨i, x ^ n⟩⟧ : DirectLimit G f) :=\n  rfl\n\n"}
{"name":"DirectLimit.nsmul_def","module":"Mathlib.Algebra.Colimit.DirectLimit","initialProofState":"ι : Type u_2\ninst✝⁶ : Preorder ι\nG : ι → Type u_3\nT : ⦃i j : ι⦄ → LE.le i j → Type u_4\nf : (x x_1 : ι) → (h : LE.le x x_1) → T h\ninst✝⁵ : (i j : ι) → (h : LE.le i j) → FunLike (T h) (G i) (G j)\ninst✝⁴ : DirectedSystem G fun x1 x2 x3 => ⇑(f x1 x2 x3)\ninst✝³ : IsDirected ι fun x1 x2 => LE.le x1 x2\ninst✝² : Nonempty ι\ninst✝¹ : (i : ι) → AddMonoid (G i)\ninst✝ : ∀ (i j : ι) (h : LE.le i j), AddMonoidHomClass (T h) (G i) (G j)\ni : ι\nx : G i\nn : Nat\n⊢ Eq (HSMul.hSMul n (Quotient.mk (DirectLimit.setoid f) ⟨i, x⟩)) (Quotient.mk (DirectLimit.setoid f) ⟨i, HSMul.hSMul n x⟩)","decl":"@[to_additive] theorem npow_def (i x) (n : ℕ) : ⟦⟨i, x⟩⟧ ^ n = (⟦⟨i, x ^ n⟩⟧ : DirectLimit G f) :=\n  rfl\n\n"}
{"name":"DirectLimit.inv_def","module":"Mathlib.Algebra.Colimit.DirectLimit","initialProofState":"ι : Type u_2\ninst✝⁶ : Preorder ι\nG : ι → Type u_3\nT : ⦃i j : ι⦄ → LE.le i j → Type u_4\nf : (x x_1 : ι) → (h : LE.le x x_1) → T h\ninst✝⁵ : (i j : ι) → (h : LE.le i j) → FunLike (T h) (G i) (G j)\ninst✝⁴ : DirectedSystem G fun x1 x2 x3 => ⇑(f x1 x2 x3)\ninst✝³ : IsDirected ι fun x1 x2 => LE.le x1 x2\ninst✝² : Nonempty ι\ninst✝¹ : (i : ι) → Group (G i)\ninst✝ : ∀ (i j : ι) (h : LE.le i j), MonoidHomClass (T h) (G i) (G j)\ni : ι\nx : G i\n⊢ Eq (Inv.inv (Quotient.mk (DirectLimit.setoid f) ⟨i, x⟩)) (Quotient.mk (DirectLimit.setoid f) ⟨i, Inv.inv x⟩)","decl":"@[to_additive] theorem inv_def (i x) : (⟦⟨i, x⟩⟧)⁻¹ = (⟦⟨i, x⁻¹⟩⟧ : DirectLimit G f) := rfl\n\n"}
{"name":"DirectLimit.neg_def","module":"Mathlib.Algebra.Colimit.DirectLimit","initialProofState":"ι : Type u_2\ninst✝⁶ : Preorder ι\nG : ι → Type u_3\nT : ⦃i j : ι⦄ → LE.le i j → Type u_4\nf : (x x_1 : ι) → (h : LE.le x x_1) → T h\ninst✝⁵ : (i j : ι) → (h : LE.le i j) → FunLike (T h) (G i) (G j)\ninst✝⁴ : DirectedSystem G fun x1 x2 x3 => ⇑(f x1 x2 x3)\ninst✝³ : IsDirected ι fun x1 x2 => LE.le x1 x2\ninst✝² : Nonempty ι\ninst✝¹ : (i : ι) → AddGroup (G i)\ninst✝ : ∀ (i j : ι) (h : LE.le i j), AddMonoidHomClass (T h) (G i) (G j)\ni : ι\nx : G i\n⊢ Eq (Neg.neg (Quotient.mk (DirectLimit.setoid f) ⟨i, x⟩)) (Quotient.mk (DirectLimit.setoid f) ⟨i, Neg.neg x⟩)","decl":"@[to_additive] theorem inv_def (i x) : (⟦⟨i, x⟩⟧)⁻¹ = (⟦⟨i, x⁻¹⟩⟧ : DirectLimit G f) := rfl\n\n"}
{"name":"DirectLimit.div_def","module":"Mathlib.Algebra.Colimit.DirectLimit","initialProofState":"ι : Type u_2\ninst✝⁶ : Preorder ι\nG : ι → Type u_3\nT : ⦃i j : ι⦄ → LE.le i j → Type u_4\nf : (x x_1 : ι) → (h : LE.le x x_1) → T h\ninst✝⁵ : (i j : ι) → (h : LE.le i j) → FunLike (T h) (G i) (G j)\ninst✝⁴ : DirectedSystem G fun x1 x2 x3 => ⇑(f x1 x2 x3)\ninst✝³ : IsDirected ι fun x1 x2 => LE.le x1 x2\ninst✝² : Nonempty ι\ninst✝¹ : (i : ι) → Group (G i)\ninst✝ : ∀ (i j : ι) (h : LE.le i j), MonoidHomClass (T h) (G i) (G j)\ni : ι\nx y : G i\n⊢ Eq (HDiv.hDiv (Quotient.mk (DirectLimit.setoid f) ⟨i, x⟩) (Quotient.mk (DirectLimit.setoid f) ⟨i, y⟩)) (Quotient.mk (DirectLimit.setoid f) ⟨i, HDiv.hDiv x y⟩)","decl":"@[to_additive] theorem div_def (i x y) : ⟦⟨i, x⟩⟧ / ⟦⟨i, y⟩⟧ = (⟦⟨i, x / y⟩⟧ : DirectLimit G f) :=\n  map₂_def ..\n\n"}
{"name":"DirectLimit.sub_def","module":"Mathlib.Algebra.Colimit.DirectLimit","initialProofState":"ι : Type u_2\ninst✝⁶ : Preorder ι\nG : ι → Type u_3\nT : ⦃i j : ι⦄ → LE.le i j → Type u_4\nf : (x x_1 : ι) → (h : LE.le x x_1) → T h\ninst✝⁵ : (i j : ι) → (h : LE.le i j) → FunLike (T h) (G i) (G j)\ninst✝⁴ : DirectedSystem G fun x1 x2 x3 => ⇑(f x1 x2 x3)\ninst✝³ : IsDirected ι fun x1 x2 => LE.le x1 x2\ninst✝² : Nonempty ι\ninst✝¹ : (i : ι) → AddGroup (G i)\ninst✝ : ∀ (i j : ι) (h : LE.le i j), AddMonoidHomClass (T h) (G i) (G j)\ni : ι\nx y : G i\n⊢ Eq (HSub.hSub (Quotient.mk (DirectLimit.setoid f) ⟨i, x⟩) (Quotient.mk (DirectLimit.setoid f) ⟨i, y⟩)) (Quotient.mk (DirectLimit.setoid f) ⟨i, HSub.hSub x y⟩)","decl":"@[to_additive] theorem div_def (i x y) : ⟦⟨i, x⟩⟧ / ⟦⟨i, y⟩⟧ = (⟦⟨i, x / y⟩⟧ : DirectLimit G f) :=\n  map₂_def ..\n\n"}
{"name":"DirectLimit.zpow_def","module":"Mathlib.Algebra.Colimit.DirectLimit","initialProofState":"ι : Type u_2\ninst✝⁶ : Preorder ι\nG : ι → Type u_3\nT : ⦃i j : ι⦄ → LE.le i j → Type u_4\nf : (x x_1 : ι) → (h : LE.le x x_1) → T h\ninst✝⁵ : (i j : ι) → (h : LE.le i j) → FunLike (T h) (G i) (G j)\ninst✝⁴ : DirectedSystem G fun x1 x2 x3 => ⇑(f x1 x2 x3)\ninst✝³ : IsDirected ι fun x1 x2 => LE.le x1 x2\ninst✝² : Nonempty ι\ninst✝¹ : (i : ι) → Group (G i)\ninst✝ : ∀ (i j : ι) (h : LE.le i j), MonoidHomClass (T h) (G i) (G j)\ni : ι\nx : G i\nn : Int\n⊢ Eq (HPow.hPow (Quotient.mk (DirectLimit.setoid f) ⟨i, x⟩) n) (Quotient.mk (DirectLimit.setoid f) ⟨i, HPow.hPow x n⟩)","decl":"@[to_additive] theorem zpow_def (i x) (n : ℤ) : ⟦⟨i, x⟩⟧ ^ n = (⟦⟨i, x ^ n⟩⟧ : DirectLimit G f) :=\n  rfl\n\n"}
{"name":"DirectLimit.zsmul_def","module":"Mathlib.Algebra.Colimit.DirectLimit","initialProofState":"ι : Type u_2\ninst✝⁶ : Preorder ι\nG : ι → Type u_3\nT : ⦃i j : ι⦄ → LE.le i j → Type u_4\nf : (x x_1 : ι) → (h : LE.le x x_1) → T h\ninst✝⁵ : (i j : ι) → (h : LE.le i j) → FunLike (T h) (G i) (G j)\ninst✝⁴ : DirectedSystem G fun x1 x2 x3 => ⇑(f x1 x2 x3)\ninst✝³ : IsDirected ι fun x1 x2 => LE.le x1 x2\ninst✝² : Nonempty ι\ninst✝¹ : (i : ι) → AddGroup (G i)\ninst✝ : ∀ (i j : ι) (h : LE.le i j), AddMonoidHomClass (T h) (G i) (G j)\ni : ι\nx : G i\nn : Int\n⊢ Eq (HSMul.hSMul n (Quotient.mk (DirectLimit.setoid f) ⟨i, x⟩)) (Quotient.mk (DirectLimit.setoid f) ⟨i, HSMul.hSMul n x⟩)","decl":"@[to_additive] theorem zpow_def (i x) (n : ℤ) : ⟦⟨i, x⟩⟧ ^ n = (⟦⟨i, x ^ n⟩⟧ : DirectLimit G f) :=\n  rfl\n\n"}
{"name":"DirectLimit.instNontrivial","module":"Mathlib.Algebra.Colimit.DirectLimit","initialProofState":"ι : Type u_2\ninst✝⁶ : Preorder ι\nG : ι → Type u_3\nT : ⦃i j : ι⦄ → LE.le i j → Type u_4\nf : (x x_1 : ι) → (h : LE.le x x_1) → T h\ninst✝⁵ : (i j : ι) → (h : LE.le i j) → FunLike (T h) (G i) (G j)\ninst✝⁴ : DirectedSystem G fun x1 x2 x3 => ⇑(f x1 x2 x3)\ninst✝³ : IsDirected ι fun x1 x2 => LE.le x1 x2\ninst✝² : Nonempty ι\ninst✝¹ : (i : ι) → MulZeroOneClass (G i)\ninst✝ : ∀ (i : ι), Nontrivial (G i)\n⊢ Nontrivial (DirectLimit G f)","decl":"instance [∀ i, Nontrivial (G i)] : Nontrivial (DirectLimit G f) where\n  exists_pair_ne := ⟨0, 1, fun h ↦ have ⟨i, _, _, eq⟩ := Quotient.eq.mp h; by simp at eq⟩\n\n"}
{"name":"DirectLimit.inv₀_def","module":"Mathlib.Algebra.Colimit.DirectLimit","initialProofState":"ι : Type u_2\ninst✝⁶ : Preorder ι\nG : ι → Type u_3\nT : ⦃i j : ι⦄ → LE.le i j → Type u_4\nf : (x x_1 : ι) → (h : LE.le x x_1) → T h\ninst✝⁵ : (i j : ι) → (h : LE.le i j) → FunLike (T h) (G i) (G j)\ninst✝⁴ : DirectedSystem G fun x1 x2 x3 => ⇑(f x1 x2 x3)\ninst✝³ : IsDirected ι fun x1 x2 => LE.le x1 x2\ninst✝² : Nonempty ι\ninst✝¹ : (i : ι) → GroupWithZero (G i)\ninst✝ : ∀ (i j : ι) (h : LE.le i j), MonoidWithZeroHomClass (T h) (G i) (G j)\ni : ι\nx : G i\n⊢ Eq (Inv.inv (Quotient.mk (DirectLimit.setoid f) ⟨i, x⟩)) (Quotient.mk (DirectLimit.setoid f) ⟨i, Inv.inv x⟩)","decl":"theorem inv₀_def (i x) : (⟦⟨i, x⟩⟧)⁻¹ = (⟦⟨i, x⁻¹⟩⟧ : DirectLimit G f) := rfl\n\n"}
{"name":"DirectLimit.div₀_def","module":"Mathlib.Algebra.Colimit.DirectLimit","initialProofState":"ι : Type u_2\ninst✝⁶ : Preorder ι\nG : ι → Type u_3\nT : ⦃i j : ι⦄ → LE.le i j → Type u_4\nf : (x x_1 : ι) → (h : LE.le x x_1) → T h\ninst✝⁵ : (i j : ι) → (h : LE.le i j) → FunLike (T h) (G i) (G j)\ninst✝⁴ : DirectedSystem G fun x1 x2 x3 => ⇑(f x1 x2 x3)\ninst✝³ : IsDirected ι fun x1 x2 => LE.le x1 x2\ninst✝² : Nonempty ι\ninst✝¹ : (i : ι) → GroupWithZero (G i)\ninst✝ : ∀ (i j : ι) (h : LE.le i j), MonoidWithZeroHomClass (T h) (G i) (G j)\ni : ι\nx y : G i\n⊢ Eq (HDiv.hDiv (Quotient.mk (DirectLimit.setoid f) ⟨i, x⟩) (Quotient.mk (DirectLimit.setoid f) ⟨i, y⟩)) (Quotient.mk (DirectLimit.setoid f) ⟨i, HDiv.hDiv x y⟩)","decl":"theorem div₀_def (i x y) : ⟦⟨i, x⟩⟧ / ⟦⟨i, y⟩⟧ = (⟦⟨i, x / y⟩⟧ : DirectLimit G f) :=\n  map₂_def ..\n\n"}
{"name":"DirectLimit.zpow₀_def","module":"Mathlib.Algebra.Colimit.DirectLimit","initialProofState":"ι : Type u_2\ninst✝⁶ : Preorder ι\nG : ι → Type u_3\nT : ⦃i j : ι⦄ → LE.le i j → Type u_4\nf : (x x_1 : ι) → (h : LE.le x x_1) → T h\ninst✝⁵ : (i j : ι) → (h : LE.le i j) → FunLike (T h) (G i) (G j)\ninst✝⁴ : DirectedSystem G fun x1 x2 x3 => ⇑(f x1 x2 x3)\ninst✝³ : IsDirected ι fun x1 x2 => LE.le x1 x2\ninst✝² : Nonempty ι\ninst✝¹ : (i : ι) → GroupWithZero (G i)\ninst✝ : ∀ (i j : ι) (h : LE.le i j), MonoidWithZeroHomClass (T h) (G i) (G j)\ni : ι\nx : G i\nn : Int\n⊢ Eq (HPow.hPow (Quotient.mk (DirectLimit.setoid f) ⟨i, x⟩) n) (Quotient.mk (DirectLimit.setoid f) ⟨i, HPow.hPow x n⟩)","decl":"theorem zpow₀_def (i x) (n : ℤ) : ⟦⟨i, x⟩⟧ ^ n = (⟦⟨i, x ^ n⟩⟧ : DirectLimit G f) := rfl\n\n"}
{"name":"DirectLimit.natCast_def","module":"Mathlib.Algebra.Colimit.DirectLimit","initialProofState":"ι : Type u_2\ninst✝⁷ : Preorder ι\nG : ι → Type u_3\nT : ⦃i j : ι⦄ → LE.le i j → Type u_4\nf : (x x_1 : ι) → (h : LE.le x x_1) → T h\ninst✝⁶ : (i j : ι) → (h : LE.le i j) → FunLike (T h) (G i) (G j)\ninst✝⁵ : DirectedSystem G fun x1 x2 x3 => ⇑(f x1 x2 x3)\ninst✝⁴ : IsDirected ι fun x1 x2 => LE.le x1 x2\ninst✝³ : Nonempty ι\ninst✝² : (i : ι) → AddMonoidWithOne (G i)\ninst✝¹ : ∀ (i j : ι) (h : LE.le i j), AddMonoidHomClass (T h) (G i) (G j)\ninst✝ : ∀ (i j : ι) (h : LE.le i j), OneHomClass (T h) (G i) (G j)\nn : Nat\ni : ι\n⊢ Eq (↑n) (Quotient.mk (DirectLimit.setoid f) ⟨i, ↑n⟩)","decl":"theorem natCast_def [∀ i j h, OneHomClass (T h) (G i) (G j)] (n : ℕ) (i) :\n    (n : DirectLimit G f) = ⟦⟨i, n⟩⟧ :=\n  map₀_def _ _ (fun _ _ _ ↦ map_natCast' _ (map_one _) _) _\n\n"}
{"name":"DirectLimit.intCast_def","module":"Mathlib.Algebra.Colimit.DirectLimit","initialProofState":"ι : Type u_2\ninst✝⁷ : Preorder ι\nG : ι → Type u_3\nT : ⦃i j : ι⦄ → LE.le i j → Type u_4\nf : (x x_1 : ι) → (h : LE.le x x_1) → T h\ninst✝⁶ : (i j : ι) → (h : LE.le i j) → FunLike (T h) (G i) (G j)\ninst✝⁵ : DirectedSystem G fun x1 x2 x3 => ⇑(f x1 x2 x3)\ninst✝⁴ : IsDirected ι fun x1 x2 => LE.le x1 x2\ninst✝³ : Nonempty ι\ninst✝² : (i : ι) → AddGroupWithOne (G i)\ninst✝¹ : ∀ (i j : ι) (h : LE.le i j), AddMonoidHomClass (T h) (G i) (G j)\ninst✝ : ∀ (i j : ι) (h : LE.le i j), OneHomClass (T h) (G i) (G j)\nn : Int\ni : ι\n⊢ Eq (↑n) (Quotient.mk (DirectLimit.setoid f) ⟨i, ↑n⟩)","decl":"theorem intCast_def [∀ i j h, OneHomClass (T h) (G i) (G j)] (n : ℤ) (i) :\n    (n : DirectLimit G f) = ⟦⟨i, n⟩⟧ :=\n  map₀_def _ _ (fun _ _ _ ↦ map_intCast' _ (map_one _) _) _\n\n"}
{"name":"DirectLimit.nnratCast_def","module":"Mathlib.Algebra.Colimit.DirectLimit","initialProofState":"ι : Type u_2\ninst✝⁶ : Preorder ι\nG : ι → Type u_3\nT : ⦃i j : ι⦄ → LE.le i j → Type u_4\nf : (x x_1 : ι) → (h : LE.le x x_1) → T h\ninst✝⁵ : (i j : ι) → (h : LE.le i j) → FunLike (T h) (G i) (G j)\ninst✝⁴ : DirectedSystem G fun x1 x2 x3 => ⇑(f x1 x2 x3)\ninst✝³ : IsDirected ι fun x1 x2 => LE.le x1 x2\ninst✝² : Nonempty ι\ninst✝¹ : (i : ι) → DivisionSemiring (G i)\ninst✝ : ∀ (i j : ι) (h : LE.le i j), RingHomClass (T h) (G i) (G j)\nq : NNRat\ni : ι\n⊢ Eq (↑q) (Quotient.mk (DirectLimit.setoid f) ⟨i, ↑q⟩)","decl":"theorem nnratCast_def (q : ℚ≥0) (i) : (q : DirectLimit G f) = ⟦⟨i, q⟩⟧ :=\n  map₀_def _ _ (fun _ _ _ ↦ map_nnratCast _ _) _\n\n"}
{"name":"DirectLimit.ratCast_def","module":"Mathlib.Algebra.Colimit.DirectLimit","initialProofState":"ι : Type u_2\ninst✝⁶ : Preorder ι\nG : ι → Type u_3\nT : ⦃i j : ι⦄ → LE.le i j → Type u_4\nf : (x x_1 : ι) → (h : LE.le x x_1) → T h\ninst✝⁵ : (i j : ι) → (h : LE.le i j) → FunLike (T h) (G i) (G j)\ninst✝⁴ : DirectedSystem G fun x1 x2 x3 => ⇑(f x1 x2 x3)\ninst✝³ : IsDirected ι fun x1 x2 => LE.le x1 x2\ninst✝² : Nonempty ι\ninst✝¹ : (i : ι) → DivisionRing (G i)\ninst✝ : ∀ (i j : ι) (h : LE.le i j), RingHomClass (T h) (G i) (G j)\nq : Rat\ni : ι\n⊢ Eq (↑q) (Quotient.mk (DirectLimit.setoid f) ⟨i, ↑q⟩)","decl":"theorem ratCast_def (q : ℚ) (i) : (q : DirectLimit G f) = ⟦⟨i, q⟩⟧ :=\n  map₀_def _ _ (fun _ _ _ ↦ map_ratCast _ _) _\n\n"}
{"name":"DirectLimit.Module.of_f","module":"Mathlib.Algebra.Colimit.DirectLimit","initialProofState":"R : Type u_1\nι : Type u_2\ninst✝⁸ : Preorder ι\nG : ι → Type u_3\nT : ⦃i j : ι⦄ → LE.le i j → Type u_4\nf : (x x_1 : ι) → (h : LE.le x x_1) → T h\ninst✝⁷ : (i j : ι) → (h : LE.le i j) → FunLike (T h) (G i) (G j)\ninst✝⁶ : DirectedSystem G fun x1 x2 x3 => ⇑(f x1 x2 x3)\ninst✝⁵ : IsDirected ι fun x1 x2 => LE.le x1 x2\ninst✝⁴ : Semiring R\ninst✝³ : (i : ι) → AddCommMonoid (G i)\ninst✝² : (i : ι) → Module R (G i)\ninst✝¹ : ∀ (i j : ι) (h : LE.le i j), LinearMapClass (T h) R (G i) (G j)\ninst✝ : Nonempty ι\ni j : ι\nhij : LE.le i j\nx : G i\n⊢ Eq ((DirectLimit.Module.of R ι G f j) ((f i j hij) x)) ((DirectLimit.Module.of R ι G f i) x)","decl":"@[simp]\ntheorem of_f {i j hij x} : of R ι G f j (f i j hij x) = of R ι G f i x := .symm <| eq_of_le ..\n\n"}
{"name":"DirectLimit.Module.lift_of","module":"Mathlib.Algebra.Colimit.DirectLimit","initialProofState":"R : Type u_1\nι : Type u_2\ninst✝¹⁰ : Preorder ι\nG : ι → Type u_3\nT : ⦃i j : ι⦄ → LE.le i j → Type u_4\nf : (x x_1 : ι) → (h : LE.le x x_1) → T h\ninst✝⁹ : (i j : ι) → (h : LE.le i j) → FunLike (T h) (G i) (G j)\ninst✝⁸ : DirectedSystem G fun x1 x2 x3 => ⇑(f x1 x2 x3)\ninst✝⁷ : IsDirected ι fun x1 x2 => LE.le x1 x2\ninst✝⁶ : Semiring R\ninst✝⁵ : (i : ι) → AddCommMonoid (G i)\ninst✝⁴ : (i : ι) → Module R (G i)\ninst✝³ : ∀ (i j : ι) (h : LE.le i j), LinearMapClass (T h) R (G i) (G j)\ninst✝² : Nonempty ι\nP : Type u_5\ninst✝¹ : AddCommMonoid P\ninst✝ : Module R P\ng : (i : ι) → LinearMap (RingHom.id R) (G i) P\nHg : ∀ (i j : ι) (hij : LE.le i j) (x : G i), Eq ((g j) ((f i j hij) x)) ((g i) x)\ni : ι\nx : G i\n⊢ Eq ((DirectLimit.Module.lift R ι G f g Hg) ((DirectLimit.Module.of R ι G f i) x)) ((g i) x)","decl":"theorem lift_of {i} (x) : lift R ι G f g Hg (of R ι G f i x) = g i x := rfl\n\n"}
{"name":"DirectLimit.Ring.of_f","module":"Mathlib.Algebra.Colimit.DirectLimit","initialProofState":"ι : Type u_2\ninst✝⁶ : Preorder ι\nG : ι → Type u_3\nT : ⦃i j : ι⦄ → LE.le i j → Type u_4\nf : (x x_1 : ι) → (h : LE.le x x_1) → T h\ninst✝⁵ : (i j : ι) → (h : LE.le i j) → FunLike (T h) (G i) (G j)\ninst✝⁴ : DirectedSystem G fun x1 x2 x3 => ⇑(f x1 x2 x3)\ninst✝³ : IsDirected ι fun x1 x2 => LE.le x1 x2\ninst✝² : (i : ι) → NonAssocSemiring (G i)\ninst✝¹ : ∀ (i j : ι) (h : LE.le i j), RingHomClass (T h) (G i) (G j)\ninst✝ : Nonempty ι\ni j : ι\nhij : LE.le i j\nx : G i\n⊢ Eq ((DirectLimit.Ring.of G f j) ((f i j hij) x)) ((DirectLimit.Ring.of G f i) x)","decl":"@[simp] theorem of_f {i j} (hij) (x) : of G f j (f i j hij x) = of G f i x := .symm <| eq_of_le ..\n\n"}
{"name":"DirectLimit.Ring.lift_of","module":"Mathlib.Algebra.Colimit.DirectLimit","initialProofState":"ι : Type u_2\ninst✝⁷ : Preorder ι\nG : ι → Type u_3\nT : ⦃i j : ι⦄ → LE.le i j → Type u_4\nf : (x x_1 : ι) → (h : LE.le x x_1) → T h\ninst✝⁶ : (i j : ι) → (h : LE.le i j) → FunLike (T h) (G i) (G j)\ninst✝⁵ : DirectedSystem G fun x1 x2 x3 => ⇑(f x1 x2 x3)\ninst✝⁴ : IsDirected ι fun x1 x2 => LE.le x1 x2\ninst✝³ : (i : ι) → NonAssocSemiring (G i)\ninst✝² : ∀ (i j : ι) (h : LE.le i j), RingHomClass (T h) (G i) (G j)\ninst✝¹ : Nonempty ι\nP : Type u_5\ninst✝ : NonAssocSemiring P\ng : (i : ι) → RingHom (G i) P\nHg : ∀ (i j : ι) (hij : LE.le i j) (x : G i), Eq ((g j) ((f i j hij) x)) ((g i) x)\ni : ι\nx : G i\n⊢ Eq ((DirectLimit.Ring.lift G f P g Hg) ((DirectLimit.Ring.of G f i) x)) ((g i) x)","decl":"@[simp] theorem lift_of (i x) : lift G f P g Hg (of G f i x) = g i x := rfl\n\n"}
