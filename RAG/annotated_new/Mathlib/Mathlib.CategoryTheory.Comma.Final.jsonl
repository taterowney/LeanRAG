{"name":"CategoryTheory.Comma.final_fst","module":"Mathlib.CategoryTheory.Comma.Final","initialProofState":"A : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\ninstâœ : R.Final\nâŠ¢ (CategoryTheory.Comma.fst L R).Final","decl":"instance final_fst [R.Final] : (fst L R).Final := by\n  let sA : A â‰Œ AsSmall.{max uâ‚ uâ‚‚ uâ‚ƒ vâ‚ vâ‚‚ vâ‚ƒ} A := AsSmall.equiv\n  let sB : B â‰Œ AsSmall.{max uâ‚ uâ‚‚ uâ‚ƒ vâ‚ vâ‚‚ vâ‚ƒ} B := AsSmall.equiv\n  let sT : T â‰Œ AsSmall.{max uâ‚ uâ‚‚ uâ‚ƒ vâ‚ vâ‚‚ vâ‚ƒ} T := AsSmall.equiv\n  let L' := sA.inverse â‹™ L â‹™ sT.functor\n  let R' := sB.inverse â‹™ R â‹™ sT.functor\n  let fC : Comma L R â¥¤ Comma L' R' :=\n    map (Fâ‚ := sA.functor) (F := sT.functor) (Fâ‚‚ := sB.functor)\n      (isoWhiskerRight sA.unitIso (L â‹™ sT.functor)).hom\n      (isoWhiskerRight sB.unitIso (R â‹™ sT.functor)).hom\n  have : Final (fst L' R') := final_fst_small _ _\n  apply final_of_natIso (F := (fC â‹™ fst L' R' â‹™ sA.inverse))\n  exact (Functor.associator _ _ _).symm.trans (Iso.compInverseIso (mapFst _ _))\n\n"}
{"name":"CategoryTheory.Comma.initial_snd","module":"Mathlib.CategoryTheory.Comma.Final","initialProofState":"A : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\ninstâœ : L.Initial\nâŠ¢ (CategoryTheory.Comma.snd L R).Initial","decl":"instance initial_snd [L.Initial] : (snd L R).Initial := by\n  have : ((opFunctor L R).leftOp â‹™ fst R.op L.op).Final :=\n    final_equivalence_comp (opEquiv L R).functor.leftOp (fst R.op L.op)\n  have : (snd L R).op.Final := final_of_natIso (opFunctorCompFst _ _)\n  apply initial_of_final_op\n\n"}
{"name":"CategoryTheory.Comma.isConnected_comma_of_final","module":"Mathlib.CategoryTheory.Comma.Final","initialProofState":"A : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœÂ² : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\ninstâœÂ¹ : CategoryTheory.IsConnected A\ninstâœ : R.Final\nâŠ¢ CategoryTheory.IsConnected (CategoryTheory.Comma L R)","decl":"/-- `Comma L R` with `L : A â¥¤ T` and `R : B â¥¤ T` is connected if `R` is final and `A` is\nconnected. -/\ninstance isConnected_comma_of_final [IsConnected A] [R.Final] : IsConnected (Comma L R) := by\n  rwa [isConnected_iff_of_final (fst L R)]\n\n"}
{"name":"CategoryTheory.Comma.isConnected_comma_of_initial","module":"Mathlib.CategoryTheory.Comma.Final","initialProofState":"A : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœÂ² : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\ninstâœÂ¹ : CategoryTheory.IsConnected B\ninstâœ : L.Initial\nâŠ¢ CategoryTheory.IsConnected (CategoryTheory.Comma L R)","decl":"/-- `Comma L R` with `L : A â¥¤ T` and `R : B â¥¤ T` is connected if `L` is initial and `B` is\nconnected. -/\ninstance isConnected_comma_of_initial [IsConnected B] [L.Initial] : IsConnected (Comma L R) := by\n  rwa [isConnected_iff_of_initial (snd L R)]\n\n"}
{"name":"CategoryTheory.Comma.map_final","module":"Mathlib.CategoryTheory.Comma.Final","initialProofState":"A : Type uâ‚\ninstâœÂ¹â° : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœâ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœâ¸ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nA' : Type uâ‚„\ninstâœâ· : CategoryTheory.Category.{vâ‚„, uâ‚„} A'\nB' : Type uâ‚…\ninstâœâ¶ : CategoryTheory.Category.{vâ‚…, uâ‚…} B'\nT' : Type uâ‚†\ninstâœâµ : CategoryTheory.Category.{vâ‚†, uâ‚†} T'\nL' : CategoryTheory.Functor A' T'\nR' : CategoryTheory.Functor B' T'\nF : CategoryTheory.Functor A A'\nG : CategoryTheory.Functor B B'\nH : CategoryTheory.Functor T T'\niL : CategoryTheory.Iso (F.comp L') (L.comp H)\niR : CategoryTheory.Iso (G.comp R') (R.comp H)\ninstâœâ´ : CategoryTheory.IsFiltered B\ninstâœÂ³ : R.Final\ninstâœÂ² : R'.Final\ninstâœÂ¹ : F.Final\ninstâœ : G.Final\nâŠ¢ (CategoryTheory.Comma.map iL.hom iR.inv).Final","decl":"/-- Let the following diagram commute up to isomorphism:\n\n      L       R\n  A  ---â†’ T  â†--- B\n  |       |       |\n  | F     | H     | G\n  â†“       â†“       â†“\n  A' ---â†’ T' â†--- B'\n      L'      R'\n\nLet `F`, `G`, `R` and `R'` be final and `B` be filtered. Then, the induced functor between the comma\ncategories of the first and second row of the diagram is final. -/\nlemma map_final {A : Type uâ‚} [Category.{vâ‚} A] {B : Type uâ‚‚} [Category.{vâ‚‚} B] {T : Type uâ‚ƒ}\n    [Category.{vâ‚ƒ} T] {L : A â¥¤ T} {R : B â¥¤ T} {A' : Type uâ‚„} [Category.{vâ‚„} A'] {B' : Type uâ‚…}\n    [Category.{vâ‚…} B'] {T' : Type uâ‚†} [Category.{vâ‚†} T'] {L' : A' â¥¤ T'} {R' : B' â¥¤ T'} {F : A â¥¤ A'}\n    {G : B â¥¤ B'} {H : T â¥¤ T'} (iL : F â‹™ L' â‰… L â‹™ H) (iR : G â‹™ R' â‰… R â‹™ H) [IsFiltered B]\n    [R.Final] [R'.Final] [F.Final] [G.Final] :\n    (Comma.map iL.hom iR.inv).Final := âŸ¨fun âŸ¨iâ‚‚, jâ‚‚, uâ‚‚âŸ© => by\n  haveI := final_of_natIso iR\n  rw [isConnected_iff_of_equivalence (StructuredArrow.commaMapEquivalence iL.hom iR.inv _)]\n  have : StructuredArrow.mapâ‚‚ uâ‚‚ iR.hom â‰… StructuredArrow.post jâ‚‚ G R' â‹™\n      StructuredArrow.mapâ‚‚ (G := ğŸ­ _) (F := ğŸ­ _) (R' := R â‹™ H) uâ‚‚ iR.hom â‹™\n      StructuredArrow.pre _ R H :=\n    eqToIso (by\n      congr\n      Â· simp\n      Â· ext; simp) â‰ªâ‰«\n    (StructuredArrow.mapâ‚‚CompMapâ‚‚Iso _ _ _ _).symm â‰ªâ‰«\n    isoWhiskerLeft _ ((StructuredArrow.mapâ‚‚CompMapâ‚‚Iso _ _ _ _).symm â‰ªâ‰«\n      isoWhiskerLeft _ (StructuredArrow.preIsoMapâ‚‚ _ _ _).symm) â‰ªâ‰«\n    isoWhiskerRight (StructuredArrow.postIsoMapâ‚‚ jâ‚‚ G R').symm _\n  haveI := final_of_natIso this.symm\n  rw [IsIso.Iso.inv_inv]\n  infer_instanceâŸ©\n\n"}
{"name":"CategoryTheory.Comma.isFiltered_of_final","module":"Mathlib.CategoryTheory.Comma.Final","initialProofState":"A : Type uâ‚\ninstâœâµ : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœÂ³ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\ninstâœÂ² : CategoryTheory.IsFiltered A\ninstâœÂ¹ : CategoryTheory.IsFiltered B\ninstâœ : R.Final\nâŠ¢ CategoryTheory.IsFiltered (CategoryTheory.Comma L R)","decl":"attribute [local instance] map_final in\n/-- Let `A` and `B` be filtered categories, `R : B â¥¤ T` be final and `L : A â¥¤ T`. Then, the\ncomma category `Comma L R` is filtered. -/\ninstance isFiltered_of_final [IsFiltered A] [IsFiltered B] [R.Final] : IsFiltered (Comma L R) := by\n  haveI (a : A) : IsFiltered (Comma (fromPUnit (L.obj a)) R) :=\n    R.final_iff_isFiltered_structuredArrow.mp inferInstance (L.obj a)\n  have (a : A) : (fromPUnit (Over.mk (ğŸ™ a))).Final := final_const_of_isTerminal Over.mkIdTerminal\n  let Î· (a : A) : fromPUnit (Over.mk (ğŸ™ a)) â‹™ Over.forget a â‹™ L â‰… fromPUnit (L.obj a) :=\n    NatIso.ofComponents (fun _ => Iso.refl _)\n  have (a : A) := IsFiltered.of_final (map (L := fromPUnit (L.obj a)) (F := ğŸ­ T) (Î· a).hom\n    ((Iso.refl (ğŸ­ B â‹™ R)).inv))\n  have : RepresentablyCoflat (fst L R) :=\n    âŸ¨fun a => IsFiltered.of_equivalence (CostructuredArrow.ofCommaFstEquivalence L R a).symmâŸ©\n  apply isFiltered_of_representablyCoflat (fst L R)\n\n"}
{"name":"CategoryTheory.Comma.isCofiltered_of_initial","module":"Mathlib.CategoryTheory.Comma.Final","initialProofState":"A : Type uâ‚\ninstâœâµ : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœÂ³ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\ninstâœÂ² : CategoryTheory.IsCofiltered A\ninstâœÂ¹ : CategoryTheory.IsCofiltered B\ninstâœ : L.Initial\nâŠ¢ CategoryTheory.IsCofiltered (CategoryTheory.Comma L R)","decl":"attribute [local instance] isFiltered_of_final in\n/-- Let `A` and `B` be cofiltered categories, `L : A â¥¤ T` be initial and `R : B â¥¤ T`. Then, the\ncomma category `Comma L R` is cofiltered. -/\nlemma isCofiltered_of_initial [IsCofiltered A] [IsCofiltered B] [L.Initial] :\n    IsCofiltered (Comma L R) :=\n IsCofiltered.of_equivalence (Comma.opEquiv _ _).symm\n\n"}
{"name":"CategoryTheory.Comma.final_snd","module":"Mathlib.CategoryTheory.Comma.Final","initialProofState":"A : Type uâ‚\ninstâœâµ : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœÂ³ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\ninstâœÂ² : CategoryTheory.IsFiltered A\ninstâœÂ¹ : CategoryTheory.IsFiltered B\ninstâœ : R.Final\nâŠ¢ (CategoryTheory.Comma.snd L R).Final","decl":"attribute [local instance] final_of_isFiltered_of_pUnit in\n/-- Let `A` and `B` be filtered categories, `R : B â¥¤ T` be final and `R : A â¥¤ T`. Then, the\nprojection `snd L R : Comma L R â¥¤ B` is final. -/\ninstance final_snd [IsFiltered A] [IsFiltered B] [R.Final] : (snd L R).Final := by\n  let iL : star.{1} A â‹™ ğŸ­ _ â‰… L â‹™ star _ := Iso.refl _\n  let iR : ğŸ­ B â‹™ star.{1} B â‰… R â‹™ star _ := Iso.refl _\n  have := map_final iL iR\n  let s := (equivProd (ğŸ­ _) (star B)).trans <| prod.leftUnitorEquivalence B\n  let iS : map iL.hom iR.inv â‹™ s.functor â‰… snd L R :=\n    NatIso.ofComponents (fun _ => Iso.refl _) (fun f => by simp [iL, iR, s])\n  apply final_of_natIso iS\n\n"}
{"name":"CategoryTheory.Comma.initial_fst","module":"Mathlib.CategoryTheory.Comma.Final","initialProofState":"A : Type uâ‚\ninstâœâµ : CategoryTheory.Category.{vâ‚, uâ‚} A\nB : Type uâ‚‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} B\nT : Type uâ‚ƒ\ninstâœÂ³ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\ninstâœÂ² : CategoryTheory.IsCofiltered A\ninstâœÂ¹ : CategoryTheory.IsCofiltered B\ninstâœ : L.Initial\nâŠ¢ (CategoryTheory.Comma.fst L R).Initial","decl":"/-- Let `A` and `B` be cofiltered categories, `L : A â¥¤ T` be initial and `R : B â¥¤ T`. Then, the\nprojection `fst L R : Comma L R â¥¤ A` is initial. -/\ninstance initial_fst [IsCofiltered A] [IsCofiltered B] [L.Initial] : (fst L R).Initial := by\n  have : ((opFunctor L R).leftOp â‹™ snd R.op L.op).Final :=\n    final_equivalence_comp (opEquiv L R).functor.leftOp _\n  have : (fst L R).op.Final := final_of_natIso <| opFunctorCompSnd _ _\n  apply initial_of_final_op\n\n"}
