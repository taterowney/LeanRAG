{"name":"HomologicalComplex.truncGE'.hasHomology_sc'_of_not_mem_boundary","module":"Mathlib.Algebra.Homology.Embedding.TruncGEHomology","initialProofState":"Œπ : Type u_1\nŒπ' : Type u_2\nc : ComplexShape Œπ\nc' : ComplexShape Œπ'\nC : Type u_3\ninst‚úù¬≥ : CategoryTheory.Category.{u_4, u_3} C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\nK : HomologicalComplex C c'\ne : c.Embedding c'\ninst‚úù¬π : e.IsTruncGE\ninst‚úù : ‚àÄ (i' : Œπ'), K.HasHomology i'\ni j k : Œπ\nhi : Eq (c.prev j) i\nhk : Eq (c.next j) k\nhj : Not (e.BoundaryGE j)\n‚ä¢ ((K.truncGE' e).sc' i j k).HasHomology","decl":"include hi hk in\nlemma hasHomology_sc'_of_not_mem_boundary (hj : ¬¨ e.BoundaryGE j) :\n    ((K.truncGE' e).sc' i j k).HasHomology := by\n  have : (K.restriction e).HasHomology j :=\n    restriction.hasHomology K e i j k hi hk rfl rfl rfl\n      (e.prev_f_of_not_boundaryGE hi hj) (e.next_f hk)\n  have := ShortComplex.hasHomology_of_iso ((K.restriction e).isoSc' i j k hi hk)\n  let œÜ := (shortComplexFunctor' C c i j k).map (K.restrictionToTruncGE' e)\n  have : Epi œÜ.œÑ‚ÇÅ := by dsimp [œÜ]; infer_instance\n  have : IsIso œÜ.œÑ‚ÇÇ := K.isIso_restrictionToTruncGE' e j hj\n  have : IsIso œÜ.œÑ‚ÇÉ := K.isIso_restrictionToTruncGE' e k (e.not_boundaryGE_next' hj hk)\n  exact ShortComplex.hasHomology_of_epi_of_isIso_of_mono œÜ\n\n"}
{"name":"HomologicalComplex.truncGE'.hasHomology_of_not_mem_boundary","module":"Mathlib.Algebra.Homology.Embedding.TruncGEHomology","initialProofState":"Œπ : Type u_1\nŒπ' : Type u_2\nc : ComplexShape Œπ\nc' : ComplexShape Œπ'\nC : Type u_3\ninst‚úù¬≥ : CategoryTheory.Category.{u_4, u_3} C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\nK : HomologicalComplex C c'\ne : c.Embedding c'\ninst‚úù¬π : e.IsTruncGE\ninst‚úù : ‚àÄ (i' : Œπ'), K.HasHomology i'\nj : Œπ\nhj : Not (e.BoundaryGE j)\n‚ä¢ (K.truncGE' e).HasHomology j","decl":"lemma hasHomology_of_not_mem_boundary (hj : ¬¨ e.BoundaryGE j) :\n    (K.truncGE' e).HasHomology j :=\n  hasHomology_sc'_of_not_mem_boundary K e _ j _ rfl rfl hj\n\n"}
{"name":"HomologicalComplex.truncGE'.quasiIsoAt_restrictionToTruncGE'","module":"Mathlib.Algebra.Homology.Embedding.TruncGEHomology","initialProofState":"Œπ : Type u_1\nŒπ' : Type u_2\nc : ComplexShape Œπ\nc' : ComplexShape Œπ'\nC : Type u_3\ninst‚úù‚Åµ : CategoryTheory.Category.{u_4, u_3} C\ninst‚úù‚Å¥ : CategoryTheory.Limits.HasZeroMorphisms C\nK : HomologicalComplex C c'\ne : c.Embedding c'\ninst‚úù¬≥ : e.IsTruncGE\ninst‚úù¬≤ : ‚àÄ (i' : Œπ'), K.HasHomology i'\nj : Œπ\nhj : Not (e.BoundaryGE j)\ninst‚úù¬π : (K.restriction e).HasHomology j\ninst‚úù : (K.truncGE' e).HasHomology j\n‚ä¢ QuasiIsoAt (K.restrictionToTruncGE' e) j","decl":"/-- `K.restrictionToTruncGE' e` is a quasi-isomorphism in degrees that are not at the boundary. -/\nlemma quasiIsoAt_restrictionToTruncGE' (hj : ¬¨ e.BoundaryGE j)\n    [(K.restriction e).HasHomology j] [(K.truncGE' e).HasHomology j] :\n    QuasiIsoAt (K.restrictionToTruncGE' e) j := by\n  rw [quasiIsoAt_iff]\n  let œÜ := (shortComplexFunctor C c j).map (K.restrictionToTruncGE' e)\n  have : Epi œÜ.œÑ‚ÇÅ := by dsimp [œÜ]; infer_instance\n  have : IsIso œÜ.œÑ‚ÇÇ := K.isIso_restrictionToTruncGE' e j hj\n  have : IsIso œÜ.œÑ‚ÇÉ := K.isIso_restrictionToTruncGE' e _ (e.not_boundaryGE_next' hj rfl)\n  exact ShortComplex.quasiIso_of_epi_of_isIso_of_mono œÜ\n\n"}
{"name":"HomologicalComplex.truncGE'.homologyŒπ_truncGE'XIsoOpcycles_inv_d","module":"Mathlib.Algebra.Homology.Embedding.TruncGEHomology","initialProofState":"Œπ : Type u_1\nŒπ' : Type u_2\nc : ComplexShape Œπ\nc' : ComplexShape Œπ'\nC : Type u_3\ninst‚úù¬≥ : CategoryTheory.Category.{u_4, u_3} C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\nK : HomologicalComplex C c'\ne : c.Embedding c'\ninst‚úù¬π : e.IsTruncGE\ninst‚úù : ‚àÄ (i' : Œπ'), K.HasHomology i'\nj k : Œπ\nj' : Œπ'\nhj' : Eq (e.f j) j'\nhj : e.BoundaryGE j\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.comp (K.homologyŒπ j') (K.truncGE'XIsoOpcycles e hj' hj).inv) ((K.truncGE' e).d j k)) 0","decl":"lemma homologyŒπ_truncGE'XIsoOpcycles_inv_d :\n    (K.homologyŒπ j' ‚â´ (K.truncGE'XIsoOpcycles e hj' hj).inv) ‚â´ (K.truncGE' e).d j k = 0 := by\n  by_cases hjk : c.Rel j k\n  ¬∑ rw [K.truncGE'_d_eq_fromOpcycles e hjk hj' rfl hj, assoc, Iso.inv_hom_id_assoc,\n    homologyŒπ_comp_fromOpcycles_assoc, zero_comp]\n  ¬∑ rw [shape _ _ _ hjk, comp_zero]\n\n"}
{"name":"HomologicalComplex.truncGE'.homologyData_right_g'","module":"Mathlib.Algebra.Homology.Embedding.TruncGEHomology","initialProofState":"Œπ : Type u_1\nŒπ' : Type u_2\nc : ComplexShape Œπ\nc' : ComplexShape Œπ'\nC : Type u_3\ninst‚úù¬≥ : CategoryTheory.Category.{u_4, u_3} C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\nK : HomologicalComplex C c'\ne : c.Embedding c'\ninst‚úù¬π : e.IsTruncGE\ninst‚úù : ‚àÄ (i' : Œπ'), K.HasHomology i'\ni j k : Œπ\nhk : Eq (c.next j) k\nj' : Œπ'\nhj' : Eq (e.f j) j'\nhj : e.BoundaryGE j\n‚ä¢ Eq (HomologicalComplex.truncGE'.homologyData K e i j k hk hj' hj).right.g' ((K.truncGE' e).d j k)","decl":"/-- Computation of the `right.g'` field of `truncGE'.homologyData K e i j k hk hj' hj`. -/\n@[simp]\nlemma homologyData_right_g' :\n    (homologyData K e i j k hk hj' hj).right.g' = (K.truncGE' e).d j k := rfl\n\n"}
{"name":"HomologicalComplex.truncGE'.truncGE'_hasHomology","module":"Mathlib.Algebra.Homology.Embedding.TruncGEHomology","initialProofState":"Œπ : Type u_1\nŒπ' : Type u_2\nc : ComplexShape Œπ\nc' : ComplexShape Œπ'\nC : Type u_3\ninst‚úù¬≥ : CategoryTheory.Category.{u_4, u_3} C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\nK : HomologicalComplex C c'\ne : c.Embedding c'\ninst‚úù¬π : e.IsTruncGE\ninst‚úù : ‚àÄ (i' : Œπ'), K.HasHomology i'\ni : Œπ\n‚ä¢ (K.truncGE' e).HasHomology i","decl":"instance truncGE'_hasHomology (i : Œπ) : (K.truncGE' e).HasHomology i := by\n  by_cases hi : e.BoundaryGE i\n  ¬∑ exact ShortComplex.HasHomology.mk' (homologyData K e _ _ _ rfl rfl hi)\n  ¬∑ exact hasHomology_of_not_mem_boundary K e i hi\n\n"}
{"name":"HomologicalComplex.truncGE.instHasHomology","module":"Mathlib.Algebra.Homology.Embedding.TruncGEHomology","initialProofState":"Œπ : Type u_1\nŒπ' : Type u_2\nc : ComplexShape Œπ\nc' : ComplexShape Œπ'\nC : Type u_3\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_4, u_3} C\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroMorphisms C\nK : HomologicalComplex C c'\ne : c.Embedding c'\ninst‚úù¬≤ : e.IsTruncGE\ninst‚úù¬π : ‚àÄ (i' : Œπ'), K.HasHomology i'\ninst‚úù : CategoryTheory.Limits.HasZeroObject C\ni' : Œπ'\n‚ä¢ (K.truncGE e).HasHomology i'","decl":"instance (i' : Œπ') : (K.truncGE e).HasHomology i' := by\n  dsimp [truncGE]\n  infer_instance\n\n"}
{"name":"HomologicalComplex.truncGE.rightHomologyMapData_œÜQ","module":"Mathlib.Algebra.Homology.Embedding.TruncGEHomology","initialProofState":"Œπ : Type u_1\nŒπ' : Type u_2\nc : ComplexShape Œπ\nc' : ComplexShape Œπ'\nC : Type u_3\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_4, u_3} C\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroMorphisms C\nK : HomologicalComplex C c'\ne : c.Embedding c'\ninst‚úù¬≤ : e.IsTruncGE\ninst‚úù¬π : ‚àÄ (i' : Œπ'), K.HasHomology i'\ninst‚úù : CategoryTheory.Limits.HasZeroObject C\ni j k : Œπ\nj' : Œπ'\nhj' : Eq (e.f j) j'\nhi : Eq (c.prev j) i\nhk : Eq (c.next j) k\nhj : e.BoundaryGE j\n‚ä¢ Eq (HomologicalComplex.truncGE.rightHomologyMapData K e hj' hi hk hj).œÜQ (K.truncGE'XIsoOpcycles e hj' hj).inv","decl":"/-- The right homology data which allows to show that `K.œÄTruncGE e`\ninduces an isomorphism in homology in degrees `j'` such that `e.f j = j'` for some `j`. -/\n@[simps]\nnoncomputable def rightHomologyMapData {i j k : Œπ} {j' : Œπ'} (hj' : e.f j = j')\n    (hi : c.prev j = i) (hk : c.next j = k) (hj : e.BoundaryGE j) :\n    ShortComplex.RightHomologyMapData ((shortComplexFunctor C c' j').map (K.œÄTruncGE e))\n    (ShortComplex.RightHomologyData.canonical (K.sc j'))\n    (extend.rightHomologyData (K.truncGE' e) e hj' hi rfl hk rfl\n      (truncGE'.homologyData K e i j k hk hj' hj).right) where\n  œÜQ := (K.truncGE'XIsoOpcycles e hj' hj).inv\n  œÜH := ùüô _\n  commp := by\n    change K.pOpcycles j' ‚â´ _ = _\n    simp [truncGE'.homologyData, œÄTruncGE, e.liftExtend_f _ _ hj',\n      K.restrictionToTruncGE'_f_eq_iso_hom_pOpcycles_iso_inv e hj' hj]\n  commg' := by\n    have hk' : e.f k = c'.next j' := by rw [‚Üê hj', e.next_f hk]\n    dsimp\n    rw [extend.rightHomologyData_g' _ _ _ _ _ _ _ _ hk', œÄTruncGE,\n        e.liftExtend_f _ _ hk', truncGE'.homologyData_right_g']\n    by_cases hjk : c.Rel j k\n    ¬∑ simp [K.truncGE'_d_eq_fromOpcycles e hjk hj' hk' hj,\n        K.restrictionToTruncGE'_f_eq_iso_hom_iso_inv e hk' (e.not_boundaryGE_next hjk)]\n      rfl\n    ¬∑ obtain rfl : k = j := by rw [‚Üê c.next_eq_self j  (by simpa only [hk] using hjk), hk]\n      rw [shape _ _ _ hjk, zero_comp, comp_zero,\n        K.restrictionToTruncGE'_f_eq_iso_hom_pOpcycles_iso_inv e hk' hj]\n      simp only [restriction_X, restrictionXIso, eqToIso.inv, eqToIso.hom, assoc,\n        eqToHom_trans_assoc, eqToHom_refl, id_comp]\n      change 0 = K.fromOpcycles _ _ ‚â´ _\n      rw [‚Üê cancel_epi (K.pOpcycles _), comp_zero, p_fromOpcycles_assoc,\n        d_pOpcycles_assoc, zero_comp]\n\n"}
{"name":"HomologicalComplex.truncGE.rightHomologyMapData_œÜH","module":"Mathlib.Algebra.Homology.Embedding.TruncGEHomology","initialProofState":"Œπ : Type u_1\nŒπ' : Type u_2\nc : ComplexShape Œπ\nc' : ComplexShape Œπ'\nC : Type u_3\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_4, u_3} C\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroMorphisms C\nK : HomologicalComplex C c'\ne : c.Embedding c'\ninst‚úù¬≤ : e.IsTruncGE\ninst‚úù¬π : ‚àÄ (i' : Œπ'), K.HasHomology i'\ninst‚úù : CategoryTheory.Limits.HasZeroObject C\ni j k : Œπ\nj' : Œπ'\nhj' : Eq (e.f j) j'\nhi : Eq (c.prev j) i\nhk : Eq (c.next j) k\nhj : e.BoundaryGE j\n‚ä¢ Eq (HomologicalComplex.truncGE.rightHomologyMapData K e hj' hi hk hj).œÜH (CategoryTheory.CategoryStruct.id (CategoryTheory.ShortComplex.RightHomologyData.canonical (K.sc j')).H)","decl":"/-- The right homology data which allows to show that `K.œÄTruncGE e`\ninduces an isomorphism in homology in degrees `j'` such that `e.f j = j'` for some `j`. -/\n@[simps]\nnoncomputable def rightHomologyMapData {i j k : Œπ} {j' : Œπ'} (hj' : e.f j = j')\n    (hi : c.prev j = i) (hk : c.next j = k) (hj : e.BoundaryGE j) :\n    ShortComplex.RightHomologyMapData ((shortComplexFunctor C c' j').map (K.œÄTruncGE e))\n    (ShortComplex.RightHomologyData.canonical (K.sc j'))\n    (extend.rightHomologyData (K.truncGE' e) e hj' hi rfl hk rfl\n      (truncGE'.homologyData K e i j k hk hj' hj).right) where\n  œÜQ := (K.truncGE'XIsoOpcycles e hj' hj).inv\n  œÜH := ùüô _\n  commp := by\n    change K.pOpcycles j' ‚â´ _ = _\n    simp [truncGE'.homologyData, œÄTruncGE, e.liftExtend_f _ _ hj',\n      K.restrictionToTruncGE'_f_eq_iso_hom_pOpcycles_iso_inv e hj' hj]\n  commg' := by\n    have hk' : e.f k = c'.next j' := by rw [‚Üê hj', e.next_f hk]\n    dsimp\n    rw [extend.rightHomologyData_g' _ _ _ _ _ _ _ _ hk', œÄTruncGE,\n        e.liftExtend_f _ _ hk', truncGE'.homologyData_right_g']\n    by_cases hjk : c.Rel j k\n    ¬∑ simp [K.truncGE'_d_eq_fromOpcycles e hjk hj' hk' hj,\n        K.restrictionToTruncGE'_f_eq_iso_hom_iso_inv e hk' (e.not_boundaryGE_next hjk)]\n      rfl\n    ¬∑ obtain rfl : k = j := by rw [‚Üê c.next_eq_self j  (by simpa only [hk] using hjk), hk]\n      rw [shape _ _ _ hjk, zero_comp, comp_zero,\n        K.restrictionToTruncGE'_f_eq_iso_hom_pOpcycles_iso_inv e hk' hj]\n      simp only [restriction_X, restrictionXIso, eqToIso.inv, eqToIso.hom, assoc,\n        eqToHom_trans_assoc, eqToHom_refl, id_comp]\n      change 0 = K.fromOpcycles _ _ ‚â´ _\n      rw [‚Üê cancel_epi (K.pOpcycles _), comp_zero, p_fromOpcycles_assoc,\n        d_pOpcycles_assoc, zero_comp]\n\n"}
{"name":"HomologicalComplex.quasiIsoAt_œÄTruncGE","module":"Mathlib.Algebra.Homology.Embedding.TruncGEHomology","initialProofState":"Œπ : Type u_1\nŒπ' : Type u_2\nc : ComplexShape Œπ\nc' : ComplexShape Œπ'\nC : Type u_3\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_4, u_3} C\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroMorphisms C\nK : HomologicalComplex C c'\ne : c.Embedding c'\ninst‚úù¬≤ : e.IsTruncGE\ninst‚úù¬π : ‚àÄ (i' : Œπ'), K.HasHomology i'\ninst‚úù : CategoryTheory.Limits.HasZeroObject C\nj : Œπ\nj' : Œπ'\nhj' : Eq (e.f j) j'\n‚ä¢ QuasiIsoAt (K.œÄTruncGE e) j'","decl":"lemma quasiIsoAt_œÄTruncGE {j : Œπ} {j' : Œπ'} (hj' : e.f j = j') :\n    QuasiIsoAt (K.œÄTruncGE e) j' := by\n  rw [quasiIsoAt_iff]\n  by_cases hj : e.BoundaryGE j\n  ¬∑ rw [(truncGE.rightHomologyMapData K e hj' rfl rfl hj).quasiIso_iff]\n    dsimp\n    infer_instance\n  ¬∑ let œÜ := (shortComplexFunctor C c' j').map (K.œÄTruncGE e)\n    have : Epi œÜ.œÑ‚ÇÅ := by\n      by_cases hi : ‚àÉ i, e.f i = c'.prev j'\n      ¬∑ obtain ‚ü®i, hi‚ü© := hi\n        dsimp [œÜ, œÄTruncGE]\n        rw [e.epi_liftExtend_f_iff _ _ hi]\n        infer_instance\n      ¬∑ apply IsZero.epi (isZero_extend_X _ _ _ (by simpa using hi))\n    have : IsIso œÜ.œÑ‚ÇÇ := by\n      dsimp [œÜ, œÄTruncGE]\n      rw [e.isIso_liftExtend_f_iff _ _ hj']\n      exact K.isIso_restrictionToTruncGE' e j hj\n    have : IsIso œÜ.œÑ‚ÇÉ := by\n      dsimp [œÜ, œÄTruncGE]\n      have : c'.next j' = e.f (c.next j) := by simpa only [‚Üê hj'] using e.next_f rfl\n      rw [e.isIso_liftExtend_f_iff _ _ this.symm]\n      exact K.isIso_restrictionToTruncGE' e _ (e.not_boundaryGE_next' hj rfl)\n    exact ShortComplex.quasiIso_of_epi_of_isIso_of_mono œÜ\n\n"}
{"name":"HomologicalComplex.instQuasiIsoAtœÄTruncGEF","module":"Mathlib.Algebra.Homology.Embedding.TruncGEHomology","initialProofState":"Œπ : Type u_1\nŒπ' : Type u_2\nc : ComplexShape Œπ\nc' : ComplexShape Œπ'\nC : Type u_3\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_4, u_3} C\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroMorphisms C\nK : HomologicalComplex C c'\ne : c.Embedding c'\ninst‚úù¬≤ : e.IsTruncGE\ninst‚úù¬π : ‚àÄ (i' : Œπ'), K.HasHomology i'\ninst‚úù : CategoryTheory.Limits.HasZeroObject C\ni : Œπ\n‚ä¢ QuasiIsoAt (K.œÄTruncGE e) (e.f i)","decl":"instance (i : Œπ) : QuasiIsoAt (K.œÄTruncGE e) (e.f i) := K.quasiIsoAt_œÄTruncGE e rfl\n\n"}
{"name":"HomologicalComplex.quasiIso_œÄTruncGE_iff_isSupported","module":"Mathlib.Algebra.Homology.Embedding.TruncGEHomology","initialProofState":"Œπ : Type u_1\nŒπ' : Type u_2\nc : ComplexShape Œπ\nc' : ComplexShape Œπ'\nC : Type u_3\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_4, u_3} C\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroMorphisms C\nK : HomologicalComplex C c'\ne : c.Embedding c'\ninst‚úù¬≤ : e.IsTruncGE\ninst‚úù¬π : ‚àÄ (i' : Œπ'), K.HasHomology i'\ninst‚úù : CategoryTheory.Limits.HasZeroObject C\n‚ä¢ Iff (QuasiIso (K.œÄTruncGE e)) (K.IsSupported e)","decl":"lemma quasiIso_œÄTruncGE_iff_isSupported :\n    QuasiIso (K.œÄTruncGE e) ‚Üî K.IsSupported e := by\n  constructor\n  ¬∑ intro\n    refine ‚ü®fun i' hi' => ?_‚ü©\n    rw [exactAt_iff_of_quasiIsoAt (K.œÄTruncGE e) i']\n    exact (K.truncGE e).exactAt_of_isSupported e i' hi'\n  ¬∑ intro\n    rw [quasiIso_iff]\n    intro i'\n    by_cases hi' : ‚àÉ i, e.f i = i'\n    ¬∑ obtain ‚ü®i, rfl‚ü© := hi'\n      infer_instance\n    ¬∑ rw [quasiIsoAt_iff_exactAt (K.œÄTruncGE e) i']\n      all_goals exact exactAt_of_isSupported _ e i' (by simpa using hi')\n\n"}
{"name":"HomologicalComplex.acyclic_truncGE_iff_isSupportedOutside","module":"Mathlib.Algebra.Homology.Embedding.TruncGEHomology","initialProofState":"Œπ : Type u_1\nŒπ' : Type u_2\nc : ComplexShape Œπ\nc' : ComplexShape Œπ'\nC : Type u_3\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_4, u_3} C\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroMorphisms C\nK : HomologicalComplex C c'\ne : c.Embedding c'\ninst‚úù¬≤ : e.IsTruncGE\ninst‚úù¬π : ‚àÄ (i' : Œπ'), K.HasHomology i'\ninst‚úù : CategoryTheory.Limits.HasZeroObject C\n‚ä¢ Iff (K.truncGE e).Acyclic (K.IsSupportedOutside e)","decl":"lemma acyclic_truncGE_iff_isSupportedOutside :\n    (K.truncGE e).Acyclic ‚Üî K.IsSupportedOutside e := by\n  constructor\n  ¬∑ intro hK\n    exact ‚ü®fun i =>\n      by simpa only [exactAt_iff_of_quasiIsoAt (K.œÄTruncGE e)] using hK (e.f i)‚ü©\n  ¬∑ intro hK i'\n    by_cases hi' : ‚àÉ i, e.f i = i'\n    ¬∑ obtain ‚ü®i, rfl‚ü© := hi'\n      simpa only [‚Üê exactAt_iff_of_quasiIsoAt (K.œÄTruncGE e)] using hK.exactAt i\n    ¬∑ exact exactAt_of_isSupported _ e i' (by simpa using hi')\n\n"}
{"name":"HomologicalComplex.quasiIso_truncGEMap_iff","module":"Mathlib.Algebra.Homology.Embedding.TruncGEHomology","initialProofState":"Œπ : Type u_1\nŒπ' : Type u_2\nc : ComplexShape Œπ\nc' : ComplexShape Œπ'\nC : Type u_3\ninst‚úù‚Åµ : CategoryTheory.Category.{u_4, u_3} C\ninst‚úù‚Å¥ : CategoryTheory.Limits.HasZeroMorphisms C\nK L : HomologicalComplex C c'\nœÜ : Quiver.Hom K L\ne : c.Embedding c'\ninst‚úù¬≥ : e.IsTruncGE\ninst‚úù¬≤ : ‚àÄ (i' : Œπ'), K.HasHomology i'\ninst‚úù¬π : ‚àÄ (i' : Œπ'), L.HasHomology i'\ninst‚úù : CategoryTheory.Limits.HasZeroObject C\n‚ä¢ Iff (QuasiIso (HomologicalComplex.truncGEMap œÜ e)) (‚àÄ (i : Œπ) (i' : Œπ'), Eq (e.f i) i' ‚Üí QuasiIsoAt œÜ i')","decl":"lemma quasiIso_truncGEMap_iff :\n    QuasiIso (truncGEMap œÜ e) ‚Üî ‚àÄ (i : Œπ) (i' : Œπ') (_ : e.f i = i'), QuasiIsoAt œÜ i' := by\n  have : ‚àÄ (i : Œπ) (i' : Œπ') (_ : e.f i = i'),\n      QuasiIsoAt (truncGEMap œÜ e) i' ‚Üî QuasiIsoAt œÜ i' := by\n    rintro i _ rfl\n    rw [‚Üê quasiIsoAt_iff_comp_left (K.œÄTruncGE e), œÄTruncGE_naturality œÜ e,\n      quasiIsoAt_iff_comp_right]\n  rw [quasiIso_iff]\n  constructor\n  ¬∑ intro h i i' hi\n    simpa only [‚Üê this i i' hi] using h i'\n  ¬∑ intro h i'\n    by_cases hi' : ‚àÉ i, e.f i = i'\n    ¬∑ obtain ‚ü®i, hi‚ü© := hi'\n      simpa only [this i i' hi] using h i i' hi\n    ¬∑ rw [quasiIsoAt_iff_exactAt]\n      all_goals exact exactAt_of_isSupported _ e i' (by simpa using hi')\n\n"}
