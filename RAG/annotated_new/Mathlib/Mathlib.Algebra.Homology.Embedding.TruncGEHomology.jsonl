{"name":"HomologicalComplex.truncGE'.hasHomology_sc'_of_not_mem_boundary","module":"Mathlib.Algebra.Homology.Embedding.TruncGEHomology","initialProofState":"Î¹ : Type u_1\nÎ¹' : Type u_2\nc : ComplexShape Î¹\nc' : ComplexShape Î¹'\nC : Type u_3\ninstâœÂ³ : CategoryTheory.Category.{u_4, u_3} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nK : HomologicalComplex C c'\ne : c.Embedding c'\ninstâœÂ¹ : e.IsTruncGE\ninstâœ : âˆ€ (i' : Î¹'), K.HasHomology i'\ni j k : Î¹\nhi : Eq (c.prev j) i\nhk : Eq (c.next j) k\nhj : Not (e.BoundaryGE j)\nâŠ¢ ((K.truncGE' e).sc' i j k).HasHomology","decl":"include hi hk in\nlemma hasHomology_sc'_of_not_mem_boundary (hj : Â¬ e.BoundaryGE j) :\n    ((K.truncGE' e).sc' i j k).HasHomology := by\n  have : (K.restriction e).HasHomology j :=\n    restriction.hasHomology K e i j k hi hk rfl rfl rfl\n      (e.prev_f_of_not_boundaryGE hi hj) (e.next_f hk)\n  have := ShortComplex.hasHomology_of_iso ((K.restriction e).isoSc' i j k hi hk)\n  let Ï† := (shortComplexFunctor' C c i j k).map (K.restrictionToTruncGE' e)\n  have : Epi Ï†.Ï„â‚ := by dsimp [Ï†]; infer_instance\n  have : IsIso Ï†.Ï„â‚‚ := K.isIso_restrictionToTruncGE' e j hj\n  have : IsIso Ï†.Ï„â‚ƒ := K.isIso_restrictionToTruncGE' e k (e.not_boundaryGE_next' hj hk)\n  exact ShortComplex.hasHomology_of_epi_of_isIso_of_mono Ï†\n\n"}
{"name":"HomologicalComplex.truncGE'.hasHomology_of_not_mem_boundary","module":"Mathlib.Algebra.Homology.Embedding.TruncGEHomology","initialProofState":"Î¹ : Type u_1\nÎ¹' : Type u_2\nc : ComplexShape Î¹\nc' : ComplexShape Î¹'\nC : Type u_3\ninstâœÂ³ : CategoryTheory.Category.{u_4, u_3} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nK : HomologicalComplex C c'\ne : c.Embedding c'\ninstâœÂ¹ : e.IsTruncGE\ninstâœ : âˆ€ (i' : Î¹'), K.HasHomology i'\nj : Î¹\nhj : Not (e.BoundaryGE j)\nâŠ¢ (K.truncGE' e).HasHomology j","decl":"lemma hasHomology_of_not_mem_boundary (hj : Â¬ e.BoundaryGE j) :\n    (K.truncGE' e).HasHomology j :=\n  hasHomology_sc'_of_not_mem_boundary K e _ j _ rfl rfl hj\n\n"}
{"name":"HomologicalComplex.truncGE'.quasiIsoAt_restrictionToTruncGE'","module":"Mathlib.Algebra.Homology.Embedding.TruncGEHomology","initialProofState":"Î¹ : Type u_1\nÎ¹' : Type u_2\nc : ComplexShape Î¹\nc' : ComplexShape Î¹'\nC : Type u_3\ninstâœâµ : CategoryTheory.Category.{u_4, u_3} C\ninstâœâ´ : CategoryTheory.Limits.HasZeroMorphisms C\nK : HomologicalComplex C c'\ne : c.Embedding c'\ninstâœÂ³ : e.IsTruncGE\ninstâœÂ² : âˆ€ (i' : Î¹'), K.HasHomology i'\nj : Î¹\nhj : Not (e.BoundaryGE j)\ninstâœÂ¹ : (K.restriction e).HasHomology j\ninstâœ : (K.truncGE' e).HasHomology j\nâŠ¢ QuasiIsoAt (K.restrictionToTruncGE' e) j","decl":"/-- `K.restrictionToTruncGE' e` is a quasi-isomorphism in degrees that are not at the boundary. -/\nlemma quasiIsoAt_restrictionToTruncGE' (hj : Â¬ e.BoundaryGE j)\n    [(K.restriction e).HasHomology j] [(K.truncGE' e).HasHomology j] :\n    QuasiIsoAt (K.restrictionToTruncGE' e) j := by\n  rw [quasiIsoAt_iff]\n  let Ï† := (shortComplexFunctor C c j).map (K.restrictionToTruncGE' e)\n  have : Epi Ï†.Ï„â‚ := by dsimp [Ï†]; infer_instance\n  have : IsIso Ï†.Ï„â‚‚ := K.isIso_restrictionToTruncGE' e j hj\n  have : IsIso Ï†.Ï„â‚ƒ := K.isIso_restrictionToTruncGE' e _ (e.not_boundaryGE_next' hj rfl)\n  exact ShortComplex.quasiIso_of_epi_of_isIso_of_mono Ï†\n\n"}
{"name":"HomologicalComplex.truncGE'.homologyÎ¹_truncGE'XIsoOpcycles_inv_d","module":"Mathlib.Algebra.Homology.Embedding.TruncGEHomology","initialProofState":"Î¹ : Type u_1\nÎ¹' : Type u_2\nc : ComplexShape Î¹\nc' : ComplexShape Î¹'\nC : Type u_3\ninstâœÂ³ : CategoryTheory.Category.{u_4, u_3} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nK : HomologicalComplex C c'\ne : c.Embedding c'\ninstâœÂ¹ : e.IsTruncGE\ninstâœ : âˆ€ (i' : Î¹'), K.HasHomology i'\nj k : Î¹\nj' : Î¹'\nhj' : Eq (e.f j) j'\nhj : e.BoundaryGE j\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.comp (K.homologyÎ¹ j') (K.truncGE'XIsoOpcycles e hj' hj).inv) ((K.truncGE' e).d j k)) 0","decl":"lemma homologyÎ¹_truncGE'XIsoOpcycles_inv_d :\n    (K.homologyÎ¹ j' â‰« (K.truncGE'XIsoOpcycles e hj' hj).inv) â‰« (K.truncGE' e).d j k = 0 := by\n  by_cases hjk : c.Rel j k\n  Â· rw [K.truncGE'_d_eq_fromOpcycles e hjk hj' rfl hj, assoc, Iso.inv_hom_id_assoc,\n    homologyÎ¹_comp_fromOpcycles_assoc, zero_comp]\n  Â· rw [shape _ _ _ hjk, comp_zero]\n\n"}
{"name":"HomologicalComplex.truncGE'.homologyData_right_g'","module":"Mathlib.Algebra.Homology.Embedding.TruncGEHomology","initialProofState":"Î¹ : Type u_1\nÎ¹' : Type u_2\nc : ComplexShape Î¹\nc' : ComplexShape Î¹'\nC : Type u_3\ninstâœÂ³ : CategoryTheory.Category.{u_4, u_3} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nK : HomologicalComplex C c'\ne : c.Embedding c'\ninstâœÂ¹ : e.IsTruncGE\ninstâœ : âˆ€ (i' : Î¹'), K.HasHomology i'\ni j k : Î¹\nhk : Eq (c.next j) k\nj' : Î¹'\nhj' : Eq (e.f j) j'\nhj : e.BoundaryGE j\nâŠ¢ Eq (HomologicalComplex.truncGE'.homologyData K e i j k hk hj' hj).right.g' ((K.truncGE' e).d j k)","decl":"/-- Computation of the `right.g'` field of `truncGE'.homologyData K e i j k hk hj' hj`. -/\n@[simp]\nlemma homologyData_right_g' :\n    (homologyData K e i j k hk hj' hj).right.g' = (K.truncGE' e).d j k := rfl\n\n"}
{"name":"HomologicalComplex.truncGE'.truncGE'_hasHomology","module":"Mathlib.Algebra.Homology.Embedding.TruncGEHomology","initialProofState":"Î¹ : Type u_1\nÎ¹' : Type u_2\nc : ComplexShape Î¹\nc' : ComplexShape Î¹'\nC : Type u_3\ninstâœÂ³ : CategoryTheory.Category.{u_4, u_3} C\ninstâœÂ² : CategoryTheory.Limits.HasZeroMorphisms C\nK : HomologicalComplex C c'\ne : c.Embedding c'\ninstâœÂ¹ : e.IsTruncGE\ninstâœ : âˆ€ (i' : Î¹'), K.HasHomology i'\ni : Î¹\nâŠ¢ (K.truncGE' e).HasHomology i","decl":"instance truncGE'_hasHomology (i : Î¹) : (K.truncGE' e).HasHomology i := by\n  by_cases hi : e.BoundaryGE i\n  Â· exact ShortComplex.HasHomology.mk' (homologyData K e _ _ _ rfl rfl hi)\n  Â· exact hasHomology_of_not_mem_boundary K e i hi\n\n"}
{"name":"HomologicalComplex.truncGE.instHasHomology","module":"Mathlib.Algebra.Homology.Embedding.TruncGEHomology","initialProofState":"Î¹ : Type u_1\nÎ¹' : Type u_2\nc : ComplexShape Î¹\nc' : ComplexShape Î¹'\nC : Type u_3\ninstâœâ´ : CategoryTheory.Category.{u_4, u_3} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroMorphisms C\nK : HomologicalComplex C c'\ne : c.Embedding c'\ninstâœÂ² : e.IsTruncGE\ninstâœÂ¹ : âˆ€ (i' : Î¹'), K.HasHomology i'\ninstâœ : CategoryTheory.Limits.HasZeroObject C\ni' : Î¹'\nâŠ¢ (K.truncGE e).HasHomology i'","decl":"instance (i' : Î¹') : (K.truncGE e).HasHomology i' := by\n  dsimp [truncGE]\n  infer_instance\n\n"}
{"name":"HomologicalComplex.truncGE.rightHomologyMapData_Ï†Q","module":"Mathlib.Algebra.Homology.Embedding.TruncGEHomology","initialProofState":"Î¹ : Type u_1\nÎ¹' : Type u_2\nc : ComplexShape Î¹\nc' : ComplexShape Î¹'\nC : Type u_3\ninstâœâ´ : CategoryTheory.Category.{u_4, u_3} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroMorphisms C\nK : HomologicalComplex C c'\ne : c.Embedding c'\ninstâœÂ² : e.IsTruncGE\ninstâœÂ¹ : âˆ€ (i' : Î¹'), K.HasHomology i'\ninstâœ : CategoryTheory.Limits.HasZeroObject C\ni j k : Î¹\nj' : Î¹'\nhj' : Eq (e.f j) j'\nhi : Eq (c.prev j) i\nhk : Eq (c.next j) k\nhj : e.BoundaryGE j\nâŠ¢ Eq (HomologicalComplex.truncGE.rightHomologyMapData K e hj' hi hk hj).Ï†Q (K.truncGE'XIsoOpcycles e hj' hj).inv","decl":"/-- The right homology data which allows to show that `K.Ï€TruncGE e`\ninduces an isomorphism in homology in degrees `j'` such that `e.f j = j'` for some `j`. -/\n@[simps]\nnoncomputable def rightHomologyMapData {i j k : Î¹} {j' : Î¹'} (hj' : e.f j = j')\n    (hi : c.prev j = i) (hk : c.next j = k) (hj : e.BoundaryGE j) :\n    ShortComplex.RightHomologyMapData ((shortComplexFunctor C c' j').map (K.Ï€TruncGE e))\n    (ShortComplex.RightHomologyData.canonical (K.sc j'))\n    (extend.rightHomologyData (K.truncGE' e) e hj' hi rfl hk rfl\n      (truncGE'.homologyData K e i j k hk hj' hj).right) where\n  Ï†Q := (K.truncGE'XIsoOpcycles e hj' hj).inv\n  Ï†H := ğŸ™ _\n  commp := by\n    change K.pOpcycles j' â‰« _ = _\n    simp [truncGE'.homologyData, Ï€TruncGE, e.liftExtend_f _ _ hj',\n      K.restrictionToTruncGE'_f_eq_iso_hom_pOpcycles_iso_inv e hj' hj]\n  commg' := by\n    have hk' : e.f k = c'.next j' := by rw [â† hj', e.next_f hk]\n    dsimp\n    rw [extend.rightHomologyData_g' _ _ _ _ _ _ _ _ hk', Ï€TruncGE,\n        e.liftExtend_f _ _ hk', truncGE'.homologyData_right_g']\n    by_cases hjk : c.Rel j k\n    Â· simp [K.truncGE'_d_eq_fromOpcycles e hjk hj' hk' hj,\n        K.restrictionToTruncGE'_f_eq_iso_hom_iso_inv e hk' (e.not_boundaryGE_next hjk)]\n      rfl\n    Â· obtain rfl : k = j := by rw [â† c.next_eq_self j  (by simpa only [hk] using hjk), hk]\n      rw [shape _ _ _ hjk, zero_comp, comp_zero,\n        K.restrictionToTruncGE'_f_eq_iso_hom_pOpcycles_iso_inv e hk' hj]\n      simp only [restriction_X, restrictionXIso, eqToIso.inv, eqToIso.hom, assoc,\n        eqToHom_trans_assoc, eqToHom_refl, id_comp]\n      change 0 = K.fromOpcycles _ _ â‰« _\n      rw [â† cancel_epi (K.pOpcycles _), comp_zero, p_fromOpcycles_assoc,\n        d_pOpcycles_assoc, zero_comp]\n\n"}
{"name":"HomologicalComplex.truncGE.rightHomologyMapData_Ï†H","module":"Mathlib.Algebra.Homology.Embedding.TruncGEHomology","initialProofState":"Î¹ : Type u_1\nÎ¹' : Type u_2\nc : ComplexShape Î¹\nc' : ComplexShape Î¹'\nC : Type u_3\ninstâœâ´ : CategoryTheory.Category.{u_4, u_3} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroMorphisms C\nK : HomologicalComplex C c'\ne : c.Embedding c'\ninstâœÂ² : e.IsTruncGE\ninstâœÂ¹ : âˆ€ (i' : Î¹'), K.HasHomology i'\ninstâœ : CategoryTheory.Limits.HasZeroObject C\ni j k : Î¹\nj' : Î¹'\nhj' : Eq (e.f j) j'\nhi : Eq (c.prev j) i\nhk : Eq (c.next j) k\nhj : e.BoundaryGE j\nâŠ¢ Eq (HomologicalComplex.truncGE.rightHomologyMapData K e hj' hi hk hj).Ï†H (CategoryTheory.CategoryStruct.id (CategoryTheory.ShortComplex.RightHomologyData.canonical (K.sc j')).H)","decl":"/-- The right homology data which allows to show that `K.Ï€TruncGE e`\ninduces an isomorphism in homology in degrees `j'` such that `e.f j = j'` for some `j`. -/\n@[simps]\nnoncomputable def rightHomologyMapData {i j k : Î¹} {j' : Î¹'} (hj' : e.f j = j')\n    (hi : c.prev j = i) (hk : c.next j = k) (hj : e.BoundaryGE j) :\n    ShortComplex.RightHomologyMapData ((shortComplexFunctor C c' j').map (K.Ï€TruncGE e))\n    (ShortComplex.RightHomologyData.canonical (K.sc j'))\n    (extend.rightHomologyData (K.truncGE' e) e hj' hi rfl hk rfl\n      (truncGE'.homologyData K e i j k hk hj' hj).right) where\n  Ï†Q := (K.truncGE'XIsoOpcycles e hj' hj).inv\n  Ï†H := ğŸ™ _\n  commp := by\n    change K.pOpcycles j' â‰« _ = _\n    simp [truncGE'.homologyData, Ï€TruncGE, e.liftExtend_f _ _ hj',\n      K.restrictionToTruncGE'_f_eq_iso_hom_pOpcycles_iso_inv e hj' hj]\n  commg' := by\n    have hk' : e.f k = c'.next j' := by rw [â† hj', e.next_f hk]\n    dsimp\n    rw [extend.rightHomologyData_g' _ _ _ _ _ _ _ _ hk', Ï€TruncGE,\n        e.liftExtend_f _ _ hk', truncGE'.homologyData_right_g']\n    by_cases hjk : c.Rel j k\n    Â· simp [K.truncGE'_d_eq_fromOpcycles e hjk hj' hk' hj,\n        K.restrictionToTruncGE'_f_eq_iso_hom_iso_inv e hk' (e.not_boundaryGE_next hjk)]\n      rfl\n    Â· obtain rfl : k = j := by rw [â† c.next_eq_self j  (by simpa only [hk] using hjk), hk]\n      rw [shape _ _ _ hjk, zero_comp, comp_zero,\n        K.restrictionToTruncGE'_f_eq_iso_hom_pOpcycles_iso_inv e hk' hj]\n      simp only [restriction_X, restrictionXIso, eqToIso.inv, eqToIso.hom, assoc,\n        eqToHom_trans_assoc, eqToHom_refl, id_comp]\n      change 0 = K.fromOpcycles _ _ â‰« _\n      rw [â† cancel_epi (K.pOpcycles _), comp_zero, p_fromOpcycles_assoc,\n        d_pOpcycles_assoc, zero_comp]\n\n"}
{"name":"HomologicalComplex.quasiIsoAt_Ï€TruncGE","module":"Mathlib.Algebra.Homology.Embedding.TruncGEHomology","initialProofState":"Î¹ : Type u_1\nÎ¹' : Type u_2\nc : ComplexShape Î¹\nc' : ComplexShape Î¹'\nC : Type u_3\ninstâœâ´ : CategoryTheory.Category.{u_4, u_3} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroMorphisms C\nK : HomologicalComplex C c'\ne : c.Embedding c'\ninstâœÂ² : e.IsTruncGE\ninstâœÂ¹ : âˆ€ (i' : Î¹'), K.HasHomology i'\ninstâœ : CategoryTheory.Limits.HasZeroObject C\nj : Î¹\nj' : Î¹'\nhj' : Eq (e.f j) j'\nâŠ¢ QuasiIsoAt (K.Ï€TruncGE e) j'","decl":"lemma quasiIsoAt_Ï€TruncGE {j : Î¹} {j' : Î¹'} (hj' : e.f j = j') :\n    QuasiIsoAt (K.Ï€TruncGE e) j' := by\n  rw [quasiIsoAt_iff]\n  by_cases hj : e.BoundaryGE j\n  Â· rw [(truncGE.rightHomologyMapData K e hj' rfl rfl hj).quasiIso_iff]\n    dsimp\n    infer_instance\n  Â· let Ï† := (shortComplexFunctor C c' j').map (K.Ï€TruncGE e)\n    have : Epi Ï†.Ï„â‚ := by\n      by_cases hi : âˆƒ i, e.f i = c'.prev j'\n      Â· obtain âŸ¨i, hiâŸ© := hi\n        dsimp [Ï†, Ï€TruncGE]\n        rw [e.epi_liftExtend_f_iff _ _ hi]\n        infer_instance\n      Â· apply IsZero.epi (isZero_extend_X _ _ _ (by simpa using hi))\n    have : IsIso Ï†.Ï„â‚‚ := by\n      dsimp [Ï†, Ï€TruncGE]\n      rw [e.isIso_liftExtend_f_iff _ _ hj']\n      exact K.isIso_restrictionToTruncGE' e j hj\n    have : IsIso Ï†.Ï„â‚ƒ := by\n      dsimp [Ï†, Ï€TruncGE]\n      have : c'.next j' = e.f (c.next j) := by simpa only [â† hj'] using e.next_f rfl\n      rw [e.isIso_liftExtend_f_iff _ _ this.symm]\n      exact K.isIso_restrictionToTruncGE' e _ (e.not_boundaryGE_next' hj rfl)\n    exact ShortComplex.quasiIso_of_epi_of_isIso_of_mono Ï†\n\n"}
{"name":"HomologicalComplex.instQuasiIsoAtÏ€TruncGEF","module":"Mathlib.Algebra.Homology.Embedding.TruncGEHomology","initialProofState":"Î¹ : Type u_1\nÎ¹' : Type u_2\nc : ComplexShape Î¹\nc' : ComplexShape Î¹'\nC : Type u_3\ninstâœâ´ : CategoryTheory.Category.{u_4, u_3} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroMorphisms C\nK : HomologicalComplex C c'\ne : c.Embedding c'\ninstâœÂ² : e.IsTruncGE\ninstâœÂ¹ : âˆ€ (i' : Î¹'), K.HasHomology i'\ninstâœ : CategoryTheory.Limits.HasZeroObject C\ni : Î¹\nâŠ¢ QuasiIsoAt (K.Ï€TruncGE e) (e.f i)","decl":"instance (i : Î¹) : QuasiIsoAt (K.Ï€TruncGE e) (e.f i) := K.quasiIsoAt_Ï€TruncGE e rfl\n\n"}
{"name":"HomologicalComplex.quasiIso_Ï€TruncGE_iff_isSupported","module":"Mathlib.Algebra.Homology.Embedding.TruncGEHomology","initialProofState":"Î¹ : Type u_1\nÎ¹' : Type u_2\nc : ComplexShape Î¹\nc' : ComplexShape Î¹'\nC : Type u_3\ninstâœâ´ : CategoryTheory.Category.{u_4, u_3} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroMorphisms C\nK : HomologicalComplex C c'\ne : c.Embedding c'\ninstâœÂ² : e.IsTruncGE\ninstâœÂ¹ : âˆ€ (i' : Î¹'), K.HasHomology i'\ninstâœ : CategoryTheory.Limits.HasZeroObject C\nâŠ¢ Iff (QuasiIso (K.Ï€TruncGE e)) (K.IsSupported e)","decl":"lemma quasiIso_Ï€TruncGE_iff_isSupported :\n    QuasiIso (K.Ï€TruncGE e) â†” K.IsSupported e := by\n  constructor\n  Â· intro\n    refine âŸ¨fun i' hi' => ?_âŸ©\n    rw [exactAt_iff_of_quasiIsoAt (K.Ï€TruncGE e) i']\n    exact (K.truncGE e).exactAt_of_isSupported e i' hi'\n  Â· intro\n    rw [quasiIso_iff]\n    intro i'\n    by_cases hi' : âˆƒ i, e.f i = i'\n    Â· obtain âŸ¨i, rflâŸ© := hi'\n      infer_instance\n    Â· rw [quasiIsoAt_iff_exactAt (K.Ï€TruncGE e) i']\n      all_goals exact exactAt_of_isSupported _ e i' (by simpa using hi')\n\n"}
{"name":"HomologicalComplex.acyclic_truncGE_iff_isSupportedOutside","module":"Mathlib.Algebra.Homology.Embedding.TruncGEHomology","initialProofState":"Î¹ : Type u_1\nÎ¹' : Type u_2\nc : ComplexShape Î¹\nc' : ComplexShape Î¹'\nC : Type u_3\ninstâœâ´ : CategoryTheory.Category.{u_4, u_3} C\ninstâœÂ³ : CategoryTheory.Limits.HasZeroMorphisms C\nK : HomologicalComplex C c'\ne : c.Embedding c'\ninstâœÂ² : e.IsTruncGE\ninstâœÂ¹ : âˆ€ (i' : Î¹'), K.HasHomology i'\ninstâœ : CategoryTheory.Limits.HasZeroObject C\nâŠ¢ Iff (K.truncGE e).Acyclic (K.IsSupportedOutside e)","decl":"lemma acyclic_truncGE_iff_isSupportedOutside :\n    (K.truncGE e).Acyclic â†” K.IsSupportedOutside e := by\n  constructor\n  Â· intro hK\n    exact âŸ¨fun i =>\n      by simpa only [exactAt_iff_of_quasiIsoAt (K.Ï€TruncGE e)] using hK (e.f i)âŸ©\n  Â· intro hK i'\n    by_cases hi' : âˆƒ i, e.f i = i'\n    Â· obtain âŸ¨i, rflâŸ© := hi'\n      simpa only [â† exactAt_iff_of_quasiIsoAt (K.Ï€TruncGE e)] using hK.exactAt i\n    Â· exact exactAt_of_isSupported _ e i' (by simpa using hi')\n\n"}
{"name":"HomologicalComplex.quasiIso_truncGEMap_iff","module":"Mathlib.Algebra.Homology.Embedding.TruncGEHomology","initialProofState":"Î¹ : Type u_1\nÎ¹' : Type u_2\nc : ComplexShape Î¹\nc' : ComplexShape Î¹'\nC : Type u_3\ninstâœâµ : CategoryTheory.Category.{u_4, u_3} C\ninstâœâ´ : CategoryTheory.Limits.HasZeroMorphisms C\nK L : HomologicalComplex C c'\nÏ† : Quiver.Hom K L\ne : c.Embedding c'\ninstâœÂ³ : e.IsTruncGE\ninstâœÂ² : âˆ€ (i' : Î¹'), K.HasHomology i'\ninstâœÂ¹ : âˆ€ (i' : Î¹'), L.HasHomology i'\ninstâœ : CategoryTheory.Limits.HasZeroObject C\nâŠ¢ Iff (QuasiIso (HomologicalComplex.truncGEMap Ï† e)) (âˆ€ (i : Î¹) (i' : Î¹'), Eq (e.f i) i' â†’ QuasiIsoAt Ï† i')","decl":"lemma quasiIso_truncGEMap_iff :\n    QuasiIso (truncGEMap Ï† e) â†” âˆ€ (i : Î¹) (i' : Î¹') (_ : e.f i = i'), QuasiIsoAt Ï† i' := by\n  have : âˆ€ (i : Î¹) (i' : Î¹') (_ : e.f i = i'),\n      QuasiIsoAt (truncGEMap Ï† e) i' â†” QuasiIsoAt Ï† i' := by\n    rintro i _ rfl\n    rw [â† quasiIsoAt_iff_comp_left (K.Ï€TruncGE e), Ï€TruncGE_naturality Ï† e,\n      quasiIsoAt_iff_comp_right]\n  rw [quasiIso_iff]\n  constructor\n  Â· intro h i i' hi\n    simpa only [â† this i i' hi] using h i'\n  Â· intro h i'\n    by_cases hi' : âˆƒ i, e.f i = i'\n    Â· obtain âŸ¨i, hiâŸ© := hi'\n      simpa only [this i i' hi] using h i i' hi\n    Â· rw [quasiIsoAt_iff_exactAt]\n      all_goals exact exactAt_of_isSupported _ e i' (by simpa using hi')\n\n"}
