{"name":"UniformSpace.hasBasis_ofFun","module":"Mathlib.Topology.UniformSpace.OfFun","initialProofState":"X : Type u_1\nM : Type u_2\ninstâœ : LinearOrderedAddCommMonoid M\nhâ‚€ : Exists fun x => LT.lt 0 x\nd : X â†’ X â†’ M\nrefl : âˆ€ (x : X), Eq (d x x) 0\nsymm : âˆ€ (x y : X), Eq (d x y) (d y x)\ntriangle : âˆ€ (x y z : X), LE.le (d x z) (HAdd.hAdd (d x y) (d y z))\nhalf : âˆ€ (Îµ : M), GT.gt Îµ 0 â†’ Exists fun Î´ => And (GT.gt Î´ 0) (âˆ€ (x : M), LT.lt x Î´ â†’ âˆ€ (y : M), LT.lt y Î´ â†’ LT.lt (HAdd.hAdd x y) Îµ)\nâŠ¢ (uniformity X).HasBasis (fun x => LT.lt 0 x) fun Îµ => setOf fun x => LT.lt (d x.1 x.2) Îµ","decl":"theorem hasBasis_ofFun [LinearOrderedAddCommMonoid M]\n    (hâ‚€ : âˆƒ x : M, 0 < x) (d : X â†’ X â†’ M) (refl : âˆ€ x, d x x = 0) (symm : âˆ€ x y, d x y = d y x)\n    (triangle : âˆ€ x y z, d x z â‰¤ d x y + d y z)\n    (half : âˆ€ Îµ > (0 : M), âˆƒ Î´ > (0 : M), âˆ€ x < Î´, âˆ€ y < Î´, x + y < Îµ) :\n    ð“¤[.ofFun d refl symm triangle half].HasBasis ((0 : M) < Â·) (fun Îµ => { x | d x.1 x.2 < Îµ }) :=\n  hasBasis_biInf_principal'\n    (fun Îµâ‚ hâ‚ Îµâ‚‚ hâ‚‚ => âŸ¨min Îµâ‚ Îµâ‚‚, lt_min hâ‚ hâ‚‚, fun _x hx => lt_of_lt_of_le hx (min_le_left _ _),\n      fun _x hx => lt_of_lt_of_le hx (min_le_right _ _)âŸ©) hâ‚€\n\n"}
