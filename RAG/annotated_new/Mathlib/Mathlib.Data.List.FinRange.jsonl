{"name":"List.finRange_eq_pmap_range","module":"Mathlib.Data.List.FinRange","initialProofState":"n : Nat\n⊢ Eq (List.finRange n) (List.pmap Fin.mk (List.range n) ⋯)","decl":"theorem finRange_eq_pmap_range (n : ℕ) : finRange n = (range n).pmap Fin.mk (by simp) := by\n  apply List.ext_getElem <;> simp [finRange]\n\n"}
{"name":"List.mem_finRange","module":"Mathlib.Data.List.FinRange","initialProofState":"n : Nat\na : Fin n\n⊢ Membership.mem (List.finRange n) a","decl":"@[simp]\ntheorem mem_finRange {n : ℕ} (a : Fin n) : a ∈ finRange n := by\n  rw [finRange_eq_pmap_range]\n  exact mem_pmap.2\n    ⟨a.1, mem_range.2 a.2, by\n      cases a\n      rfl⟩\n\n"}
{"name":"List.nodup_finRange","module":"Mathlib.Data.List.FinRange","initialProofState":"n : Nat\n⊢ (List.finRange n).Nodup","decl":"theorem nodup_finRange (n : ℕ) : (finRange n).Nodup := by\n  rw [finRange_eq_pmap_range]\n  exact (Pairwise.pmap (nodup_range n) _) fun _ _ _ _ => @Fin.ne_of_val_ne _ ⟨_, _⟩ ⟨_, _⟩\n\n"}
{"name":"List.finRange_eq_nil","module":"Mathlib.Data.List.FinRange","initialProofState":"n : Nat\n⊢ Iff (Eq (List.finRange n) List.nil) (Eq n 0)","decl":"@[simp]\ntheorem finRange_eq_nil {n : ℕ} : finRange n = [] ↔ n = 0 := by\n  rw [← length_eq_zero, length_finRange]\n\n"}
{"name":"List.pairwise_lt_finRange","module":"Mathlib.Data.List.FinRange","initialProofState":"n : Nat\n⊢ List.Pairwise (fun x1 x2 => LT.lt x1 x2) (List.finRange n)","decl":"theorem pairwise_lt_finRange (n : ℕ) : Pairwise (· < ·) (finRange n) := by\n  rw [finRange_eq_pmap_range]\n  exact (List.pairwise_lt_range n).pmap (by simp) (by simp)\n\n"}
{"name":"List.pairwise_le_finRange","module":"Mathlib.Data.List.FinRange","initialProofState":"n : Nat\n⊢ List.Pairwise (fun x1 x2 => LE.le x1 x2) (List.finRange n)","decl":"theorem pairwise_le_finRange (n : ℕ) : Pairwise (· ≤ ·) (finRange n) := by\n  rw [finRange_eq_pmap_range]\n  exact (List.pairwise_le_range n).pmap (by simp) (by simp)\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/10756): new theorem\n"}
{"name":"List.get_finRange","module":"Mathlib.Data.List.FinRange","initialProofState":"n i : Nat\nh : LT.lt i (List.finRange n).length\n⊢ Eq ((List.finRange n).get ⟨i, h⟩) ⟨i, ⋯⟩","decl":"theorem get_finRange {n : ℕ} {i : ℕ} (h) :\n    (finRange n).get ⟨i, h⟩ = ⟨i, length_finRange n ▸ h⟩ := by\n  simp\n\n"}
{"name":"List.nthLe_finRange","module":"Mathlib.Data.List.FinRange","initialProofState":"n i : Nat\nh : LT.lt i (List.finRange n).length\n⊢ Eq ((List.finRange n).get ⟨i, h⟩) ⟨i, ⋯⟩","decl":"@[deprecated (since := \"2024-08-19\")] alias nthLe_finRange := get_finRange\n\n"}
{"name":"List.finRange_map_get","module":"Mathlib.Data.List.FinRange","initialProofState":"α : Type u\nl : List α\n⊢ Eq (List.map l.get (List.finRange l.length)) l","decl":"@[simp]\ntheorem finRange_map_get (l : List α) : (finRange l.length).map l.get = l :=\n  List.ext_get (by simp) (by simp)\n\n"}
{"name":"List.indexOf_finRange","module":"Mathlib.Data.List.FinRange","initialProofState":"k : Nat\ni : Fin k\n⊢ Eq (List.indexOf i (List.finRange k)) ↑i","decl":"@[simp] theorem indexOf_finRange {k : ℕ} (i : Fin k) : (finRange k).indexOf i = i := by\n  have : (finRange k).indexOf i < (finRange k).length := indexOf_lt_length_iff.mpr (by simp)\n  have h₁ : (finRange k).get ⟨(finRange k).indexOf i, this⟩ = i := indexOf_get this\n  have h₂ : (finRange k).get ⟨i, by simp⟩ = i := get_finRange _\n  simpa using (Nodup.get_inj_iff (nodup_finRange k)).mp (Eq.trans h₁ h₂.symm)\n\n"}
{"name":"List.map_coe_finRange","module":"Mathlib.Data.List.FinRange","initialProofState":"n : Nat\n⊢ Eq (List.map Fin.val (List.finRange n)) (List.range n)","decl":"@[simp]\ntheorem map_coe_finRange (n : ℕ) : ((finRange n) : List (Fin n)).map (Fin.val) = List.range n := by\n  apply List.ext_getElem <;> simp\n\n"}
{"name":"List.finRange_succ_eq_map","module":"Mathlib.Data.List.FinRange","initialProofState":"n : Nat\n⊢ Eq (List.finRange n.succ) (List.cons 0 (List.map Fin.succ (List.finRange n)))","decl":"theorem finRange_succ_eq_map (n : ℕ) : finRange n.succ = 0 :: (finRange n).map Fin.succ := by\n  apply map_injective_iff.mpr Fin.val_injective\n  rw [map_cons, map_coe_finRange, range_succ_eq_map, Fin.val_zero, ← map_coe_finRange, map_map,\n    map_map]\n  simp only [Function.comp_def, Fin.val_succ]\n\n-- Porting note: `map_nth_le` moved to `List.finRange_map_get` in Data.List.Range\n\n"}
{"name":"List.ofFn_eq_pmap","module":"Mathlib.Data.List.FinRange","initialProofState":"α : Type u\nn : Nat\nf : Fin n → α\n⊢ Eq (List.ofFn f) (List.pmap (fun i hi => f ⟨i, hi⟩) (List.range n) ⋯)","decl":"theorem ofFn_eq_pmap {n} {f : Fin n → α} :\n    ofFn f = pmap (fun i hi => f ⟨i, hi⟩) (range n) fun _ => mem_range.1 := by\n  rw [pmap_eq_map_attach]\n  exact ext_getElem (by simp) fun i hi1 hi2 => by simp [List.getElem_ofFn f i hi1]\n\n"}
{"name":"List.ofFn_id","module":"Mathlib.Data.List.FinRange","initialProofState":"n : Nat\n⊢ Eq (List.ofFn id) (List.finRange n)","decl":"theorem ofFn_id (n) : ofFn id = finRange n :=\n  rfl\n\n"}
{"name":"List.ofFn_eq_map","module":"Mathlib.Data.List.FinRange","initialProofState":"α : Type u\nn : Nat\nf : Fin n → α\n⊢ Eq (List.ofFn f) (List.map f (List.finRange n))","decl":"theorem ofFn_eq_map {n} {f : Fin n → α} : ofFn f = (finRange n).map f := by\n  rw [← ofFn_id, map_ofFn, Function.comp_id]\n\n"}
{"name":"List.nodup_ofFn_ofInjective","module":"Mathlib.Data.List.FinRange","initialProofState":"α : Type u\nn : Nat\nf : Fin n → α\nhf : Function.Injective f\n⊢ (List.ofFn f).Nodup","decl":"theorem nodup_ofFn_ofInjective {n} {f : Fin n → α} (hf : Function.Injective f) :\n    Nodup (ofFn f) := by\n  rw [ofFn_eq_pmap]\n  exact (nodup_range n).pmap fun _ _ _ _ H => Fin.val_eq_of_eq <| hf H\n\n"}
{"name":"List.nodup_ofFn","module":"Mathlib.Data.List.FinRange","initialProofState":"α : Type u\nn : Nat\nf : Fin n → α\n⊢ Iff (List.ofFn f).Nodup (Function.Injective f)","decl":"theorem nodup_ofFn {n} {f : Fin n → α} : Nodup (ofFn f) ↔ Function.Injective f := by\n  refine ⟨?_, nodup_ofFn_ofInjective⟩\n  refine Fin.consInduction ?_ (fun x₀ xs ih => ?_) f\n  · intro _\n    exact Function.injective_of_subsingleton _\n  · intro h\n    rw [Fin.cons_injective_iff]\n    simp_rw [ofFn_succ, Fin.cons_succ, nodup_cons, Fin.cons_zero, mem_ofFn] at h\n    exact h.imp_right ih\n\n"}
{"name":"Equiv.Perm.map_finRange_perm","module":"Mathlib.Data.List.FinRange","initialProofState":"n : Nat\nσ : Equiv.Perm (Fin n)\n⊢ (List.map (⇑σ) (List.finRange n)).Perm (List.finRange n)","decl":"theorem Equiv.Perm.map_finRange_perm {n : ℕ} (σ : Equiv.Perm (Fin n)) :\n    map σ (finRange n) ~ finRange n := by\n  rw [perm_ext_iff_of_nodup ((nodup_finRange n).map σ.injective) <| nodup_finRange n]\n  simpa [mem_map, mem_finRange] using σ.surjective\n\n"}
{"name":"Equiv.Perm.ofFn_comp_perm","module":"Mathlib.Data.List.FinRange","initialProofState":"n : Nat\nα : Type u\nσ : Equiv.Perm (Fin n)\nf : Fin n → α\n⊢ (List.ofFn (Function.comp f ⇑σ)).Perm (List.ofFn f)","decl":"/-- The list obtained from a permutation of a tuple `f` is permutation equivalent to\nthe list obtained from `f`. -/\ntheorem Equiv.Perm.ofFn_comp_perm {n : ℕ} {α : Type u} (σ : Equiv.Perm (Fin n)) (f : Fin n → α) :\n    ofFn (f ∘ σ) ~ ofFn f := by\n  rw [ofFn_eq_map, ofFn_eq_map, ← map_map]\n  exact σ.map_finRange_perm.map f\n"}
