{"name":"rat_add_continuous_lemma","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : LinearOrderedField α\ninst✝¹ : Ring β\nabv : β → α\ninst✝ : IsAbsoluteValue abv\nε : α\nε0 : LT.lt 0 ε\n⊢ Exists fun δ => And (GT.gt δ 0) (∀ {a₁ a₂ b₁ b₂ : β}, LT.lt (abv (HSub.hSub a₁ b₁)) δ → LT.lt (abv (HSub.hSub a₂ b₂)) δ → LT.lt (abv (HSub.hSub (HAdd.hAdd a₁ a₂) (HAdd.hAdd b₁ b₂))) ε)","decl":"theorem rat_add_continuous_lemma {ε : α} (ε0 : 0 < ε) :\n    ∃ δ > 0, ∀ {a₁ a₂ b₁ b₂ : β}, abv (a₁ - b₁) < δ → abv (a₂ - b₂) < δ →\n      abv (a₁ + a₂ - (b₁ + b₂)) < ε :=\n  ⟨ε / 2, half_pos ε0, fun {a₁ a₂ b₁ b₂} h₁ h₂ => by\n    simpa [add_halves, sub_eq_add_neg, add_comm, add_left_comm, add_assoc] using\n      lt_of_le_of_lt (abv_add abv _ _) (add_lt_add h₁ h₂)⟩\n\n"}
{"name":"rat_mul_continuous_lemma","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : LinearOrderedField α\ninst✝¹ : Ring β\nabv : β → α\ninst✝ : IsAbsoluteValue abv\nε K₁ K₂ : α\nε0 : LT.lt 0 ε\n⊢ Exists fun δ => And (GT.gt δ 0) (∀ {a₁ a₂ b₁ b₂ : β}, LT.lt (abv a₁) K₁ → LT.lt (abv b₂) K₂ → LT.lt (abv (HSub.hSub a₁ b₁)) δ → LT.lt (abv (HSub.hSub a₂ b₂)) δ → LT.lt (abv (HSub.hSub (HMul.hMul a₁ a₂) (HMul.hMul b₁ b₂))) ε)","decl":"theorem rat_mul_continuous_lemma {ε K₁ K₂ : α} (ε0 : 0 < ε) :\n    ∃ δ > 0, ∀ {a₁ a₂ b₁ b₂ : β}, abv a₁ < K₁ → abv b₂ < K₂ → abv (a₁ - b₁) < δ →\n      abv (a₂ - b₂) < δ → abv (a₁ * a₂ - b₁ * b₂) < ε := by\n  have K0 : (0 : α) < max 1 (max K₁ K₂) := lt_of_lt_of_le zero_lt_one (le_max_left _ _)\n  have εK := div_pos (half_pos ε0) K0\n  refine ⟨_, εK, fun {a₁ a₂ b₁ b₂} ha₁ hb₂ h₁ h₂ => ?_⟩\n  replace ha₁ := lt_of_lt_of_le ha₁ (le_trans (le_max_left _ K₂) (le_max_right 1 _))\n  replace hb₂ := lt_of_lt_of_le hb₂ (le_trans (le_max_right K₁ _) (le_max_right 1 _))\n  set M := max 1 (max K₁ K₂)\n  have : abv (a₁ - b₁) * abv b₂ + abv (a₂ - b₂) * abv a₁ < ε / 2 / M * M + ε / 2 / M * M := by\n    gcongr\n  rw [← abv_mul abv, mul_comm, div_mul_cancel₀ _ (ne_of_gt K0), ← abv_mul abv, add_halves] at this\n  simpa [sub_eq_add_neg, mul_add, add_mul, add_left_comm] using\n    lt_of_le_of_lt (abv_add abv _ _) this\n\n"}
{"name":"rat_inv_continuous_lemma","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\ninst✝² : LinearOrderedField α\nβ : Type u_3\ninst✝¹ : DivisionRing β\nabv : β → α\ninst✝ : IsAbsoluteValue abv\nε K : α\nε0 : LT.lt 0 ε\nK0 : LT.lt 0 K\n⊢ Exists fun δ => And (GT.gt δ 0) (∀ {a b : β}, LE.le K (abv a) → LE.le K (abv b) → LT.lt (abv (HSub.hSub a b)) δ → LT.lt (abv (HSub.hSub (Inv.inv a) (Inv.inv b))) ε)","decl":"theorem rat_inv_continuous_lemma {β : Type*} [DivisionRing β] (abv : β → α) [IsAbsoluteValue abv]\n    {ε K : α} (ε0 : 0 < ε) (K0 : 0 < K) :\n    ∃ δ > 0, ∀ {a b : β}, K ≤ abv a → K ≤ abv b → abv (a - b) < δ → abv (a⁻¹ - b⁻¹) < ε := by\n  refine ⟨K * ε * K, mul_pos (mul_pos K0 ε0) K0, fun {a b} ha hb h => ?_⟩\n  have a0 := K0.trans_le ha\n  have b0 := K0.trans_le hb\n  rw [inv_sub_inv' ((abv_pos abv).1 a0) ((abv_pos abv).1 b0), abv_mul abv, abv_mul abv, abv_inv abv,\n    abv_inv abv, abv_sub abv]\n  refine lt_of_mul_lt_mul_left (lt_of_mul_lt_mul_right ?_ b0.le) a0.le\n  rw [mul_assoc, inv_mul_cancel_right₀ b0.ne', ← mul_assoc, mul_inv_cancel₀ a0.ne', one_mul]\n  refine h.trans_le ?_\n  gcongr\n\n"}
{"name":"IsCauSeq.cauchy₂","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : LinearOrderedField α\ninst✝¹ : Ring β\nabv : β → α\ninst✝ : IsAbsoluteValue abv\nf : Nat → β\nhf : IsCauSeq abv f\nε : α\nε0 : LT.lt 0 ε\n⊢ Exists fun i => ∀ (j : Nat), GE.ge j i → ∀ (k : Nat), GE.ge k i → LT.lt (abv (HSub.hSub (f j) (f k))) ε","decl":"theorem cauchy₂ (hf : IsCauSeq abv f) {ε : α} (ε0 : 0 < ε) :\n    ∃ i, ∀ j ≥ i, ∀ k ≥ i, abv (f j - f k) < ε := by\n  refine (hf _ (half_pos ε0)).imp fun i hi j ij k ik => ?_\n  rw [← add_halves ε]\n  refine lt_of_le_of_lt (abv_sub_le abv _ _ _) (add_lt_add (hi _ ij) ?_)\n  rw [abv_sub abv]; exact hi _ ik\n\n"}
{"name":"IsCauSeq.cauchy₃","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : LinearOrderedField α\ninst✝¹ : Ring β\nabv : β → α\ninst✝ : IsAbsoluteValue abv\nf : Nat → β\nhf : IsCauSeq abv f\nε : α\nε0 : LT.lt 0 ε\n⊢ Exists fun i => ∀ (j : Nat), GE.ge j i → ∀ (k : Nat), GE.ge k j → LT.lt (abv (HSub.hSub (f k) (f j))) ε","decl":"theorem cauchy₃ (hf : IsCauSeq abv f) {ε : α} (ε0 : 0 < ε) :\n    ∃ i, ∀ j ≥ i, ∀ k ≥ j, abv (f k - f j) < ε :=\n  let ⟨i, H⟩ := hf.cauchy₂ ε0\n  ⟨i, fun _ ij _ jk => H _ (le_trans ij jk) _ ij⟩\n\n"}
{"name":"IsCauSeq.bounded","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : LinearOrderedField α\ninst✝¹ : Ring β\nabv : β → α\ninst✝ : IsAbsoluteValue abv\nf : Nat → β\nhf : IsCauSeq abv f\n⊢ Exists fun r => ∀ (i : Nat), LT.lt (abv (f i)) r","decl":"lemma bounded (hf : IsCauSeq abv f) : ∃ r, ∀ i, abv (f i) < r := by\n  obtain ⟨i, h⟩ := hf _ zero_lt_one\n  set R : ℕ → α := @Nat.rec (fun _ => α) (abv (f 0)) fun i c => max c (abv (f i.succ)) with hR\n  have : ∀ i, ∀ j ≤ i, abv (f j) ≤ R i := by\n    refine Nat.rec (by simp [hR]) ?_\n    rintro i hi j (rfl | hj)\n    · simp [R]\n    · exact (hi j hj).trans (le_max_left _ _)\n  refine ⟨R i + 1, fun j ↦ ?_⟩\n  obtain hji | hij := le_total j i\n  · exact (this i _ hji).trans_lt (lt_add_one _)\n  · simpa using (abv_add abv _ _).trans_lt <| add_lt_add_of_le_of_lt (this i _ le_rfl) (h _ hij)\n\n"}
{"name":"IsCauSeq.bounded'","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : LinearOrderedField α\ninst✝¹ : Ring β\nabv : β → α\ninst✝ : IsAbsoluteValue abv\nf : Nat → β\nhf : IsCauSeq abv f\nx : α\n⊢ Exists fun r => And (GT.gt r x) (∀ (i : Nat), LT.lt (abv (f i)) r)","decl":"lemma bounded' (hf : IsCauSeq abv f) (x : α) : ∃ r > x, ∀ i, abv (f i) < r :=\n  let ⟨r, h⟩ := hf.bounded\n  ⟨max r (x + 1), (lt_add_one x).trans_le (le_max_right _ _),\n    fun i ↦ (h i).trans_le (le_max_left _ _)⟩\n\n"}
{"name":"IsCauSeq.const","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : LinearOrderedField α\ninst✝¹ : Ring β\nabv : β → α\ninst✝ : IsAbsoluteValue abv\nx : β\n⊢ IsCauSeq abv fun x_1 => x","decl":"lemma const (x : β) : IsCauSeq abv fun _ ↦ x :=\n  fun ε ε0 ↦ ⟨0, fun j _ => by simpa [abv_zero] using ε0⟩\n\n"}
{"name":"IsCauSeq.add","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : LinearOrderedField α\ninst✝¹ : Ring β\nabv : β → α\ninst✝ : IsAbsoluteValue abv\nf g : Nat → β\nhf : IsCauSeq abv f\nhg : IsCauSeq abv g\n⊢ IsCauSeq abv (HAdd.hAdd f g)","decl":"theorem add (hf : IsCauSeq abv f) (hg : IsCauSeq abv g) : IsCauSeq abv (f + g) := fun _ ε0 =>\n  let ⟨_, δ0, Hδ⟩ := rat_add_continuous_lemma abv ε0\n  let ⟨i, H⟩ := exists_forall_ge_and (hf.cauchy₃ δ0) (hg.cauchy₃ δ0)\n  ⟨i, fun _ ij =>\n    let ⟨H₁, H₂⟩ := H _ le_rfl\n    Hδ (H₁ _ ij) (H₂ _ ij)⟩\n\n"}
{"name":"IsCauSeq.mul","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : LinearOrderedField α\ninst✝¹ : Ring β\nabv : β → α\ninst✝ : IsAbsoluteValue abv\nf g : Nat → β\nhf : IsCauSeq abv f\nhg : IsCauSeq abv g\n⊢ IsCauSeq abv (HMul.hMul f g)","decl":"lemma mul (hf : IsCauSeq abv f) (hg : IsCauSeq abv g) : IsCauSeq abv (f * g) := fun _ ε0 =>\n  let ⟨_, _, hF⟩ := hf.bounded' 0\n  let ⟨_, _, hG⟩ := hg.bounded' 0\n  let ⟨_, δ0, Hδ⟩ := rat_mul_continuous_lemma abv ε0\n  let ⟨i, H⟩ := exists_forall_ge_and (hf.cauchy₃ δ0) (hg.cauchy₃ δ0)\n  ⟨i, fun j ij =>\n    let ⟨H₁, H₂⟩ := H _ le_rfl\n    Hδ (hF j) (hG i) (H₁ _ ij) (H₂ _ ij)⟩\n\n"}
{"name":"isCauSeq_neg","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : LinearOrderedField α\ninst✝¹ : Ring β\nabv : β → α\ninst✝ : IsAbsoluteValue abv\nf : Nat → β\n⊢ Iff (IsCauSeq abv (Neg.neg f)) (IsCauSeq abv f)","decl":"@[simp] lemma _root_.isCauSeq_neg : IsCauSeq abv (-f) ↔ IsCauSeq abv f := by\n  simp only [IsCauSeq, Pi.neg_apply, ← neg_sub', abv_neg]\n\n"}
{"name":"IsCauSeq.of_neg","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : LinearOrderedField α\ninst✝¹ : Ring β\nabv : β → α\ninst✝ : IsAbsoluteValue abv\nf : Nat → β\na✝ : IsCauSeq abv (Neg.neg f)\n⊢ IsCauSeq abv f","decl":"protected alias ⟨of_neg, neg⟩ := isCauSeq_neg\n\n"}
{"name":"IsCauSeq.neg","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : LinearOrderedField α\ninst✝¹ : Ring β\nabv : β → α\ninst✝ : IsAbsoluteValue abv\nf : Nat → β\na✝ : IsCauSeq abv f\n⊢ IsCauSeq abv (Neg.neg f)","decl":"protected alias ⟨of_neg, neg⟩ := isCauSeq_neg\n\n"}
{"name":"CauSeq.ext","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : LinearOrderedField α\ninst✝ : Ring β\nabv : β → α\nf g : CauSeq β abv\nh : ∀ (i : Nat), Eq (↑f i) (↑g i)\n⊢ Eq f g","decl":"@[ext]\ntheorem ext {f g : CauSeq β abv} (h : ∀ i, f i = g i) : f = g := Subtype.eq (funext h)\n\n"}
{"name":"CauSeq.ext_iff","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : LinearOrderedField α\ninst✝ : Ring β\nabv : β → α\nf g : CauSeq β abv\n⊢ Iff (Eq f g) (∀ (i : Nat), Eq (↑f i) (↑g i))","decl":"@[ext]\ntheorem ext {f g : CauSeq β abv} (h : ∀ i, f i = g i) : f = g := Subtype.eq (funext h)\n\n"}
{"name":"CauSeq.isCauSeq","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : LinearOrderedField α\ninst✝ : Ring β\nabv : β → α\nf : CauSeq β abv\n⊢ IsCauSeq abv ↑f","decl":"theorem isCauSeq (f : CauSeq β abv) : IsCauSeq abv f :=\n  f.2\n\n"}
{"name":"CauSeq.cauchy","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : LinearOrderedField α\ninst✝ : Ring β\nabv : β → α\nf : CauSeq β abv\nε : α\na✝ : LT.lt 0 ε\n⊢ Exists fun i => ∀ (j : Nat), GE.ge j i → LT.lt (abv (HSub.hSub (↑f j) (↑f i))) ε","decl":"theorem cauchy (f : CauSeq β abv) : ∀ {ε}, 0 < ε → ∃ i, ∀ j ≥ i, abv (f j - f i) < ε := @f.2\n\n"}
{"name":"CauSeq.cauchy₂","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : LinearOrderedField α\ninst✝¹ : Ring β\nabv : β → α\ninst✝ : IsAbsoluteValue abv\nf : CauSeq β abv\nε : α\na✝ : LT.lt 0 ε\n⊢ Exists fun i => ∀ (j : Nat), GE.ge j i → ∀ (k : Nat), GE.ge k i → LT.lt (abv (HSub.hSub (↑f j) (↑f k))) ε","decl":"theorem cauchy₂ (f : CauSeq β abv) {ε} :\n    0 < ε → ∃ i, ∀ j ≥ i, ∀ k ≥ i, abv (f j - f k) < ε :=\n  f.2.cauchy₂\n\n"}
{"name":"CauSeq.cauchy₃","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : LinearOrderedField α\ninst✝¹ : Ring β\nabv : β → α\ninst✝ : IsAbsoluteValue abv\nf : CauSeq β abv\nε : α\na✝ : LT.lt 0 ε\n⊢ Exists fun i => ∀ (j : Nat), GE.ge j i → ∀ (k : Nat), GE.ge k j → LT.lt (abv (HSub.hSub (↑f k) (↑f j))) ε","decl":"theorem cauchy₃ (f : CauSeq β abv) {ε} : 0 < ε → ∃ i, ∀ j ≥ i, ∀ k ≥ j, abv (f k - f j) < ε :=\n  f.2.cauchy₃\n\n"}
{"name":"CauSeq.bounded","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : LinearOrderedField α\ninst✝¹ : Ring β\nabv : β → α\ninst✝ : IsAbsoluteValue abv\nf : CauSeq β abv\n⊢ Exists fun r => ∀ (i : Nat), LT.lt (abv (↑f i)) r","decl":"theorem bounded (f : CauSeq β abv) : ∃ r, ∀ i, abv (f i) < r := f.2.bounded\n\n"}
{"name":"CauSeq.bounded'","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : LinearOrderedField α\ninst✝¹ : Ring β\nabv : β → α\ninst✝ : IsAbsoluteValue abv\nf : CauSeq β abv\nx : α\n⊢ Exists fun r => And (GT.gt r x) (∀ (i : Nat), LT.lt (abv (↑f i)) r)","decl":"theorem bounded' (f : CauSeq β abv) (x : α) : ∃ r > x, ∀ i, abv (f i) < r := f.2.bounded' x\n\n"}
{"name":"CauSeq.coe_add","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : LinearOrderedField α\ninst✝¹ : Ring β\nabv : β → α\ninst✝ : IsAbsoluteValue abv\nf g : CauSeq β abv\n⊢ Eq (↑(HAdd.hAdd f g)) (HAdd.hAdd ↑f ↑g)","decl":"@[simp, norm_cast]\ntheorem coe_add (f g : CauSeq β abv) : ⇑(f + g) = (f : ℕ → β) + g :=\n  rfl\n\n"}
{"name":"CauSeq.add_apply","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : LinearOrderedField α\ninst✝¹ : Ring β\nabv : β → α\ninst✝ : IsAbsoluteValue abv\nf g : CauSeq β abv\ni : Nat\n⊢ Eq (↑(HAdd.hAdd f g) i) (HAdd.hAdd (↑f i) (↑g i))","decl":"@[simp, norm_cast]\ntheorem add_apply (f g : CauSeq β abv) (i : ℕ) : (f + g) i = f i + g i :=\n  rfl\n\n"}
{"name":"CauSeq.coe_const","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : LinearOrderedField α\ninst✝¹ : Ring β\nabv : β → α\ninst✝ : IsAbsoluteValue abv\nx : β\n⊢ Eq (↑(CauSeq.const abv x)) (Function.const Nat x)","decl":"@[simp, norm_cast]\ntheorem coe_const (x : β) : (const x : ℕ → β) = Function.const ℕ x :=\n  rfl\n\n"}
{"name":"CauSeq.const_apply","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : LinearOrderedField α\ninst✝¹ : Ring β\nabv : β → α\ninst✝ : IsAbsoluteValue abv\nx : β\ni : Nat\n⊢ Eq (↑(CauSeq.const abv x) i) x","decl":"@[simp, norm_cast]\ntheorem const_apply (x : β) (i : ℕ) : (const x : ℕ → β) i = x :=\n  rfl\n\n"}
{"name":"CauSeq.const_inj","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : LinearOrderedField α\ninst✝¹ : Ring β\nabv : β → α\ninst✝ : IsAbsoluteValue abv\nx y : β\n⊢ Iff (Eq (CauSeq.const abv x) (CauSeq.const abv y)) (Eq x y)","decl":"theorem const_inj {x y : β} : (const x : CauSeq β abv) = const y ↔ x = y :=\n  ⟨fun h => congr_arg (fun f : CauSeq β abv => (f : ℕ → β) 0) h, congr_arg _⟩\n\n"}
{"name":"CauSeq.coe_zero","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : LinearOrderedField α\ninst✝¹ : Ring β\nabv : β → α\ninst✝ : IsAbsoluteValue abv\n⊢ Eq (↑0) 0","decl":"@[simp, norm_cast]\ntheorem coe_zero : ⇑(0 : CauSeq β abv) = 0 :=\n  rfl\n\n"}
{"name":"CauSeq.coe_one","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : LinearOrderedField α\ninst✝¹ : Ring β\nabv : β → α\ninst✝ : IsAbsoluteValue abv\n⊢ Eq (↑1) 1","decl":"@[simp, norm_cast]\ntheorem coe_one : ⇑(1 : CauSeq β abv) = 1 :=\n  rfl\n\n"}
{"name":"CauSeq.zero_apply","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : LinearOrderedField α\ninst✝¹ : Ring β\nabv : β → α\ninst✝ : IsAbsoluteValue abv\ni : Nat\n⊢ Eq (↑0 i) 0","decl":"@[simp, norm_cast]\ntheorem zero_apply (i) : (0 : CauSeq β abv) i = 0 :=\n  rfl\n\n"}
{"name":"CauSeq.one_apply","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : LinearOrderedField α\ninst✝¹ : Ring β\nabv : β → α\ninst✝ : IsAbsoluteValue abv\ni : Nat\n⊢ Eq (↑1 i) 1","decl":"@[simp, norm_cast]\ntheorem one_apply (i) : (1 : CauSeq β abv) i = 1 :=\n  rfl\n\n"}
{"name":"CauSeq.const_zero","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : LinearOrderedField α\ninst✝¹ : Ring β\nabv : β → α\ninst✝ : IsAbsoluteValue abv\n⊢ Eq (CauSeq.const abv 0) 0","decl":"@[simp]\ntheorem const_zero : const 0 = 0 :=\n  rfl\n\n"}
{"name":"CauSeq.const_one","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : LinearOrderedField α\ninst✝¹ : Ring β\nabv : β → α\ninst✝ : IsAbsoluteValue abv\n⊢ Eq (CauSeq.const abv 1) 1","decl":"@[simp]\ntheorem const_one : const 1 = 1 :=\n  rfl\n\n"}
{"name":"CauSeq.const_add","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : LinearOrderedField α\ninst✝¹ : Ring β\nabv : β → α\ninst✝ : IsAbsoluteValue abv\nx y : β\n⊢ Eq (CauSeq.const abv (HAdd.hAdd x y)) (HAdd.hAdd (CauSeq.const abv x) (CauSeq.const abv y))","decl":"theorem const_add (x y : β) : const (x + y) = const x + const y :=\n  rfl\n\n"}
{"name":"CauSeq.coe_mul","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : LinearOrderedField α\ninst✝¹ : Ring β\nabv : β → α\ninst✝ : IsAbsoluteValue abv\nf g : CauSeq β abv\n⊢ Eq (↑(HMul.hMul f g)) (HMul.hMul ↑f ↑g)","decl":"@[simp, norm_cast]\ntheorem coe_mul (f g : CauSeq β abv) : ⇑(f * g) = (f : ℕ → β) * g :=\n  rfl\n\n"}
{"name":"CauSeq.mul_apply","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : LinearOrderedField α\ninst✝¹ : Ring β\nabv : β → α\ninst✝ : IsAbsoluteValue abv\nf g : CauSeq β abv\ni : Nat\n⊢ Eq (↑(HMul.hMul f g) i) (HMul.hMul (↑f i) (↑g i))","decl":"@[simp, norm_cast]\ntheorem mul_apply (f g : CauSeq β abv) (i : ℕ) : (f * g) i = f i * g i :=\n  rfl\n\n"}
{"name":"CauSeq.const_mul","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : LinearOrderedField α\ninst✝¹ : Ring β\nabv : β → α\ninst✝ : IsAbsoluteValue abv\nx y : β\n⊢ Eq (CauSeq.const abv (HMul.hMul x y)) (HMul.hMul (CauSeq.const abv x) (CauSeq.const abv y))","decl":"theorem const_mul (x y : β) : const (x * y) = const x * const y :=\n  rfl\n\n"}
{"name":"CauSeq.coe_neg","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : LinearOrderedField α\ninst✝¹ : Ring β\nabv : β → α\ninst✝ : IsAbsoluteValue abv\nf : CauSeq β abv\n⊢ Eq (↑(Neg.neg f)) (Neg.neg ↑f)","decl":"@[simp, norm_cast]\ntheorem coe_neg (f : CauSeq β abv) : ⇑(-f) = -f :=\n  rfl\n\n"}
{"name":"CauSeq.neg_apply","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : LinearOrderedField α\ninst✝¹ : Ring β\nabv : β → α\ninst✝ : IsAbsoluteValue abv\nf : CauSeq β abv\ni : Nat\n⊢ Eq (↑(Neg.neg f) i) (Neg.neg (↑f i))","decl":"@[simp, norm_cast]\ntheorem neg_apply (f : CauSeq β abv) (i) : (-f) i = -f i :=\n  rfl\n\n"}
{"name":"CauSeq.const_neg","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : LinearOrderedField α\ninst✝¹ : Ring β\nabv : β → α\ninst✝ : IsAbsoluteValue abv\nx : β\n⊢ Eq (CauSeq.const abv (Neg.neg x)) (Neg.neg (CauSeq.const abv x))","decl":"theorem const_neg (x : β) : const (-x) = -const x :=\n  rfl\n\n"}
{"name":"CauSeq.coe_sub","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : LinearOrderedField α\ninst✝¹ : Ring β\nabv : β → α\ninst✝ : IsAbsoluteValue abv\nf g : CauSeq β abv\n⊢ Eq (↑(HSub.hSub f g)) (HSub.hSub ↑f ↑g)","decl":"@[simp, norm_cast]\ntheorem coe_sub (f g : CauSeq β abv) : ⇑(f - g) = (f : ℕ → β) - g :=\n  rfl\n\n"}
{"name":"CauSeq.sub_apply","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : LinearOrderedField α\ninst✝¹ : Ring β\nabv : β → α\ninst✝ : IsAbsoluteValue abv\nf g : CauSeq β abv\ni : Nat\n⊢ Eq (↑(HSub.hSub f g) i) (HSub.hSub (↑f i) (↑g i))","decl":"@[simp, norm_cast]\ntheorem sub_apply (f g : CauSeq β abv) (i : ℕ) : (f - g) i = f i - g i :=\n  rfl\n\n"}
{"name":"CauSeq.const_sub","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : LinearOrderedField α\ninst✝¹ : Ring β\nabv : β → α\ninst✝ : IsAbsoluteValue abv\nx y : β\n⊢ Eq (CauSeq.const abv (HSub.hSub x y)) (HSub.hSub (CauSeq.const abv x) (CauSeq.const abv y))","decl":"theorem const_sub (x y : β) : const (x - y) = const x - const y :=\n  rfl\n\n"}
{"name":"CauSeq.coe_smul","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁴ : LinearOrderedField α\ninst✝³ : Ring β\nabv : β → α\ninst✝² : IsAbsoluteValue abv\nG : Type u_3\ninst✝¹ : SMul G β\ninst✝ : IsScalarTower G β β\na : G\nf : CauSeq β abv\n⊢ Eq (↑(HSMul.hSMul a f)) (HSMul.hSMul a ↑f)","decl":"@[simp, norm_cast]\ntheorem coe_smul (a : G) (f : CauSeq β abv) : ⇑(a • f) = a • (f : ℕ → β) :=\n  rfl\n\n"}
{"name":"CauSeq.smul_apply","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁴ : LinearOrderedField α\ninst✝³ : Ring β\nabv : β → α\ninst✝² : IsAbsoluteValue abv\nG : Type u_3\ninst✝¹ : SMul G β\ninst✝ : IsScalarTower G β β\na : G\nf : CauSeq β abv\ni : Nat\n⊢ Eq (↑(HSMul.hSMul a f) i) (HSMul.hSMul a (↑f i))","decl":"@[simp, norm_cast]\ntheorem smul_apply (a : G) (f : CauSeq β abv) (i : ℕ) : (a • f) i = a • f i :=\n  rfl\n\n"}
{"name":"CauSeq.const_smul","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁴ : LinearOrderedField α\ninst✝³ : Ring β\nabv : β → α\ninst✝² : IsAbsoluteValue abv\nG : Type u_3\ninst✝¹ : SMul G β\ninst✝ : IsScalarTower G β β\na : G\nx : β\n⊢ Eq (CauSeq.const abv (HSMul.hSMul a x)) (HSMul.hSMul a (CauSeq.const abv x))","decl":"theorem const_smul (a : G) (x : β) : const (a • x) = a • const x :=\n  rfl\n\n"}
{"name":"CauSeq.instIsScalarTower","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁴ : LinearOrderedField α\ninst✝³ : Ring β\nabv : β → α\ninst✝² : IsAbsoluteValue abv\nG : Type u_3\ninst✝¹ : SMul G β\ninst✝ : IsScalarTower G β β\n⊢ IsScalarTower G (CauSeq β abv) (CauSeq β abv)","decl":"instance : IsScalarTower G (CauSeq β abv) (CauSeq β abv) :=\n  ⟨fun a f g => Subtype.ext <| smul_assoc a (f : ℕ → β) (g : ℕ → β)⟩\n\n"}
{"name":"CauSeq.coe_pow","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : LinearOrderedField α\ninst✝¹ : Ring β\nabv : β → α\ninst✝ : IsAbsoluteValue abv\nf : CauSeq β abv\nn : Nat\n⊢ Eq (↑(HPow.hPow f n)) (HPow.hPow (↑f) n)","decl":"@[simp, norm_cast]\ntheorem coe_pow (f : CauSeq β abv) (n : ℕ) : ⇑(f ^ n) = (f : ℕ → β) ^ n :=\n  rfl\n\n"}
{"name":"CauSeq.pow_apply","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : LinearOrderedField α\ninst✝¹ : Ring β\nabv : β → α\ninst✝ : IsAbsoluteValue abv\nf : CauSeq β abv\nn i : Nat\n⊢ Eq (↑(HPow.hPow f n) i) (HPow.hPow (↑f i) n)","decl":"@[simp, norm_cast]\ntheorem pow_apply (f : CauSeq β abv) (n i : ℕ) : (f ^ n) i = f i ^ n :=\n  rfl\n\n"}
{"name":"CauSeq.const_pow","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : LinearOrderedField α\ninst✝¹ : Ring β\nabv : β → α\ninst✝ : IsAbsoluteValue abv\nx : β\nn : Nat\n⊢ Eq (CauSeq.const abv (HPow.hPow x n)) (HPow.hPow (CauSeq.const abv x) n)","decl":"theorem const_pow (x : β) (n : ℕ) : const (x ^ n) = const x ^ n :=\n  rfl\n\n"}
{"name":"CauSeq.add_limZero","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : LinearOrderedField α\ninst✝¹ : Ring β\nabv : β → α\ninst✝ : IsAbsoluteValue abv\nf g : CauSeq β abv\nhf : f.LimZero\nhg : g.LimZero\n⊢ (HAdd.hAdd f g).LimZero","decl":"theorem add_limZero {f g : CauSeq β abv} (hf : LimZero f) (hg : LimZero g) : LimZero (f + g)\n  | ε, ε0 =>\n    (exists_forall_ge_and (hf _ <| half_pos ε0) (hg _ <| half_pos ε0)).imp fun _ H j ij => by\n      let ⟨H₁, H₂⟩ := H _ ij\n      simpa [add_halves ε] using lt_of_le_of_lt (abv_add abv _ _) (add_lt_add H₁ H₂)\n\n"}
{"name":"CauSeq.mul_limZero_right","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : LinearOrderedField α\ninst✝¹ : Ring β\nabv : β → α\ninst✝ : IsAbsoluteValue abv\nf g : CauSeq β abv\nhg : g.LimZero\n⊢ (HMul.hMul f g).LimZero","decl":"theorem mul_limZero_right (f : CauSeq β abv) {g} (hg : LimZero g) : LimZero (f * g)\n  | ε, ε0 =>\n    let ⟨F, F0, hF⟩ := f.bounded' 0\n    (hg _ <| div_pos ε0 F0).imp fun _ H j ij => by\n      have := mul_lt_mul' (le_of_lt <| hF j) (H _ ij) (abv_nonneg abv _) F0\n      rwa [mul_comm F, div_mul_cancel₀ _ (ne_of_gt F0), ← abv_mul] at this\n\n"}
{"name":"CauSeq.mul_limZero_left","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : LinearOrderedField α\ninst✝¹ : Ring β\nabv : β → α\ninst✝ : IsAbsoluteValue abv\nf g : CauSeq β abv\nhg : f.LimZero\n⊢ (HMul.hMul f g).LimZero","decl":"theorem mul_limZero_left {f} (g : CauSeq β abv) (hg : LimZero f) : LimZero (f * g)\n  | ε, ε0 =>\n    let ⟨G, G0, hG⟩ := g.bounded' 0\n    (hg _ <| div_pos ε0 G0).imp fun _ H j ij => by\n      have := mul_lt_mul'' (H _ ij) (hG j) (abv_nonneg abv _) (abv_nonneg abv _)\n      rwa [div_mul_cancel₀ _ (ne_of_gt G0), ← abv_mul] at this\n\n"}
{"name":"CauSeq.neg_limZero","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : LinearOrderedField α\ninst✝¹ : Ring β\nabv : β → α\ninst✝ : IsAbsoluteValue abv\nf : CauSeq β abv\nhf : f.LimZero\n⊢ (Neg.neg f).LimZero","decl":"theorem neg_limZero {f : CauSeq β abv} (hf : LimZero f) : LimZero (-f) := by\n  rw [← neg_one_mul f]\n  exact mul_limZero_right _ hf\n\n"}
{"name":"CauSeq.sub_limZero","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : LinearOrderedField α\ninst✝¹ : Ring β\nabv : β → α\ninst✝ : IsAbsoluteValue abv\nf g : CauSeq β abv\nhf : f.LimZero\nhg : g.LimZero\n⊢ (HSub.hSub f g).LimZero","decl":"theorem sub_limZero {f g : CauSeq β abv} (hf : LimZero f) (hg : LimZero g) : LimZero (f - g) := by\n  simpa only [sub_eq_add_neg] using add_limZero hf (neg_limZero hg)\n\n"}
{"name":"CauSeq.limZero_sub_rev","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : LinearOrderedField α\ninst✝¹ : Ring β\nabv : β → α\ninst✝ : IsAbsoluteValue abv\nf g : CauSeq β abv\nhfg : (HSub.hSub f g).LimZero\n⊢ (HSub.hSub g f).LimZero","decl":"theorem limZero_sub_rev {f g : CauSeq β abv} (hfg : LimZero (f - g)) : LimZero (g - f) := by\n  simpa using neg_limZero hfg\n\n"}
{"name":"CauSeq.zero_limZero","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : LinearOrderedField α\ninst✝¹ : Ring β\nabv : β → α\ninst✝ : IsAbsoluteValue abv\n⊢ CauSeq.LimZero 0","decl":"theorem zero_limZero : LimZero (0 : CauSeq β abv)\n  | ε, ε0 => ⟨0, fun j _ => by simpa [abv_zero abv] using ε0⟩\n\n"}
{"name":"CauSeq.const_limZero","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : LinearOrderedField α\ninst✝¹ : Ring β\nabv : β → α\ninst✝ : IsAbsoluteValue abv\nx : β\n⊢ Iff (CauSeq.const abv x).LimZero (Eq x 0)","decl":"theorem const_limZero {x : β} : LimZero (const x) ↔ x = 0 :=\n  ⟨fun H =>\n    (abv_eq_zero abv).1 <|\n      (eq_of_le_of_forall_lt_imp_le_of_dense (abv_nonneg abv _)) fun _ ε0 =>\n        let ⟨_, hi⟩ := H _ ε0\n        le_of_lt <| hi _ le_rfl,\n    fun e => e.symm ▸ zero_limZero⟩\n\n"}
{"name":"CauSeq.add_equiv_add","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : LinearOrderedField α\ninst✝¹ : Ring β\nabv : β → α\ninst✝ : IsAbsoluteValue abv\nf1 f2 g1 g2 : CauSeq β abv\nhf : HasEquiv.Equiv f1 f2\nhg : HasEquiv.Equiv g1 g2\n⊢ HasEquiv.Equiv (HAdd.hAdd f1 g1) (HAdd.hAdd f2 g2)","decl":"theorem add_equiv_add {f1 f2 g1 g2 : CauSeq β abv} (hf : f1 ≈ f2) (hg : g1 ≈ g2) :\n    f1 + g1 ≈ f2 + g2 := by simpa only [← add_sub_add_comm] using add_limZero hf hg\n\n"}
{"name":"CauSeq.neg_equiv_neg","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : LinearOrderedField α\ninst✝¹ : Ring β\nabv : β → α\ninst✝ : IsAbsoluteValue abv\nf g : CauSeq β abv\nhf : HasEquiv.Equiv f g\n⊢ HasEquiv.Equiv (Neg.neg f) (Neg.neg g)","decl":"theorem neg_equiv_neg {f g : CauSeq β abv} (hf : f ≈ g) : -f ≈ -g := by\n  simpa only [neg_sub'] using neg_limZero hf\n\n"}
{"name":"CauSeq.sub_equiv_sub","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : LinearOrderedField α\ninst✝¹ : Ring β\nabv : β → α\ninst✝ : IsAbsoluteValue abv\nf1 f2 g1 g2 : CauSeq β abv\nhf : HasEquiv.Equiv f1 f2\nhg : HasEquiv.Equiv g1 g2\n⊢ HasEquiv.Equiv (HSub.hSub f1 g1) (HSub.hSub f2 g2)","decl":"theorem sub_equiv_sub {f1 f2 g1 g2 : CauSeq β abv} (hf : f1 ≈ f2) (hg : g1 ≈ g2) :\n    f1 - g1 ≈ f2 - g2 := by simpa only [sub_eq_add_neg] using add_equiv_add hf (neg_equiv_neg hg)\n\n"}
{"name":"CauSeq.equiv_def₃","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : LinearOrderedField α\ninst✝¹ : Ring β\nabv : β → α\ninst✝ : IsAbsoluteValue abv\nf g : CauSeq β abv\nh : HasEquiv.Equiv f g\nε : α\nε0 : LT.lt 0 ε\n⊢ Exists fun i => ∀ (j : Nat), GE.ge j i → ∀ (k : Nat), GE.ge k j → LT.lt (abv (HSub.hSub (↑f k) (↑g j))) ε","decl":"theorem equiv_def₃ {f g : CauSeq β abv} (h : f ≈ g) {ε : α} (ε0 : 0 < ε) :\n    ∃ i, ∀ j ≥ i, ∀ k ≥ j, abv (f k - g j) < ε :=\n  (exists_forall_ge_and (h _ <| half_pos ε0) (f.cauchy₃ <| half_pos ε0)).imp fun _ H j ij k jk => by\n    let ⟨h₁, h₂⟩ := H _ ij\n    have := lt_of_le_of_lt (abv_add abv (f j - g j) _) (add_lt_add h₁ (h₂ _ jk))\n    rwa [sub_add_sub_cancel', add_halves] at this\n\n"}
{"name":"CauSeq.limZero_congr","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : LinearOrderedField α\ninst✝¹ : Ring β\nabv : β → α\ninst✝ : IsAbsoluteValue abv\nf g : CauSeq β abv\nh : HasEquiv.Equiv f g\n⊢ Iff f.LimZero g.LimZero","decl":"theorem limZero_congr {f g : CauSeq β abv} (h : f ≈ g) : LimZero f ↔ LimZero g :=\n  ⟨fun l => by simpa using add_limZero (Setoid.symm h) l, fun l => by simpa using add_limZero h l⟩\n\n"}
{"name":"CauSeq.abv_pos_of_not_limZero","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : LinearOrderedField α\ninst✝¹ : Ring β\nabv : β → α\ninst✝ : IsAbsoluteValue abv\nf : CauSeq β abv\nhf : Not f.LimZero\n⊢ Exists fun K => And (GT.gt K 0) (Exists fun i => ∀ (j : Nat), GE.ge j i → LE.le K (abv (↑f j)))","decl":"theorem abv_pos_of_not_limZero {f : CauSeq β abv} (hf : ¬LimZero f) :\n    ∃ K > 0, ∃ i, ∀ j ≥ i, K ≤ abv (f j) := by\n  haveI := Classical.propDecidable\n  by_contra nk\n  refine hf fun ε ε0 => ?_\n  simp? [not_forall] at nk says\n    simp only [gt_iff_lt, ge_iff_le, not_exists, not_and, not_forall, Classical.not_imp,\n      not_le] at nk\n  cases' f.cauchy₃ (half_pos ε0) with i hi\n  rcases nk _ (half_pos ε0) i with ⟨j, ij, hj⟩\n  refine ⟨j, fun k jk => ?_⟩\n  have := lt_of_le_of_lt (abv_add abv _ _) (add_lt_add (hi j ij k jk) hj)\n  rwa [sub_add_cancel, add_halves] at this\n\n"}
{"name":"CauSeq.of_near","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : LinearOrderedField α\ninst✝¹ : Ring β\nabv : β → α\ninst✝ : IsAbsoluteValue abv\nf : Nat → β\ng : CauSeq β abv\nh : ∀ (ε : α), GT.gt ε 0 → Exists fun i => ∀ (j : Nat), GE.ge j i → LT.lt (abv (HSub.hSub (f j) (↑g j))) ε\n⊢ IsCauSeq abv f","decl":"theorem of_near (f : ℕ → β) (g : CauSeq β abv) (h : ∀ ε > 0, ∃ i, ∀ j ≥ i, abv (f j - g j) < ε) :\n    IsCauSeq abv f\n  | ε, ε0 =>\n    let ⟨i, hi⟩ := exists_forall_ge_and (h _ (half_pos <| half_pos ε0)) (g.cauchy₃ <| half_pos ε0)\n    ⟨i, fun j ij => by\n      cases' hi _ le_rfl with h₁ h₂; rw [abv_sub abv] at h₁\n      have := lt_of_le_of_lt (abv_add abv _ _) (add_lt_add (hi _ ij).1 h₁)\n      have := lt_of_le_of_lt (abv_add abv _ _) (add_lt_add this (h₂ _ ij))\n      rwa [add_halves, add_halves, add_right_comm, sub_add_sub_cancel, sub_add_sub_cancel] at this⟩\n\n"}
{"name":"CauSeq.not_limZero_of_not_congr_zero","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : LinearOrderedField α\ninst✝¹ : Ring β\nabv : β → α\ninst✝ : IsAbsoluteValue abv\nf : CauSeq β abv\nhf : Not (HasEquiv.Equiv f 0)\n⊢ Not f.LimZero","decl":"theorem not_limZero_of_not_congr_zero {f : CauSeq _ abv} (hf : ¬f ≈ 0) : ¬LimZero f := by\n  intro h\n  have : LimZero (f - 0) := by simp [h]\n  exact hf this\n\n"}
{"name":"CauSeq.mul_equiv_zero","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : LinearOrderedField α\ninst✝¹ : Ring β\nabv : β → α\ninst✝ : IsAbsoluteValue abv\ng f : CauSeq β abv\nhf : HasEquiv.Equiv f 0\n⊢ HasEquiv.Equiv (HMul.hMul g f) 0","decl":"theorem mul_equiv_zero (g : CauSeq _ abv) {f : CauSeq _ abv} (hf : f ≈ 0) : g * f ≈ 0 :=\n  have : LimZero (f - 0) := hf\n  have : LimZero (g * f) := mul_limZero_right _ <| by simpa\n  show LimZero (g * f - 0) by simpa\n\n"}
{"name":"CauSeq.mul_equiv_zero'","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : LinearOrderedField α\ninst✝¹ : Ring β\nabv : β → α\ninst✝ : IsAbsoluteValue abv\ng f : CauSeq β abv\nhf : HasEquiv.Equiv f 0\n⊢ HasEquiv.Equiv (HMul.hMul f g) 0","decl":"theorem mul_equiv_zero' (g : CauSeq _ abv) {f : CauSeq _ abv} (hf : f ≈ 0) : f * g ≈ 0 :=\n  have : LimZero (f - 0) := hf\n  have : LimZero (f * g) := mul_limZero_left _ <| by simpa\n  show LimZero (f * g - 0) by simpa\n\n"}
{"name":"CauSeq.mul_not_equiv_zero","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : LinearOrderedField α\ninst✝¹ : Ring β\nabv : β → α\ninst✝ : IsAbsoluteValue abv\nf g : CauSeq β abv\nhf : Not (HasEquiv.Equiv f 0)\nhg : Not (HasEquiv.Equiv g 0)\n⊢ Not (HasEquiv.Equiv (HMul.hMul f g) 0)","decl":"theorem mul_not_equiv_zero {f g : CauSeq _ abv} (hf : ¬f ≈ 0) (hg : ¬g ≈ 0) : ¬f * g ≈ 0 :=\n  fun (this : LimZero (f * g - 0)) => by\n  have hlz : LimZero (f * g) := by simpa\n  have hf' : ¬LimZero f := by simpa using show ¬LimZero (f - 0) from hf\n  have hg' : ¬LimZero g := by simpa using show ¬LimZero (g - 0) from hg\n  rcases abv_pos_of_not_limZero hf' with ⟨a1, ha1, N1, hN1⟩\n  rcases abv_pos_of_not_limZero hg' with ⟨a2, ha2, N2, hN2⟩\n  have : 0 < a1 * a2 := mul_pos ha1 ha2\n  cases' hlz _ this with N hN\n  let i := max N (max N1 N2)\n  have hN' := hN i (le_max_left _ _)\n  have hN1' := hN1 i (le_trans (le_max_left _ _) (le_max_right _ _))\n  have hN1' := hN2 i (le_trans (le_max_right _ _) (le_max_right _ _))\n  apply not_le_of_lt hN'\n  change _ ≤ abv (_ * _)\n  rw [abv_mul abv]\n  gcongr\n\n"}
{"name":"CauSeq.const_equiv","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : LinearOrderedField α\ninst✝¹ : Ring β\nabv : β → α\ninst✝ : IsAbsoluteValue abv\nx y : β\n⊢ Iff (HasEquiv.Equiv (CauSeq.const abv x) (CauSeq.const abv y)) (Eq x y)","decl":"theorem const_equiv {x y : β} : const x ≈ const y ↔ x = y :=\n  show LimZero _ ↔ _ by rw [← const_sub, const_limZero, sub_eq_zero]\n\n"}
{"name":"CauSeq.mul_equiv_mul","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : LinearOrderedField α\ninst✝¹ : Ring β\nabv : β → α\ninst✝ : IsAbsoluteValue abv\nf1 f2 g1 g2 : CauSeq β abv\nhf : HasEquiv.Equiv f1 f2\nhg : HasEquiv.Equiv g1 g2\n⊢ HasEquiv.Equiv (HMul.hMul f1 g1) (HMul.hMul f2 g2)","decl":"theorem mul_equiv_mul {f1 f2 g1 g2 : CauSeq β abv} (hf : f1 ≈ f2) (hg : g1 ≈ g2) :\n    f1 * g1 ≈ f2 * g2 := by\n  change LimZero (f1 * g1 - f2 * g2)\n  convert add_limZero (mul_limZero_left g1 hf) (mul_limZero_right f2 hg) using 1\n  rw [mul_sub, sub_mul]\n  -- Porting note: doesn't work with `rw`, but did in Lean 3\n  exact (sub_add_sub_cancel (f1*g1) (f2*g1) (f2*g2)).symm\n  -- Porting note: was\n  /-\n  simpa only [mul_sub, sub_mul, sub_add_sub_cancel] using\n    add_lim_zero (mul_limZero_left g1 hf) (mul_limZero_right f2 hg)\n  -/\n\n"}
{"name":"CauSeq.smul_equiv_smul","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁴ : LinearOrderedField α\ninst✝³ : Ring β\nabv : β → α\ninst✝² : IsAbsoluteValue abv\nG : Type u_3\ninst✝¹ : SMul G β\ninst✝ : IsScalarTower G β β\nf1 f2 : CauSeq β abv\nc : G\nhf : HasEquiv.Equiv f1 f2\n⊢ HasEquiv.Equiv (HSMul.hSMul c f1) (HSMul.hSMul c f2)","decl":"theorem smul_equiv_smul {G : Type*} [SMul G β] [IsScalarTower G β β] {f1 f2 : CauSeq β abv} (c : G)\n    (hf : f1 ≈ f2) : c • f1 ≈ c • f2 := by\n  simpa [const_smul, smul_one_mul _ _] using\n    mul_equiv_mul (const_equiv.mpr <| Eq.refl <| c • (1 : β)) hf\n\n"}
{"name":"CauSeq.pow_equiv_pow","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : LinearOrderedField α\ninst✝¹ : Ring β\nabv : β → α\ninst✝ : IsAbsoluteValue abv\nf1 f2 : CauSeq β abv\nhf : HasEquiv.Equiv f1 f2\nn : Nat\n⊢ HasEquiv.Equiv (HPow.hPow f1 n) (HPow.hPow f2 n)","decl":"theorem pow_equiv_pow {f1 f2 : CauSeq β abv} (hf : f1 ≈ f2) (n : ℕ) : f1 ^ n ≈ f2 ^ n := by\n  induction n with\n  | zero => simp only [pow_zero, Setoid.refl]\n  | succ n ih => simpa only [pow_succ'] using mul_equiv_mul hf ih\n\n"}
{"name":"CauSeq.one_not_equiv_zero","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : LinearOrderedField α\ninst✝² : Ring β\ninst✝¹ : IsDomain β\nabv : β → α\ninst✝ : IsAbsoluteValue abv\n⊢ Not (HasEquiv.Equiv (CauSeq.const abv 1) (CauSeq.const abv 0))","decl":"theorem one_not_equiv_zero : ¬const abv 1 ≈ const abv 0 := fun h =>\n  have : ∀ ε > 0, ∃ i, ∀ k, i ≤ k → abv (1 - 0) < ε := h\n  have h1 : abv 1 ≤ 0 :=\n    le_of_not_gt fun h2 : 0 < abv 1 =>\n      (Exists.elim (this _ h2)) fun i hi => lt_irrefl (abv 1) <| by simpa using hi _ le_rfl\n  have h2 : 0 ≤ abv 1 := abv_nonneg abv _\n  have : abv 1 = 0 := le_antisymm h1 h2\n  have : (1 : β) = 0 := (abv_eq_zero abv).mp this\n  absurd this one_ne_zero\n\n"}
{"name":"CauSeq.inv_aux","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : LinearOrderedField α\ninst✝¹ : DivisionRing β\nabv : β → α\ninst✝ : IsAbsoluteValue abv\nf : CauSeq β abv\nhf : Not f.LimZero\nε : α\na✝ : GT.gt ε 0\n⊢ Exists fun i => ∀ (j : Nat), GE.ge j i → LT.lt (abv (HSub.hSub (Inv.inv (↑f j)) (Inv.inv (↑f i)))) ε","decl":"theorem inv_aux {f : CauSeq β abv} (hf : ¬LimZero f) :\n    ∀ ε > 0, ∃ i, ∀ j ≥ i, abv ((f j)⁻¹ - (f i)⁻¹) < ε\n  | _, ε0 =>\n    let ⟨_, K0, HK⟩ := abv_pos_of_not_limZero hf\n    let ⟨_, δ0, Hδ⟩ := rat_inv_continuous_lemma abv ε0 K0\n    let ⟨i, H⟩ := exists_forall_ge_and HK (f.cauchy₃ δ0)\n    ⟨i, fun _ ij =>\n      let ⟨iK, H'⟩ := H _ le_rfl\n      Hδ (H _ ij).1 iK (H' _ ij)⟩\n\n"}
{"name":"CauSeq.coe_inv","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : LinearOrderedField α\ninst✝¹ : DivisionRing β\nabv : β → α\ninst✝ : IsAbsoluteValue abv\nf : CauSeq β abv\nhf : Not f.LimZero\n⊢ Eq (↑(f.inv hf)) (Inv.inv ↑f)","decl":"@[simp, norm_cast]\ntheorem coe_inv {f : CauSeq β abv} (hf) : ⇑(inv f hf) = (f : ℕ → β)⁻¹ :=\n  rfl\n\n"}
{"name":"CauSeq.inv_apply","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : LinearOrderedField α\ninst✝¹ : DivisionRing β\nabv : β → α\ninst✝ : IsAbsoluteValue abv\nf : CauSeq β abv\nhf : Not f.LimZero\ni : Nat\n⊢ Eq (↑(f.inv hf) i) (Inv.inv (↑f i))","decl":"@[simp, norm_cast]\ntheorem inv_apply {f : CauSeq β abv} (hf i) : inv f hf i = (f i)⁻¹ :=\n  rfl\n\n"}
{"name":"CauSeq.inv_mul_cancel","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : LinearOrderedField α\ninst✝¹ : DivisionRing β\nabv : β → α\ninst✝ : IsAbsoluteValue abv\nf : CauSeq β abv\nhf : Not f.LimZero\n⊢ HasEquiv.Equiv (HMul.hMul (f.inv hf) f) 1","decl":"theorem inv_mul_cancel {f : CauSeq β abv} (hf) : inv f hf * f ≈ 1 := fun ε ε0 =>\n  let ⟨K, K0, i, H⟩ := abv_pos_of_not_limZero hf\n  ⟨i, fun j ij => by simpa [(abv_pos abv).1 (lt_of_lt_of_le K0 (H _ ij)), abv_zero abv] using ε0⟩\n\n"}
{"name":"CauSeq.mul_inv_cancel","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : LinearOrderedField α\ninst✝¹ : DivisionRing β\nabv : β → α\ninst✝ : IsAbsoluteValue abv\nf : CauSeq β abv\nhf : Not f.LimZero\n⊢ HasEquiv.Equiv (HMul.hMul f (f.inv hf)) 1","decl":"theorem mul_inv_cancel {f : CauSeq β abv} (hf) : f * inv f hf ≈ 1 := fun ε ε0 =>\n  let ⟨K, K0, i, H⟩ := abv_pos_of_not_limZero hf\n  ⟨i, fun j ij => by simpa [(abv_pos abv).1 (lt_of_lt_of_le K0 (H _ ij)), abv_zero abv] using ε0⟩\n\n"}
{"name":"CauSeq.const_inv","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : LinearOrderedField α\ninst✝¹ : DivisionRing β\nabv : β → α\ninst✝ : IsAbsoluteValue abv\nx : β\nhx : Ne x 0\n⊢ Eq (CauSeq.const abv (Inv.inv x)) ((CauSeq.const abv x).inv ⋯)","decl":"theorem const_inv {x : β} (hx : x ≠ 0) :\n    const abv x⁻¹ = inv (const abv x) (by rwa [const_limZero]) :=\n  rfl\n\n"}
{"name":"CauSeq.not_limZero_of_pos","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedField α\nf : CauSeq α abs\na✝ : f.Pos\n⊢ Not f.LimZero","decl":"theorem not_limZero_of_pos {f : CauSeq α abs} : Pos f → ¬LimZero f\n  | ⟨_, F0, hF⟩, H =>\n    let ⟨_, h⟩ := exists_forall_ge_and hF (H _ F0)\n    let ⟨h₁, h₂⟩ := h _ le_rfl\n    not_lt_of_le h₁ (abs_lt.1 h₂).2\n\n"}
{"name":"CauSeq.const_pos","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedField α\nx : α\n⊢ Iff (CauSeq.const abs x).Pos (LT.lt 0 x)","decl":"theorem const_pos {x : α} : Pos (const x) ↔ 0 < x :=\n  ⟨fun ⟨_, K0, _, h⟩ => lt_of_lt_of_le K0 (h _ le_rfl), fun h => ⟨x, h, 0, fun _ _ => le_rfl⟩⟩\n\n"}
{"name":"CauSeq.add_pos","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedField α\nf g : CauSeq α abs\na✝¹ : f.Pos\na✝ : g.Pos\n⊢ (HAdd.hAdd f g).Pos","decl":"theorem add_pos {f g : CauSeq α abs} : Pos f → Pos g → Pos (f + g)\n  | ⟨_, F0, hF⟩, ⟨_, G0, hG⟩ =>\n    let ⟨i, h⟩ := exists_forall_ge_and hF hG\n    ⟨_, _root_.add_pos F0 G0, i, fun _ ij =>\n      let ⟨h₁, h₂⟩ := h _ ij\n      add_le_add h₁ h₂⟩\n\n"}
{"name":"CauSeq.pos_add_limZero","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedField α\nf g : CauSeq α abs\na✝¹ : f.Pos\na✝ : g.LimZero\n⊢ (HAdd.hAdd f g).Pos","decl":"theorem pos_add_limZero {f g : CauSeq α abs} : Pos f → LimZero g → Pos (f + g)\n  | ⟨F, F0, hF⟩, H =>\n    let ⟨i, h⟩ := exists_forall_ge_and hF (H _ (half_pos F0))\n    ⟨_, half_pos F0, i, fun j ij => by\n      cases' h j ij with h₁ h₂\n      have := add_le_add h₁ (le_of_lt (abs_lt.1 h₂).1)\n      rwa [← sub_eq_add_neg, sub_self_div_two] at this⟩\n\n"}
{"name":"CauSeq.mul_pos","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedField α\nf g : CauSeq α abs\na✝¹ : f.Pos\na✝ : g.Pos\n⊢ (HMul.hMul f g).Pos","decl":"protected theorem mul_pos {f g : CauSeq α abs} : Pos f → Pos g → Pos (f * g)\n  | ⟨_, F0, hF⟩, ⟨_, G0, hG⟩ =>\n    let ⟨i, h⟩ := exists_forall_ge_and hF hG\n    ⟨_, mul_pos F0 G0, i, fun _ ij =>\n      let ⟨h₁, h₂⟩ := h _ ij\n      mul_le_mul h₁ h₂ (le_of_lt G0) (le_trans (le_of_lt F0) h₁)⟩\n\n"}
{"name":"CauSeq.trichotomy","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedField α\nf : CauSeq α abs\n⊢ Or f.Pos (Or f.LimZero (Neg.neg f).Pos)","decl":"theorem trichotomy (f : CauSeq α abs) : Pos f ∨ LimZero f ∨ Pos (-f) := by\n  cases' Classical.em (LimZero f) with h h <;> simp [*]\n  rcases abv_pos_of_not_limZero h with ⟨K, K0, hK⟩\n  rcases exists_forall_ge_and hK (f.cauchy₃ K0) with ⟨i, hi⟩\n  refine (le_total 0 (f i)).imp ?_ ?_ <;>\n    refine fun h => ⟨K, K0, i, fun j ij => ?_⟩ <;>\n    have := (hi _ ij).1 <;>\n    cases' hi _ le_rfl with h₁ h₂\n  · rwa [abs_of_nonneg] at this\n    rw [abs_of_nonneg h] at h₁\n    exact\n      (le_add_iff_nonneg_right _).1\n        (le_trans h₁ <| neg_le_sub_iff_le_add'.1 <| le_of_lt (abs_lt.1 <| h₂ _ ij).1)\n  · rwa [abs_of_nonpos] at this\n    rw [abs_of_nonpos h] at h₁\n    rw [← sub_le_sub_iff_right, zero_sub]\n    exact le_trans (le_of_lt (abs_lt.1 <| h₂ _ ij).2) h₁\n\n"}
{"name":"CauSeq.lt_of_lt_of_eq","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedField α\nf g h : CauSeq α abs\nfg : LT.lt f g\ngh : HasEquiv.Equiv g h\n⊢ LT.lt f h","decl":"theorem lt_of_lt_of_eq {f g h : CauSeq α abs} (fg : f < g) (gh : g ≈ h) : f < h :=\n  show Pos (h - f) by\n    convert pos_add_limZero fg (neg_limZero gh) using 1\n    simp\n\n"}
{"name":"CauSeq.lt_of_eq_of_lt","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedField α\nf g h : CauSeq α abs\nfg : HasEquiv.Equiv f g\ngh : LT.lt g h\n⊢ LT.lt f h","decl":"theorem lt_of_eq_of_lt {f g h : CauSeq α abs} (fg : f ≈ g) (gh : g < h) : f < h := by\n  have := pos_add_limZero gh (neg_limZero fg)\n  rwa [← sub_eq_add_neg, sub_sub_sub_cancel_right] at this\n\n"}
{"name":"CauSeq.lt_trans","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedField α\nf g h : CauSeq α abs\nfg : LT.lt f g\ngh : LT.lt g h\n⊢ LT.lt f h","decl":"theorem lt_trans {f g h : CauSeq α abs} (fg : f < g) (gh : g < h) : f < h :=\n  show Pos (h - f) by\n    convert add_pos fg gh using 1\n    simp\n\n"}
{"name":"CauSeq.lt_irrefl","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedField α\nf : CauSeq α abs\n⊢ Not (LT.lt f f)","decl":"theorem lt_irrefl {f : CauSeq α abs} : ¬f < f\n  | h => not_limZero_of_pos h (by simp [zero_limZero])\n\n"}
{"name":"CauSeq.le_of_eq_of_le","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedField α\nf g h : CauSeq α abs\nhfg : HasEquiv.Equiv f g\nhgh : LE.le g h\n⊢ LE.le f h","decl":"theorem le_of_eq_of_le {f g h : CauSeq α abs} (hfg : f ≈ g) (hgh : g ≤ h) : f ≤ h :=\n  hgh.elim (Or.inl ∘ CauSeq.lt_of_eq_of_lt hfg) (Or.inr ∘ Setoid.trans hfg)\n\n"}
{"name":"CauSeq.le_of_le_of_eq","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedField α\nf g h : CauSeq α abs\nhfg : LE.le f g\nhgh : HasEquiv.Equiv g h\n⊢ LE.le f h","decl":"theorem le_of_le_of_eq {f g h : CauSeq α abs} (hfg : f ≤ g) (hgh : g ≈ h) : f ≤ h :=\n  hfg.elim (fun h => Or.inl (CauSeq.lt_of_lt_of_eq h hgh)) fun h => Or.inr (Setoid.trans h hgh)\n\n"}
{"name":"CauSeq.le_antisymm","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedField α\nf g : CauSeq α abs\nfg : LE.le f g\ngf : LE.le g f\n⊢ HasEquiv.Equiv f g","decl":"theorem le_antisymm {f g : CauSeq α abs} (fg : f ≤ g) (gf : g ≤ f) : f ≈ g :=\n  fg.resolve_left (not_lt_of_le gf)\n\n"}
{"name":"CauSeq.lt_total","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedField α\nf g : CauSeq α abs\n⊢ Or (LT.lt f g) (Or (HasEquiv.Equiv f g) (LT.lt g f))","decl":"theorem lt_total (f g : CauSeq α abs) : f < g ∨ f ≈ g ∨ g < f :=\n  (trichotomy (g - f)).imp_right fun h =>\n    h.imp (fun h => Setoid.symm h) fun h => by rwa [neg_sub] at h\n\n"}
{"name":"CauSeq.le_total","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedField α\nf g : CauSeq α abs\n⊢ Or (LE.le f g) (LE.le g f)","decl":"theorem le_total (f g : CauSeq α abs) : f ≤ g ∨ g ≤ f :=\n  (or_assoc.2 (lt_total f g)).imp_right Or.inl\n\n"}
{"name":"CauSeq.const_lt","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedField α\nx y : α\n⊢ Iff (LT.lt (CauSeq.const abs x) (CauSeq.const abs y)) (LT.lt x y)","decl":"theorem const_lt {x y : α} : const x < const y ↔ x < y :=\n  show Pos _ ↔ _ by rw [← const_sub, const_pos, sub_pos]\n\n"}
{"name":"CauSeq.const_le","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedField α\nx y : α\n⊢ Iff (LE.le (CauSeq.const abs x) (CauSeq.const abs y)) (LE.le x y)","decl":"theorem const_le {x y : α} : const x ≤ const y ↔ x ≤ y := by\n  rw [le_iff_lt_or_eq]; exact or_congr const_lt const_equiv\n\n"}
{"name":"CauSeq.le_of_exists","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedField α\nf g : CauSeq α abs\nh : Exists fun i => ∀ (j : Nat), GE.ge j i → LE.le (↑f j) (↑g j)\n⊢ LE.le f g","decl":"theorem le_of_exists {f g : CauSeq α abs} (h : ∃ i, ∀ j ≥ i, f j ≤ g j) : f ≤ g :=\n  let ⟨i, hi⟩ := h\n  (or_assoc.2 (CauSeq.lt_total f g)).elim id fun hgf =>\n    False.elim\n      (let ⟨_, hK0, j, hKj⟩ := hgf\n      not_lt_of_ge (hi (max i j) (le_max_left _ _))\n        (sub_pos.1 (lt_of_lt_of_le hK0 (hKj _ (le_max_right _ _)))))\n\n"}
{"name":"CauSeq.exists_gt","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedField α\nf : CauSeq α abs\n⊢ Exists fun a => LT.lt f (CauSeq.const abs a)","decl":"theorem exists_gt (f : CauSeq α abs) : ∃ a : α, f < const a :=\n  let ⟨K, H⟩ := f.bounded\n  ⟨K + 1, 1, zero_lt_one, 0, fun i _ => by\n    rw [sub_apply, const_apply, le_sub_iff_add_le', add_le_add_iff_right]\n    exact le_of_lt (abs_lt.1 (H _)).2⟩\n\n"}
{"name":"CauSeq.exists_lt","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedField α\nf : CauSeq α abs\n⊢ Exists fun a => LT.lt (CauSeq.const abs a) f","decl":"theorem exists_lt (f : CauSeq α abs) : ∃ a : α, const a < f :=\n  let ⟨a, h⟩ := (-f).exists_gt\n  ⟨-a, show Pos _ by rwa [const_neg, sub_neg_eq_add, add_comm, ← sub_neg_eq_add]⟩\n\n-- so named to match `rat_add_continuous_lemma`\n"}
{"name":"CauSeq.rat_sup_continuous_lemma","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedField α\nε a₁ a₂ b₁ b₂ : α\na✝¹ : LT.lt (abs (HSub.hSub a₁ b₁)) ε\na✝ : LT.lt (abs (HSub.hSub a₂ b₂)) ε\n⊢ LT.lt (abs (HSub.hSub (Max.max a₁ a₂) (Max.max b₁ b₂))) ε","decl":"theorem rat_sup_continuous_lemma {ε : α} {a₁ a₂ b₁ b₂ : α} :\n    abs (a₁ - b₁) < ε → abs (a₂ - b₂) < ε → abs (a₁ ⊔ a₂ - b₁ ⊔ b₂) < ε := fun h₁ h₂ =>\n  (abs_max_sub_max_le_max _ _ _ _).trans_lt (max_lt h₁ h₂)\n\n-- so named to match `rat_add_continuous_lemma`\n"}
{"name":"CauSeq.rat_inf_continuous_lemma","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedField α\nε a₁ a₂ b₁ b₂ : α\na✝¹ : LT.lt (abs (HSub.hSub a₁ b₁)) ε\na✝ : LT.lt (abs (HSub.hSub a₂ b₂)) ε\n⊢ LT.lt (abs (HSub.hSub (Min.min a₁ a₂) (Min.min b₁ b₂))) ε","decl":"theorem rat_inf_continuous_lemma {ε : α} {a₁ a₂ b₁ b₂ : α} :\n    abs (a₁ - b₁) < ε → abs (a₂ - b₂) < ε → abs (a₁ ⊓ a₂ - b₁ ⊓ b₂) < ε := fun h₁ h₂ =>\n  (abs_min_sub_min_le_max _ _ _ _).trans_lt (max_lt h₁ h₂)\n\n"}
{"name":"CauSeq.coe_sup","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedField α\nf g : CauSeq α abs\n⊢ Eq (↑(Max.max f g)) (Max.max ↑f ↑g)","decl":"@[simp, norm_cast]\ntheorem coe_sup (f g : CauSeq α abs) : ⇑(f ⊔ g) = (f : ℕ → α) ⊔ g :=\n  rfl\n\n"}
{"name":"CauSeq.coe_inf","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedField α\nf g : CauSeq α abs\n⊢ Eq (↑(Min.min f g)) (Min.min ↑f ↑g)","decl":"@[simp, norm_cast]\ntheorem coe_inf (f g : CauSeq α abs) : ⇑(f ⊓ g) = (f : ℕ → α) ⊓ g :=\n  rfl\n\n"}
{"name":"CauSeq.sup_limZero","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedField α\nf g : CauSeq α abs\nhf : f.LimZero\nhg : g.LimZero\n⊢ (Max.max f g).LimZero","decl":"theorem sup_limZero {f g : CauSeq α abs} (hf : LimZero f) (hg : LimZero g) : LimZero (f ⊔ g)\n  | ε, ε0 =>\n    (exists_forall_ge_and (hf _ ε0) (hg _ ε0)).imp fun _ H j ij => by\n      let ⟨H₁, H₂⟩ := H _ ij\n      rw [abs_lt] at H₁ H₂ ⊢\n      exact ⟨lt_sup_iff.mpr (Or.inl H₁.1), sup_lt_iff.mpr ⟨H₁.2, H₂.2⟩⟩\n\n"}
{"name":"CauSeq.inf_limZero","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedField α\nf g : CauSeq α abs\nhf : f.LimZero\nhg : g.LimZero\n⊢ (Min.min f g).LimZero","decl":"theorem inf_limZero {f g : CauSeq α abs} (hf : LimZero f) (hg : LimZero g) : LimZero (f ⊓ g)\n  | ε, ε0 =>\n    (exists_forall_ge_and (hf _ ε0) (hg _ ε0)).imp fun _ H j ij => by\n      let ⟨H₁, H₂⟩ := H _ ij\n      rw [abs_lt] at H₁ H₂ ⊢\n      exact ⟨lt_inf_iff.mpr ⟨H₁.1, H₂.1⟩, inf_lt_iff.mpr (Or.inl H₁.2)⟩\n\n"}
{"name":"CauSeq.sup_equiv_sup","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedField α\na₁ b₁ a₂ b₂ : CauSeq α abs\nha : HasEquiv.Equiv a₁ a₂\nhb : HasEquiv.Equiv b₁ b₂\n⊢ HasEquiv.Equiv (Max.max a₁ b₁) (Max.max a₂ b₂)","decl":"theorem sup_equiv_sup {a₁ b₁ a₂ b₂ : CauSeq α abs} (ha : a₁ ≈ a₂) (hb : b₁ ≈ b₂) :\n    a₁ ⊔ b₁ ≈ a₂ ⊔ b₂ := by\n  intro ε ε0\n  obtain ⟨ai, hai⟩ := ha ε ε0\n  obtain ⟨bi, hbi⟩ := hb ε ε0\n  exact\n    ⟨ai ⊔ bi, fun i hi =>\n      (abs_max_sub_max_le_max (a₁ i) (b₁ i) (a₂ i) (b₂ i)).trans_lt\n        (max_lt (hai i (sup_le_iff.mp hi).1) (hbi i (sup_le_iff.mp hi).2))⟩\n\n"}
{"name":"CauSeq.inf_equiv_inf","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedField α\na₁ b₁ a₂ b₂ : CauSeq α abs\nha : HasEquiv.Equiv a₁ a₂\nhb : HasEquiv.Equiv b₁ b₂\n⊢ HasEquiv.Equiv (Min.min a₁ b₁) (Min.min a₂ b₂)","decl":"theorem inf_equiv_inf {a₁ b₁ a₂ b₂ : CauSeq α abs} (ha : a₁ ≈ a₂) (hb : b₁ ≈ b₂) :\n    a₁ ⊓ b₁ ≈ a₂ ⊓ b₂ := by\n  intro ε ε0\n  obtain ⟨ai, hai⟩ := ha ε ε0\n  obtain ⟨bi, hbi⟩ := hb ε ε0\n  exact\n    ⟨ai ⊔ bi, fun i hi =>\n      (abs_min_sub_min_le_max (a₁ i) (b₁ i) (a₂ i) (b₂ i)).trans_lt\n        (max_lt (hai i (sup_le_iff.mp hi).1) (hbi i (sup_le_iff.mp hi).2))⟩\n\n"}
{"name":"CauSeq.sup_lt","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedField α\na b c : CauSeq α abs\nha : LT.lt a c\nhb : LT.lt b c\n⊢ LT.lt (Max.max a b) c","decl":"protected theorem sup_lt {a b c : CauSeq α abs} (ha : a < c) (hb : b < c) : a ⊔ b < c := by\n  obtain ⟨⟨εa, εa0, ia, ha⟩, ⟨εb, εb0, ib, hb⟩⟩ := ha, hb\n  refine ⟨εa ⊓ εb, lt_inf_iff.mpr ⟨εa0, εb0⟩, ia ⊔ ib, fun i hi => ?_⟩\n  have := min_le_min (ha _ (sup_le_iff.mp hi).1) (hb _ (sup_le_iff.mp hi).2)\n  exact this.trans_eq (min_sub_sub_left _ _ _)\n\n"}
{"name":"CauSeq.lt_inf","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedField α\na b c : CauSeq α abs\nhb : LT.lt a b\nhc : LT.lt a c\n⊢ LT.lt a (Min.min b c)","decl":"protected theorem lt_inf {a b c : CauSeq α abs} (hb : a < b) (hc : a < c) : a < b ⊓ c := by\n  obtain ⟨⟨εb, εb0, ib, hb⟩, ⟨εc, εc0, ic, hc⟩⟩ := hb, hc\n  refine ⟨εb ⊓ εc, lt_inf_iff.mpr ⟨εb0, εc0⟩, ib ⊔ ic, fun i hi => ?_⟩\n  have := min_le_min (hb _ (sup_le_iff.mp hi).1) (hc _ (sup_le_iff.mp hi).2)\n  exact this.trans_eq (min_sub_sub_right _ _ _)\n\n"}
{"name":"CauSeq.sup_idem","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedField α\na : CauSeq α abs\n⊢ Eq (Max.max a a) a","decl":"@[simp]\nprotected theorem sup_idem (a : CauSeq α abs) : a ⊔ a = a := Subtype.ext (sup_idem _)\n\n"}
{"name":"CauSeq.inf_idem","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedField α\na : CauSeq α abs\n⊢ Eq (Min.min a a) a","decl":"@[simp]\nprotected theorem inf_idem (a : CauSeq α abs) : a ⊓ a = a := Subtype.ext (inf_idem _)\n\n"}
{"name":"CauSeq.sup_comm","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedField α\na b : CauSeq α abs\n⊢ Eq (Max.max a b) (Max.max b a)","decl":"protected theorem sup_comm (a b : CauSeq α abs) : a ⊔ b = b ⊔ a := Subtype.ext (sup_comm _ _)\n\n"}
{"name":"CauSeq.inf_comm","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedField α\na b : CauSeq α abs\n⊢ Eq (Min.min a b) (Min.min b a)","decl":"protected theorem inf_comm (a b : CauSeq α abs) : a ⊓ b = b ⊓ a := Subtype.ext (inf_comm _ _)\n\n"}
{"name":"CauSeq.sup_eq_right","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedField α\na b : CauSeq α abs\nh : LE.le a b\n⊢ HasEquiv.Equiv (Max.max a b) b","decl":"protected theorem sup_eq_right {a b : CauSeq α abs} (h : a ≤ b) : a ⊔ b ≈ b := by\n  obtain ⟨ε, ε0 : _ < _, i, h⟩ | h := h\n  · intro _ _\n    refine ⟨i, fun j hj => ?_⟩\n    dsimp\n    rw [← max_sub_sub_right]\n    rwa [sub_self, max_eq_right, abs_zero]\n    rw [sub_nonpos, ← sub_nonneg]\n    exact ε0.le.trans (h _ hj)\n  · refine Setoid.trans (sup_equiv_sup h (Setoid.refl _)) ?_\n    rw [CauSeq.sup_idem]\n\n"}
{"name":"CauSeq.inf_eq_right","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedField α\na b : CauSeq α abs\nh : LE.le b a\n⊢ HasEquiv.Equiv (Min.min a b) b","decl":"protected theorem inf_eq_right {a b : CauSeq α abs} (h : b ≤ a) : a ⊓ b ≈ b := by\n  obtain ⟨ε, ε0 : _ < _, i, h⟩ | h := h\n  · intro _ _\n    refine ⟨i, fun j hj => ?_⟩\n    dsimp\n    rw [← min_sub_sub_right]\n    rwa [sub_self, min_eq_right, abs_zero]\n    exact ε0.le.trans (h _ hj)\n  · refine Setoid.trans (inf_equiv_inf (Setoid.symm h) (Setoid.refl _)) ?_\n    rw [CauSeq.inf_idem]\n\n"}
{"name":"CauSeq.sup_eq_left","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedField α\na b : CauSeq α abs\nh : LE.le b a\n⊢ HasEquiv.Equiv (Max.max a b) a","decl":"protected theorem sup_eq_left {a b : CauSeq α abs} (h : b ≤ a) : a ⊔ b ≈ a := by\n  simpa only [CauSeq.sup_comm] using CauSeq.sup_eq_right h\n\n"}
{"name":"CauSeq.inf_eq_left","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedField α\na b : CauSeq α abs\nh : LE.le a b\n⊢ HasEquiv.Equiv (Min.min a b) a","decl":"protected theorem inf_eq_left {a b : CauSeq α abs} (h : a ≤ b) : a ⊓ b ≈ a := by\n  simpa only [CauSeq.inf_comm] using CauSeq.inf_eq_right h\n\n"}
{"name":"CauSeq.le_sup_left","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedField α\na b : CauSeq α abs\n⊢ LE.le a (Max.max a b)","decl":"protected theorem le_sup_left {a b : CauSeq α abs} : a ≤ a ⊔ b :=\n  le_of_exists ⟨0, fun _ _ => le_sup_left⟩\n\n"}
{"name":"CauSeq.inf_le_left","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedField α\na b : CauSeq α abs\n⊢ LE.le (Min.min a b) a","decl":"protected theorem inf_le_left {a b : CauSeq α abs} : a ⊓ b ≤ a :=\n  le_of_exists ⟨0, fun _ _ => inf_le_left⟩\n\n"}
{"name":"CauSeq.le_sup_right","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedField α\na b : CauSeq α abs\n⊢ LE.le b (Max.max a b)","decl":"protected theorem le_sup_right {a b : CauSeq α abs} : b ≤ a ⊔ b :=\n  le_of_exists ⟨0, fun _ _ => le_sup_right⟩\n\n"}
{"name":"CauSeq.inf_le_right","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedField α\na b : CauSeq α abs\n⊢ LE.le (Min.min a b) b","decl":"protected theorem inf_le_right {a b : CauSeq α abs} : a ⊓ b ≤ b :=\n  le_of_exists ⟨0, fun _ _ => inf_le_right⟩\n\n"}
{"name":"CauSeq.sup_le","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedField α\na b c : CauSeq α abs\nha : LE.le a c\nhb : LE.le b c\n⊢ LE.le (Max.max a b) c","decl":"protected theorem sup_le {a b c : CauSeq α abs} (ha : a ≤ c) (hb : b ≤ c) : a ⊔ b ≤ c := by\n  cases' ha with ha ha\n  · cases' hb with hb hb\n    · exact Or.inl (CauSeq.sup_lt ha hb)\n    · replace ha := le_of_le_of_eq ha.le (Setoid.symm hb)\n      refine le_of_le_of_eq (Or.inr ?_) hb\n      exact CauSeq.sup_eq_right ha\n  · replace hb := le_of_le_of_eq hb (Setoid.symm ha)\n    refine le_of_le_of_eq (Or.inr ?_) ha\n    exact CauSeq.sup_eq_left hb\n\n"}
{"name":"CauSeq.le_inf","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedField α\na b c : CauSeq α abs\nhb : LE.le a b\nhc : LE.le a c\n⊢ LE.le a (Min.min b c)","decl":"protected theorem le_inf {a b c : CauSeq α abs} (hb : a ≤ b) (hc : a ≤ c) : a ≤ b ⊓ c := by\n  cases' hb with hb hb\n  · cases' hc with hc hc\n    · exact Or.inl (CauSeq.lt_inf hb hc)\n    · replace hb := le_of_eq_of_le (Setoid.symm hc) hb.le\n      refine le_of_eq_of_le hc (Or.inr ?_)\n      exact Setoid.symm (CauSeq.inf_eq_right hb)\n  · replace hc := le_of_eq_of_le (Setoid.symm hb) hc\n    refine le_of_eq_of_le hb (Or.inr ?_)\n    exact Setoid.symm (CauSeq.inf_eq_left hc)\n\n"}
{"name":"CauSeq.sup_inf_distrib_left","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedField α\na b c : CauSeq α abs\n⊢ Eq (Max.max a (Min.min b c)) (Min.min (Max.max a b) (Max.max a c))","decl":"protected theorem sup_inf_distrib_left (a b c : CauSeq α abs) : a ⊔ b ⊓ c = (a ⊔ b) ⊓ (a ⊔ c) :=\n  ext fun _ ↦ max_min_distrib_left _ _ _\n\n"}
{"name":"CauSeq.sup_inf_distrib_right","module":"Mathlib.Algebra.Order.CauSeq.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedField α\na b c : CauSeq α abs\n⊢ Eq (Max.max (Min.min a b) c) (Min.min (Max.max a c) (Max.max b c))","decl":"protected theorem sup_inf_distrib_right (a b c : CauSeq α abs) : a ⊓ b ⊔ c = (a ⊔ c) ⊓ (b ⊔ c) :=\n  ext fun _ ↦ max_min_distrib_right _ _ _\n\n"}
