{"name":"HasProd.tendsto_prod_nat","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninstâœÂ¹ : CommMonoid M\ninstâœ : TopologicalSpace M\nm : M\nf : Nat â†’ M\nh : HasProd f m\nâŠ¢ Filter.Tendsto (fun n => (Finset.range n).prod fun i => f i) Filter.atTop (nhds m)","decl":"/-- If `f : â„• â†’ M` has product `m`, then the partial products `âˆ i âˆˆ range n, f i` converge\nto `m`. -/\n@[to_additive \"If `f : â„• â†’ M` has sum `m`, then the partial sums `âˆ‘ i âˆˆ range n, f i` converge\nto `m`.\"]\ntheorem tendsto_prod_nat {f : â„• â†’ M} (h : HasProd f m) :\n    Tendsto (fun n â†¦ âˆ i âˆˆ range n, f i) atTop (ğ“ m) :=\n  h.comp tendsto_finset_range\n\n"}
{"name":"HasSum.tendsto_sum_nat","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninstâœÂ¹ : AddCommMonoid M\ninstâœ : TopologicalSpace M\nm : M\nf : Nat â†’ M\nh : HasSum f m\nâŠ¢ Filter.Tendsto (fun n => (Finset.range n).sum fun i => f i) Filter.atTop (nhds m)","decl":"/-- If `f : â„• â†’ M` has product `m`, then the partial products `âˆ i âˆˆ range n, f i` converge\nto `m`. -/\n@[to_additive \"If `f : â„• â†’ M` has sum `m`, then the partial sums `âˆ‘ i âˆˆ range n, f i` converge\nto `m`.\"]\ntheorem tendsto_prod_nat {f : â„• â†’ M} (h : HasProd f m) :\n    Tendsto (fun n â†¦ âˆ i âˆˆ range n, f i) atTop (ğ“ m) :=\n  h.comp tendsto_finset_range\n\n"}
{"name":"HasSum.Multipliable.tendsto_sum_tsum_nat","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninstâœÂ¹ : AddCommMonoid M\ninstâœ : TopologicalSpace M\nf : Nat â†’ M\nh : Summable f\nâŠ¢ Filter.Tendsto (fun n => (Finset.range n).sum fun i => f i) Filter.atTop (nhds (tsum fun i => f i))","decl":"/-- If `f : â„• â†’ M` is multipliable, then the partial products `âˆ i âˆˆ range n, f i` converge\nto `âˆ' i, f i`. -/\n@[to_additive \"If `f : â„• â†’ M` is summable, then the partial sums `âˆ‘ i âˆˆ range n, f i` converge\nto `âˆ‘' i, f i`.\"]\ntheorem Multipliable.tendsto_prod_tprod_nat {f : â„• â†’ M} (h : Multipliable f) :\n    Tendsto (fun n â†¦ âˆ i âˆˆ range n, f i) atTop (ğ“ (âˆ' i, f i)) :=\n  tendsto_prod_nat h.hasProd\n\n"}
{"name":"HasProd.Multipliable.tendsto_prod_tprod_nat","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninstâœÂ¹ : CommMonoid M\ninstâœ : TopologicalSpace M\nf : Nat â†’ M\nh : Multipliable f\nâŠ¢ Filter.Tendsto (fun n => (Finset.range n).prod fun i => f i) Filter.atTop (nhds (tprod fun i => f i))","decl":"/-- If `f : â„• â†’ M` is multipliable, then the partial products `âˆ i âˆˆ range n, f i` converge\nto `âˆ' i, f i`. -/\n@[to_additive \"If `f : â„• â†’ M` is summable, then the partial sums `âˆ‘ i âˆˆ range n, f i` converge\nto `âˆ‘' i, f i`.\"]\ntheorem Multipliable.tendsto_prod_tprod_nat {f : â„• â†’ M} (h : Multipliable f) :\n    Tendsto (fun n â†¦ âˆ i âˆˆ range n, f i) atTop (ğ“ (âˆ' i, f i)) :=\n  tendsto_prod_nat h.hasProd\n\n"}
{"name":"HasProd.prod_range_mul","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninstâœÂ² : CommMonoid M\ninstâœÂ¹ : TopologicalSpace M\nm : M\ninstâœ : ContinuousMul M\nf : Nat â†’ M\nk : Nat\nh : HasProd (fun n => f (HAdd.hAdd n k)) m\nâŠ¢ HasProd f (HMul.hMul ((Finset.range k).prod fun i => f i) m)","decl":"@[to_additive]\ntheorem prod_range_mul {f : â„• â†’ M} {k : â„•} (h : HasProd (fun n â†¦ f (n + k)) m) :\n    HasProd f ((âˆ i âˆˆ range k, f i) * m) := by\n  refine ((range k).hasProd f).mul_compl ?_\n  rwa [â† (notMemRangeEquiv k).symm.hasProd_iff]\n\n"}
{"name":"HasSum.sum_range_add","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninstâœÂ² : AddCommMonoid M\ninstâœÂ¹ : TopologicalSpace M\nm : M\ninstâœ : ContinuousAdd M\nf : Nat â†’ M\nk : Nat\nh : HasSum (fun n => f (HAdd.hAdd n k)) m\nâŠ¢ HasSum f (HAdd.hAdd ((Finset.range k).sum fun i => f i) m)","decl":"@[to_additive]\ntheorem prod_range_mul {f : â„• â†’ M} {k : â„•} (h : HasProd (fun n â†¦ f (n + k)) m) :\n    HasProd f ((âˆ i âˆˆ range k, f i) * m) := by\n  refine ((range k).hasProd f).mul_compl ?_\n  rwa [â† (notMemRangeEquiv k).symm.hasProd_iff]\n\n"}
{"name":"HasSum.zero_add","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninstâœÂ² : AddCommMonoid M\ninstâœÂ¹ : TopologicalSpace M\nm : M\ninstâœ : ContinuousAdd M\nf : Nat â†’ M\nh : HasSum (fun n => f (HAdd.hAdd n 1)) m\nâŠ¢ HasSum f (HAdd.hAdd (f 0) m)","decl":"@[to_additive]\ntheorem zero_mul {f : â„• â†’ M} (h : HasProd (fun n â†¦ f (n + 1)) m) :\n    HasProd f (f 0 * m) := by\n  simpa only [prod_range_one] using h.prod_range_mul\n\n"}
{"name":"HasProd.zero_mul","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninstâœÂ² : CommMonoid M\ninstâœÂ¹ : TopologicalSpace M\nm : M\ninstâœ : ContinuousMul M\nf : Nat â†’ M\nh : HasProd (fun n => f (HAdd.hAdd n 1)) m\nâŠ¢ HasProd f (HMul.hMul (f 0) m)","decl":"@[to_additive]\ntheorem zero_mul {f : â„• â†’ M} (h : HasProd (fun n â†¦ f (n + 1)) m) :\n    HasProd f (f 0 * m) := by\n  simpa only [prod_range_one] using h.prod_range_mul\n\n"}
{"name":"HasSum.even_add_odd","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninstâœÂ² : AddCommMonoid M\ninstâœÂ¹ : TopologicalSpace M\nm m' : M\ninstâœ : ContinuousAdd M\nf : Nat â†’ M\nhe : HasSum (fun k => f (HMul.hMul 2 k)) m\nho : HasSum (fun k => f (HAdd.hAdd (HMul.hMul 2 k) 1)) m'\nâŠ¢ HasSum f (HAdd.hAdd m m')","decl":"@[to_additive]\ntheorem even_mul_odd {f : â„• â†’ M} (he : HasProd (fun k â†¦ f (2 * k)) m)\n    (ho : HasProd (fun k â†¦ f (2 * k + 1)) m') : HasProd f (m * m') := by\n  have := mul_right_injectiveâ‚€ (two_ne_zero' â„•)\n  replace ho := ((add_left_injective 1).comp this).hasProd_range_iff.2 ho\n  refine (this.hasProd_range_iff.2 he).mul_isCompl ?_ ho\n  simpa [Function.comp_def] using Nat.isCompl_even_odd\n\n"}
{"name":"HasProd.even_mul_odd","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninstâœÂ² : CommMonoid M\ninstâœÂ¹ : TopologicalSpace M\nm m' : M\ninstâœ : ContinuousMul M\nf : Nat â†’ M\nhe : HasProd (fun k => f (HMul.hMul 2 k)) m\nho : HasProd (fun k => f (HAdd.hAdd (HMul.hMul 2 k) 1)) m'\nâŠ¢ HasProd f (HMul.hMul m m')","decl":"@[to_additive]\ntheorem even_mul_odd {f : â„• â†’ M} (he : HasProd (fun k â†¦ f (2 * k)) m)\n    (ho : HasProd (fun k â†¦ f (2 * k + 1)) m') : HasProd f (m * m') := by\n  have := mul_right_injectiveâ‚€ (two_ne_zero' â„•)\n  replace ho := ((add_left_injective 1).comp this).hasProd_range_iff.2 ho\n  refine (this.hasProd_range_iff.2 he).mul_isCompl ?_ ho\n  simpa [Function.comp_def] using Nat.isCompl_even_odd\n\n"}
{"name":"Summable.hasSum_iff_tendsto_nat","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninstâœÂ² : AddCommMonoid M\ninstâœÂ¹ : TopologicalSpace M\nm : M\ninstâœ : T2Space M\nf : Nat â†’ M\nhf : Summable f\nâŠ¢ Iff (HasSum f m) (Filter.Tendsto (fun n => (Finset.range n).sum fun i => f i) Filter.atTop (nhds m))","decl":"@[to_additive]\ntheorem hasProd_iff_tendsto_nat [T2Space M] {f : â„• â†’ M} (hf : Multipliable f) :\n    HasProd f m â†” Tendsto (fun n : â„• â†¦ âˆ i âˆˆ range n, f i) atTop (ğ“ m) := by\n  refine âŸ¨fun h â†¦ h.tendsto_prod_nat, fun h â†¦ ?_âŸ©\n  rw [tendsto_nhds_unique h hf.hasProd.tendsto_prod_nat]\n  exact hf.hasProd\n\n"}
{"name":"Multipliable.hasProd_iff_tendsto_nat","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninstâœÂ² : CommMonoid M\ninstâœÂ¹ : TopologicalSpace M\nm : M\ninstâœ : T2Space M\nf : Nat â†’ M\nhf : Multipliable f\nâŠ¢ Iff (HasProd f m) (Filter.Tendsto (fun n => (Finset.range n).prod fun i => f i) Filter.atTop (nhds m))","decl":"@[to_additive]\ntheorem hasProd_iff_tendsto_nat [T2Space M] {f : â„• â†’ M} (hf : Multipliable f) :\n    HasProd f m â†” Tendsto (fun n : â„• â†¦ âˆ i âˆˆ range n, f i) atTop (ğ“ m) := by\n  refine âŸ¨fun h â†¦ h.tendsto_prod_nat, fun h â†¦ ?_âŸ©\n  rw [tendsto_nhds_unique h hf.hasProd.tendsto_prod_nat]\n  exact hf.hasProd\n\n"}
{"name":"Multipliable.comp_nat_add","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninstâœÂ² : CommMonoid M\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : ContinuousMul M\nf : Nat â†’ M\nk : Nat\nh : Multipliable fun n => f (HAdd.hAdd n k)\nâŠ¢ Multipliable f","decl":"@[to_additive]\ntheorem comp_nat_add {f : â„• â†’ M} {k : â„•} (h : Multipliable fun n â†¦ f (n + k)) : Multipliable f :=\n  h.hasProd.prod_range_mul.multipliable\n\n"}
{"name":"Summable.comp_nat_add","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninstâœÂ² : AddCommMonoid M\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : ContinuousAdd M\nf : Nat â†’ M\nk : Nat\nh : Summable fun n => f (HAdd.hAdd n k)\nâŠ¢ Summable f","decl":"@[to_additive]\ntheorem comp_nat_add {f : â„• â†’ M} {k : â„•} (h : Multipliable fun n â†¦ f (n + k)) : Multipliable f :=\n  h.hasProd.prod_range_mul.multipliable\n\n"}
{"name":"Summable.even_add_odd","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninstâœÂ² : AddCommMonoid M\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : ContinuousAdd M\nf : Nat â†’ M\nhe : Summable fun k => f (HMul.hMul 2 k)\nho : Summable fun k => f (HAdd.hAdd (HMul.hMul 2 k) 1)\nâŠ¢ Summable f","decl":"@[to_additive]\ntheorem even_mul_odd {f : â„• â†’ M} (he : Multipliable fun k â†¦ f (2 * k))\n    (ho : Multipliable fun k â†¦ f (2 * k + 1)) : Multipliable f :=\n  (he.hasProd.even_mul_odd ho.hasProd).multipliable\n\n"}
{"name":"Multipliable.even_mul_odd","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninstâœÂ² : CommMonoid M\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : ContinuousMul M\nf : Nat â†’ M\nhe : Multipliable fun k => f (HMul.hMul 2 k)\nho : Multipliable fun k => f (HAdd.hAdd (HMul.hMul 2 k) 1)\nâŠ¢ Multipliable f","decl":"@[to_additive]\ntheorem even_mul_odd {f : â„• â†’ M} (he : Multipliable fun k â†¦ f (2 * k))\n    (ho : Multipliable fun k â†¦ f (2 * k + 1)) : Multipliable f :=\n  (he.hasProd.even_mul_odd ho.hasProd).multipliable\n\n"}
{"name":"tprod_iSup_decodeâ‚‚","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninstâœÂ³ : CommMonoid M\ninstâœÂ² : TopologicalSpace M\nÎ± : Type u_3\nÎ² : Type u_4\ninstâœÂ¹ : Encodable Î²\ninstâœ : CompleteLattice Î±\nm : Î± â†’ M\nm0 : Eq (m Bot.bot) 1\ns : Î² â†’ Î±\nâŠ¢ Eq (tprod fun i => m (iSup fun b => iSup fun h => s b)) (tprod fun b => m (s b))","decl":"/-- You can compute a product over an encodable type by multiplying over the natural numbers and\ntaking a supremum. -/\n@[to_additive \"You can compute a sum over an encodable type by summing over the natural numbers and\n  taking a supremum. This is useful for outer measures.\"]\ntheorem tprod_iSup_decodeâ‚‚ [CompleteLattice Î±] (m : Î± â†’ M) (m0 : m âŠ¥ = 1) (s : Î² â†’ Î±) :\n    âˆ' i : â„•, m (â¨† b âˆˆ decodeâ‚‚ Î² i, s b) = âˆ' b : Î², m (s b) := by\n  rw [â† tprod_extend_one (@encode_injective Î² _)]\n  refine tprod_congr fun n â†¦ ?_\n  rcases em (n âˆˆ Set.range (encode : Î² â†’ â„•)) with âŸ¨a, rflâŸ© | hn\n  Â· simp [encode_injective.extend_apply]\n  Â· rw [extend_apply' _ _ _ hn]\n    rw [â† decodeâ‚‚_ne_none_iff, ne_eq, not_not] at hn\n    simp [hn, m0]\n\n"}
{"name":"tsum_iSup_decodeâ‚‚","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninstâœÂ³ : AddCommMonoid M\ninstâœÂ² : TopologicalSpace M\nÎ± : Type u_3\nÎ² : Type u_4\ninstâœÂ¹ : Encodable Î²\ninstâœ : CompleteLattice Î±\nm : Î± â†’ M\nm0 : Eq (m Bot.bot) 0\ns : Î² â†’ Î±\nâŠ¢ Eq (tsum fun i => m (iSup fun b => iSup fun h => s b)) (tsum fun b => m (s b))","decl":"/-- You can compute a product over an encodable type by multiplying over the natural numbers and\ntaking a supremum. -/\n@[to_additive \"You can compute a sum over an encodable type by summing over the natural numbers and\n  taking a supremum. This is useful for outer measures.\"]\ntheorem tprod_iSup_decodeâ‚‚ [CompleteLattice Î±] (m : Î± â†’ M) (m0 : m âŠ¥ = 1) (s : Î² â†’ Î±) :\n    âˆ' i : â„•, m (â¨† b âˆˆ decodeâ‚‚ Î² i, s b) = âˆ' b : Î², m (s b) := by\n  rw [â† tprod_extend_one (@encode_injective Î² _)]\n  refine tprod_congr fun n â†¦ ?_\n  rcases em (n âˆˆ Set.range (encode : Î² â†’ â„•)) with âŸ¨a, rflâŸ© | hn\n  Â· simp [encode_injective.extend_apply]\n  Â· rw [extend_apply' _ _ _ hn]\n    rw [â† decodeâ‚‚_ne_none_iff, ne_eq, not_not] at hn\n    simp [hn, m0]\n\n"}
{"name":"tsum_iUnion_decodeâ‚‚","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninstâœÂ² : AddCommMonoid M\ninstâœÂ¹ : TopologicalSpace M\nÎ± : Type u_3\nÎ² : Type u_4\ninstâœ : Encodable Î²\nm : Set Î± â†’ M\nm0 : Eq (m EmptyCollection.emptyCollection) 0\ns : Î² â†’ Set Î±\nâŠ¢ Eq (tsum fun i => m (Set.iUnion fun b => Set.iUnion fun h => s b)) (tsum fun b => m (s b))","decl":"/-- `tprod_iSup_decodeâ‚‚` specialized to the complete lattice of sets. -/\n@[to_additive \"`tsum_iSup_decodeâ‚‚` specialized to the complete lattice of sets.\"]\ntheorem tprod_iUnion_decodeâ‚‚ (m : Set Î± â†’ M) (m0 : m âˆ… = 1) (s : Î² â†’ Set Î±) :\n    âˆ' i, m (â‹ƒ b âˆˆ decodeâ‚‚ Î² i, s b) = âˆ' b, m (s b) :=\n  tprod_iSup_decodeâ‚‚ m m0 s\n\n"}
{"name":"tprod_iUnion_decodeâ‚‚","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninstâœÂ² : CommMonoid M\ninstâœÂ¹ : TopologicalSpace M\nÎ± : Type u_3\nÎ² : Type u_4\ninstâœ : Encodable Î²\nm : Set Î± â†’ M\nm0 : Eq (m EmptyCollection.emptyCollection) 1\ns : Î² â†’ Set Î±\nâŠ¢ Eq (tprod fun i => m (Set.iUnion fun b => Set.iUnion fun h => s b)) (tprod fun b => m (s b))","decl":"/-- `tprod_iSup_decodeâ‚‚` specialized to the complete lattice of sets. -/\n@[to_additive \"`tsum_iSup_decodeâ‚‚` specialized to the complete lattice of sets.\"]\ntheorem tprod_iUnion_decodeâ‚‚ (m : Set Î± â†’ M) (m0 : m âˆ… = 1) (s : Î² â†’ Set Î±) :\n    âˆ' i, m (â‹ƒ b âˆˆ decodeâ‚‚ Î² i, s b) = âˆ' b, m (s b) :=\n  tprod_iSup_decodeâ‚‚ m m0 s\n\n"}
{"name":"rel_iSup_tprod","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninstâœÂ³ : CommMonoid M\ninstâœÂ² : TopologicalSpace M\nÎ± : Type u_3\nÎ² : Type u_4\ninstâœÂ¹ : Countable Î²\ninstâœ : CompleteLattice Î±\nm : Î± â†’ M\nm0 : Eq (m Bot.bot) 1\nR : M â†’ M â†’ Prop\nm_iSup : âˆ€ (s : Nat â†’ Î±), R (m (iSup fun i => s i)) (tprod fun i => m (s i))\ns : Î² â†’ Î±\nâŠ¢ R (m (iSup fun b => s b)) (tprod fun b => m (s b))","decl":"/-- If a function is countably sub-multiplicative then it is sub-multiplicative on countable\ntypes -/\n@[to_additive \"If a function is countably sub-additive then it is sub-additive on countable types\"]\ntheorem rel_iSup_tprod [CompleteLattice Î±] (m : Î± â†’ M) (m0 : m âŠ¥ = 1) (R : M â†’ M â†’ Prop)\n    (m_iSup : âˆ€ s : â„• â†’ Î±, R (m (â¨† i, s i)) (âˆ' i, m (s i))) (s : Î² â†’ Î±) :\n    R (m (â¨† b : Î², s b)) (âˆ' b : Î², m (s b)) := by\n  cases nonempty_encodable Î²\n  rw [â† iSup_decodeâ‚‚, â† tprod_iSup_decodeâ‚‚ _ m0 s]\n  exact m_iSup _\n\n"}
{"name":"rel_iSup_tsum","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninstâœÂ³ : AddCommMonoid M\ninstâœÂ² : TopologicalSpace M\nÎ± : Type u_3\nÎ² : Type u_4\ninstâœÂ¹ : Countable Î²\ninstâœ : CompleteLattice Î±\nm : Î± â†’ M\nm0 : Eq (m Bot.bot) 0\nR : M â†’ M â†’ Prop\nm_iSup : âˆ€ (s : Nat â†’ Î±), R (m (iSup fun i => s i)) (tsum fun i => m (s i))\ns : Î² â†’ Î±\nâŠ¢ R (m (iSup fun b => s b)) (tsum fun b => m (s b))","decl":"/-- If a function is countably sub-multiplicative then it is sub-multiplicative on countable\ntypes -/\n@[to_additive \"If a function is countably sub-additive then it is sub-additive on countable types\"]\ntheorem rel_iSup_tprod [CompleteLattice Î±] (m : Î± â†’ M) (m0 : m âŠ¥ = 1) (R : M â†’ M â†’ Prop)\n    (m_iSup : âˆ€ s : â„• â†’ Î±, R (m (â¨† i, s i)) (âˆ' i, m (s i))) (s : Î² â†’ Î±) :\n    R (m (â¨† b : Î², s b)) (âˆ' b : Î², m (s b)) := by\n  cases nonempty_encodable Î²\n  rw [â† iSup_decodeâ‚‚, â† tprod_iSup_decodeâ‚‚ _ m0 s]\n  exact m_iSup _\n\n"}
{"name":"rel_iSup_sum","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninstâœÂ² : AddCommMonoid M\ninstâœÂ¹ : TopologicalSpace M\nÎ± : Type u_3\nÎ³ : Type u_5\ninstâœ : CompleteLattice Î±\nm : Î± â†’ M\nm0 : Eq (m Bot.bot) 0\nR : M â†’ M â†’ Prop\nm_iSup : âˆ€ (s : Nat â†’ Î±), R (m (iSup fun i => s i)) (tsum fun i => m (s i))\ns : Î³ â†’ Î±\nt : Finset Î³\nâŠ¢ R (m (iSup fun d => iSup fun h => s d)) (t.sum fun d => m (s d))","decl":"/-- If a function is countably sub-multiplicative then it is sub-multiplicative on finite sets -/\n@[to_additive \"If a function is countably sub-additive then it is sub-additive on finite sets\"]\ntheorem rel_iSup_prod [CompleteLattice Î±] (m : Î± â†’ M) (m0 : m âŠ¥ = 1) (R : M â†’ M â†’ Prop)\n    (m_iSup : âˆ€ s : â„• â†’ Î±, R (m (â¨† i, s i)) (âˆ' i, m (s i))) (s : Î³ â†’ Î±) (t : Finset Î³) :\n    R (m (â¨† d âˆˆ t, s d)) (âˆ d âˆˆ t, m (s d)) := by\n  rw [iSup_subtype', â† Finset.tprod_subtype]\n  exact rel_iSup_tprod m m0 R m_iSup _\n\n"}
{"name":"rel_iSup_prod","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninstâœÂ² : CommMonoid M\ninstâœÂ¹ : TopologicalSpace M\nÎ± : Type u_3\nÎ³ : Type u_5\ninstâœ : CompleteLattice Î±\nm : Î± â†’ M\nm0 : Eq (m Bot.bot) 1\nR : M â†’ M â†’ Prop\nm_iSup : âˆ€ (s : Nat â†’ Î±), R (m (iSup fun i => s i)) (tprod fun i => m (s i))\ns : Î³ â†’ Î±\nt : Finset Î³\nâŠ¢ R (m (iSup fun d => iSup fun h => s d)) (t.prod fun d => m (s d))","decl":"/-- If a function is countably sub-multiplicative then it is sub-multiplicative on finite sets -/\n@[to_additive \"If a function is countably sub-additive then it is sub-additive on finite sets\"]\ntheorem rel_iSup_prod [CompleteLattice Î±] (m : Î± â†’ M) (m0 : m âŠ¥ = 1) (R : M â†’ M â†’ Prop)\n    (m_iSup : âˆ€ s : â„• â†’ Î±, R (m (â¨† i, s i)) (âˆ' i, m (s i))) (s : Î³ â†’ Î±) (t : Finset Î³) :\n    R (m (â¨† d âˆˆ t, s d)) (âˆ d âˆˆ t, m (s d)) := by\n  rw [iSup_subtype', â† Finset.tprod_subtype]\n  exact rel_iSup_tprod m m0 R m_iSup _\n\n"}
{"name":"rel_sup_add","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninstâœÂ² : AddCommMonoid M\ninstâœÂ¹ : TopologicalSpace M\nÎ± : Type u_3\ninstâœ : CompleteLattice Î±\nm : Î± â†’ M\nm0 : Eq (m Bot.bot) 0\nR : M â†’ M â†’ Prop\nm_iSup : âˆ€ (s : Nat â†’ Î±), R (m (iSup fun i => s i)) (tsum fun i => m (s i))\nsâ‚ sâ‚‚ : Î±\nâŠ¢ R (m (Max.max sâ‚ sâ‚‚)) (HAdd.hAdd (m sâ‚) (m sâ‚‚))","decl":"/-- If a function is countably sub-multiplicative then it is binary sub-multiplicative -/\n@[to_additive \"If a function is countably sub-additive then it is binary sub-additive\"]\ntheorem rel_sup_mul [CompleteLattice Î±] (m : Î± â†’ M) (m0 : m âŠ¥ = 1) (R : M â†’ M â†’ Prop)\n    (m_iSup : âˆ€ s : â„• â†’ Î±, R (m (â¨† i, s i)) (âˆ' i, m (s i))) (sâ‚ sâ‚‚ : Î±) :\n    R (m (sâ‚ âŠ” sâ‚‚)) (m sâ‚ * m sâ‚‚) := by\n  convert rel_iSup_tprod m m0 R m_iSup fun b â†¦ cond b sâ‚ sâ‚‚\n  Â· simp only [iSup_bool_eq, cond]\n  Â· rw [tprod_fintype, Fintype.prod_bool, cond, cond]\n\n"}
{"name":"rel_sup_mul","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninstâœÂ² : CommMonoid M\ninstâœÂ¹ : TopologicalSpace M\nÎ± : Type u_3\ninstâœ : CompleteLattice Î±\nm : Î± â†’ M\nm0 : Eq (m Bot.bot) 1\nR : M â†’ M â†’ Prop\nm_iSup : âˆ€ (s : Nat â†’ Î±), R (m (iSup fun i => s i)) (tprod fun i => m (s i))\nsâ‚ sâ‚‚ : Î±\nâŠ¢ R (m (Max.max sâ‚ sâ‚‚)) (HMul.hMul (m sâ‚) (m sâ‚‚))","decl":"/-- If a function is countably sub-multiplicative then it is binary sub-multiplicative -/\n@[to_additive \"If a function is countably sub-additive then it is binary sub-additive\"]\ntheorem rel_sup_mul [CompleteLattice Î±] (m : Î± â†’ M) (m0 : m âŠ¥ = 1) (R : M â†’ M â†’ Prop)\n    (m_iSup : âˆ€ s : â„• â†’ Î±, R (m (â¨† i, s i)) (âˆ' i, m (s i))) (sâ‚ sâ‚‚ : Î±) :\n    R (m (sâ‚ âŠ” sâ‚‚)) (m sâ‚ * m sâ‚‚) := by\n  convert rel_iSup_tprod m m0 R m_iSup fun b â†¦ cond b sâ‚ sâ‚‚\n  Â· simp only [iSup_bool_eq, cond]\n  Â· rw [tprod_fintype, Fintype.prod_bool, cond, cond]\n\n"}
{"name":"sum_add_tsum_nat_add'","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninstâœÂ³ : AddCommMonoid M\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : T2Space M\ninstâœ : ContinuousAdd M\nf : Nat â†’ M\nk : Nat\nh : Summable fun n => f (HAdd.hAdd n k)\nâŠ¢ Eq (HAdd.hAdd ((Finset.range k).sum fun i => f i) (tsum fun i => f (HAdd.hAdd i k))) (tsum fun i => f i)","decl":"@[to_additive]\ntheorem prod_mul_tprod_nat_mul'\n    {f : â„• â†’ M} {k : â„•} (h : Multipliable (fun n â†¦ f (n + k))) :\n    ((âˆ i âˆˆ range k, f i) * âˆ' i, f (i + k)) = âˆ' i, f i :=\n  h.hasProd.prod_range_mul.tprod_eq.symm\n\n"}
{"name":"prod_mul_tprod_nat_mul'","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninstâœÂ³ : CommMonoid M\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : T2Space M\ninstâœ : ContinuousMul M\nf : Nat â†’ M\nk : Nat\nh : Multipliable fun n => f (HAdd.hAdd n k)\nâŠ¢ Eq (HMul.hMul ((Finset.range k).prod fun i => f i) (tprod fun i => f (HAdd.hAdd i k))) (tprod fun i => f i)","decl":"@[to_additive]\ntheorem prod_mul_tprod_nat_mul'\n    {f : â„• â†’ M} {k : â„•} (h : Multipliable (fun n â†¦ f (n + k))) :\n    ((âˆ i âˆˆ range k, f i) * âˆ' i, f (i + k)) = âˆ' i, f i :=\n  h.hasProd.prod_range_mul.tprod_eq.symm\n\n"}
{"name":"tprod_eq_zero_mul'","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninstâœÂ³ : CommMonoid M\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : T2Space M\ninstâœ : ContinuousMul M\nf : Nat â†’ M\nhf : Multipliable fun n => f (HAdd.hAdd n 1)\nâŠ¢ Eq (tprod fun b => f b) (HMul.hMul (f 0) (tprod fun b => f (HAdd.hAdd b 1)))","decl":"@[to_additive]\ntheorem tprod_eq_zero_mul'\n    {f : â„• â†’ M} (hf : Multipliable (fun n â†¦ f (n + 1))) :\n    âˆ' b, f b = f 0 * âˆ' b, f (b + 1) := by\n  simpa only [prod_range_one] using (prod_mul_tprod_nat_mul' hf).symm\n\n"}
{"name":"tsum_eq_zero_add'","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninstâœÂ³ : AddCommMonoid M\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : T2Space M\ninstâœ : ContinuousAdd M\nf : Nat â†’ M\nhf : Summable fun n => f (HAdd.hAdd n 1)\nâŠ¢ Eq (tsum fun b => f b) (HAdd.hAdd (f 0) (tsum fun b => f (HAdd.hAdd b 1)))","decl":"@[to_additive]\ntheorem tprod_eq_zero_mul'\n    {f : â„• â†’ M} (hf : Multipliable (fun n â†¦ f (n + 1))) :\n    âˆ' b, f b = f 0 * âˆ' b, f (b + 1) := by\n  simpa only [prod_range_one] using (prod_mul_tprod_nat_mul' hf).symm\n\n"}
{"name":"tsum_even_add_odd","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninstâœÂ³ : AddCommMonoid M\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : T2Space M\ninstâœ : ContinuousAdd M\nf : Nat â†’ M\nhe : Summable fun k => f (HMul.hMul 2 k)\nho : Summable fun k => f (HAdd.hAdd (HMul.hMul 2 k) 1)\nâŠ¢ Eq (HAdd.hAdd (tsum fun k => f (HMul.hMul 2 k)) (tsum fun k => f (HAdd.hAdd (HMul.hMul 2 k) 1))) (tsum fun k => f k)","decl":"@[to_additive]\ntheorem tprod_even_mul_odd {f : â„• â†’ M} (he : Multipliable fun k â†¦ f (2 * k))\n    (ho : Multipliable fun k â†¦ f (2 * k + 1)) :\n    (âˆ' k, f (2 * k)) * âˆ' k, f (2 * k + 1) = âˆ' k, f k :=\n  (he.hasProd.even_mul_odd ho.hasProd).tprod_eq.symm\n\n"}
{"name":"tprod_even_mul_odd","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninstâœÂ³ : CommMonoid M\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : T2Space M\ninstâœ : ContinuousMul M\nf : Nat â†’ M\nhe : Multipliable fun k => f (HMul.hMul 2 k)\nho : Multipliable fun k => f (HAdd.hAdd (HMul.hMul 2 k) 1)\nâŠ¢ Eq (HMul.hMul (tprod fun k => f (HMul.hMul 2 k)) (tprod fun k => f (HAdd.hAdd (HMul.hMul 2 k) 1))) (tprod fun k => f k)","decl":"@[to_additive]\ntheorem tprod_even_mul_odd {f : â„• â†’ M} (he : Multipliable fun k â†¦ f (2 * k))\n    (ho : Multipliable fun k â†¦ f (2 * k + 1)) :\n    (âˆ' k, f (2 * k)) * âˆ' k, f (2 * k + 1) = âˆ' k, f k :=\n  (he.hasProd.even_mul_odd ho.hasProd).tprod_eq.symm\n\n"}
{"name":"hasSum_nat_add_iff","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"G : Type u_2\ninstâœÂ² : AddCommGroup G\ng : G\ninstâœÂ¹ : TopologicalSpace G\ninstâœ : TopologicalAddGroup G\nf : Nat â†’ G\nk : Nat\nâŠ¢ Iff (HasSum (fun n => f (HAdd.hAdd n k)) g) (HasSum f (HAdd.hAdd g ((Finset.range k).sum fun i => f i)))","decl":"@[to_additive]\ntheorem hasProd_nat_add_iff {f : â„• â†’ G} (k : â„•) :\n    HasProd (fun n â†¦ f (n + k)) g â†” HasProd f (g * âˆ i âˆˆ range k, f i) := by\n  refine Iff.trans ?_ (range k).hasProd_compl_iff\n  rw [â† (notMemRangeEquiv k).symm.hasProd_iff, Function.comp_def, coe_notMemRangeEquiv_symm]\n\n"}
{"name":"hasProd_nat_add_iff","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"G : Type u_2\ninstâœÂ² : CommGroup G\ng : G\ninstâœÂ¹ : TopologicalSpace G\ninstâœ : TopologicalGroup G\nf : Nat â†’ G\nk : Nat\nâŠ¢ Iff (HasProd (fun n => f (HAdd.hAdd n k)) g) (HasProd f (HMul.hMul g ((Finset.range k).prod fun i => f i)))","decl":"@[to_additive]\ntheorem hasProd_nat_add_iff {f : â„• â†’ G} (k : â„•) :\n    HasProd (fun n â†¦ f (n + k)) g â†” HasProd f (g * âˆ i âˆˆ range k, f i) := by\n  refine Iff.trans ?_ (range k).hasProd_compl_iff\n  rw [â† (notMemRangeEquiv k).symm.hasProd_iff, Function.comp_def, coe_notMemRangeEquiv_symm]\n\n"}
{"name":"summable_nat_add_iff","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"G : Type u_2\ninstâœÂ² : AddCommGroup G\ninstâœÂ¹ : TopologicalSpace G\ninstâœ : TopologicalAddGroup G\nf : Nat â†’ G\nk : Nat\nâŠ¢ Iff (Summable fun n => f (HAdd.hAdd n k)) (Summable f)","decl":"@[to_additive]\ntheorem multipliable_nat_add_iff {f : â„• â†’ G} (k : â„•) :\n    (Multipliable fun n â†¦ f (n + k)) â†” Multipliable f :=\n  Iff.symm <|\n    (Equiv.mulRight (âˆ i âˆˆ range k, f i)).surjective.multipliable_iff_of_hasProd_iff\n      (hasProd_nat_add_iff k).symm\n\n"}
{"name":"multipliable_nat_add_iff","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"G : Type u_2\ninstâœÂ² : CommGroup G\ninstâœÂ¹ : TopologicalSpace G\ninstâœ : TopologicalGroup G\nf : Nat â†’ G\nk : Nat\nâŠ¢ Iff (Multipliable fun n => f (HAdd.hAdd n k)) (Multipliable f)","decl":"@[to_additive]\ntheorem multipliable_nat_add_iff {f : â„• â†’ G} (k : â„•) :\n    (Multipliable fun n â†¦ f (n + k)) â†” Multipliable f :=\n  Iff.symm <|\n    (Equiv.mulRight (âˆ i âˆˆ range k, f i)).surjective.multipliable_iff_of_hasProd_iff\n      (hasProd_nat_add_iff k).symm\n\n"}
{"name":"hasSum_nat_add_iff'","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"G : Type u_2\ninstâœÂ² : AddCommGroup G\ng : G\ninstâœÂ¹ : TopologicalSpace G\ninstâœ : TopologicalAddGroup G\nf : Nat â†’ G\nk : Nat\nâŠ¢ Iff (HasSum (fun n => f (HAdd.hAdd n k)) (HSub.hSub g ((Finset.range k).sum fun i => f i))) (HasSum f g)","decl":"@[to_additive]\ntheorem hasProd_nat_add_iff' {f : â„• â†’ G} (k : â„•) :\n    HasProd (fun n â†¦ f (n + k)) (g / âˆ i âˆˆ range k, f i) â†” HasProd f g := by\n  simp [hasProd_nat_add_iff]\n\n"}
{"name":"hasProd_nat_add_iff'","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"G : Type u_2\ninstâœÂ² : CommGroup G\ng : G\ninstâœÂ¹ : TopologicalSpace G\ninstâœ : TopologicalGroup G\nf : Nat â†’ G\nk : Nat\nâŠ¢ Iff (HasProd (fun n => f (HAdd.hAdd n k)) (HDiv.hDiv g ((Finset.range k).prod fun i => f i))) (HasProd f g)","decl":"@[to_additive]\ntheorem hasProd_nat_add_iff' {f : â„• â†’ G} (k : â„•) :\n    HasProd (fun n â†¦ f (n + k)) (g / âˆ i âˆˆ range k, f i) â†” HasProd f g := by\n  simp [hasProd_nat_add_iff]\n\n"}
{"name":"sum_add_tsum_nat_add","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"G : Type u_2\ninstâœÂ³ : AddCommGroup G\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : TopologicalAddGroup G\ninstâœ : T2Space G\nf : Nat â†’ G\nk : Nat\nh : Summable f\nâŠ¢ Eq (HAdd.hAdd ((Finset.range k).sum fun i => f i) (tsum fun i => f (HAdd.hAdd i k))) (tsum fun i => f i)","decl":"@[to_additive]\ntheorem prod_mul_tprod_nat_add [T2Space G] {f : â„• â†’ G} (k : â„•) (h : Multipliable f) :\n    ((âˆ i âˆˆ range k, f i) * âˆ' i, f (i + k)) = âˆ' i, f i :=\n  prod_mul_tprod_nat_mul' <| (multipliable_nat_add_iff k).2 h\n\n"}
{"name":"prod_mul_tprod_nat_add","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"G : Type u_2\ninstâœÂ³ : CommGroup G\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : TopologicalGroup G\ninstâœ : T2Space G\nf : Nat â†’ G\nk : Nat\nh : Multipliable f\nâŠ¢ Eq (HMul.hMul ((Finset.range k).prod fun i => f i) (tprod fun i => f (HAdd.hAdd i k))) (tprod fun i => f i)","decl":"@[to_additive]\ntheorem prod_mul_tprod_nat_add [T2Space G] {f : â„• â†’ G} (k : â„•) (h : Multipliable f) :\n    ((âˆ i âˆˆ range k, f i) * âˆ' i, f (i + k)) = âˆ' i, f i :=\n  prod_mul_tprod_nat_mul' <| (multipliable_nat_add_iff k).2 h\n\n"}
{"name":"tprod_eq_zero_mul","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"G : Type u_2\ninstâœÂ³ : CommGroup G\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : TopologicalGroup G\ninstâœ : T2Space G\nf : Nat â†’ G\nhf : Multipliable f\nâŠ¢ Eq (tprod fun b => f b) (HMul.hMul (f 0) (tprod fun b => f (HAdd.hAdd b 1)))","decl":"@[to_additive]\ntheorem tprod_eq_zero_mul [T2Space G] {f : â„• â†’ G} (hf : Multipliable f) :\n    âˆ' b, f b = f 0 * âˆ' b, f (b + 1) :=\n  tprod_eq_zero_mul' <| (multipliable_nat_add_iff 1).2 hf\n\n"}
{"name":"tsum_eq_zero_add","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"G : Type u_2\ninstâœÂ³ : AddCommGroup G\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : TopologicalAddGroup G\ninstâœ : T2Space G\nf : Nat â†’ G\nhf : Summable f\nâŠ¢ Eq (tsum fun b => f b) (HAdd.hAdd (f 0) (tsum fun b => f (HAdd.hAdd b 1)))","decl":"@[to_additive]\ntheorem tprod_eq_zero_mul [T2Space G] {f : â„• â†’ G} (hf : Multipliable f) :\n    âˆ' b, f b = f 0 * âˆ' b, f (b + 1) :=\n  tprod_eq_zero_mul' <| (multipliable_nat_add_iff 1).2 hf\n\n"}
{"name":"tendsto_sum_nat_add","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"G : Type u_2\ninstâœÂ³ : AddCommGroup G\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : TopologicalAddGroup G\ninstâœ : T2Space G\nf : Nat â†’ G\nâŠ¢ Filter.Tendsto (fun i => tsum fun k => f (HAdd.hAdd k i)) Filter.atTop (nhds 0)","decl":"/-- For `f : â„• â†’ G`, the product `âˆ' k, f (k + i)` tends to one. This does not require a\nmultipliability assumption on `f`, as otherwise all such products are one. -/\n@[to_additive \"For `f : â„• â†’ G`, the sum `âˆ‘' k, f (k + i)` tends to zero. This does not require a\nsummability assumption on `f`, as otherwise all such sums are zero.\"]\ntheorem tendsto_prod_nat_add [T2Space G] (f : â„• â†’ G) :\n    Tendsto (fun i â†¦ âˆ' k, f (k + i)) atTop (ğ“ 1) := by\n  by_cases hf : Multipliable f\n  Â· have hâ‚€ : (fun i â†¦ (âˆ' i, f i) / âˆ j âˆˆ range i, f j) = fun i â†¦ âˆ' k : â„•, f (k + i) := by\n      ext1 i\n      rw [div_eq_iff_eq_mul, mul_comm, prod_mul_tprod_nat_add i hf]\n    have hâ‚ : Tendsto (fun _ : â„• â†¦ âˆ' i, f i) atTop (ğ“ (âˆ' i, f i)) := tendsto_const_nhds\n    simpa only [hâ‚€, div_self'] using Tendsto.div' hâ‚ hf.hasProd.tendsto_prod_nat\n  Â· refine tendsto_const_nhds.congr fun n â†¦ (tprod_eq_one_of_not_multipliable ?_).symm\n    rwa [multipliable_nat_add_iff n]\n\n"}
{"name":"tendsto_prod_nat_add","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"G : Type u_2\ninstâœÂ³ : CommGroup G\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : TopologicalGroup G\ninstâœ : T2Space G\nf : Nat â†’ G\nâŠ¢ Filter.Tendsto (fun i => tprod fun k => f (HAdd.hAdd k i)) Filter.atTop (nhds 1)","decl":"/-- For `f : â„• â†’ G`, the product `âˆ' k, f (k + i)` tends to one. This does not require a\nmultipliability assumption on `f`, as otherwise all such products are one. -/\n@[to_additive \"For `f : â„• â†’ G`, the sum `âˆ‘' k, f (k + i)` tends to zero. This does not require a\nsummability assumption on `f`, as otherwise all such sums are zero.\"]\ntheorem tendsto_prod_nat_add [T2Space G] (f : â„• â†’ G) :\n    Tendsto (fun i â†¦ âˆ' k, f (k + i)) atTop (ğ“ 1) := by\n  by_cases hf : Multipliable f\n  Â· have hâ‚€ : (fun i â†¦ (âˆ' i, f i) / âˆ j âˆˆ range i, f j) = fun i â†¦ âˆ' k : â„•, f (k + i) := by\n      ext1 i\n      rw [div_eq_iff_eq_mul, mul_comm, prod_mul_tprod_nat_add i hf]\n    have hâ‚ : Tendsto (fun _ : â„• â†¦ âˆ' i, f i) atTop (ğ“ (âˆ' i, f i)) := tendsto_const_nhds\n    simpa only [hâ‚€, div_self'] using Tendsto.div' hâ‚ hf.hasProd.tendsto_prod_nat\n  Â· refine tendsto_const_nhds.congr fun n â†¦ (tprod_eq_one_of_not_multipliable ?_).symm\n    rwa [multipliable_nat_add_iff n]\n\n"}
{"name":"cauchySeq_finset_iff_nat_tprod_vanishing","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"G : Type u_2\ninstâœÂ² : CommGroup G\ninstâœÂ¹ : UniformSpace G\ninstâœ : UniformGroup G\nf : Nat â†’ G\nâŠ¢ Iff (CauchySeq fun s => s.prod fun n => f n) (âˆ€ (e : Set G), Membership.mem (nhds 1) e â†’ Exists fun N => âˆ€ (t : Set Nat), HasSubset.Subset t (setOf fun n => LE.le N n) â†’ Membership.mem e (tprod fun n => f â†‘n))","decl":"@[to_additive]\ntheorem cauchySeq_finset_iff_nat_tprod_vanishing {f : â„• â†’ G} :\n    (CauchySeq fun s : Finset â„• â†¦ âˆ n âˆˆ s, f n) â†”\n      âˆ€ e âˆˆ ğ“ (1 : G), âˆƒ N : â„•, âˆ€ t âŠ† {n | N â‰¤ n}, (âˆ' n : t, f n) âˆˆ e := by\n  refine cauchySeq_finset_iff_tprod_vanishing.trans âŸ¨fun vanish e he â†¦ ?_, fun vanish e he â†¦ ?_âŸ©\n  Â· obtain âŸ¨s, hsâŸ© := vanish e he\n    refine âŸ¨if h : s.Nonempty then s.max' h + 1 else 0,\n      fun t ht â†¦ hs _ <| Set.disjoint_left.mpr ?_âŸ©\n    split_ifs at ht with h\n    Â· exact fun m hmt hms â†¦ (s.le_max' _ hms).not_lt (Nat.succ_le_iff.mp <| ht hmt)\n    Â· exact fun _ _ hs â†¦ h âŸ¨_, hsâŸ©\n  Â· obtain âŸ¨N, hNâŸ© := vanish e he\n    exact âŸ¨range N, fun t ht â†¦ hN _ fun n hnt â†¦\n      le_of_not_lt fun h â†¦ Set.disjoint_left.mp ht hnt (mem_range.mpr h)âŸ©\n\n"}
{"name":"cauchySeq_finset_iff_nat_tsum_vanishing","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"G : Type u_2\ninstâœÂ² : AddCommGroup G\ninstâœÂ¹ : UniformSpace G\ninstâœ : UniformAddGroup G\nf : Nat â†’ G\nâŠ¢ Iff (CauchySeq fun s => s.sum fun n => f n) (âˆ€ (e : Set G), Membership.mem (nhds 0) e â†’ Exists fun N => âˆ€ (t : Set Nat), HasSubset.Subset t (setOf fun n => LE.le N n) â†’ Membership.mem e (tsum fun n => f â†‘n))","decl":"@[to_additive]\ntheorem cauchySeq_finset_iff_nat_tprod_vanishing {f : â„• â†’ G} :\n    (CauchySeq fun s : Finset â„• â†¦ âˆ n âˆˆ s, f n) â†”\n      âˆ€ e âˆˆ ğ“ (1 : G), âˆƒ N : â„•, âˆ€ t âŠ† {n | N â‰¤ n}, (âˆ' n : t, f n) âˆˆ e := by\n  refine cauchySeq_finset_iff_tprod_vanishing.trans âŸ¨fun vanish e he â†¦ ?_, fun vanish e he â†¦ ?_âŸ©\n  Â· obtain âŸ¨s, hsâŸ© := vanish e he\n    refine âŸ¨if h : s.Nonempty then s.max' h + 1 else 0,\n      fun t ht â†¦ hs _ <| Set.disjoint_left.mpr ?_âŸ©\n    split_ifs at ht with h\n    Â· exact fun m hmt hms â†¦ (s.le_max' _ hms).not_lt (Nat.succ_le_iff.mp <| ht hmt)\n    Â· exact fun _ _ hs â†¦ h âŸ¨_, hsâŸ©\n  Â· obtain âŸ¨N, hNâŸ© := vanish e he\n    exact âŸ¨range N, fun t ht â†¦ hN _ fun n hnt â†¦\n      le_of_not_lt fun h â†¦ Set.disjoint_left.mp ht hnt (mem_range.mpr h)âŸ©\n\n"}
{"name":"multipliable_iff_nat_tprod_vanishing","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"G : Type u_2\ninstâœÂ³ : CommGroup G\ninstâœÂ² : UniformSpace G\ninstâœÂ¹ : UniformGroup G\ninstâœ : CompleteSpace G\nf : Nat â†’ G\nâŠ¢ Iff (Multipliable f) (âˆ€ (e : Set G), Membership.mem (nhds 1) e â†’ Exists fun N => âˆ€ (t : Set Nat), HasSubset.Subset t (setOf fun n => LE.le N n) â†’ Membership.mem e (tprod fun n => f â†‘n))","decl":"@[to_additive]\ntheorem multipliable_iff_nat_tprod_vanishing {f : â„• â†’ G} : Multipliable f â†”\n    âˆ€ e âˆˆ ğ“ 1, âˆƒ N : â„•, âˆ€ t âŠ† {n | N â‰¤ n}, (âˆ' n : t, f n) âˆˆ e := by\n  rw [multipliable_iff_cauchySeq_finset, cauchySeq_finset_iff_nat_tprod_vanishing]\n\n"}
{"name":"summable_iff_nat_tsum_vanishing","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"G : Type u_2\ninstâœÂ³ : AddCommGroup G\ninstâœÂ² : UniformSpace G\ninstâœÂ¹ : UniformAddGroup G\ninstâœ : CompleteSpace G\nf : Nat â†’ G\nâŠ¢ Iff (Summable f) (âˆ€ (e : Set G), Membership.mem (nhds 0) e â†’ Exists fun N => âˆ€ (t : Set Nat), HasSubset.Subset t (setOf fun n => LE.le N n) â†’ Membership.mem e (tsum fun n => f â†‘n))","decl":"@[to_additive]\ntheorem multipliable_iff_nat_tprod_vanishing {f : â„• â†’ G} : Multipliable f â†”\n    âˆ€ e âˆˆ ğ“ 1, âˆƒ N : â„•, âˆ€ t âŠ† {n | N â‰¤ n}, (âˆ' n : t, f n) âˆˆ e := by\n  rw [multipliable_iff_cauchySeq_finset, cauchySeq_finset_iff_nat_tprod_vanishing]\n\n"}
{"name":"Multipliable.nat_tprod_vanishing","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"G : Type u_2\ninstâœÂ² : CommGroup G\ninstâœÂ¹ : TopologicalSpace G\ninstâœ : TopologicalGroup G\nf : Nat â†’ G\nhf : Multipliable f\ne : Set G\nhe : Membership.mem (nhds 1) e\nâŠ¢ Exists fun N => âˆ€ (t : Set Nat), HasSubset.Subset t (setOf fun n => LE.le N n) â†’ Membership.mem e (tprod fun n => f â†‘n)","decl":"@[to_additive]\ntheorem Multipliable.nat_tprod_vanishing {f : â„• â†’ G} (hf : Multipliable f) â¦ƒe : Set Gâ¦„\n    (he : e âˆˆ ğ“ 1) : âˆƒ N : â„•, âˆ€ t âŠ† {n | N â‰¤ n}, (âˆ' n : t, f n) âˆˆ e :=\n  letI : UniformSpace G := TopologicalGroup.toUniformSpace G\n  have : UniformGroup G := comm_topologicalGroup_is_uniform\n  cauchySeq_finset_iff_nat_tprod_vanishing.1 hf.hasProd.cauchySeq e he\n\n"}
{"name":"Summable.nat_tsum_vanishing","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"G : Type u_2\ninstâœÂ² : AddCommGroup G\ninstâœÂ¹ : TopologicalSpace G\ninstâœ : TopologicalAddGroup G\nf : Nat â†’ G\nhf : Summable f\ne : Set G\nhe : Membership.mem (nhds 0) e\nâŠ¢ Exists fun N => âˆ€ (t : Set Nat), HasSubset.Subset t (setOf fun n => LE.le N n) â†’ Membership.mem e (tsum fun n => f â†‘n)","decl":"@[to_additive]\ntheorem Multipliable.nat_tprod_vanishing {f : â„• â†’ G} (hf : Multipliable f) â¦ƒe : Set Gâ¦„\n    (he : e âˆˆ ğ“ 1) : âˆƒ N : â„•, âˆ€ t âŠ† {n | N â‰¤ n}, (âˆ' n : t, f n) âˆˆ e :=\n  letI : UniformSpace G := TopologicalGroup.toUniformSpace G\n  have : UniformGroup G := comm_topologicalGroup_is_uniform\n  cauchySeq_finset_iff_nat_tprod_vanishing.1 hf.hasProd.cauchySeq e he\n\n"}
{"name":"Summable.tendsto_atTop_zero","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"G : Type u_2\ninstâœÂ² : AddCommGroup G\ninstâœÂ¹ : TopologicalSpace G\ninstâœ : TopologicalAddGroup G\nf : Nat â†’ G\nhf : Summable f\nâŠ¢ Filter.Tendsto f Filter.atTop (nhds 0)","decl":"@[to_additive]\ntheorem Multipliable.tendsto_atTop_one {f : â„• â†’ G} (hf : Multipliable f) :\n    Tendsto f atTop (ğ“ 1) := by\n  rw [â† Nat.cofinite_eq_atTop]\n  exact hf.tendsto_cofinite_one\n\n"}
{"name":"Multipliable.tendsto_atTop_one","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"G : Type u_2\ninstâœÂ² : CommGroup G\ninstâœÂ¹ : TopologicalSpace G\ninstâœ : TopologicalGroup G\nf : Nat â†’ G\nhf : Multipliable f\nâŠ¢ Filter.Tendsto f Filter.atTop (nhds 1)","decl":"@[to_additive]\ntheorem Multipliable.tendsto_atTop_one {f : â„• â†’ G} (hf : Multipliable f) :\n    Tendsto f atTop (ğ“ 1) := by\n  rw [â† Nat.cofinite_eq_atTop]\n  exact hf.tendsto_cofinite_one\n\n"}
{"name":"HasSum.nat_add_neg_add_one","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninstâœÂ¹ : AddCommMonoid M\ninstâœ : TopologicalSpace M\nm : M\nf : Int â†’ M\nhf : HasSum f m\nâŠ¢ HasSum (fun n => HAdd.hAdd (f â†‘n) (f (Neg.neg (HAdd.hAdd (â†‘n) 1)))) m","decl":"@[to_additive HasSum.nat_add_neg_add_one]\nlemma HasProd.nat_mul_neg_add_one {f : â„¤ â†’ M} (hf : HasProd f m) :\n    HasProd (fun n : â„• â†¦ f n * f (-(n + 1))) m := by\n  change HasProd (fun n : â„• â†¦ f n * f (Int.negSucc n)) m\n  have : Injective Int.negSucc := @Int.negSucc.inj\n  refine hf.hasProd_of_prod_eq fun u â†¦ ?_\n  refine âŸ¨u.preimage _ Nat.cast_injective.injOn âˆª u.preimage _ this.injOn,\n      fun v' hv' â†¦ âŸ¨v'.image Nat.cast âˆª v'.image Int.negSucc, fun x hx â†¦ ?_, ?_âŸ©âŸ©\n  Â· simp only [mem_union, mem_image]\n    cases x\n    Â· exact Or.inl âŸ¨_, hv' (by simpa using Or.inl hx), rflâŸ©\n    Â· exact Or.inr âŸ¨_, hv' (by simpa using Or.inr hx), rflâŸ©\n  Â· rw [prod_union, prod_image Nat.cast_injective.injOn, prod_image this.injOn,\n      prod_mul_distrib]\n    simp only [disjoint_iff_ne, mem_image, ne_eq, forall_exists_index, and_imp,\n      forall_apply_eq_imp_iffâ‚‚, not_false_eq_true, implies_true, forall_const, reduceCtorEq]\n\n"}
{"name":"HasProd.nat_mul_neg_add_one","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninstâœÂ¹ : CommMonoid M\ninstâœ : TopologicalSpace M\nm : M\nf : Int â†’ M\nhf : HasProd f m\nâŠ¢ HasProd (fun n => HMul.hMul (f â†‘n) (f (Neg.neg (HAdd.hAdd (â†‘n) 1)))) m","decl":"@[to_additive HasSum.nat_add_neg_add_one]\nlemma HasProd.nat_mul_neg_add_one {f : â„¤ â†’ M} (hf : HasProd f m) :\n    HasProd (fun n : â„• â†¦ f n * f (-(n + 1))) m := by\n  change HasProd (fun n : â„• â†¦ f n * f (Int.negSucc n)) m\n  have : Injective Int.negSucc := @Int.negSucc.inj\n  refine hf.hasProd_of_prod_eq fun u â†¦ ?_\n  refine âŸ¨u.preimage _ Nat.cast_injective.injOn âˆª u.preimage _ this.injOn,\n      fun v' hv' â†¦ âŸ¨v'.image Nat.cast âˆª v'.image Int.negSucc, fun x hx â†¦ ?_, ?_âŸ©âŸ©\n  Â· simp only [mem_union, mem_image]\n    cases x\n    Â· exact Or.inl âŸ¨_, hv' (by simpa using Or.inl hx), rflâŸ©\n    Â· exact Or.inr âŸ¨_, hv' (by simpa using Or.inr hx), rflâŸ©\n  Â· rw [prod_union, prod_image Nat.cast_injective.injOn, prod_image this.injOn,\n      prod_mul_distrib]\n    simp only [disjoint_iff_ne, mem_image, ne_eq, forall_exists_index, and_imp,\n      forall_apply_eq_imp_iffâ‚‚, not_false_eq_true, implies_true, forall_const, reduceCtorEq]\n\n"}
{"name":"Multipliable.nat_mul_neg_add_one","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninstâœÂ¹ : CommMonoid M\ninstâœ : TopologicalSpace M\nf : Int â†’ M\nhf : Multipliable f\nâŠ¢ Multipliable fun n => HMul.hMul (f â†‘n) (f (Neg.neg (HAdd.hAdd (â†‘n) 1)))","decl":"@[to_additive Summable.nat_add_neg_add_one]\nlemma Multipliable.nat_mul_neg_add_one {f : â„¤ â†’ M} (hf : Multipliable f) :\n    Multipliable (fun n : â„• â†¦ f n * f (-(n + 1))) :=\n  hf.hasProd.nat_mul_neg_add_one.multipliable\n\n"}
{"name":"Summable.nat_add_neg_add_one","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninstâœÂ¹ : AddCommMonoid M\ninstâœ : TopologicalSpace M\nf : Int â†’ M\nhf : Summable f\nâŠ¢ Summable fun n => HAdd.hAdd (f â†‘n) (f (Neg.neg (HAdd.hAdd (â†‘n) 1)))","decl":"@[to_additive Summable.nat_add_neg_add_one]\nlemma Multipliable.nat_mul_neg_add_one {f : â„¤ â†’ M} (hf : Multipliable f) :\n    Multipliable (fun n : â„• â†¦ f n * f (-(n + 1))) :=\n  hf.hasProd.nat_mul_neg_add_one.multipliable\n\n"}
{"name":"tsum_nat_add_neg_add_one","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninstâœÂ² : AddCommMonoid M\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : T2Space M\nf : Int â†’ M\nhf : Summable f\nâŠ¢ Eq (tsum fun n => HAdd.hAdd (f â†‘n) (f (Neg.neg (HAdd.hAdd (â†‘n) 1)))) (tsum fun n => f n)","decl":"@[to_additive tsum_nat_add_neg_add_one]\nlemma tprod_nat_mul_neg_add_one [T2Space M] {f : â„¤ â†’ M} (hf : Multipliable f) :\n    âˆ' (n : â„•), (f n * f (-(n + 1))) = âˆ' (n : â„¤), f n :=\n  hf.hasProd.nat_mul_neg_add_one.tprod_eq\n\n"}
{"name":"tprod_nat_mul_neg_add_one","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninstâœÂ² : CommMonoid M\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : T2Space M\nf : Int â†’ M\nhf : Multipliable f\nâŠ¢ Eq (tprod fun n => HMul.hMul (f â†‘n) (f (Neg.neg (HAdd.hAdd (â†‘n) 1)))) (tprod fun n => f n)","decl":"@[to_additive tsum_nat_add_neg_add_one]\nlemma tprod_nat_mul_neg_add_one [T2Space M] {f : â„¤ â†’ M} (hf : Multipliable f) :\n    âˆ' (n : â„•), (f n * f (-(n + 1))) = âˆ' (n : â„¤), f n :=\n  hf.hasProd.nat_mul_neg_add_one.tprod_eq\n\n"}
{"name":"HasSum.of_nat_of_neg_add_one","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninstâœÂ² : AddCommMonoid M\ninstâœÂ¹ : TopologicalSpace M\nm m' : M\ninstâœ : ContinuousAdd M\nf : Int â†’ M\nhfâ‚ : HasSum (fun n => f â†‘n) m\nhfâ‚‚ : HasSum (fun n => f (Neg.neg (HAdd.hAdd (â†‘n) 1))) m'\nâŠ¢ HasSum f (HAdd.hAdd m m')","decl":"@[to_additive HasSum.of_nat_of_neg_add_one]\nlemma HasProd.of_nat_of_neg_add_one {f : â„¤ â†’ M}\n    (hfâ‚ : HasProd (fun n : â„• â†¦ f n) m) (hfâ‚‚ : HasProd (fun n : â„• â†¦ f (-(n + 1))) m') :\n    HasProd f (m * m') := by\n  have hiâ‚‚ : Injective Int.negSucc := @Int.negSucc.inj\n  have : IsCompl (Set.range ((â†‘) : â„• â†’ â„¤)) (Set.range Int.negSucc) := by\n    constructor\n    Â· rw [disjoint_iff_inf_le]\n      rintro _ âŸ¨âŸ¨i, rflâŸ©, âŸ¨j, âŸ¨âŸ©âŸ©âŸ©\n    Â· rw [codisjoint_iff_le_sup]\n      rintro (i | j) <;> simp\n  exact (Nat.cast_injective.hasProd_range_iff.mpr hfâ‚).mul_isCompl\n    this (hiâ‚‚.hasProd_range_iff.mpr hfâ‚‚)\n\n\n"}
{"name":"HasProd.of_nat_of_neg_add_one","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninstâœÂ² : CommMonoid M\ninstâœÂ¹ : TopologicalSpace M\nm m' : M\ninstâœ : ContinuousMul M\nf : Int â†’ M\nhfâ‚ : HasProd (fun n => f â†‘n) m\nhfâ‚‚ : HasProd (fun n => f (Neg.neg (HAdd.hAdd (â†‘n) 1))) m'\nâŠ¢ HasProd f (HMul.hMul m m')","decl":"@[to_additive HasSum.of_nat_of_neg_add_one]\nlemma HasProd.of_nat_of_neg_add_one {f : â„¤ â†’ M}\n    (hfâ‚ : HasProd (fun n : â„• â†¦ f n) m) (hfâ‚‚ : HasProd (fun n : â„• â†¦ f (-(n + 1))) m') :\n    HasProd f (m * m') := by\n  have hiâ‚‚ : Injective Int.negSucc := @Int.negSucc.inj\n  have : IsCompl (Set.range ((â†‘) : â„• â†’ â„¤)) (Set.range Int.negSucc) := by\n    constructor\n    Â· rw [disjoint_iff_inf_le]\n      rintro _ âŸ¨âŸ¨i, rflâŸ©, âŸ¨j, âŸ¨âŸ©âŸ©âŸ©\n    Â· rw [codisjoint_iff_le_sup]\n      rintro (i | j) <;> simp\n  exact (Nat.cast_injective.hasProd_range_iff.mpr hfâ‚).mul_isCompl\n    this (hiâ‚‚.hasProd_range_iff.mpr hfâ‚‚)\n\n\n"}
{"name":"Summable.of_nat_of_neg_add_one","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninstâœÂ² : AddCommMonoid M\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : ContinuousAdd M\nf : Int â†’ M\nhfâ‚ : Summable fun n => f â†‘n\nhfâ‚‚ : Summable fun n => f (Neg.neg (HAdd.hAdd (â†‘n) 1))\nâŠ¢ Summable f","decl":"@[to_additive Summable.of_nat_of_neg_add_one]\nlemma Multipliable.of_nat_of_neg_add_one {f : â„¤ â†’ M}\n    (hfâ‚ : Multipliable fun n : â„• â†¦ f n) (hfâ‚‚ : Multipliable fun n : â„• â†¦ f (-(n + 1))) :\n    Multipliable f :=\n  (hfâ‚.hasProd.of_nat_of_neg_add_one hfâ‚‚.hasProd).multipliable\n\n"}
{"name":"Multipliable.of_nat_of_neg_add_one","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninstâœÂ² : CommMonoid M\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : ContinuousMul M\nf : Int â†’ M\nhfâ‚ : Multipliable fun n => f â†‘n\nhfâ‚‚ : Multipliable fun n => f (Neg.neg (HAdd.hAdd (â†‘n) 1))\nâŠ¢ Multipliable f","decl":"@[to_additive Summable.of_nat_of_neg_add_one]\nlemma Multipliable.of_nat_of_neg_add_one {f : â„¤ â†’ M}\n    (hfâ‚ : Multipliable fun n : â„• â†¦ f n) (hfâ‚‚ : Multipliable fun n : â„• â†¦ f (-(n + 1))) :\n    Multipliable f :=\n  (hfâ‚.hasProd.of_nat_of_neg_add_one hfâ‚‚.hasProd).multipliable\n\n"}
{"name":"tprod_of_nat_of_neg_add_one","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninstâœÂ³ : CommMonoid M\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : ContinuousMul M\ninstâœ : T2Space M\nf : Int â†’ M\nhfâ‚ : Multipliable fun n => f â†‘n\nhfâ‚‚ : Multipliable fun n => f (Neg.neg (HAdd.hAdd (â†‘n) 1))\nâŠ¢ Eq (tprod fun n => f n) (HMul.hMul (tprod fun n => f â†‘n) (tprod fun n => f (Neg.neg (HAdd.hAdd (â†‘n) 1))))","decl":"@[to_additive tsum_of_nat_of_neg_add_one]\nlemma tprod_of_nat_of_neg_add_one [T2Space M] {f : â„¤ â†’ M}\n    (hfâ‚ : Multipliable fun n : â„• â†¦ f n) (hfâ‚‚ : Multipliable fun n : â„• â†¦ f (-(n + 1))) :\n    âˆ' n : â„¤, f n = (âˆ' n : â„•, f n) * âˆ' n : â„•, f (-(n + 1)) :=\n  (hfâ‚.hasProd.of_nat_of_neg_add_one hfâ‚‚.hasProd).tprod_eq\n\n"}
{"name":"tsum_of_nat_of_neg_add_one","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninstâœÂ³ : AddCommMonoid M\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : ContinuousAdd M\ninstâœ : T2Space M\nf : Int â†’ M\nhfâ‚ : Summable fun n => f â†‘n\nhfâ‚‚ : Summable fun n => f (Neg.neg (HAdd.hAdd (â†‘n) 1))\nâŠ¢ Eq (tsum fun n => f n) (HAdd.hAdd (tsum fun n => f â†‘n) (tsum fun n => f (Neg.neg (HAdd.hAdd (â†‘n) 1))))","decl":"@[to_additive tsum_of_nat_of_neg_add_one]\nlemma tprod_of_nat_of_neg_add_one [T2Space M] {f : â„¤ â†’ M}\n    (hfâ‚ : Multipliable fun n : â„• â†¦ f n) (hfâ‚‚ : Multipliable fun n : â„• â†¦ f (-(n + 1))) :\n    âˆ' n : â„¤, f n = (âˆ' n : â„•, f n) * âˆ' n : â„•, f (-(n + 1)) :=\n  (hfâ‚.hasProd.of_nat_of_neg_add_one hfâ‚‚.hasProd).tprod_eq\n\n"}
{"name":"HasProd.int_rec","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninstâœÂ² : CommMonoid M\ninstâœÂ¹ : TopologicalSpace M\nm m' : M\ninstâœ : ContinuousMul M\nf g : Nat â†’ M\nhf : HasProd f m\nhg : HasProd g m'\nâŠ¢ HasProd (fun t => Int.rec f g t) (HMul.hMul m m')","decl":"/-- If `fâ‚€, fâ‚, fâ‚‚, ...` and `gâ‚€, gâ‚, gâ‚‚, ...` have products `a`, `b` respectively, then\nthe `â„¤`-indexed sequence: `..., gâ‚‚, gâ‚, gâ‚€, fâ‚€, fâ‚, fâ‚‚, ...` (with `fâ‚€` at the `0`-th position) has\nproduct `a + b`. -/\n@[to_additive \"If `fâ‚€, fâ‚, fâ‚‚, ...` and `gâ‚€, gâ‚, gâ‚‚, ...` have sums `a`, `b` respectively, then\nthe `â„¤`-indexed sequence: `..., gâ‚‚, gâ‚, gâ‚€, fâ‚€, fâ‚, fâ‚‚, ...` (with `fâ‚€` at the `0`-th position) has\nsum `a + b`.\"]\nlemma HasProd.int_rec {f g : â„• â†’ M} (hf : HasProd f m) (hg : HasProd g m') :\n    HasProd (Int.rec f g) (m * m') :=\n  HasProd.of_nat_of_neg_add_one hf hg\n\n"}
{"name":"HasSum.int_rec","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninstâœÂ² : AddCommMonoid M\ninstâœÂ¹ : TopologicalSpace M\nm m' : M\ninstâœ : ContinuousAdd M\nf g : Nat â†’ M\nhf : HasSum f m\nhg : HasSum g m'\nâŠ¢ HasSum (fun t => Int.rec f g t) (HAdd.hAdd m m')","decl":"/-- If `fâ‚€, fâ‚, fâ‚‚, ...` and `gâ‚€, gâ‚, gâ‚‚, ...` have products `a`, `b` respectively, then\nthe `â„¤`-indexed sequence: `..., gâ‚‚, gâ‚, gâ‚€, fâ‚€, fâ‚, fâ‚‚, ...` (with `fâ‚€` at the `0`-th position) has\nproduct `a + b`. -/\n@[to_additive \"If `fâ‚€, fâ‚, fâ‚‚, ...` and `gâ‚€, gâ‚, gâ‚‚, ...` have sums `a`, `b` respectively, then\nthe `â„¤`-indexed sequence: `..., gâ‚‚, gâ‚, gâ‚€, fâ‚€, fâ‚, fâ‚‚, ...` (with `fâ‚€` at the `0`-th position) has\nsum `a + b`.\"]\nlemma HasProd.int_rec {f g : â„• â†’ M} (hf : HasProd f m) (hg : HasProd g m') :\n    HasProd (Int.rec f g) (m * m') :=\n  HasProd.of_nat_of_neg_add_one hf hg\n\n"}
{"name":"Multipliable.int_rec","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninstâœÂ² : CommMonoid M\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : ContinuousMul M\nf g : Nat â†’ M\nhf : Multipliable f\nhg : Multipliable g\nâŠ¢ Multipliable fun t => Int.rec f g t","decl":"/-- If `fâ‚€, fâ‚, fâ‚‚, ...` and `gâ‚€, gâ‚, gâ‚‚, ...` are both multipliable then so is the\n`â„¤`-indexed sequence: `..., gâ‚‚, gâ‚, gâ‚€, fâ‚€, fâ‚, fâ‚‚, ...` (with `fâ‚€` at the `0`-th position). -/\n@[to_additive \"If `fâ‚€, fâ‚, fâ‚‚, ...` and `gâ‚€, gâ‚, gâ‚‚, ...` are both summable then so is the\n`â„¤`-indexed sequence: `..., gâ‚‚, gâ‚, gâ‚€, fâ‚€, fâ‚, fâ‚‚, ...` (with `fâ‚€` at the `0`-th position).\"]\nlemma Multipliable.int_rec {f g : â„• â†’ M} (hf : Multipliable f) (hg : Multipliable g) :\n    Multipliable (Int.rec f g) :=\n  .of_nat_of_neg_add_one hf hg\n\n"}
{"name":"Summable.int_rec","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninstâœÂ² : AddCommMonoid M\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : ContinuousAdd M\nf g : Nat â†’ M\nhf : Summable f\nhg : Summable g\nâŠ¢ Summable fun t => Int.rec f g t","decl":"/-- If `fâ‚€, fâ‚, fâ‚‚, ...` and `gâ‚€, gâ‚, gâ‚‚, ...` are both multipliable then so is the\n`â„¤`-indexed sequence: `..., gâ‚‚, gâ‚, gâ‚€, fâ‚€, fâ‚, fâ‚‚, ...` (with `fâ‚€` at the `0`-th position). -/\n@[to_additive \"If `fâ‚€, fâ‚, fâ‚‚, ...` and `gâ‚€, gâ‚, gâ‚‚, ...` are both summable then so is the\n`â„¤`-indexed sequence: `..., gâ‚‚, gâ‚, gâ‚€, fâ‚€, fâ‚, fâ‚‚, ...` (with `fâ‚€` at the `0`-th position).\"]\nlemma Multipliable.int_rec {f g : â„• â†’ M} (hf : Multipliable f) (hg : Multipliable g) :\n    Multipliable (Int.rec f g) :=\n  .of_nat_of_neg_add_one hf hg\n\n"}
{"name":"tsum_int_rec","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninstâœÂ³ : AddCommMonoid M\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : ContinuousAdd M\ninstâœ : T2Space M\nf g : Nat â†’ M\nhf : Summable f\nhg : Summable g\nâŠ¢ Eq (tsum fun n => Int.rec f g n) (HAdd.hAdd (tsum fun n => f n) (tsum fun n => g n))","decl":"/-- If `fâ‚€, fâ‚, fâ‚‚, ...` and `gâ‚€, gâ‚, gâ‚‚, ...` are both multipliable, then the product of the\n`â„¤`-indexed sequence: `..., gâ‚‚, gâ‚, gâ‚€, fâ‚€, fâ‚, fâ‚‚, ...` (with `fâ‚€` at the `0`-th position) is\n`(âˆ' n, f n) * âˆ' n, g n`. -/\n@[to_additive \"If `fâ‚€, fâ‚, fâ‚‚, ...` and `gâ‚€, gâ‚, gâ‚‚, ...` are both summable, then the sum of the\n`â„¤`-indexed sequence: `..., gâ‚‚, gâ‚, gâ‚€, fâ‚€, fâ‚, fâ‚‚, ...` (with `fâ‚€` at the `0`-th position) is\n`âˆ‘' n, f n + âˆ‘' n, g n`.\"]\nlemma tprod_int_rec [T2Space M] {f g : â„• â†’ M} (hf : Multipliable f) (hg : Multipliable g) :\n    âˆ' n : â„¤, Int.rec f g n = (âˆ' n : â„•, f n) * âˆ' n : â„•, g n :=\n  (hf.hasProd.int_rec hg.hasProd).tprod_eq\n\n"}
{"name":"tprod_int_rec","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninstâœÂ³ : CommMonoid M\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : ContinuousMul M\ninstâœ : T2Space M\nf g : Nat â†’ M\nhf : Multipliable f\nhg : Multipliable g\nâŠ¢ Eq (tprod fun n => Int.rec f g n) (HMul.hMul (tprod fun n => f n) (tprod fun n => g n))","decl":"/-- If `fâ‚€, fâ‚, fâ‚‚, ...` and `gâ‚€, gâ‚, gâ‚‚, ...` are both multipliable, then the product of the\n`â„¤`-indexed sequence: `..., gâ‚‚, gâ‚, gâ‚€, fâ‚€, fâ‚, fâ‚‚, ...` (with `fâ‚€` at the `0`-th position) is\n`(âˆ' n, f n) * âˆ' n, g n`. -/\n@[to_additive \"If `fâ‚€, fâ‚, fâ‚‚, ...` and `gâ‚€, gâ‚, gâ‚‚, ...` are both summable, then the sum of the\n`â„¤`-indexed sequence: `..., gâ‚‚, gâ‚, gâ‚€, fâ‚€, fâ‚, fâ‚‚, ...` (with `fâ‚€` at the `0`-th position) is\n`âˆ‘' n, f n + âˆ‘' n, g n`.\"]\nlemma tprod_int_rec [T2Space M] {f g : â„• â†’ M} (hf : Multipliable f) (hg : Multipliable g) :\n    âˆ' n : â„¤, Int.rec f g n = (âˆ' n : â„•, f n) * âˆ' n : â„•, g n :=\n  (hf.hasProd.int_rec hg.hasProd).tprod_eq\n\n"}
{"name":"HasSum.nat_add_neg","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninstâœÂ² : AddCommMonoid M\ninstâœÂ¹ : TopologicalSpace M\nm : M\ninstâœ : ContinuousAdd M\nf : Int â†’ M\nhf : HasSum f m\nâŠ¢ HasSum (fun n => HAdd.hAdd (f â†‘n) (f (Neg.neg â†‘n))) (HAdd.hAdd m (f 0))","decl":"@[to_additive]\ntheorem HasProd.nat_mul_neg {f : â„¤ â†’ M} (hf : HasProd f m) :\n    HasProd (fun n : â„• â†¦ f n * f (-n)) (m * f 0) := by\n  -- Note this is much easier to prove if you assume more about the target space, but we have to\n  -- work hard to prove it under the very minimal assumptions here.\n  apply (hf.mul (hasProd_ite_eq (0 : â„¤) (f 0))).hasProd_of_prod_eq fun u â†¦ ?_\n  refine âŸ¨u.image Int.natAbs, fun v' hv' â†¦ ?_âŸ©\n  let u1 := v'.image fun x : â„• â†¦ (x : â„¤)\n  let u2 := v'.image fun x : â„• â†¦ -(x : â„¤)\n  have A : u âŠ† u1 âˆª u2 := by\n    intro x hx\n    simp only [u1, u2, mem_union, mem_image, exists_prop]\n    rcases le_total 0 x with (h'x | h'x)\n    Â· refine Or.inl âŸ¨_, hv' <| mem_image.mpr âŸ¨x, hx, rflâŸ©, ?_âŸ©\n      simp only [Int.natCast_natAbs, abs_eq_self, h'x]\n    Â· refine Or.inr âŸ¨_, hv' <| mem_image.mpr âŸ¨x, hx, rflâŸ©, ?_âŸ©\n      simp only [abs_of_nonpos h'x, Int.natCast_natAbs, neg_neg]\n  exact âŸ¨_, A, calc\n    (âˆ x âˆˆ u1 âˆª u2, (f x * if x = 0 then f 0 else 1)) =\n        (âˆ x âˆˆ u1 âˆª u2, f x) * âˆ x âˆˆ u1 âˆ© u2, f x := by\n      rw [prod_mul_distrib]\n      congr 1\n      refine (prod_subset_one_on_sdiff inter_subset_union ?_ ?_).symm\n      Â· intro x hx\n        suffices x â‰  0 by simp only [this, if_false]\n        rintro rfl\n        simp only [mem_sdiff, mem_union, mem_image, Nat.cast_eq_zero, exists_eq_right, neg_eq_zero,\n          or_self, mem_inter, and_self, and_not_self, u1, u2] at hx\n      Â· intro x hx\n        simp only [u1, u2, mem_inter, mem_image, exists_prop] at hx\n        suffices x = 0 by simp only [this, eq_self_iff_true, if_true]\n        omega\n    _ = (âˆ x âˆˆ u1, f x) * âˆ x âˆˆ u2, f x := prod_union_inter\n    _ = (âˆ b âˆˆ v', f b) * âˆ b âˆˆ v', f (-b) := by\n      simp only [u1, u2, Nat.cast_inj, imp_self, implies_true, forall_const, prod_image, neg_inj]\n    _ = âˆ b âˆˆ v', (f b * f (-b)) := prod_mul_distrib.symmâŸ©\n\n"}
{"name":"HasProd.nat_mul_neg","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninstâœÂ² : CommMonoid M\ninstâœÂ¹ : TopologicalSpace M\nm : M\ninstâœ : ContinuousMul M\nf : Int â†’ M\nhf : HasProd f m\nâŠ¢ HasProd (fun n => HMul.hMul (f â†‘n) (f (Neg.neg â†‘n))) (HMul.hMul m (f 0))","decl":"@[to_additive]\ntheorem HasProd.nat_mul_neg {f : â„¤ â†’ M} (hf : HasProd f m) :\n    HasProd (fun n : â„• â†¦ f n * f (-n)) (m * f 0) := by\n  -- Note this is much easier to prove if you assume more about the target space, but we have to\n  -- work hard to prove it under the very minimal assumptions here.\n  apply (hf.mul (hasProd_ite_eq (0 : â„¤) (f 0))).hasProd_of_prod_eq fun u â†¦ ?_\n  refine âŸ¨u.image Int.natAbs, fun v' hv' â†¦ ?_âŸ©\n  let u1 := v'.image fun x : â„• â†¦ (x : â„¤)\n  let u2 := v'.image fun x : â„• â†¦ -(x : â„¤)\n  have A : u âŠ† u1 âˆª u2 := by\n    intro x hx\n    simp only [u1, u2, mem_union, mem_image, exists_prop]\n    rcases le_total 0 x with (h'x | h'x)\n    Â· refine Or.inl âŸ¨_, hv' <| mem_image.mpr âŸ¨x, hx, rflâŸ©, ?_âŸ©\n      simp only [Int.natCast_natAbs, abs_eq_self, h'x]\n    Â· refine Or.inr âŸ¨_, hv' <| mem_image.mpr âŸ¨x, hx, rflâŸ©, ?_âŸ©\n      simp only [abs_of_nonpos h'x, Int.natCast_natAbs, neg_neg]\n  exact âŸ¨_, A, calc\n    (âˆ x âˆˆ u1 âˆª u2, (f x * if x = 0 then f 0 else 1)) =\n        (âˆ x âˆˆ u1 âˆª u2, f x) * âˆ x âˆˆ u1 âˆ© u2, f x := by\n      rw [prod_mul_distrib]\n      congr 1\n      refine (prod_subset_one_on_sdiff inter_subset_union ?_ ?_).symm\n      Â· intro x hx\n        suffices x â‰  0 by simp only [this, if_false]\n        rintro rfl\n        simp only [mem_sdiff, mem_union, mem_image, Nat.cast_eq_zero, exists_eq_right, neg_eq_zero,\n          or_self, mem_inter, and_self, and_not_self, u1, u2] at hx\n      Â· intro x hx\n        simp only [u1, u2, mem_inter, mem_image, exists_prop] at hx\n        suffices x = 0 by simp only [this, eq_self_iff_true, if_true]\n        omega\n    _ = (âˆ x âˆˆ u1, f x) * âˆ x âˆˆ u2, f x := prod_union_inter\n    _ = (âˆ b âˆˆ v', f b) * âˆ b âˆˆ v', f (-b) := by\n      simp only [u1, u2, Nat.cast_inj, imp_self, implies_true, forall_const, prod_image, neg_inj]\n    _ = âˆ b âˆˆ v', (f b * f (-b)) := prod_mul_distrib.symmâŸ©\n\n"}
{"name":"Multipliable.nat_mul_neg","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninstâœÂ² : CommMonoid M\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : ContinuousMul M\nf : Int â†’ M\nhf : Multipliable f\nâŠ¢ Multipliable fun n => HMul.hMul (f â†‘n) (f (Neg.neg â†‘n))","decl":"@[to_additive]\ntheorem Multipliable.nat_mul_neg {f : â„¤ â†’ M} (hf : Multipliable f) :\n    Multipliable fun n : â„• â†¦ f n * f (-n) :=\n  hf.hasProd.nat_mul_neg.multipliable\n\n"}
{"name":"Summable.nat_add_neg","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninstâœÂ² : AddCommMonoid M\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : ContinuousAdd M\nf : Int â†’ M\nhf : Summable f\nâŠ¢ Summable fun n => HAdd.hAdd (f â†‘n) (f (Neg.neg â†‘n))","decl":"@[to_additive]\ntheorem Multipliable.nat_mul_neg {f : â„¤ â†’ M} (hf : Multipliable f) :\n    Multipliable fun n : â„• â†¦ f n * f (-n) :=\n  hf.hasProd.nat_mul_neg.multipliable\n\n"}
{"name":"tsum_nat_add_neg","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninstâœÂ³ : AddCommMonoid M\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : ContinuousAdd M\ninstâœ : T2Space M\nf : Int â†’ M\nhf : Summable f\nâŠ¢ Eq (tsum fun n => HAdd.hAdd (f â†‘n) (f (Neg.neg â†‘n))) (HAdd.hAdd (tsum fun n => f n) (f 0))","decl":"@[to_additive]\nlemma tprod_nat_mul_neg [T2Space M] {f : â„¤ â†’ M} (hf : Multipliable f) :\n    âˆ' n : â„•, (f n * f (-n)) = (âˆ' n : â„¤, f n) * f 0 :=\n  hf.hasProd.nat_mul_neg.tprod_eq\n\n"}
{"name":"tprod_nat_mul_neg","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninstâœÂ³ : CommMonoid M\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : ContinuousMul M\ninstâœ : T2Space M\nf : Int â†’ M\nhf : Multipliable f\nâŠ¢ Eq (tprod fun n => HMul.hMul (f â†‘n) (f (Neg.neg â†‘n))) (HMul.hMul (tprod fun n => f n) (f 0))","decl":"@[to_additive]\nlemma tprod_nat_mul_neg [T2Space M] {f : â„¤ â†’ M} (hf : Multipliable f) :\n    âˆ' n : â„•, (f n * f (-n)) = (âˆ' n : â„¤, f n) * f 0 :=\n  hf.hasProd.nat_mul_neg.tprod_eq\n\n"}
{"name":"HasSum.of_add_one_of_neg_add_one","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninstâœÂ² : AddCommMonoid M\ninstâœÂ¹ : TopologicalSpace M\nm m' : M\ninstâœ : ContinuousAdd M\nf : Int â†’ M\nhfâ‚ : HasSum (fun n => f (HAdd.hAdd (â†‘n) 1)) m\nhfâ‚‚ : HasSum (fun n => f (Neg.neg (HAdd.hAdd (â†‘n) 1))) m'\nâŠ¢ HasSum f (HAdd.hAdd (HAdd.hAdd m (f 0)) m')","decl":"@[to_additive HasSum.of_add_one_of_neg_add_one]\ntheorem HasProd.of_add_one_of_neg_add_one {f : â„¤ â†’ M}\n    (hfâ‚ : HasProd (fun n : â„• â†¦ f (n + 1)) m) (hfâ‚‚ : HasProd (fun n : â„• â†¦ f (-(n + 1))) m') :\n    HasProd f (m * f 0 * m') :=\n  HasProd.of_nat_of_neg_add_one (mul_comm _ m â–¸ HasProd.zero_mul hfâ‚) hfâ‚‚\n\n"}
{"name":"HasProd.of_add_one_of_neg_add_one","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninstâœÂ² : CommMonoid M\ninstâœÂ¹ : TopologicalSpace M\nm m' : M\ninstâœ : ContinuousMul M\nf : Int â†’ M\nhfâ‚ : HasProd (fun n => f (HAdd.hAdd (â†‘n) 1)) m\nhfâ‚‚ : HasProd (fun n => f (Neg.neg (HAdd.hAdd (â†‘n) 1))) m'\nâŠ¢ HasProd f (HMul.hMul (HMul.hMul m (f 0)) m')","decl":"@[to_additive HasSum.of_add_one_of_neg_add_one]\ntheorem HasProd.of_add_one_of_neg_add_one {f : â„¤ â†’ M}\n    (hfâ‚ : HasProd (fun n : â„• â†¦ f (n + 1)) m) (hfâ‚‚ : HasProd (fun n : â„• â†¦ f (-(n + 1))) m') :\n    HasProd f (m * f 0 * m') :=\n  HasProd.of_nat_of_neg_add_one (mul_comm _ m â–¸ HasProd.zero_mul hfâ‚) hfâ‚‚\n\n"}
{"name":"Summable.of_add_one_of_neg_add_one","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninstâœÂ² : AddCommMonoid M\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : ContinuousAdd M\nf : Int â†’ M\nhfâ‚ : Summable fun n => f (HAdd.hAdd (â†‘n) 1)\nhfâ‚‚ : Summable fun n => f (Neg.neg (HAdd.hAdd (â†‘n) 1))\nâŠ¢ Summable f","decl":"@[to_additive Summable.of_add_one_of_neg_add_one]\nlemma Multipliable.of_add_one_of_neg_add_one {f : â„¤ â†’ M}\n    (hfâ‚ : Multipliable fun n : â„• â†¦ f (n + 1)) (hfâ‚‚ : Multipliable fun n : â„• â†¦ f (-(n + 1))) :\n    Multipliable f :=\n  (hfâ‚.hasProd.of_add_one_of_neg_add_one hfâ‚‚.hasProd).multipliable\n\n"}
{"name":"Multipliable.of_add_one_of_neg_add_one","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninstâœÂ² : CommMonoid M\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : ContinuousMul M\nf : Int â†’ M\nhfâ‚ : Multipliable fun n => f (HAdd.hAdd (â†‘n) 1)\nhfâ‚‚ : Multipliable fun n => f (Neg.neg (HAdd.hAdd (â†‘n) 1))\nâŠ¢ Multipliable f","decl":"@[to_additive Summable.of_add_one_of_neg_add_one]\nlemma Multipliable.of_add_one_of_neg_add_one {f : â„¤ â†’ M}\n    (hfâ‚ : Multipliable fun n : â„• â†¦ f (n + 1)) (hfâ‚‚ : Multipliable fun n : â„• â†¦ f (-(n + 1))) :\n    Multipliable f :=\n  (hfâ‚.hasProd.of_add_one_of_neg_add_one hfâ‚‚.hasProd).multipliable\n\n"}
{"name":"tsum_of_add_one_of_neg_add_one","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninstâœÂ³ : AddCommMonoid M\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : ContinuousAdd M\ninstâœ : T2Space M\nf : Int â†’ M\nhfâ‚ : Summable fun n => f (HAdd.hAdd (â†‘n) 1)\nhfâ‚‚ : Summable fun n => f (Neg.neg (HAdd.hAdd (â†‘n) 1))\nâŠ¢ Eq (tsum fun n => f n) (HAdd.hAdd (HAdd.hAdd (tsum fun n => f (HAdd.hAdd (â†‘n) 1)) (f 0)) (tsum fun n => f (Neg.neg (HAdd.hAdd (â†‘n) 1))))","decl":"@[to_additive tsum_of_add_one_of_neg_add_one]\nlemma tprod_of_add_one_of_neg_add_one [T2Space M] {f : â„¤ â†’ M}\n    (hfâ‚ : Multipliable fun n : â„• â†¦ f (n + 1)) (hfâ‚‚ : Multipliable fun n : â„• â†¦ f (-(n + 1))) :\n    âˆ' n : â„¤, f n = (âˆ' n : â„•, f (n + 1)) * f 0 * âˆ' n : â„•, f (-(n + 1)) :=\n  (hfâ‚.hasProd.of_add_one_of_neg_add_one hfâ‚‚.hasProd).tprod_eq\n\n"}
{"name":"tprod_of_add_one_of_neg_add_one","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninstâœÂ³ : CommMonoid M\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : ContinuousMul M\ninstâœ : T2Space M\nf : Int â†’ M\nhfâ‚ : Multipliable fun n => f (HAdd.hAdd (â†‘n) 1)\nhfâ‚‚ : Multipliable fun n => f (Neg.neg (HAdd.hAdd (â†‘n) 1))\nâŠ¢ Eq (tprod fun n => f n) (HMul.hMul (HMul.hMul (tprod fun n => f (HAdd.hAdd (â†‘n) 1)) (f 0)) (tprod fun n => f (Neg.neg (HAdd.hAdd (â†‘n) 1))))","decl":"@[to_additive tsum_of_add_one_of_neg_add_one]\nlemma tprod_of_add_one_of_neg_add_one [T2Space M] {f : â„¤ â†’ M}\n    (hfâ‚ : Multipliable fun n : â„• â†¦ f (n + 1)) (hfâ‚‚ : Multipliable fun n : â„• â†¦ f (-(n + 1))) :\n    âˆ' n : â„¤, f n = (âˆ' n : â„•, f (n + 1)) * f 0 * âˆ' n : â„•, f (-(n + 1)) :=\n  (hfâ‚.hasProd.of_add_one_of_neg_add_one hfâ‚‚.hasProd).tprod_eq\n\n"}
{"name":"HasSum.of_nat_of_neg","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"G : Type u_2\ninstâœÂ² : AddCommGroup G\ng g' : G\ninstâœÂ¹ : TopologicalSpace G\ninstâœ : TopologicalAddGroup G\nf : Int â†’ G\nhfâ‚ : HasSum (fun n => f â†‘n) g\nhfâ‚‚ : HasSum (fun n => f (Neg.neg â†‘n)) g'\nâŠ¢ HasSum f (HSub.hSub (HAdd.hAdd g g') (f 0))","decl":"@[to_additive]\nlemma HasProd.of_nat_of_neg {f : â„¤ â†’ G} (hfâ‚ : HasProd (fun n : â„• â†¦ f n) g)\n    (hfâ‚‚ : HasProd (fun n : â„• â†¦ f (-n)) g') : HasProd f (g * g' / f 0) := by\n  refine mul_div_assoc' g .. â–¸ hfâ‚.of_nat_of_neg_add_one (m' := g' / f 0) ?_\n  rwa [â† hasProd_nat_add_iff' 1, prod_range_one, Nat.cast_zero, neg_zero] at hfâ‚‚\n\n"}
{"name":"HasProd.of_nat_of_neg","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"G : Type u_2\ninstâœÂ² : CommGroup G\ng g' : G\ninstâœÂ¹ : TopologicalSpace G\ninstâœ : TopologicalGroup G\nf : Int â†’ G\nhfâ‚ : HasProd (fun n => f â†‘n) g\nhfâ‚‚ : HasProd (fun n => f (Neg.neg â†‘n)) g'\nâŠ¢ HasProd f (HDiv.hDiv (HMul.hMul g g') (f 0))","decl":"@[to_additive]\nlemma HasProd.of_nat_of_neg {f : â„¤ â†’ G} (hfâ‚ : HasProd (fun n : â„• â†¦ f n) g)\n    (hfâ‚‚ : HasProd (fun n : â„• â†¦ f (-n)) g') : HasProd f (g * g' / f 0) := by\n  refine mul_div_assoc' g .. â–¸ hfâ‚.of_nat_of_neg_add_one (m' := g' / f 0) ?_\n  rwa [â† hasProd_nat_add_iff' 1, prod_range_one, Nat.cast_zero, neg_zero] at hfâ‚‚\n\n"}
{"name":"Multipliable.of_nat_of_neg","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"G : Type u_2\ninstâœÂ² : CommGroup G\ninstâœÂ¹ : TopologicalSpace G\ninstâœ : TopologicalGroup G\nf : Int â†’ G\nhfâ‚ : Multipliable fun n => f â†‘n\nhfâ‚‚ : Multipliable fun n => f (Neg.neg â†‘n)\nâŠ¢ Multipliable f","decl":"@[to_additive]\nlemma Multipliable.of_nat_of_neg {f : â„¤ â†’ G} (hfâ‚ : Multipliable fun n : â„• â†¦ f n)\n    (hfâ‚‚ : Multipliable fun n : â„• â†¦ f (-n)) : Multipliable f :=\n  (hfâ‚.hasProd.of_nat_of_neg hfâ‚‚.hasProd).multipliable\n\n"}
{"name":"Summable.of_nat_of_neg","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"G : Type u_2\ninstâœÂ² : AddCommGroup G\ninstâœÂ¹ : TopologicalSpace G\ninstâœ : TopologicalAddGroup G\nf : Int â†’ G\nhfâ‚ : Summable fun n => f â†‘n\nhfâ‚‚ : Summable fun n => f (Neg.neg â†‘n)\nâŠ¢ Summable f","decl":"@[to_additive]\nlemma Multipliable.of_nat_of_neg {f : â„¤ â†’ G} (hfâ‚ : Multipliable fun n : â„• â†¦ f n)\n    (hfâ‚‚ : Multipliable fun n : â„• â†¦ f (-n)) : Multipliable f :=\n  (hfâ‚.hasProd.of_nat_of_neg hfâ‚‚.hasProd).multipliable\n\n"}
{"name":"tsum_of_nat_of_neg","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"G : Type u_2\ninstâœÂ³ : AddCommGroup G\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : TopologicalAddGroup G\ninstâœ : T2Space G\nf : Int â†’ G\nhfâ‚ : Summable fun n => f â†‘n\nhfâ‚‚ : Summable fun n => f (Neg.neg â†‘n)\nâŠ¢ Eq (tsum fun n => f n) (HSub.hSub (HAdd.hAdd (tsum fun n => f â†‘n) (tsum fun n => f (Neg.neg â†‘n))) (f 0))","decl":"@[to_additive]\nlemma tprod_of_nat_of_neg [T2Space G] {f : â„¤ â†’ G}\n    (hfâ‚ : Multipliable fun n : â„• â†¦ f n) (hfâ‚‚ : Multipliable fun n : â„• â†¦ f (-n)) :\n    âˆ' n : â„¤, f n = (âˆ' n : â„•, f n) * (âˆ' n : â„•, f (-n)) / f 0 :=\n  (hfâ‚.hasProd.of_nat_of_neg hfâ‚‚.hasProd).tprod_eq\n\n"}
{"name":"tprod_of_nat_of_neg","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"G : Type u_2\ninstâœÂ³ : CommGroup G\ninstâœÂ² : TopologicalSpace G\ninstâœÂ¹ : TopologicalGroup G\ninstâœ : T2Space G\nf : Int â†’ G\nhfâ‚ : Multipliable fun n => f â†‘n\nhfâ‚‚ : Multipliable fun n => f (Neg.neg â†‘n)\nâŠ¢ Eq (tprod fun n => f n) (HDiv.hDiv (HMul.hMul (tprod fun n => f â†‘n) (tprod fun n => f (Neg.neg â†‘n))) (f 0))","decl":"@[to_additive]\nlemma tprod_of_nat_of_neg [T2Space G] {f : â„¤ â†’ G}\n    (hfâ‚ : Multipliable fun n : â„• â†¦ f n) (hfâ‚‚ : Multipliable fun n : â„• â†¦ f (-n)) :\n    âˆ' n : â„¤, f n = (âˆ' n : â„•, f n) * (âˆ' n : â„•, f (-n)) / f 0 :=\n  (hfâ‚.hasProd.of_nat_of_neg hfâ‚‚.hasProd).tprod_eq\n\n"}
{"name":"multipliable_int_iff_multipliable_nat_and_neg_add_one","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"G : Type u_2\ninstâœÂ³ : CommGroup G\ninstâœÂ² : UniformSpace G\ninstâœÂ¹ : UniformGroup G\ninstâœ : CompleteSpace G\nf : Int â†’ G\nâŠ¢ Iff (Multipliable f) (And (Multipliable fun n => f â†‘n) (Multipliable fun n => f (Neg.neg (HAdd.hAdd (â†‘n) 1))))","decl":"/-- \"iff\" version of `Multipliable.of_nat_of_neg_add_one`. -/\n@[to_additive \"\\\"iff\\\" version of `Summable.of_nat_of_neg_add_one`.\"]\nlemma multipliable_int_iff_multipliable_nat_and_neg_add_one {f : â„¤ â†’ G} : Multipliable f â†”\n    (Multipliable fun n : â„• â†¦ f n) âˆ§ (Multipliable fun n : â„• â†¦ f (-(n + 1))) := by\n  refine âŸ¨fun p â†¦ âŸ¨?_, ?_âŸ©, fun âŸ¨hfâ‚, hfâ‚‚âŸ© â†¦ Multipliable.of_nat_of_neg_add_one hfâ‚ hfâ‚‚âŸ© <;>\n  apply p.comp_injective\n  exacts [Nat.cast_injective, @Int.negSucc.inj]\n\n"}
{"name":"summable_int_iff_summable_nat_and_neg_add_zero","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"G : Type u_2\ninstâœÂ³ : AddCommGroup G\ninstâœÂ² : UniformSpace G\ninstâœÂ¹ : UniformAddGroup G\ninstâœ : CompleteSpace G\nf : Int â†’ G\nâŠ¢ Iff (Summable f) (And (Summable fun n => f â†‘n) (Summable fun n => f (Neg.neg (HAdd.hAdd (â†‘n) 1))))","decl":"/-- \"iff\" version of `Multipliable.of_nat_of_neg_add_one`. -/\n@[to_additive \"\\\"iff\\\" version of `Summable.of_nat_of_neg_add_one`.\"]\nlemma multipliable_int_iff_multipliable_nat_and_neg_add_one {f : â„¤ â†’ G} : Multipliable f â†”\n    (Multipliable fun n : â„• â†¦ f n) âˆ§ (Multipliable fun n : â„• â†¦ f (-(n + 1))) := by\n  refine âŸ¨fun p â†¦ âŸ¨?_, ?_âŸ©, fun âŸ¨hfâ‚, hfâ‚‚âŸ© â†¦ Multipliable.of_nat_of_neg_add_one hfâ‚ hfâ‚‚âŸ© <;>\n  apply p.comp_injective\n  exacts [Nat.cast_injective, @Int.negSucc.inj]\n\n"}
{"name":"multipliable_int_iff_multipliable_nat_and_neg","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"G : Type u_2\ninstâœÂ³ : CommGroup G\ninstâœÂ² : UniformSpace G\ninstâœÂ¹ : UniformGroup G\ninstâœ : CompleteSpace G\nf : Int â†’ G\nâŠ¢ Iff (Multipliable f) (And (Multipliable fun n => f â†‘n) (Multipliable fun n => f (Neg.neg â†‘n)))","decl":"/-- \"iff\" version of `Multipliable.of_nat_of_neg`. -/\n@[to_additive \"\\\"iff\\\" version of `Summable.of_nat_of_neg`.\"]\nlemma multipliable_int_iff_multipliable_nat_and_neg {f : â„¤ â†’ G} :\n    Multipliable f â†” (Multipliable fun n : â„• â†¦ f n) âˆ§ (Multipliable fun n : â„• â†¦ f (-n)) := by\n  refine âŸ¨fun p â†¦ âŸ¨?_, ?_âŸ©, fun âŸ¨hfâ‚, hfâ‚‚âŸ© â†¦ Multipliable.of_nat_of_neg hfâ‚ hfâ‚‚âŸ© <;>\n  apply p.comp_injective\n  exacts [Nat.cast_injective, neg_injective.comp Nat.cast_injective]\n\n"}
{"name":"summable_int_iff_summable_nat_and_neg","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"G : Type u_2\ninstâœÂ³ : AddCommGroup G\ninstâœÂ² : UniformSpace G\ninstâœÂ¹ : UniformAddGroup G\ninstâœ : CompleteSpace G\nf : Int â†’ G\nâŠ¢ Iff (Summable f) (And (Summable fun n => f â†‘n) (Summable fun n => f (Neg.neg â†‘n)))","decl":"/-- \"iff\" version of `Multipliable.of_nat_of_neg`. -/\n@[to_additive \"\\\"iff\\\" version of `Summable.of_nat_of_neg`.\"]\nlemma multipliable_int_iff_multipliable_nat_and_neg {f : â„¤ â†’ G} :\n    Multipliable f â†” (Multipliable fun n : â„• â†¦ f n) âˆ§ (Multipliable fun n : â„• â†¦ f (-n)) := by\n  refine âŸ¨fun p â†¦ âŸ¨?_, ?_âŸ©, fun âŸ¨hfâ‚, hfâ‚‚âŸ© â†¦ Multipliable.of_nat_of_neg hfâ‚ hfâ‚‚âŸ© <;>\n  apply p.comp_injective\n  exacts [Nat.cast_injective, neg_injective.comp Nat.cast_injective]\n\n"}
{"name":"pnat_multipliable_iff_multipliable_succ","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"Î± : Type u_3\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : CommMonoid Î±\nf : Nat â†’ Î±\nâŠ¢ Iff (Multipliable fun x => f â†‘x) (Multipliable fun x => f (HAdd.hAdd x 1))","decl":"@[to_additive]\ntheorem pnat_multipliable_iff_multipliable_succ {Î± : Type*} [TopologicalSpace Î±] [CommMonoid Î±]\n    {f : â„• â†’ Î±} : Multipliable (fun x : â„•+ => f x) â†” Multipliable fun x : â„• => f (x + 1) :=\n  Equiv.pnatEquivNat.symm.multipliable_iff.symm\n\n"}
{"name":"pnat_summable_iff_summable_succ","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"Î± : Type u_3\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : AddCommMonoid Î±\nf : Nat â†’ Î±\nâŠ¢ Iff (Summable fun x => f â†‘x) (Summable fun x => f (HAdd.hAdd x 1))","decl":"@[to_additive]\ntheorem pnat_multipliable_iff_multipliable_succ {Î± : Type*} [TopologicalSpace Î±] [CommMonoid Î±]\n    {f : â„• â†’ Î±} : Multipliable (fun x : â„•+ => f x) â†” Multipliable fun x : â„• => f (x + 1) :=\n  Equiv.pnatEquivNat.symm.multipliable_iff.symm\n\n"}
{"name":"tsum_pnat_eq_tsum_succ","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"Î± : Type u_3\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : AddCommMonoid Î±\nf : Nat â†’ Î±\nâŠ¢ Eq (tsum fun n => f â†‘n) (tsum fun n => f (HAdd.hAdd n 1))","decl":"@[to_additive]\ntheorem tprod_pnat_eq_tprod_succ {Î± : Type*} [TopologicalSpace Î±] [CommMonoid Î±] (f : â„• â†’ Î±) :\n    âˆ' n : â„•+, f n = âˆ' n, f (n + 1) := (Equiv.pnatEquivNat.symm.tprod_eq _).symm\n\n"}
{"name":"tprod_pnat_eq_tprod_succ","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"Î± : Type u_3\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : CommMonoid Î±\nf : Nat â†’ Î±\nâŠ¢ Eq (tprod fun n => f â†‘n) (tprod fun n => f (HAdd.hAdd n 1))","decl":"@[to_additive]\ntheorem tprod_pnat_eq_tprod_succ {Î± : Type*} [TopologicalSpace Î±] [CommMonoid Î±] (f : â„• â†’ Î±) :\n    âˆ' n : â„•+, f n = âˆ' n, f (n + 1) := (Equiv.pnatEquivNat.symm.tprod_eq _).symm\n\n"}
