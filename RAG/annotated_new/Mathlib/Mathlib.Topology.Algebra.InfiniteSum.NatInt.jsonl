{"name":"HasProd.tendsto_prod_nat","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninst✝¹ : CommMonoid M\ninst✝ : TopologicalSpace M\nm : M\nf : Nat → M\nh : HasProd f m\n⊢ Filter.Tendsto (fun n => (Finset.range n).prod fun i => f i) Filter.atTop (nhds m)","decl":"/-- If `f : ℕ → M` has product `m`, then the partial products `∏ i ∈ range n, f i` converge\nto `m`. -/\n@[to_additive \"If `f : ℕ → M` has sum `m`, then the partial sums `∑ i ∈ range n, f i` converge\nto `m`.\"]\ntheorem tendsto_prod_nat {f : ℕ → M} (h : HasProd f m) :\n    Tendsto (fun n ↦ ∏ i ∈ range n, f i) atTop (𝓝 m) :=\n  h.comp tendsto_finset_range\n\n"}
{"name":"HasSum.tendsto_sum_nat","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninst✝¹ : AddCommMonoid M\ninst✝ : TopologicalSpace M\nm : M\nf : Nat → M\nh : HasSum f m\n⊢ Filter.Tendsto (fun n => (Finset.range n).sum fun i => f i) Filter.atTop (nhds m)","decl":"/-- If `f : ℕ → M` has product `m`, then the partial products `∏ i ∈ range n, f i` converge\nto `m`. -/\n@[to_additive \"If `f : ℕ → M` has sum `m`, then the partial sums `∑ i ∈ range n, f i` converge\nto `m`.\"]\ntheorem tendsto_prod_nat {f : ℕ → M} (h : HasProd f m) :\n    Tendsto (fun n ↦ ∏ i ∈ range n, f i) atTop (𝓝 m) :=\n  h.comp tendsto_finset_range\n\n"}
{"name":"HasSum.Multipliable.tendsto_sum_tsum_nat","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninst✝¹ : AddCommMonoid M\ninst✝ : TopologicalSpace M\nf : Nat → M\nh : Summable f\n⊢ Filter.Tendsto (fun n => (Finset.range n).sum fun i => f i) Filter.atTop (nhds (tsum fun i => f i))","decl":"/-- If `f : ℕ → M` is multipliable, then the partial products `∏ i ∈ range n, f i` converge\nto `∏' i, f i`. -/\n@[to_additive \"If `f : ℕ → M` is summable, then the partial sums `∑ i ∈ range n, f i` converge\nto `∑' i, f i`.\"]\ntheorem Multipliable.tendsto_prod_tprod_nat {f : ℕ → M} (h : Multipliable f) :\n    Tendsto (fun n ↦ ∏ i ∈ range n, f i) atTop (𝓝 (∏' i, f i)) :=\n  tendsto_prod_nat h.hasProd\n\n"}
{"name":"HasProd.Multipliable.tendsto_prod_tprod_nat","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninst✝¹ : CommMonoid M\ninst✝ : TopologicalSpace M\nf : Nat → M\nh : Multipliable f\n⊢ Filter.Tendsto (fun n => (Finset.range n).prod fun i => f i) Filter.atTop (nhds (tprod fun i => f i))","decl":"/-- If `f : ℕ → M` is multipliable, then the partial products `∏ i ∈ range n, f i` converge\nto `∏' i, f i`. -/\n@[to_additive \"If `f : ℕ → M` is summable, then the partial sums `∑ i ∈ range n, f i` converge\nto `∑' i, f i`.\"]\ntheorem Multipliable.tendsto_prod_tprod_nat {f : ℕ → M} (h : Multipliable f) :\n    Tendsto (fun n ↦ ∏ i ∈ range n, f i) atTop (𝓝 (∏' i, f i)) :=\n  tendsto_prod_nat h.hasProd\n\n"}
{"name":"HasProd.prod_range_mul","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninst✝² : CommMonoid M\ninst✝¹ : TopologicalSpace M\nm : M\ninst✝ : ContinuousMul M\nf : Nat → M\nk : Nat\nh : HasProd (fun n => f (HAdd.hAdd n k)) m\n⊢ HasProd f (HMul.hMul ((Finset.range k).prod fun i => f i) m)","decl":"@[to_additive]\ntheorem prod_range_mul {f : ℕ → M} {k : ℕ} (h : HasProd (fun n ↦ f (n + k)) m) :\n    HasProd f ((∏ i ∈ range k, f i) * m) := by\n  refine ((range k).hasProd f).mul_compl ?_\n  rwa [← (notMemRangeEquiv k).symm.hasProd_iff]\n\n"}
{"name":"HasSum.sum_range_add","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninst✝² : AddCommMonoid M\ninst✝¹ : TopologicalSpace M\nm : M\ninst✝ : ContinuousAdd M\nf : Nat → M\nk : Nat\nh : HasSum (fun n => f (HAdd.hAdd n k)) m\n⊢ HasSum f (HAdd.hAdd ((Finset.range k).sum fun i => f i) m)","decl":"@[to_additive]\ntheorem prod_range_mul {f : ℕ → M} {k : ℕ} (h : HasProd (fun n ↦ f (n + k)) m) :\n    HasProd f ((∏ i ∈ range k, f i) * m) := by\n  refine ((range k).hasProd f).mul_compl ?_\n  rwa [← (notMemRangeEquiv k).symm.hasProd_iff]\n\n"}
{"name":"HasSum.zero_add","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninst✝² : AddCommMonoid M\ninst✝¹ : TopologicalSpace M\nm : M\ninst✝ : ContinuousAdd M\nf : Nat → M\nh : HasSum (fun n => f (HAdd.hAdd n 1)) m\n⊢ HasSum f (HAdd.hAdd (f 0) m)","decl":"@[to_additive]\ntheorem zero_mul {f : ℕ → M} (h : HasProd (fun n ↦ f (n + 1)) m) :\n    HasProd f (f 0 * m) := by\n  simpa only [prod_range_one] using h.prod_range_mul\n\n"}
{"name":"HasProd.zero_mul","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninst✝² : CommMonoid M\ninst✝¹ : TopologicalSpace M\nm : M\ninst✝ : ContinuousMul M\nf : Nat → M\nh : HasProd (fun n => f (HAdd.hAdd n 1)) m\n⊢ HasProd f (HMul.hMul (f 0) m)","decl":"@[to_additive]\ntheorem zero_mul {f : ℕ → M} (h : HasProd (fun n ↦ f (n + 1)) m) :\n    HasProd f (f 0 * m) := by\n  simpa only [prod_range_one] using h.prod_range_mul\n\n"}
{"name":"HasSum.even_add_odd","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninst✝² : AddCommMonoid M\ninst✝¹ : TopologicalSpace M\nm m' : M\ninst✝ : ContinuousAdd M\nf : Nat → M\nhe : HasSum (fun k => f (HMul.hMul 2 k)) m\nho : HasSum (fun k => f (HAdd.hAdd (HMul.hMul 2 k) 1)) m'\n⊢ HasSum f (HAdd.hAdd m m')","decl":"@[to_additive]\ntheorem even_mul_odd {f : ℕ → M} (he : HasProd (fun k ↦ f (2 * k)) m)\n    (ho : HasProd (fun k ↦ f (2 * k + 1)) m') : HasProd f (m * m') := by\n  have := mul_right_injective₀ (two_ne_zero' ℕ)\n  replace ho := ((add_left_injective 1).comp this).hasProd_range_iff.2 ho\n  refine (this.hasProd_range_iff.2 he).mul_isCompl ?_ ho\n  simpa [Function.comp_def] using Nat.isCompl_even_odd\n\n"}
{"name":"HasProd.even_mul_odd","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninst✝² : CommMonoid M\ninst✝¹ : TopologicalSpace M\nm m' : M\ninst✝ : ContinuousMul M\nf : Nat → M\nhe : HasProd (fun k => f (HMul.hMul 2 k)) m\nho : HasProd (fun k => f (HAdd.hAdd (HMul.hMul 2 k) 1)) m'\n⊢ HasProd f (HMul.hMul m m')","decl":"@[to_additive]\ntheorem even_mul_odd {f : ℕ → M} (he : HasProd (fun k ↦ f (2 * k)) m)\n    (ho : HasProd (fun k ↦ f (2 * k + 1)) m') : HasProd f (m * m') := by\n  have := mul_right_injective₀ (two_ne_zero' ℕ)\n  replace ho := ((add_left_injective 1).comp this).hasProd_range_iff.2 ho\n  refine (this.hasProd_range_iff.2 he).mul_isCompl ?_ ho\n  simpa [Function.comp_def] using Nat.isCompl_even_odd\n\n"}
{"name":"Summable.hasSum_iff_tendsto_nat","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninst✝² : AddCommMonoid M\ninst✝¹ : TopologicalSpace M\nm : M\ninst✝ : T2Space M\nf : Nat → M\nhf : Summable f\n⊢ Iff (HasSum f m) (Filter.Tendsto (fun n => (Finset.range n).sum fun i => f i) Filter.atTop (nhds m))","decl":"@[to_additive]\ntheorem hasProd_iff_tendsto_nat [T2Space M] {f : ℕ → M} (hf : Multipliable f) :\n    HasProd f m ↔ Tendsto (fun n : ℕ ↦ ∏ i ∈ range n, f i) atTop (𝓝 m) := by\n  refine ⟨fun h ↦ h.tendsto_prod_nat, fun h ↦ ?_⟩\n  rw [tendsto_nhds_unique h hf.hasProd.tendsto_prod_nat]\n  exact hf.hasProd\n\n"}
{"name":"Multipliable.hasProd_iff_tendsto_nat","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninst✝² : CommMonoid M\ninst✝¹ : TopologicalSpace M\nm : M\ninst✝ : T2Space M\nf : Nat → M\nhf : Multipliable f\n⊢ Iff (HasProd f m) (Filter.Tendsto (fun n => (Finset.range n).prod fun i => f i) Filter.atTop (nhds m))","decl":"@[to_additive]\ntheorem hasProd_iff_tendsto_nat [T2Space M] {f : ℕ → M} (hf : Multipliable f) :\n    HasProd f m ↔ Tendsto (fun n : ℕ ↦ ∏ i ∈ range n, f i) atTop (𝓝 m) := by\n  refine ⟨fun h ↦ h.tendsto_prod_nat, fun h ↦ ?_⟩\n  rw [tendsto_nhds_unique h hf.hasProd.tendsto_prod_nat]\n  exact hf.hasProd\n\n"}
{"name":"Multipliable.comp_nat_add","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninst✝² : CommMonoid M\ninst✝¹ : TopologicalSpace M\ninst✝ : ContinuousMul M\nf : Nat → M\nk : Nat\nh : Multipliable fun n => f (HAdd.hAdd n k)\n⊢ Multipliable f","decl":"@[to_additive]\ntheorem comp_nat_add {f : ℕ → M} {k : ℕ} (h : Multipliable fun n ↦ f (n + k)) : Multipliable f :=\n  h.hasProd.prod_range_mul.multipliable\n\n"}
{"name":"Summable.comp_nat_add","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninst✝² : AddCommMonoid M\ninst✝¹ : TopologicalSpace M\ninst✝ : ContinuousAdd M\nf : Nat → M\nk : Nat\nh : Summable fun n => f (HAdd.hAdd n k)\n⊢ Summable f","decl":"@[to_additive]\ntheorem comp_nat_add {f : ℕ → M} {k : ℕ} (h : Multipliable fun n ↦ f (n + k)) : Multipliable f :=\n  h.hasProd.prod_range_mul.multipliable\n\n"}
{"name":"Summable.even_add_odd","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninst✝² : AddCommMonoid M\ninst✝¹ : TopologicalSpace M\ninst✝ : ContinuousAdd M\nf : Nat → M\nhe : Summable fun k => f (HMul.hMul 2 k)\nho : Summable fun k => f (HAdd.hAdd (HMul.hMul 2 k) 1)\n⊢ Summable f","decl":"@[to_additive]\ntheorem even_mul_odd {f : ℕ → M} (he : Multipliable fun k ↦ f (2 * k))\n    (ho : Multipliable fun k ↦ f (2 * k + 1)) : Multipliable f :=\n  (he.hasProd.even_mul_odd ho.hasProd).multipliable\n\n"}
{"name":"Multipliable.even_mul_odd","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninst✝² : CommMonoid M\ninst✝¹ : TopologicalSpace M\ninst✝ : ContinuousMul M\nf : Nat → M\nhe : Multipliable fun k => f (HMul.hMul 2 k)\nho : Multipliable fun k => f (HAdd.hAdd (HMul.hMul 2 k) 1)\n⊢ Multipliable f","decl":"@[to_additive]\ntheorem even_mul_odd {f : ℕ → M} (he : Multipliable fun k ↦ f (2 * k))\n    (ho : Multipliable fun k ↦ f (2 * k + 1)) : Multipliable f :=\n  (he.hasProd.even_mul_odd ho.hasProd).multipliable\n\n"}
{"name":"tprod_iSup_decode₂","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninst✝³ : CommMonoid M\ninst✝² : TopologicalSpace M\nα : Type u_3\nβ : Type u_4\ninst✝¹ : Encodable β\ninst✝ : CompleteLattice α\nm : α → M\nm0 : Eq (m Bot.bot) 1\ns : β → α\n⊢ Eq (tprod fun i => m (iSup fun b => iSup fun h => s b)) (tprod fun b => m (s b))","decl":"/-- You can compute a product over an encodable type by multiplying over the natural numbers and\ntaking a supremum. -/\n@[to_additive \"You can compute a sum over an encodable type by summing over the natural numbers and\n  taking a supremum. This is useful for outer measures.\"]\ntheorem tprod_iSup_decode₂ [CompleteLattice α] (m : α → M) (m0 : m ⊥ = 1) (s : β → α) :\n    ∏' i : ℕ, m (⨆ b ∈ decode₂ β i, s b) = ∏' b : β, m (s b) := by\n  rw [← tprod_extend_one (@encode_injective β _)]\n  refine tprod_congr fun n ↦ ?_\n  rcases em (n ∈ Set.range (encode : β → ℕ)) with ⟨a, rfl⟩ | hn\n  · simp [encode_injective.extend_apply]\n  · rw [extend_apply' _ _ _ hn]\n    rw [← decode₂_ne_none_iff, ne_eq, not_not] at hn\n    simp [hn, m0]\n\n"}
{"name":"tsum_iSup_decode₂","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninst✝³ : AddCommMonoid M\ninst✝² : TopologicalSpace M\nα : Type u_3\nβ : Type u_4\ninst✝¹ : Encodable β\ninst✝ : CompleteLattice α\nm : α → M\nm0 : Eq (m Bot.bot) 0\ns : β → α\n⊢ Eq (tsum fun i => m (iSup fun b => iSup fun h => s b)) (tsum fun b => m (s b))","decl":"/-- You can compute a product over an encodable type by multiplying over the natural numbers and\ntaking a supremum. -/\n@[to_additive \"You can compute a sum over an encodable type by summing over the natural numbers and\n  taking a supremum. This is useful for outer measures.\"]\ntheorem tprod_iSup_decode₂ [CompleteLattice α] (m : α → M) (m0 : m ⊥ = 1) (s : β → α) :\n    ∏' i : ℕ, m (⨆ b ∈ decode₂ β i, s b) = ∏' b : β, m (s b) := by\n  rw [← tprod_extend_one (@encode_injective β _)]\n  refine tprod_congr fun n ↦ ?_\n  rcases em (n ∈ Set.range (encode : β → ℕ)) with ⟨a, rfl⟩ | hn\n  · simp [encode_injective.extend_apply]\n  · rw [extend_apply' _ _ _ hn]\n    rw [← decode₂_ne_none_iff, ne_eq, not_not] at hn\n    simp [hn, m0]\n\n"}
{"name":"tsum_iUnion_decode₂","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninst✝² : AddCommMonoid M\ninst✝¹ : TopologicalSpace M\nα : Type u_3\nβ : Type u_4\ninst✝ : Encodable β\nm : Set α → M\nm0 : Eq (m EmptyCollection.emptyCollection) 0\ns : β → Set α\n⊢ Eq (tsum fun i => m (Set.iUnion fun b => Set.iUnion fun h => s b)) (tsum fun b => m (s b))","decl":"/-- `tprod_iSup_decode₂` specialized to the complete lattice of sets. -/\n@[to_additive \"`tsum_iSup_decode₂` specialized to the complete lattice of sets.\"]\ntheorem tprod_iUnion_decode₂ (m : Set α → M) (m0 : m ∅ = 1) (s : β → Set α) :\n    ∏' i, m (⋃ b ∈ decode₂ β i, s b) = ∏' b, m (s b) :=\n  tprod_iSup_decode₂ m m0 s\n\n"}
{"name":"tprod_iUnion_decode₂","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninst✝² : CommMonoid M\ninst✝¹ : TopologicalSpace M\nα : Type u_3\nβ : Type u_4\ninst✝ : Encodable β\nm : Set α → M\nm0 : Eq (m EmptyCollection.emptyCollection) 1\ns : β → Set α\n⊢ Eq (tprod fun i => m (Set.iUnion fun b => Set.iUnion fun h => s b)) (tprod fun b => m (s b))","decl":"/-- `tprod_iSup_decode₂` specialized to the complete lattice of sets. -/\n@[to_additive \"`tsum_iSup_decode₂` specialized to the complete lattice of sets.\"]\ntheorem tprod_iUnion_decode₂ (m : Set α → M) (m0 : m ∅ = 1) (s : β → Set α) :\n    ∏' i, m (⋃ b ∈ decode₂ β i, s b) = ∏' b, m (s b) :=\n  tprod_iSup_decode₂ m m0 s\n\n"}
{"name":"rel_iSup_tprod","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninst✝³ : CommMonoid M\ninst✝² : TopologicalSpace M\nα : Type u_3\nβ : Type u_4\ninst✝¹ : Countable β\ninst✝ : CompleteLattice α\nm : α → M\nm0 : Eq (m Bot.bot) 1\nR : M → M → Prop\nm_iSup : ∀ (s : Nat → α), R (m (iSup fun i => s i)) (tprod fun i => m (s i))\ns : β → α\n⊢ R (m (iSup fun b => s b)) (tprod fun b => m (s b))","decl":"/-- If a function is countably sub-multiplicative then it is sub-multiplicative on countable\ntypes -/\n@[to_additive \"If a function is countably sub-additive then it is sub-additive on countable types\"]\ntheorem rel_iSup_tprod [CompleteLattice α] (m : α → M) (m0 : m ⊥ = 1) (R : M → M → Prop)\n    (m_iSup : ∀ s : ℕ → α, R (m (⨆ i, s i)) (∏' i, m (s i))) (s : β → α) :\n    R (m (⨆ b : β, s b)) (∏' b : β, m (s b)) := by\n  cases nonempty_encodable β\n  rw [← iSup_decode₂, ← tprod_iSup_decode₂ _ m0 s]\n  exact m_iSup _\n\n"}
{"name":"rel_iSup_tsum","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninst✝³ : AddCommMonoid M\ninst✝² : TopologicalSpace M\nα : Type u_3\nβ : Type u_4\ninst✝¹ : Countable β\ninst✝ : CompleteLattice α\nm : α → M\nm0 : Eq (m Bot.bot) 0\nR : M → M → Prop\nm_iSup : ∀ (s : Nat → α), R (m (iSup fun i => s i)) (tsum fun i => m (s i))\ns : β → α\n⊢ R (m (iSup fun b => s b)) (tsum fun b => m (s b))","decl":"/-- If a function is countably sub-multiplicative then it is sub-multiplicative on countable\ntypes -/\n@[to_additive \"If a function is countably sub-additive then it is sub-additive on countable types\"]\ntheorem rel_iSup_tprod [CompleteLattice α] (m : α → M) (m0 : m ⊥ = 1) (R : M → M → Prop)\n    (m_iSup : ∀ s : ℕ → α, R (m (⨆ i, s i)) (∏' i, m (s i))) (s : β → α) :\n    R (m (⨆ b : β, s b)) (∏' b : β, m (s b)) := by\n  cases nonempty_encodable β\n  rw [← iSup_decode₂, ← tprod_iSup_decode₂ _ m0 s]\n  exact m_iSup _\n\n"}
{"name":"rel_iSup_sum","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninst✝² : AddCommMonoid M\ninst✝¹ : TopologicalSpace M\nα : Type u_3\nγ : Type u_5\ninst✝ : CompleteLattice α\nm : α → M\nm0 : Eq (m Bot.bot) 0\nR : M → M → Prop\nm_iSup : ∀ (s : Nat → α), R (m (iSup fun i => s i)) (tsum fun i => m (s i))\ns : γ → α\nt : Finset γ\n⊢ R (m (iSup fun d => iSup fun h => s d)) (t.sum fun d => m (s d))","decl":"/-- If a function is countably sub-multiplicative then it is sub-multiplicative on finite sets -/\n@[to_additive \"If a function is countably sub-additive then it is sub-additive on finite sets\"]\ntheorem rel_iSup_prod [CompleteLattice α] (m : α → M) (m0 : m ⊥ = 1) (R : M → M → Prop)\n    (m_iSup : ∀ s : ℕ → α, R (m (⨆ i, s i)) (∏' i, m (s i))) (s : γ → α) (t : Finset γ) :\n    R (m (⨆ d ∈ t, s d)) (∏ d ∈ t, m (s d)) := by\n  rw [iSup_subtype', ← Finset.tprod_subtype]\n  exact rel_iSup_tprod m m0 R m_iSup _\n\n"}
{"name":"rel_iSup_prod","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninst✝² : CommMonoid M\ninst✝¹ : TopologicalSpace M\nα : Type u_3\nγ : Type u_5\ninst✝ : CompleteLattice α\nm : α → M\nm0 : Eq (m Bot.bot) 1\nR : M → M → Prop\nm_iSup : ∀ (s : Nat → α), R (m (iSup fun i => s i)) (tprod fun i => m (s i))\ns : γ → α\nt : Finset γ\n⊢ R (m (iSup fun d => iSup fun h => s d)) (t.prod fun d => m (s d))","decl":"/-- If a function is countably sub-multiplicative then it is sub-multiplicative on finite sets -/\n@[to_additive \"If a function is countably sub-additive then it is sub-additive on finite sets\"]\ntheorem rel_iSup_prod [CompleteLattice α] (m : α → M) (m0 : m ⊥ = 1) (R : M → M → Prop)\n    (m_iSup : ∀ s : ℕ → α, R (m (⨆ i, s i)) (∏' i, m (s i))) (s : γ → α) (t : Finset γ) :\n    R (m (⨆ d ∈ t, s d)) (∏ d ∈ t, m (s d)) := by\n  rw [iSup_subtype', ← Finset.tprod_subtype]\n  exact rel_iSup_tprod m m0 R m_iSup _\n\n"}
{"name":"rel_sup_add","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninst✝² : AddCommMonoid M\ninst✝¹ : TopologicalSpace M\nα : Type u_3\ninst✝ : CompleteLattice α\nm : α → M\nm0 : Eq (m Bot.bot) 0\nR : M → M → Prop\nm_iSup : ∀ (s : Nat → α), R (m (iSup fun i => s i)) (tsum fun i => m (s i))\ns₁ s₂ : α\n⊢ R (m (Max.max s₁ s₂)) (HAdd.hAdd (m s₁) (m s₂))","decl":"/-- If a function is countably sub-multiplicative then it is binary sub-multiplicative -/\n@[to_additive \"If a function is countably sub-additive then it is binary sub-additive\"]\ntheorem rel_sup_mul [CompleteLattice α] (m : α → M) (m0 : m ⊥ = 1) (R : M → M → Prop)\n    (m_iSup : ∀ s : ℕ → α, R (m (⨆ i, s i)) (∏' i, m (s i))) (s₁ s₂ : α) :\n    R (m (s₁ ⊔ s₂)) (m s₁ * m s₂) := by\n  convert rel_iSup_tprod m m0 R m_iSup fun b ↦ cond b s₁ s₂\n  · simp only [iSup_bool_eq, cond]\n  · rw [tprod_fintype, Fintype.prod_bool, cond, cond]\n\n"}
{"name":"rel_sup_mul","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninst✝² : CommMonoid M\ninst✝¹ : TopologicalSpace M\nα : Type u_3\ninst✝ : CompleteLattice α\nm : α → M\nm0 : Eq (m Bot.bot) 1\nR : M → M → Prop\nm_iSup : ∀ (s : Nat → α), R (m (iSup fun i => s i)) (tprod fun i => m (s i))\ns₁ s₂ : α\n⊢ R (m (Max.max s₁ s₂)) (HMul.hMul (m s₁) (m s₂))","decl":"/-- If a function is countably sub-multiplicative then it is binary sub-multiplicative -/\n@[to_additive \"If a function is countably sub-additive then it is binary sub-additive\"]\ntheorem rel_sup_mul [CompleteLattice α] (m : α → M) (m0 : m ⊥ = 1) (R : M → M → Prop)\n    (m_iSup : ∀ s : ℕ → α, R (m (⨆ i, s i)) (∏' i, m (s i))) (s₁ s₂ : α) :\n    R (m (s₁ ⊔ s₂)) (m s₁ * m s₂) := by\n  convert rel_iSup_tprod m m0 R m_iSup fun b ↦ cond b s₁ s₂\n  · simp only [iSup_bool_eq, cond]\n  · rw [tprod_fintype, Fintype.prod_bool, cond, cond]\n\n"}
{"name":"sum_add_tsum_nat_add'","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninst✝³ : AddCommMonoid M\ninst✝² : TopologicalSpace M\ninst✝¹ : T2Space M\ninst✝ : ContinuousAdd M\nf : Nat → M\nk : Nat\nh : Summable fun n => f (HAdd.hAdd n k)\n⊢ Eq (HAdd.hAdd ((Finset.range k).sum fun i => f i) (tsum fun i => f (HAdd.hAdd i k))) (tsum fun i => f i)","decl":"@[to_additive]\ntheorem prod_mul_tprod_nat_mul'\n    {f : ℕ → M} {k : ℕ} (h : Multipliable (fun n ↦ f (n + k))) :\n    ((∏ i ∈ range k, f i) * ∏' i, f (i + k)) = ∏' i, f i :=\n  h.hasProd.prod_range_mul.tprod_eq.symm\n\n"}
{"name":"prod_mul_tprod_nat_mul'","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninst✝³ : CommMonoid M\ninst✝² : TopologicalSpace M\ninst✝¹ : T2Space M\ninst✝ : ContinuousMul M\nf : Nat → M\nk : Nat\nh : Multipliable fun n => f (HAdd.hAdd n k)\n⊢ Eq (HMul.hMul ((Finset.range k).prod fun i => f i) (tprod fun i => f (HAdd.hAdd i k))) (tprod fun i => f i)","decl":"@[to_additive]\ntheorem prod_mul_tprod_nat_mul'\n    {f : ℕ → M} {k : ℕ} (h : Multipliable (fun n ↦ f (n + k))) :\n    ((∏ i ∈ range k, f i) * ∏' i, f (i + k)) = ∏' i, f i :=\n  h.hasProd.prod_range_mul.tprod_eq.symm\n\n"}
{"name":"tprod_eq_zero_mul'","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninst✝³ : CommMonoid M\ninst✝² : TopologicalSpace M\ninst✝¹ : T2Space M\ninst✝ : ContinuousMul M\nf : Nat → M\nhf : Multipliable fun n => f (HAdd.hAdd n 1)\n⊢ Eq (tprod fun b => f b) (HMul.hMul (f 0) (tprod fun b => f (HAdd.hAdd b 1)))","decl":"@[to_additive]\ntheorem tprod_eq_zero_mul'\n    {f : ℕ → M} (hf : Multipliable (fun n ↦ f (n + 1))) :\n    ∏' b, f b = f 0 * ∏' b, f (b + 1) := by\n  simpa only [prod_range_one] using (prod_mul_tprod_nat_mul' hf).symm\n\n"}
{"name":"tsum_eq_zero_add'","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninst✝³ : AddCommMonoid M\ninst✝² : TopologicalSpace M\ninst✝¹ : T2Space M\ninst✝ : ContinuousAdd M\nf : Nat → M\nhf : Summable fun n => f (HAdd.hAdd n 1)\n⊢ Eq (tsum fun b => f b) (HAdd.hAdd (f 0) (tsum fun b => f (HAdd.hAdd b 1)))","decl":"@[to_additive]\ntheorem tprod_eq_zero_mul'\n    {f : ℕ → M} (hf : Multipliable (fun n ↦ f (n + 1))) :\n    ∏' b, f b = f 0 * ∏' b, f (b + 1) := by\n  simpa only [prod_range_one] using (prod_mul_tprod_nat_mul' hf).symm\n\n"}
{"name":"tsum_even_add_odd","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninst✝³ : AddCommMonoid M\ninst✝² : TopologicalSpace M\ninst✝¹ : T2Space M\ninst✝ : ContinuousAdd M\nf : Nat → M\nhe : Summable fun k => f (HMul.hMul 2 k)\nho : Summable fun k => f (HAdd.hAdd (HMul.hMul 2 k) 1)\n⊢ Eq (HAdd.hAdd (tsum fun k => f (HMul.hMul 2 k)) (tsum fun k => f (HAdd.hAdd (HMul.hMul 2 k) 1))) (tsum fun k => f k)","decl":"@[to_additive]\ntheorem tprod_even_mul_odd {f : ℕ → M} (he : Multipliable fun k ↦ f (2 * k))\n    (ho : Multipliable fun k ↦ f (2 * k + 1)) :\n    (∏' k, f (2 * k)) * ∏' k, f (2 * k + 1) = ∏' k, f k :=\n  (he.hasProd.even_mul_odd ho.hasProd).tprod_eq.symm\n\n"}
{"name":"tprod_even_mul_odd","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninst✝³ : CommMonoid M\ninst✝² : TopologicalSpace M\ninst✝¹ : T2Space M\ninst✝ : ContinuousMul M\nf : Nat → M\nhe : Multipliable fun k => f (HMul.hMul 2 k)\nho : Multipliable fun k => f (HAdd.hAdd (HMul.hMul 2 k) 1)\n⊢ Eq (HMul.hMul (tprod fun k => f (HMul.hMul 2 k)) (tprod fun k => f (HAdd.hAdd (HMul.hMul 2 k) 1))) (tprod fun k => f k)","decl":"@[to_additive]\ntheorem tprod_even_mul_odd {f : ℕ → M} (he : Multipliable fun k ↦ f (2 * k))\n    (ho : Multipliable fun k ↦ f (2 * k + 1)) :\n    (∏' k, f (2 * k)) * ∏' k, f (2 * k + 1) = ∏' k, f k :=\n  (he.hasProd.even_mul_odd ho.hasProd).tprod_eq.symm\n\n"}
{"name":"hasSum_nat_add_iff","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"G : Type u_2\ninst✝² : AddCommGroup G\ng : G\ninst✝¹ : TopologicalSpace G\ninst✝ : TopologicalAddGroup G\nf : Nat → G\nk : Nat\n⊢ Iff (HasSum (fun n => f (HAdd.hAdd n k)) g) (HasSum f (HAdd.hAdd g ((Finset.range k).sum fun i => f i)))","decl":"@[to_additive]\ntheorem hasProd_nat_add_iff {f : ℕ → G} (k : ℕ) :\n    HasProd (fun n ↦ f (n + k)) g ↔ HasProd f (g * ∏ i ∈ range k, f i) := by\n  refine Iff.trans ?_ (range k).hasProd_compl_iff\n  rw [← (notMemRangeEquiv k).symm.hasProd_iff, Function.comp_def, coe_notMemRangeEquiv_symm]\n\n"}
{"name":"hasProd_nat_add_iff","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"G : Type u_2\ninst✝² : CommGroup G\ng : G\ninst✝¹ : TopologicalSpace G\ninst✝ : TopologicalGroup G\nf : Nat → G\nk : Nat\n⊢ Iff (HasProd (fun n => f (HAdd.hAdd n k)) g) (HasProd f (HMul.hMul g ((Finset.range k).prod fun i => f i)))","decl":"@[to_additive]\ntheorem hasProd_nat_add_iff {f : ℕ → G} (k : ℕ) :\n    HasProd (fun n ↦ f (n + k)) g ↔ HasProd f (g * ∏ i ∈ range k, f i) := by\n  refine Iff.trans ?_ (range k).hasProd_compl_iff\n  rw [← (notMemRangeEquiv k).symm.hasProd_iff, Function.comp_def, coe_notMemRangeEquiv_symm]\n\n"}
{"name":"summable_nat_add_iff","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"G : Type u_2\ninst✝² : AddCommGroup G\ninst✝¹ : TopologicalSpace G\ninst✝ : TopologicalAddGroup G\nf : Nat → G\nk : Nat\n⊢ Iff (Summable fun n => f (HAdd.hAdd n k)) (Summable f)","decl":"@[to_additive]\ntheorem multipliable_nat_add_iff {f : ℕ → G} (k : ℕ) :\n    (Multipliable fun n ↦ f (n + k)) ↔ Multipliable f :=\n  Iff.symm <|\n    (Equiv.mulRight (∏ i ∈ range k, f i)).surjective.multipliable_iff_of_hasProd_iff\n      (hasProd_nat_add_iff k).symm\n\n"}
{"name":"multipliable_nat_add_iff","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"G : Type u_2\ninst✝² : CommGroup G\ninst✝¹ : TopologicalSpace G\ninst✝ : TopologicalGroup G\nf : Nat → G\nk : Nat\n⊢ Iff (Multipliable fun n => f (HAdd.hAdd n k)) (Multipliable f)","decl":"@[to_additive]\ntheorem multipliable_nat_add_iff {f : ℕ → G} (k : ℕ) :\n    (Multipliable fun n ↦ f (n + k)) ↔ Multipliable f :=\n  Iff.symm <|\n    (Equiv.mulRight (∏ i ∈ range k, f i)).surjective.multipliable_iff_of_hasProd_iff\n      (hasProd_nat_add_iff k).symm\n\n"}
{"name":"hasSum_nat_add_iff'","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"G : Type u_2\ninst✝² : AddCommGroup G\ng : G\ninst✝¹ : TopologicalSpace G\ninst✝ : TopologicalAddGroup G\nf : Nat → G\nk : Nat\n⊢ Iff (HasSum (fun n => f (HAdd.hAdd n k)) (HSub.hSub g ((Finset.range k).sum fun i => f i))) (HasSum f g)","decl":"@[to_additive]\ntheorem hasProd_nat_add_iff' {f : ℕ → G} (k : ℕ) :\n    HasProd (fun n ↦ f (n + k)) (g / ∏ i ∈ range k, f i) ↔ HasProd f g := by\n  simp [hasProd_nat_add_iff]\n\n"}
{"name":"hasProd_nat_add_iff'","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"G : Type u_2\ninst✝² : CommGroup G\ng : G\ninst✝¹ : TopologicalSpace G\ninst✝ : TopologicalGroup G\nf : Nat → G\nk : Nat\n⊢ Iff (HasProd (fun n => f (HAdd.hAdd n k)) (HDiv.hDiv g ((Finset.range k).prod fun i => f i))) (HasProd f g)","decl":"@[to_additive]\ntheorem hasProd_nat_add_iff' {f : ℕ → G} (k : ℕ) :\n    HasProd (fun n ↦ f (n + k)) (g / ∏ i ∈ range k, f i) ↔ HasProd f g := by\n  simp [hasProd_nat_add_iff]\n\n"}
{"name":"sum_add_tsum_nat_add","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"G : Type u_2\ninst✝³ : AddCommGroup G\ninst✝² : TopologicalSpace G\ninst✝¹ : TopologicalAddGroup G\ninst✝ : T2Space G\nf : Nat → G\nk : Nat\nh : Summable f\n⊢ Eq (HAdd.hAdd ((Finset.range k).sum fun i => f i) (tsum fun i => f (HAdd.hAdd i k))) (tsum fun i => f i)","decl":"@[to_additive]\ntheorem prod_mul_tprod_nat_add [T2Space G] {f : ℕ → G} (k : ℕ) (h : Multipliable f) :\n    ((∏ i ∈ range k, f i) * ∏' i, f (i + k)) = ∏' i, f i :=\n  prod_mul_tprod_nat_mul' <| (multipliable_nat_add_iff k).2 h\n\n"}
{"name":"prod_mul_tprod_nat_add","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"G : Type u_2\ninst✝³ : CommGroup G\ninst✝² : TopologicalSpace G\ninst✝¹ : TopologicalGroup G\ninst✝ : T2Space G\nf : Nat → G\nk : Nat\nh : Multipliable f\n⊢ Eq (HMul.hMul ((Finset.range k).prod fun i => f i) (tprod fun i => f (HAdd.hAdd i k))) (tprod fun i => f i)","decl":"@[to_additive]\ntheorem prod_mul_tprod_nat_add [T2Space G] {f : ℕ → G} (k : ℕ) (h : Multipliable f) :\n    ((∏ i ∈ range k, f i) * ∏' i, f (i + k)) = ∏' i, f i :=\n  prod_mul_tprod_nat_mul' <| (multipliable_nat_add_iff k).2 h\n\n"}
{"name":"tprod_eq_zero_mul","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"G : Type u_2\ninst✝³ : CommGroup G\ninst✝² : TopologicalSpace G\ninst✝¹ : TopologicalGroup G\ninst✝ : T2Space G\nf : Nat → G\nhf : Multipliable f\n⊢ Eq (tprod fun b => f b) (HMul.hMul (f 0) (tprod fun b => f (HAdd.hAdd b 1)))","decl":"@[to_additive]\ntheorem tprod_eq_zero_mul [T2Space G] {f : ℕ → G} (hf : Multipliable f) :\n    ∏' b, f b = f 0 * ∏' b, f (b + 1) :=\n  tprod_eq_zero_mul' <| (multipliable_nat_add_iff 1).2 hf\n\n"}
{"name":"tsum_eq_zero_add","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"G : Type u_2\ninst✝³ : AddCommGroup G\ninst✝² : TopologicalSpace G\ninst✝¹ : TopologicalAddGroup G\ninst✝ : T2Space G\nf : Nat → G\nhf : Summable f\n⊢ Eq (tsum fun b => f b) (HAdd.hAdd (f 0) (tsum fun b => f (HAdd.hAdd b 1)))","decl":"@[to_additive]\ntheorem tprod_eq_zero_mul [T2Space G] {f : ℕ → G} (hf : Multipliable f) :\n    ∏' b, f b = f 0 * ∏' b, f (b + 1) :=\n  tprod_eq_zero_mul' <| (multipliable_nat_add_iff 1).2 hf\n\n"}
{"name":"tendsto_sum_nat_add","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"G : Type u_2\ninst✝³ : AddCommGroup G\ninst✝² : TopologicalSpace G\ninst✝¹ : TopologicalAddGroup G\ninst✝ : T2Space G\nf : Nat → G\n⊢ Filter.Tendsto (fun i => tsum fun k => f (HAdd.hAdd k i)) Filter.atTop (nhds 0)","decl":"/-- For `f : ℕ → G`, the product `∏' k, f (k + i)` tends to one. This does not require a\nmultipliability assumption on `f`, as otherwise all such products are one. -/\n@[to_additive \"For `f : ℕ → G`, the sum `∑' k, f (k + i)` tends to zero. This does not require a\nsummability assumption on `f`, as otherwise all such sums are zero.\"]\ntheorem tendsto_prod_nat_add [T2Space G] (f : ℕ → G) :\n    Tendsto (fun i ↦ ∏' k, f (k + i)) atTop (𝓝 1) := by\n  by_cases hf : Multipliable f\n  · have h₀ : (fun i ↦ (∏' i, f i) / ∏ j ∈ range i, f j) = fun i ↦ ∏' k : ℕ, f (k + i) := by\n      ext1 i\n      rw [div_eq_iff_eq_mul, mul_comm, prod_mul_tprod_nat_add i hf]\n    have h₁ : Tendsto (fun _ : ℕ ↦ ∏' i, f i) atTop (𝓝 (∏' i, f i)) := tendsto_const_nhds\n    simpa only [h₀, div_self'] using Tendsto.div' h₁ hf.hasProd.tendsto_prod_nat\n  · refine tendsto_const_nhds.congr fun n ↦ (tprod_eq_one_of_not_multipliable ?_).symm\n    rwa [multipliable_nat_add_iff n]\n\n"}
{"name":"tendsto_prod_nat_add","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"G : Type u_2\ninst✝³ : CommGroup G\ninst✝² : TopologicalSpace G\ninst✝¹ : TopologicalGroup G\ninst✝ : T2Space G\nf : Nat → G\n⊢ Filter.Tendsto (fun i => tprod fun k => f (HAdd.hAdd k i)) Filter.atTop (nhds 1)","decl":"/-- For `f : ℕ → G`, the product `∏' k, f (k + i)` tends to one. This does not require a\nmultipliability assumption on `f`, as otherwise all such products are one. -/\n@[to_additive \"For `f : ℕ → G`, the sum `∑' k, f (k + i)` tends to zero. This does not require a\nsummability assumption on `f`, as otherwise all such sums are zero.\"]\ntheorem tendsto_prod_nat_add [T2Space G] (f : ℕ → G) :\n    Tendsto (fun i ↦ ∏' k, f (k + i)) atTop (𝓝 1) := by\n  by_cases hf : Multipliable f\n  · have h₀ : (fun i ↦ (∏' i, f i) / ∏ j ∈ range i, f j) = fun i ↦ ∏' k : ℕ, f (k + i) := by\n      ext1 i\n      rw [div_eq_iff_eq_mul, mul_comm, prod_mul_tprod_nat_add i hf]\n    have h₁ : Tendsto (fun _ : ℕ ↦ ∏' i, f i) atTop (𝓝 (∏' i, f i)) := tendsto_const_nhds\n    simpa only [h₀, div_self'] using Tendsto.div' h₁ hf.hasProd.tendsto_prod_nat\n  · refine tendsto_const_nhds.congr fun n ↦ (tprod_eq_one_of_not_multipliable ?_).symm\n    rwa [multipliable_nat_add_iff n]\n\n"}
{"name":"cauchySeq_finset_iff_nat_tprod_vanishing","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"G : Type u_2\ninst✝² : CommGroup G\ninst✝¹ : UniformSpace G\ninst✝ : UniformGroup G\nf : Nat → G\n⊢ Iff (CauchySeq fun s => s.prod fun n => f n) (∀ (e : Set G), Membership.mem (nhds 1) e → Exists fun N => ∀ (t : Set Nat), HasSubset.Subset t (setOf fun n => LE.le N n) → Membership.mem e (tprod fun n => f ↑n))","decl":"@[to_additive]\ntheorem cauchySeq_finset_iff_nat_tprod_vanishing {f : ℕ → G} :\n    (CauchySeq fun s : Finset ℕ ↦ ∏ n ∈ s, f n) ↔\n      ∀ e ∈ 𝓝 (1 : G), ∃ N : ℕ, ∀ t ⊆ {n | N ≤ n}, (∏' n : t, f n) ∈ e := by\n  refine cauchySeq_finset_iff_tprod_vanishing.trans ⟨fun vanish e he ↦ ?_, fun vanish e he ↦ ?_⟩\n  · obtain ⟨s, hs⟩ := vanish e he\n    refine ⟨if h : s.Nonempty then s.max' h + 1 else 0,\n      fun t ht ↦ hs _ <| Set.disjoint_left.mpr ?_⟩\n    split_ifs at ht with h\n    · exact fun m hmt hms ↦ (s.le_max' _ hms).not_lt (Nat.succ_le_iff.mp <| ht hmt)\n    · exact fun _ _ hs ↦ h ⟨_, hs⟩\n  · obtain ⟨N, hN⟩ := vanish e he\n    exact ⟨range N, fun t ht ↦ hN _ fun n hnt ↦\n      le_of_not_lt fun h ↦ Set.disjoint_left.mp ht hnt (mem_range.mpr h)⟩\n\n"}
{"name":"cauchySeq_finset_iff_nat_tsum_vanishing","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"G : Type u_2\ninst✝² : AddCommGroup G\ninst✝¹ : UniformSpace G\ninst✝ : UniformAddGroup G\nf : Nat → G\n⊢ Iff (CauchySeq fun s => s.sum fun n => f n) (∀ (e : Set G), Membership.mem (nhds 0) e → Exists fun N => ∀ (t : Set Nat), HasSubset.Subset t (setOf fun n => LE.le N n) → Membership.mem e (tsum fun n => f ↑n))","decl":"@[to_additive]\ntheorem cauchySeq_finset_iff_nat_tprod_vanishing {f : ℕ → G} :\n    (CauchySeq fun s : Finset ℕ ↦ ∏ n ∈ s, f n) ↔\n      ∀ e ∈ 𝓝 (1 : G), ∃ N : ℕ, ∀ t ⊆ {n | N ≤ n}, (∏' n : t, f n) ∈ e := by\n  refine cauchySeq_finset_iff_tprod_vanishing.trans ⟨fun vanish e he ↦ ?_, fun vanish e he ↦ ?_⟩\n  · obtain ⟨s, hs⟩ := vanish e he\n    refine ⟨if h : s.Nonempty then s.max' h + 1 else 0,\n      fun t ht ↦ hs _ <| Set.disjoint_left.mpr ?_⟩\n    split_ifs at ht with h\n    · exact fun m hmt hms ↦ (s.le_max' _ hms).not_lt (Nat.succ_le_iff.mp <| ht hmt)\n    · exact fun _ _ hs ↦ h ⟨_, hs⟩\n  · obtain ⟨N, hN⟩ := vanish e he\n    exact ⟨range N, fun t ht ↦ hN _ fun n hnt ↦\n      le_of_not_lt fun h ↦ Set.disjoint_left.mp ht hnt (mem_range.mpr h)⟩\n\n"}
{"name":"multipliable_iff_nat_tprod_vanishing","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"G : Type u_2\ninst✝³ : CommGroup G\ninst✝² : UniformSpace G\ninst✝¹ : UniformGroup G\ninst✝ : CompleteSpace G\nf : Nat → G\n⊢ Iff (Multipliable f) (∀ (e : Set G), Membership.mem (nhds 1) e → Exists fun N => ∀ (t : Set Nat), HasSubset.Subset t (setOf fun n => LE.le N n) → Membership.mem e (tprod fun n => f ↑n))","decl":"@[to_additive]\ntheorem multipliable_iff_nat_tprod_vanishing {f : ℕ → G} : Multipliable f ↔\n    ∀ e ∈ 𝓝 1, ∃ N : ℕ, ∀ t ⊆ {n | N ≤ n}, (∏' n : t, f n) ∈ e := by\n  rw [multipliable_iff_cauchySeq_finset, cauchySeq_finset_iff_nat_tprod_vanishing]\n\n"}
{"name":"summable_iff_nat_tsum_vanishing","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"G : Type u_2\ninst✝³ : AddCommGroup G\ninst✝² : UniformSpace G\ninst✝¹ : UniformAddGroup G\ninst✝ : CompleteSpace G\nf : Nat → G\n⊢ Iff (Summable f) (∀ (e : Set G), Membership.mem (nhds 0) e → Exists fun N => ∀ (t : Set Nat), HasSubset.Subset t (setOf fun n => LE.le N n) → Membership.mem e (tsum fun n => f ↑n))","decl":"@[to_additive]\ntheorem multipliable_iff_nat_tprod_vanishing {f : ℕ → G} : Multipliable f ↔\n    ∀ e ∈ 𝓝 1, ∃ N : ℕ, ∀ t ⊆ {n | N ≤ n}, (∏' n : t, f n) ∈ e := by\n  rw [multipliable_iff_cauchySeq_finset, cauchySeq_finset_iff_nat_tprod_vanishing]\n\n"}
{"name":"Multipliable.nat_tprod_vanishing","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"G : Type u_2\ninst✝² : CommGroup G\ninst✝¹ : TopologicalSpace G\ninst✝ : TopologicalGroup G\nf : Nat → G\nhf : Multipliable f\ne : Set G\nhe : Membership.mem (nhds 1) e\n⊢ Exists fun N => ∀ (t : Set Nat), HasSubset.Subset t (setOf fun n => LE.le N n) → Membership.mem e (tprod fun n => f ↑n)","decl":"@[to_additive]\ntheorem Multipliable.nat_tprod_vanishing {f : ℕ → G} (hf : Multipliable f) ⦃e : Set G⦄\n    (he : e ∈ 𝓝 1) : ∃ N : ℕ, ∀ t ⊆ {n | N ≤ n}, (∏' n : t, f n) ∈ e :=\n  letI : UniformSpace G := TopologicalGroup.toUniformSpace G\n  have : UniformGroup G := comm_topologicalGroup_is_uniform\n  cauchySeq_finset_iff_nat_tprod_vanishing.1 hf.hasProd.cauchySeq e he\n\n"}
{"name":"Summable.nat_tsum_vanishing","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"G : Type u_2\ninst✝² : AddCommGroup G\ninst✝¹ : TopologicalSpace G\ninst✝ : TopologicalAddGroup G\nf : Nat → G\nhf : Summable f\ne : Set G\nhe : Membership.mem (nhds 0) e\n⊢ Exists fun N => ∀ (t : Set Nat), HasSubset.Subset t (setOf fun n => LE.le N n) → Membership.mem e (tsum fun n => f ↑n)","decl":"@[to_additive]\ntheorem Multipliable.nat_tprod_vanishing {f : ℕ → G} (hf : Multipliable f) ⦃e : Set G⦄\n    (he : e ∈ 𝓝 1) : ∃ N : ℕ, ∀ t ⊆ {n | N ≤ n}, (∏' n : t, f n) ∈ e :=\n  letI : UniformSpace G := TopologicalGroup.toUniformSpace G\n  have : UniformGroup G := comm_topologicalGroup_is_uniform\n  cauchySeq_finset_iff_nat_tprod_vanishing.1 hf.hasProd.cauchySeq e he\n\n"}
{"name":"Summable.tendsto_atTop_zero","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"G : Type u_2\ninst✝² : AddCommGroup G\ninst✝¹ : TopologicalSpace G\ninst✝ : TopologicalAddGroup G\nf : Nat → G\nhf : Summable f\n⊢ Filter.Tendsto f Filter.atTop (nhds 0)","decl":"@[to_additive]\ntheorem Multipliable.tendsto_atTop_one {f : ℕ → G} (hf : Multipliable f) :\n    Tendsto f atTop (𝓝 1) := by\n  rw [← Nat.cofinite_eq_atTop]\n  exact hf.tendsto_cofinite_one\n\n"}
{"name":"Multipliable.tendsto_atTop_one","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"G : Type u_2\ninst✝² : CommGroup G\ninst✝¹ : TopologicalSpace G\ninst✝ : TopologicalGroup G\nf : Nat → G\nhf : Multipliable f\n⊢ Filter.Tendsto f Filter.atTop (nhds 1)","decl":"@[to_additive]\ntheorem Multipliable.tendsto_atTop_one {f : ℕ → G} (hf : Multipliable f) :\n    Tendsto f atTop (𝓝 1) := by\n  rw [← Nat.cofinite_eq_atTop]\n  exact hf.tendsto_cofinite_one\n\n"}
{"name":"HasSum.nat_add_neg_add_one","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninst✝¹ : AddCommMonoid M\ninst✝ : TopologicalSpace M\nm : M\nf : Int → M\nhf : HasSum f m\n⊢ HasSum (fun n => HAdd.hAdd (f ↑n) (f (Neg.neg (HAdd.hAdd (↑n) 1)))) m","decl":"@[to_additive HasSum.nat_add_neg_add_one]\nlemma HasProd.nat_mul_neg_add_one {f : ℤ → M} (hf : HasProd f m) :\n    HasProd (fun n : ℕ ↦ f n * f (-(n + 1))) m := by\n  change HasProd (fun n : ℕ ↦ f n * f (Int.negSucc n)) m\n  have : Injective Int.negSucc := @Int.negSucc.inj\n  refine hf.hasProd_of_prod_eq fun u ↦ ?_\n  refine ⟨u.preimage _ Nat.cast_injective.injOn ∪ u.preimage _ this.injOn,\n      fun v' hv' ↦ ⟨v'.image Nat.cast ∪ v'.image Int.negSucc, fun x hx ↦ ?_, ?_⟩⟩\n  · simp only [mem_union, mem_image]\n    cases x\n    · exact Or.inl ⟨_, hv' (by simpa using Or.inl hx), rfl⟩\n    · exact Or.inr ⟨_, hv' (by simpa using Or.inr hx), rfl⟩\n  · rw [prod_union, prod_image Nat.cast_injective.injOn, prod_image this.injOn,\n      prod_mul_distrib]\n    simp only [disjoint_iff_ne, mem_image, ne_eq, forall_exists_index, and_imp,\n      forall_apply_eq_imp_iff₂, not_false_eq_true, implies_true, forall_const, reduceCtorEq]\n\n"}
{"name":"HasProd.nat_mul_neg_add_one","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninst✝¹ : CommMonoid M\ninst✝ : TopologicalSpace M\nm : M\nf : Int → M\nhf : HasProd f m\n⊢ HasProd (fun n => HMul.hMul (f ↑n) (f (Neg.neg (HAdd.hAdd (↑n) 1)))) m","decl":"@[to_additive HasSum.nat_add_neg_add_one]\nlemma HasProd.nat_mul_neg_add_one {f : ℤ → M} (hf : HasProd f m) :\n    HasProd (fun n : ℕ ↦ f n * f (-(n + 1))) m := by\n  change HasProd (fun n : ℕ ↦ f n * f (Int.negSucc n)) m\n  have : Injective Int.negSucc := @Int.negSucc.inj\n  refine hf.hasProd_of_prod_eq fun u ↦ ?_\n  refine ⟨u.preimage _ Nat.cast_injective.injOn ∪ u.preimage _ this.injOn,\n      fun v' hv' ↦ ⟨v'.image Nat.cast ∪ v'.image Int.negSucc, fun x hx ↦ ?_, ?_⟩⟩\n  · simp only [mem_union, mem_image]\n    cases x\n    · exact Or.inl ⟨_, hv' (by simpa using Or.inl hx), rfl⟩\n    · exact Or.inr ⟨_, hv' (by simpa using Or.inr hx), rfl⟩\n  · rw [prod_union, prod_image Nat.cast_injective.injOn, prod_image this.injOn,\n      prod_mul_distrib]\n    simp only [disjoint_iff_ne, mem_image, ne_eq, forall_exists_index, and_imp,\n      forall_apply_eq_imp_iff₂, not_false_eq_true, implies_true, forall_const, reduceCtorEq]\n\n"}
{"name":"Multipliable.nat_mul_neg_add_one","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninst✝¹ : CommMonoid M\ninst✝ : TopologicalSpace M\nf : Int → M\nhf : Multipliable f\n⊢ Multipliable fun n => HMul.hMul (f ↑n) (f (Neg.neg (HAdd.hAdd (↑n) 1)))","decl":"@[to_additive Summable.nat_add_neg_add_one]\nlemma Multipliable.nat_mul_neg_add_one {f : ℤ → M} (hf : Multipliable f) :\n    Multipliable (fun n : ℕ ↦ f n * f (-(n + 1))) :=\n  hf.hasProd.nat_mul_neg_add_one.multipliable\n\n"}
{"name":"Summable.nat_add_neg_add_one","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninst✝¹ : AddCommMonoid M\ninst✝ : TopologicalSpace M\nf : Int → M\nhf : Summable f\n⊢ Summable fun n => HAdd.hAdd (f ↑n) (f (Neg.neg (HAdd.hAdd (↑n) 1)))","decl":"@[to_additive Summable.nat_add_neg_add_one]\nlemma Multipliable.nat_mul_neg_add_one {f : ℤ → M} (hf : Multipliable f) :\n    Multipliable (fun n : ℕ ↦ f n * f (-(n + 1))) :=\n  hf.hasProd.nat_mul_neg_add_one.multipliable\n\n"}
{"name":"tsum_nat_add_neg_add_one","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninst✝² : AddCommMonoid M\ninst✝¹ : TopologicalSpace M\ninst✝ : T2Space M\nf : Int → M\nhf : Summable f\n⊢ Eq (tsum fun n => HAdd.hAdd (f ↑n) (f (Neg.neg (HAdd.hAdd (↑n) 1)))) (tsum fun n => f n)","decl":"@[to_additive tsum_nat_add_neg_add_one]\nlemma tprod_nat_mul_neg_add_one [T2Space M] {f : ℤ → M} (hf : Multipliable f) :\n    ∏' (n : ℕ), (f n * f (-(n + 1))) = ∏' (n : ℤ), f n :=\n  hf.hasProd.nat_mul_neg_add_one.tprod_eq\n\n"}
{"name":"tprod_nat_mul_neg_add_one","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninst✝² : CommMonoid M\ninst✝¹ : TopologicalSpace M\ninst✝ : T2Space M\nf : Int → M\nhf : Multipliable f\n⊢ Eq (tprod fun n => HMul.hMul (f ↑n) (f (Neg.neg (HAdd.hAdd (↑n) 1)))) (tprod fun n => f n)","decl":"@[to_additive tsum_nat_add_neg_add_one]\nlemma tprod_nat_mul_neg_add_one [T2Space M] {f : ℤ → M} (hf : Multipliable f) :\n    ∏' (n : ℕ), (f n * f (-(n + 1))) = ∏' (n : ℤ), f n :=\n  hf.hasProd.nat_mul_neg_add_one.tprod_eq\n\n"}
{"name":"HasSum.of_nat_of_neg_add_one","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninst✝² : AddCommMonoid M\ninst✝¹ : TopologicalSpace M\nm m' : M\ninst✝ : ContinuousAdd M\nf : Int → M\nhf₁ : HasSum (fun n => f ↑n) m\nhf₂ : HasSum (fun n => f (Neg.neg (HAdd.hAdd (↑n) 1))) m'\n⊢ HasSum f (HAdd.hAdd m m')","decl":"@[to_additive HasSum.of_nat_of_neg_add_one]\nlemma HasProd.of_nat_of_neg_add_one {f : ℤ → M}\n    (hf₁ : HasProd (fun n : ℕ ↦ f n) m) (hf₂ : HasProd (fun n : ℕ ↦ f (-(n + 1))) m') :\n    HasProd f (m * m') := by\n  have hi₂ : Injective Int.negSucc := @Int.negSucc.inj\n  have : IsCompl (Set.range ((↑) : ℕ → ℤ)) (Set.range Int.negSucc) := by\n    constructor\n    · rw [disjoint_iff_inf_le]\n      rintro _ ⟨⟨i, rfl⟩, ⟨j, ⟨⟩⟩⟩\n    · rw [codisjoint_iff_le_sup]\n      rintro (i | j) <;> simp\n  exact (Nat.cast_injective.hasProd_range_iff.mpr hf₁).mul_isCompl\n    this (hi₂.hasProd_range_iff.mpr hf₂)\n\n\n"}
{"name":"HasProd.of_nat_of_neg_add_one","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninst✝² : CommMonoid M\ninst✝¹ : TopologicalSpace M\nm m' : M\ninst✝ : ContinuousMul M\nf : Int → M\nhf₁ : HasProd (fun n => f ↑n) m\nhf₂ : HasProd (fun n => f (Neg.neg (HAdd.hAdd (↑n) 1))) m'\n⊢ HasProd f (HMul.hMul m m')","decl":"@[to_additive HasSum.of_nat_of_neg_add_one]\nlemma HasProd.of_nat_of_neg_add_one {f : ℤ → M}\n    (hf₁ : HasProd (fun n : ℕ ↦ f n) m) (hf₂ : HasProd (fun n : ℕ ↦ f (-(n + 1))) m') :\n    HasProd f (m * m') := by\n  have hi₂ : Injective Int.negSucc := @Int.negSucc.inj\n  have : IsCompl (Set.range ((↑) : ℕ → ℤ)) (Set.range Int.negSucc) := by\n    constructor\n    · rw [disjoint_iff_inf_le]\n      rintro _ ⟨⟨i, rfl⟩, ⟨j, ⟨⟩⟩⟩\n    · rw [codisjoint_iff_le_sup]\n      rintro (i | j) <;> simp\n  exact (Nat.cast_injective.hasProd_range_iff.mpr hf₁).mul_isCompl\n    this (hi₂.hasProd_range_iff.mpr hf₂)\n\n\n"}
{"name":"Summable.of_nat_of_neg_add_one","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninst✝² : AddCommMonoid M\ninst✝¹ : TopologicalSpace M\ninst✝ : ContinuousAdd M\nf : Int → M\nhf₁ : Summable fun n => f ↑n\nhf₂ : Summable fun n => f (Neg.neg (HAdd.hAdd (↑n) 1))\n⊢ Summable f","decl":"@[to_additive Summable.of_nat_of_neg_add_one]\nlemma Multipliable.of_nat_of_neg_add_one {f : ℤ → M}\n    (hf₁ : Multipliable fun n : ℕ ↦ f n) (hf₂ : Multipliable fun n : ℕ ↦ f (-(n + 1))) :\n    Multipliable f :=\n  (hf₁.hasProd.of_nat_of_neg_add_one hf₂.hasProd).multipliable\n\n"}
{"name":"Multipliable.of_nat_of_neg_add_one","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninst✝² : CommMonoid M\ninst✝¹ : TopologicalSpace M\ninst✝ : ContinuousMul M\nf : Int → M\nhf₁ : Multipliable fun n => f ↑n\nhf₂ : Multipliable fun n => f (Neg.neg (HAdd.hAdd (↑n) 1))\n⊢ Multipliable f","decl":"@[to_additive Summable.of_nat_of_neg_add_one]\nlemma Multipliable.of_nat_of_neg_add_one {f : ℤ → M}\n    (hf₁ : Multipliable fun n : ℕ ↦ f n) (hf₂ : Multipliable fun n : ℕ ↦ f (-(n + 1))) :\n    Multipliable f :=\n  (hf₁.hasProd.of_nat_of_neg_add_one hf₂.hasProd).multipliable\n\n"}
{"name":"tprod_of_nat_of_neg_add_one","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninst✝³ : CommMonoid M\ninst✝² : TopologicalSpace M\ninst✝¹ : ContinuousMul M\ninst✝ : T2Space M\nf : Int → M\nhf₁ : Multipliable fun n => f ↑n\nhf₂ : Multipliable fun n => f (Neg.neg (HAdd.hAdd (↑n) 1))\n⊢ Eq (tprod fun n => f n) (HMul.hMul (tprod fun n => f ↑n) (tprod fun n => f (Neg.neg (HAdd.hAdd (↑n) 1))))","decl":"@[to_additive tsum_of_nat_of_neg_add_one]\nlemma tprod_of_nat_of_neg_add_one [T2Space M] {f : ℤ → M}\n    (hf₁ : Multipliable fun n : ℕ ↦ f n) (hf₂ : Multipliable fun n : ℕ ↦ f (-(n + 1))) :\n    ∏' n : ℤ, f n = (∏' n : ℕ, f n) * ∏' n : ℕ, f (-(n + 1)) :=\n  (hf₁.hasProd.of_nat_of_neg_add_one hf₂.hasProd).tprod_eq\n\n"}
{"name":"tsum_of_nat_of_neg_add_one","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninst✝³ : AddCommMonoid M\ninst✝² : TopologicalSpace M\ninst✝¹ : ContinuousAdd M\ninst✝ : T2Space M\nf : Int → M\nhf₁ : Summable fun n => f ↑n\nhf₂ : Summable fun n => f (Neg.neg (HAdd.hAdd (↑n) 1))\n⊢ Eq (tsum fun n => f n) (HAdd.hAdd (tsum fun n => f ↑n) (tsum fun n => f (Neg.neg (HAdd.hAdd (↑n) 1))))","decl":"@[to_additive tsum_of_nat_of_neg_add_one]\nlemma tprod_of_nat_of_neg_add_one [T2Space M] {f : ℤ → M}\n    (hf₁ : Multipliable fun n : ℕ ↦ f n) (hf₂ : Multipliable fun n : ℕ ↦ f (-(n + 1))) :\n    ∏' n : ℤ, f n = (∏' n : ℕ, f n) * ∏' n : ℕ, f (-(n + 1)) :=\n  (hf₁.hasProd.of_nat_of_neg_add_one hf₂.hasProd).tprod_eq\n\n"}
{"name":"HasProd.int_rec","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninst✝² : CommMonoid M\ninst✝¹ : TopologicalSpace M\nm m' : M\ninst✝ : ContinuousMul M\nf g : Nat → M\nhf : HasProd f m\nhg : HasProd g m'\n⊢ HasProd (fun t => Int.rec f g t) (HMul.hMul m m')","decl":"/-- If `f₀, f₁, f₂, ...` and `g₀, g₁, g₂, ...` have products `a`, `b` respectively, then\nthe `ℤ`-indexed sequence: `..., g₂, g₁, g₀, f₀, f₁, f₂, ...` (with `f₀` at the `0`-th position) has\nproduct `a + b`. -/\n@[to_additive \"If `f₀, f₁, f₂, ...` and `g₀, g₁, g₂, ...` have sums `a`, `b` respectively, then\nthe `ℤ`-indexed sequence: `..., g₂, g₁, g₀, f₀, f₁, f₂, ...` (with `f₀` at the `0`-th position) has\nsum `a + b`.\"]\nlemma HasProd.int_rec {f g : ℕ → M} (hf : HasProd f m) (hg : HasProd g m') :\n    HasProd (Int.rec f g) (m * m') :=\n  HasProd.of_nat_of_neg_add_one hf hg\n\n"}
{"name":"HasSum.int_rec","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninst✝² : AddCommMonoid M\ninst✝¹ : TopologicalSpace M\nm m' : M\ninst✝ : ContinuousAdd M\nf g : Nat → M\nhf : HasSum f m\nhg : HasSum g m'\n⊢ HasSum (fun t => Int.rec f g t) (HAdd.hAdd m m')","decl":"/-- If `f₀, f₁, f₂, ...` and `g₀, g₁, g₂, ...` have products `a`, `b` respectively, then\nthe `ℤ`-indexed sequence: `..., g₂, g₁, g₀, f₀, f₁, f₂, ...` (with `f₀` at the `0`-th position) has\nproduct `a + b`. -/\n@[to_additive \"If `f₀, f₁, f₂, ...` and `g₀, g₁, g₂, ...` have sums `a`, `b` respectively, then\nthe `ℤ`-indexed sequence: `..., g₂, g₁, g₀, f₀, f₁, f₂, ...` (with `f₀` at the `0`-th position) has\nsum `a + b`.\"]\nlemma HasProd.int_rec {f g : ℕ → M} (hf : HasProd f m) (hg : HasProd g m') :\n    HasProd (Int.rec f g) (m * m') :=\n  HasProd.of_nat_of_neg_add_one hf hg\n\n"}
{"name":"Multipliable.int_rec","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninst✝² : CommMonoid M\ninst✝¹ : TopologicalSpace M\ninst✝ : ContinuousMul M\nf g : Nat → M\nhf : Multipliable f\nhg : Multipliable g\n⊢ Multipliable fun t => Int.rec f g t","decl":"/-- If `f₀, f₁, f₂, ...` and `g₀, g₁, g₂, ...` are both multipliable then so is the\n`ℤ`-indexed sequence: `..., g₂, g₁, g₀, f₀, f₁, f₂, ...` (with `f₀` at the `0`-th position). -/\n@[to_additive \"If `f₀, f₁, f₂, ...` and `g₀, g₁, g₂, ...` are both summable then so is the\n`ℤ`-indexed sequence: `..., g₂, g₁, g₀, f₀, f₁, f₂, ...` (with `f₀` at the `0`-th position).\"]\nlemma Multipliable.int_rec {f g : ℕ → M} (hf : Multipliable f) (hg : Multipliable g) :\n    Multipliable (Int.rec f g) :=\n  .of_nat_of_neg_add_one hf hg\n\n"}
{"name":"Summable.int_rec","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninst✝² : AddCommMonoid M\ninst✝¹ : TopologicalSpace M\ninst✝ : ContinuousAdd M\nf g : Nat → M\nhf : Summable f\nhg : Summable g\n⊢ Summable fun t => Int.rec f g t","decl":"/-- If `f₀, f₁, f₂, ...` and `g₀, g₁, g₂, ...` are both multipliable then so is the\n`ℤ`-indexed sequence: `..., g₂, g₁, g₀, f₀, f₁, f₂, ...` (with `f₀` at the `0`-th position). -/\n@[to_additive \"If `f₀, f₁, f₂, ...` and `g₀, g₁, g₂, ...` are both summable then so is the\n`ℤ`-indexed sequence: `..., g₂, g₁, g₀, f₀, f₁, f₂, ...` (with `f₀` at the `0`-th position).\"]\nlemma Multipliable.int_rec {f g : ℕ → M} (hf : Multipliable f) (hg : Multipliable g) :\n    Multipliable (Int.rec f g) :=\n  .of_nat_of_neg_add_one hf hg\n\n"}
{"name":"tsum_int_rec","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninst✝³ : AddCommMonoid M\ninst✝² : TopologicalSpace M\ninst✝¹ : ContinuousAdd M\ninst✝ : T2Space M\nf g : Nat → M\nhf : Summable f\nhg : Summable g\n⊢ Eq (tsum fun n => Int.rec f g n) (HAdd.hAdd (tsum fun n => f n) (tsum fun n => g n))","decl":"/-- If `f₀, f₁, f₂, ...` and `g₀, g₁, g₂, ...` are both multipliable, then the product of the\n`ℤ`-indexed sequence: `..., g₂, g₁, g₀, f₀, f₁, f₂, ...` (with `f₀` at the `0`-th position) is\n`(∏' n, f n) * ∏' n, g n`. -/\n@[to_additive \"If `f₀, f₁, f₂, ...` and `g₀, g₁, g₂, ...` are both summable, then the sum of the\n`ℤ`-indexed sequence: `..., g₂, g₁, g₀, f₀, f₁, f₂, ...` (with `f₀` at the `0`-th position) is\n`∑' n, f n + ∑' n, g n`.\"]\nlemma tprod_int_rec [T2Space M] {f g : ℕ → M} (hf : Multipliable f) (hg : Multipliable g) :\n    ∏' n : ℤ, Int.rec f g n = (∏' n : ℕ, f n) * ∏' n : ℕ, g n :=\n  (hf.hasProd.int_rec hg.hasProd).tprod_eq\n\n"}
{"name":"tprod_int_rec","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninst✝³ : CommMonoid M\ninst✝² : TopologicalSpace M\ninst✝¹ : ContinuousMul M\ninst✝ : T2Space M\nf g : Nat → M\nhf : Multipliable f\nhg : Multipliable g\n⊢ Eq (tprod fun n => Int.rec f g n) (HMul.hMul (tprod fun n => f n) (tprod fun n => g n))","decl":"/-- If `f₀, f₁, f₂, ...` and `g₀, g₁, g₂, ...` are both multipliable, then the product of the\n`ℤ`-indexed sequence: `..., g₂, g₁, g₀, f₀, f₁, f₂, ...` (with `f₀` at the `0`-th position) is\n`(∏' n, f n) * ∏' n, g n`. -/\n@[to_additive \"If `f₀, f₁, f₂, ...` and `g₀, g₁, g₂, ...` are both summable, then the sum of the\n`ℤ`-indexed sequence: `..., g₂, g₁, g₀, f₀, f₁, f₂, ...` (with `f₀` at the `0`-th position) is\n`∑' n, f n + ∑' n, g n`.\"]\nlemma tprod_int_rec [T2Space M] {f g : ℕ → M} (hf : Multipliable f) (hg : Multipliable g) :\n    ∏' n : ℤ, Int.rec f g n = (∏' n : ℕ, f n) * ∏' n : ℕ, g n :=\n  (hf.hasProd.int_rec hg.hasProd).tprod_eq\n\n"}
{"name":"HasSum.nat_add_neg","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninst✝² : AddCommMonoid M\ninst✝¹ : TopologicalSpace M\nm : M\ninst✝ : ContinuousAdd M\nf : Int → M\nhf : HasSum f m\n⊢ HasSum (fun n => HAdd.hAdd (f ↑n) (f (Neg.neg ↑n))) (HAdd.hAdd m (f 0))","decl":"@[to_additive]\ntheorem HasProd.nat_mul_neg {f : ℤ → M} (hf : HasProd f m) :\n    HasProd (fun n : ℕ ↦ f n * f (-n)) (m * f 0) := by\n  -- Note this is much easier to prove if you assume more about the target space, but we have to\n  -- work hard to prove it under the very minimal assumptions here.\n  apply (hf.mul (hasProd_ite_eq (0 : ℤ) (f 0))).hasProd_of_prod_eq fun u ↦ ?_\n  refine ⟨u.image Int.natAbs, fun v' hv' ↦ ?_⟩\n  let u1 := v'.image fun x : ℕ ↦ (x : ℤ)\n  let u2 := v'.image fun x : ℕ ↦ -(x : ℤ)\n  have A : u ⊆ u1 ∪ u2 := by\n    intro x hx\n    simp only [u1, u2, mem_union, mem_image, exists_prop]\n    rcases le_total 0 x with (h'x | h'x)\n    · refine Or.inl ⟨_, hv' <| mem_image.mpr ⟨x, hx, rfl⟩, ?_⟩\n      simp only [Int.natCast_natAbs, abs_eq_self, h'x]\n    · refine Or.inr ⟨_, hv' <| mem_image.mpr ⟨x, hx, rfl⟩, ?_⟩\n      simp only [abs_of_nonpos h'x, Int.natCast_natAbs, neg_neg]\n  exact ⟨_, A, calc\n    (∏ x ∈ u1 ∪ u2, (f x * if x = 0 then f 0 else 1)) =\n        (∏ x ∈ u1 ∪ u2, f x) * ∏ x ∈ u1 ∩ u2, f x := by\n      rw [prod_mul_distrib]\n      congr 1\n      refine (prod_subset_one_on_sdiff inter_subset_union ?_ ?_).symm\n      · intro x hx\n        suffices x ≠ 0 by simp only [this, if_false]\n        rintro rfl\n        simp only [mem_sdiff, mem_union, mem_image, Nat.cast_eq_zero, exists_eq_right, neg_eq_zero,\n          or_self, mem_inter, and_self, and_not_self, u1, u2] at hx\n      · intro x hx\n        simp only [u1, u2, mem_inter, mem_image, exists_prop] at hx\n        suffices x = 0 by simp only [this, eq_self_iff_true, if_true]\n        omega\n    _ = (∏ x ∈ u1, f x) * ∏ x ∈ u2, f x := prod_union_inter\n    _ = (∏ b ∈ v', f b) * ∏ b ∈ v', f (-b) := by\n      simp only [u1, u2, Nat.cast_inj, imp_self, implies_true, forall_const, prod_image, neg_inj]\n    _ = ∏ b ∈ v', (f b * f (-b)) := prod_mul_distrib.symm⟩\n\n"}
{"name":"HasProd.nat_mul_neg","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninst✝² : CommMonoid M\ninst✝¹ : TopologicalSpace M\nm : M\ninst✝ : ContinuousMul M\nf : Int → M\nhf : HasProd f m\n⊢ HasProd (fun n => HMul.hMul (f ↑n) (f (Neg.neg ↑n))) (HMul.hMul m (f 0))","decl":"@[to_additive]\ntheorem HasProd.nat_mul_neg {f : ℤ → M} (hf : HasProd f m) :\n    HasProd (fun n : ℕ ↦ f n * f (-n)) (m * f 0) := by\n  -- Note this is much easier to prove if you assume more about the target space, but we have to\n  -- work hard to prove it under the very minimal assumptions here.\n  apply (hf.mul (hasProd_ite_eq (0 : ℤ) (f 0))).hasProd_of_prod_eq fun u ↦ ?_\n  refine ⟨u.image Int.natAbs, fun v' hv' ↦ ?_⟩\n  let u1 := v'.image fun x : ℕ ↦ (x : ℤ)\n  let u2 := v'.image fun x : ℕ ↦ -(x : ℤ)\n  have A : u ⊆ u1 ∪ u2 := by\n    intro x hx\n    simp only [u1, u2, mem_union, mem_image, exists_prop]\n    rcases le_total 0 x with (h'x | h'x)\n    · refine Or.inl ⟨_, hv' <| mem_image.mpr ⟨x, hx, rfl⟩, ?_⟩\n      simp only [Int.natCast_natAbs, abs_eq_self, h'x]\n    · refine Or.inr ⟨_, hv' <| mem_image.mpr ⟨x, hx, rfl⟩, ?_⟩\n      simp only [abs_of_nonpos h'x, Int.natCast_natAbs, neg_neg]\n  exact ⟨_, A, calc\n    (∏ x ∈ u1 ∪ u2, (f x * if x = 0 then f 0 else 1)) =\n        (∏ x ∈ u1 ∪ u2, f x) * ∏ x ∈ u1 ∩ u2, f x := by\n      rw [prod_mul_distrib]\n      congr 1\n      refine (prod_subset_one_on_sdiff inter_subset_union ?_ ?_).symm\n      · intro x hx\n        suffices x ≠ 0 by simp only [this, if_false]\n        rintro rfl\n        simp only [mem_sdiff, mem_union, mem_image, Nat.cast_eq_zero, exists_eq_right, neg_eq_zero,\n          or_self, mem_inter, and_self, and_not_self, u1, u2] at hx\n      · intro x hx\n        simp only [u1, u2, mem_inter, mem_image, exists_prop] at hx\n        suffices x = 0 by simp only [this, eq_self_iff_true, if_true]\n        omega\n    _ = (∏ x ∈ u1, f x) * ∏ x ∈ u2, f x := prod_union_inter\n    _ = (∏ b ∈ v', f b) * ∏ b ∈ v', f (-b) := by\n      simp only [u1, u2, Nat.cast_inj, imp_self, implies_true, forall_const, prod_image, neg_inj]\n    _ = ∏ b ∈ v', (f b * f (-b)) := prod_mul_distrib.symm⟩\n\n"}
{"name":"Multipliable.nat_mul_neg","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninst✝² : CommMonoid M\ninst✝¹ : TopologicalSpace M\ninst✝ : ContinuousMul M\nf : Int → M\nhf : Multipliable f\n⊢ Multipliable fun n => HMul.hMul (f ↑n) (f (Neg.neg ↑n))","decl":"@[to_additive]\ntheorem Multipliable.nat_mul_neg {f : ℤ → M} (hf : Multipliable f) :\n    Multipliable fun n : ℕ ↦ f n * f (-n) :=\n  hf.hasProd.nat_mul_neg.multipliable\n\n"}
{"name":"Summable.nat_add_neg","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninst✝² : AddCommMonoid M\ninst✝¹ : TopologicalSpace M\ninst✝ : ContinuousAdd M\nf : Int → M\nhf : Summable f\n⊢ Summable fun n => HAdd.hAdd (f ↑n) (f (Neg.neg ↑n))","decl":"@[to_additive]\ntheorem Multipliable.nat_mul_neg {f : ℤ → M} (hf : Multipliable f) :\n    Multipliable fun n : ℕ ↦ f n * f (-n) :=\n  hf.hasProd.nat_mul_neg.multipliable\n\n"}
{"name":"tsum_nat_add_neg","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninst✝³ : AddCommMonoid M\ninst✝² : TopologicalSpace M\ninst✝¹ : ContinuousAdd M\ninst✝ : T2Space M\nf : Int → M\nhf : Summable f\n⊢ Eq (tsum fun n => HAdd.hAdd (f ↑n) (f (Neg.neg ↑n))) (HAdd.hAdd (tsum fun n => f n) (f 0))","decl":"@[to_additive]\nlemma tprod_nat_mul_neg [T2Space M] {f : ℤ → M} (hf : Multipliable f) :\n    ∏' n : ℕ, (f n * f (-n)) = (∏' n : ℤ, f n) * f 0 :=\n  hf.hasProd.nat_mul_neg.tprod_eq\n\n"}
{"name":"tprod_nat_mul_neg","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninst✝³ : CommMonoid M\ninst✝² : TopologicalSpace M\ninst✝¹ : ContinuousMul M\ninst✝ : T2Space M\nf : Int → M\nhf : Multipliable f\n⊢ Eq (tprod fun n => HMul.hMul (f ↑n) (f (Neg.neg ↑n))) (HMul.hMul (tprod fun n => f n) (f 0))","decl":"@[to_additive]\nlemma tprod_nat_mul_neg [T2Space M] {f : ℤ → M} (hf : Multipliable f) :\n    ∏' n : ℕ, (f n * f (-n)) = (∏' n : ℤ, f n) * f 0 :=\n  hf.hasProd.nat_mul_neg.tprod_eq\n\n"}
{"name":"HasSum.of_add_one_of_neg_add_one","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninst✝² : AddCommMonoid M\ninst✝¹ : TopologicalSpace M\nm m' : M\ninst✝ : ContinuousAdd M\nf : Int → M\nhf₁ : HasSum (fun n => f (HAdd.hAdd (↑n) 1)) m\nhf₂ : HasSum (fun n => f (Neg.neg (HAdd.hAdd (↑n) 1))) m'\n⊢ HasSum f (HAdd.hAdd (HAdd.hAdd m (f 0)) m')","decl":"@[to_additive HasSum.of_add_one_of_neg_add_one]\ntheorem HasProd.of_add_one_of_neg_add_one {f : ℤ → M}\n    (hf₁ : HasProd (fun n : ℕ ↦ f (n + 1)) m) (hf₂ : HasProd (fun n : ℕ ↦ f (-(n + 1))) m') :\n    HasProd f (m * f 0 * m') :=\n  HasProd.of_nat_of_neg_add_one (mul_comm _ m ▸ HasProd.zero_mul hf₁) hf₂\n\n"}
{"name":"HasProd.of_add_one_of_neg_add_one","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninst✝² : CommMonoid M\ninst✝¹ : TopologicalSpace M\nm m' : M\ninst✝ : ContinuousMul M\nf : Int → M\nhf₁ : HasProd (fun n => f (HAdd.hAdd (↑n) 1)) m\nhf₂ : HasProd (fun n => f (Neg.neg (HAdd.hAdd (↑n) 1))) m'\n⊢ HasProd f (HMul.hMul (HMul.hMul m (f 0)) m')","decl":"@[to_additive HasSum.of_add_one_of_neg_add_one]\ntheorem HasProd.of_add_one_of_neg_add_one {f : ℤ → M}\n    (hf₁ : HasProd (fun n : ℕ ↦ f (n + 1)) m) (hf₂ : HasProd (fun n : ℕ ↦ f (-(n + 1))) m') :\n    HasProd f (m * f 0 * m') :=\n  HasProd.of_nat_of_neg_add_one (mul_comm _ m ▸ HasProd.zero_mul hf₁) hf₂\n\n"}
{"name":"Summable.of_add_one_of_neg_add_one","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninst✝² : AddCommMonoid M\ninst✝¹ : TopologicalSpace M\ninst✝ : ContinuousAdd M\nf : Int → M\nhf₁ : Summable fun n => f (HAdd.hAdd (↑n) 1)\nhf₂ : Summable fun n => f (Neg.neg (HAdd.hAdd (↑n) 1))\n⊢ Summable f","decl":"@[to_additive Summable.of_add_one_of_neg_add_one]\nlemma Multipliable.of_add_one_of_neg_add_one {f : ℤ → M}\n    (hf₁ : Multipliable fun n : ℕ ↦ f (n + 1)) (hf₂ : Multipliable fun n : ℕ ↦ f (-(n + 1))) :\n    Multipliable f :=\n  (hf₁.hasProd.of_add_one_of_neg_add_one hf₂.hasProd).multipliable\n\n"}
{"name":"Multipliable.of_add_one_of_neg_add_one","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninst✝² : CommMonoid M\ninst✝¹ : TopologicalSpace M\ninst✝ : ContinuousMul M\nf : Int → M\nhf₁ : Multipliable fun n => f (HAdd.hAdd (↑n) 1)\nhf₂ : Multipliable fun n => f (Neg.neg (HAdd.hAdd (↑n) 1))\n⊢ Multipliable f","decl":"@[to_additive Summable.of_add_one_of_neg_add_one]\nlemma Multipliable.of_add_one_of_neg_add_one {f : ℤ → M}\n    (hf₁ : Multipliable fun n : ℕ ↦ f (n + 1)) (hf₂ : Multipliable fun n : ℕ ↦ f (-(n + 1))) :\n    Multipliable f :=\n  (hf₁.hasProd.of_add_one_of_neg_add_one hf₂.hasProd).multipliable\n\n"}
{"name":"tsum_of_add_one_of_neg_add_one","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninst✝³ : AddCommMonoid M\ninst✝² : TopologicalSpace M\ninst✝¹ : ContinuousAdd M\ninst✝ : T2Space M\nf : Int → M\nhf₁ : Summable fun n => f (HAdd.hAdd (↑n) 1)\nhf₂ : Summable fun n => f (Neg.neg (HAdd.hAdd (↑n) 1))\n⊢ Eq (tsum fun n => f n) (HAdd.hAdd (HAdd.hAdd (tsum fun n => f (HAdd.hAdd (↑n) 1)) (f 0)) (tsum fun n => f (Neg.neg (HAdd.hAdd (↑n) 1))))","decl":"@[to_additive tsum_of_add_one_of_neg_add_one]\nlemma tprod_of_add_one_of_neg_add_one [T2Space M] {f : ℤ → M}\n    (hf₁ : Multipliable fun n : ℕ ↦ f (n + 1)) (hf₂ : Multipliable fun n : ℕ ↦ f (-(n + 1))) :\n    ∏' n : ℤ, f n = (∏' n : ℕ, f (n + 1)) * f 0 * ∏' n : ℕ, f (-(n + 1)) :=\n  (hf₁.hasProd.of_add_one_of_neg_add_one hf₂.hasProd).tprod_eq\n\n"}
{"name":"tprod_of_add_one_of_neg_add_one","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"M : Type u_1\ninst✝³ : CommMonoid M\ninst✝² : TopologicalSpace M\ninst✝¹ : ContinuousMul M\ninst✝ : T2Space M\nf : Int → M\nhf₁ : Multipliable fun n => f (HAdd.hAdd (↑n) 1)\nhf₂ : Multipliable fun n => f (Neg.neg (HAdd.hAdd (↑n) 1))\n⊢ Eq (tprod fun n => f n) (HMul.hMul (HMul.hMul (tprod fun n => f (HAdd.hAdd (↑n) 1)) (f 0)) (tprod fun n => f (Neg.neg (HAdd.hAdd (↑n) 1))))","decl":"@[to_additive tsum_of_add_one_of_neg_add_one]\nlemma tprod_of_add_one_of_neg_add_one [T2Space M] {f : ℤ → M}\n    (hf₁ : Multipliable fun n : ℕ ↦ f (n + 1)) (hf₂ : Multipliable fun n : ℕ ↦ f (-(n + 1))) :\n    ∏' n : ℤ, f n = (∏' n : ℕ, f (n + 1)) * f 0 * ∏' n : ℕ, f (-(n + 1)) :=\n  (hf₁.hasProd.of_add_one_of_neg_add_one hf₂.hasProd).tprod_eq\n\n"}
{"name":"HasSum.of_nat_of_neg","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"G : Type u_2\ninst✝² : AddCommGroup G\ng g' : G\ninst✝¹ : TopologicalSpace G\ninst✝ : TopologicalAddGroup G\nf : Int → G\nhf₁ : HasSum (fun n => f ↑n) g\nhf₂ : HasSum (fun n => f (Neg.neg ↑n)) g'\n⊢ HasSum f (HSub.hSub (HAdd.hAdd g g') (f 0))","decl":"@[to_additive]\nlemma HasProd.of_nat_of_neg {f : ℤ → G} (hf₁ : HasProd (fun n : ℕ ↦ f n) g)\n    (hf₂ : HasProd (fun n : ℕ ↦ f (-n)) g') : HasProd f (g * g' / f 0) := by\n  refine mul_div_assoc' g .. ▸ hf₁.of_nat_of_neg_add_one (m' := g' / f 0) ?_\n  rwa [← hasProd_nat_add_iff' 1, prod_range_one, Nat.cast_zero, neg_zero] at hf₂\n\n"}
{"name":"HasProd.of_nat_of_neg","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"G : Type u_2\ninst✝² : CommGroup G\ng g' : G\ninst✝¹ : TopologicalSpace G\ninst✝ : TopologicalGroup G\nf : Int → G\nhf₁ : HasProd (fun n => f ↑n) g\nhf₂ : HasProd (fun n => f (Neg.neg ↑n)) g'\n⊢ HasProd f (HDiv.hDiv (HMul.hMul g g') (f 0))","decl":"@[to_additive]\nlemma HasProd.of_nat_of_neg {f : ℤ → G} (hf₁ : HasProd (fun n : ℕ ↦ f n) g)\n    (hf₂ : HasProd (fun n : ℕ ↦ f (-n)) g') : HasProd f (g * g' / f 0) := by\n  refine mul_div_assoc' g .. ▸ hf₁.of_nat_of_neg_add_one (m' := g' / f 0) ?_\n  rwa [← hasProd_nat_add_iff' 1, prod_range_one, Nat.cast_zero, neg_zero] at hf₂\n\n"}
{"name":"Multipliable.of_nat_of_neg","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"G : Type u_2\ninst✝² : CommGroup G\ninst✝¹ : TopologicalSpace G\ninst✝ : TopologicalGroup G\nf : Int → G\nhf₁ : Multipliable fun n => f ↑n\nhf₂ : Multipliable fun n => f (Neg.neg ↑n)\n⊢ Multipliable f","decl":"@[to_additive]\nlemma Multipliable.of_nat_of_neg {f : ℤ → G} (hf₁ : Multipliable fun n : ℕ ↦ f n)\n    (hf₂ : Multipliable fun n : ℕ ↦ f (-n)) : Multipliable f :=\n  (hf₁.hasProd.of_nat_of_neg hf₂.hasProd).multipliable\n\n"}
{"name":"Summable.of_nat_of_neg","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"G : Type u_2\ninst✝² : AddCommGroup G\ninst✝¹ : TopologicalSpace G\ninst✝ : TopologicalAddGroup G\nf : Int → G\nhf₁ : Summable fun n => f ↑n\nhf₂ : Summable fun n => f (Neg.neg ↑n)\n⊢ Summable f","decl":"@[to_additive]\nlemma Multipliable.of_nat_of_neg {f : ℤ → G} (hf₁ : Multipliable fun n : ℕ ↦ f n)\n    (hf₂ : Multipliable fun n : ℕ ↦ f (-n)) : Multipliable f :=\n  (hf₁.hasProd.of_nat_of_neg hf₂.hasProd).multipliable\n\n"}
{"name":"tsum_of_nat_of_neg","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"G : Type u_2\ninst✝³ : AddCommGroup G\ninst✝² : TopologicalSpace G\ninst✝¹ : TopologicalAddGroup G\ninst✝ : T2Space G\nf : Int → G\nhf₁ : Summable fun n => f ↑n\nhf₂ : Summable fun n => f (Neg.neg ↑n)\n⊢ Eq (tsum fun n => f n) (HSub.hSub (HAdd.hAdd (tsum fun n => f ↑n) (tsum fun n => f (Neg.neg ↑n))) (f 0))","decl":"@[to_additive]\nlemma tprod_of_nat_of_neg [T2Space G] {f : ℤ → G}\n    (hf₁ : Multipliable fun n : ℕ ↦ f n) (hf₂ : Multipliable fun n : ℕ ↦ f (-n)) :\n    ∏' n : ℤ, f n = (∏' n : ℕ, f n) * (∏' n : ℕ, f (-n)) / f 0 :=\n  (hf₁.hasProd.of_nat_of_neg hf₂.hasProd).tprod_eq\n\n"}
{"name":"tprod_of_nat_of_neg","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"G : Type u_2\ninst✝³ : CommGroup G\ninst✝² : TopologicalSpace G\ninst✝¹ : TopologicalGroup G\ninst✝ : T2Space G\nf : Int → G\nhf₁ : Multipliable fun n => f ↑n\nhf₂ : Multipliable fun n => f (Neg.neg ↑n)\n⊢ Eq (tprod fun n => f n) (HDiv.hDiv (HMul.hMul (tprod fun n => f ↑n) (tprod fun n => f (Neg.neg ↑n))) (f 0))","decl":"@[to_additive]\nlemma tprod_of_nat_of_neg [T2Space G] {f : ℤ → G}\n    (hf₁ : Multipliable fun n : ℕ ↦ f n) (hf₂ : Multipliable fun n : ℕ ↦ f (-n)) :\n    ∏' n : ℤ, f n = (∏' n : ℕ, f n) * (∏' n : ℕ, f (-n)) / f 0 :=\n  (hf₁.hasProd.of_nat_of_neg hf₂.hasProd).tprod_eq\n\n"}
{"name":"multipliable_int_iff_multipliable_nat_and_neg_add_one","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"G : Type u_2\ninst✝³ : CommGroup G\ninst✝² : UniformSpace G\ninst✝¹ : UniformGroup G\ninst✝ : CompleteSpace G\nf : Int → G\n⊢ Iff (Multipliable f) (And (Multipliable fun n => f ↑n) (Multipliable fun n => f (Neg.neg (HAdd.hAdd (↑n) 1))))","decl":"/-- \"iff\" version of `Multipliable.of_nat_of_neg_add_one`. -/\n@[to_additive \"\\\"iff\\\" version of `Summable.of_nat_of_neg_add_one`.\"]\nlemma multipliable_int_iff_multipliable_nat_and_neg_add_one {f : ℤ → G} : Multipliable f ↔\n    (Multipliable fun n : ℕ ↦ f n) ∧ (Multipliable fun n : ℕ ↦ f (-(n + 1))) := by\n  refine ⟨fun p ↦ ⟨?_, ?_⟩, fun ⟨hf₁, hf₂⟩ ↦ Multipliable.of_nat_of_neg_add_one hf₁ hf₂⟩ <;>\n  apply p.comp_injective\n  exacts [Nat.cast_injective, @Int.negSucc.inj]\n\n"}
{"name":"summable_int_iff_summable_nat_and_neg_add_zero","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"G : Type u_2\ninst✝³ : AddCommGroup G\ninst✝² : UniformSpace G\ninst✝¹ : UniformAddGroup G\ninst✝ : CompleteSpace G\nf : Int → G\n⊢ Iff (Summable f) (And (Summable fun n => f ↑n) (Summable fun n => f (Neg.neg (HAdd.hAdd (↑n) 1))))","decl":"/-- \"iff\" version of `Multipliable.of_nat_of_neg_add_one`. -/\n@[to_additive \"\\\"iff\\\" version of `Summable.of_nat_of_neg_add_one`.\"]\nlemma multipliable_int_iff_multipliable_nat_and_neg_add_one {f : ℤ → G} : Multipliable f ↔\n    (Multipliable fun n : ℕ ↦ f n) ∧ (Multipliable fun n : ℕ ↦ f (-(n + 1))) := by\n  refine ⟨fun p ↦ ⟨?_, ?_⟩, fun ⟨hf₁, hf₂⟩ ↦ Multipliable.of_nat_of_neg_add_one hf₁ hf₂⟩ <;>\n  apply p.comp_injective\n  exacts [Nat.cast_injective, @Int.negSucc.inj]\n\n"}
{"name":"multipliable_int_iff_multipliable_nat_and_neg","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"G : Type u_2\ninst✝³ : CommGroup G\ninst✝² : UniformSpace G\ninst✝¹ : UniformGroup G\ninst✝ : CompleteSpace G\nf : Int → G\n⊢ Iff (Multipliable f) (And (Multipliable fun n => f ↑n) (Multipliable fun n => f (Neg.neg ↑n)))","decl":"/-- \"iff\" version of `Multipliable.of_nat_of_neg`. -/\n@[to_additive \"\\\"iff\\\" version of `Summable.of_nat_of_neg`.\"]\nlemma multipliable_int_iff_multipliable_nat_and_neg {f : ℤ → G} :\n    Multipliable f ↔ (Multipliable fun n : ℕ ↦ f n) ∧ (Multipliable fun n : ℕ ↦ f (-n)) := by\n  refine ⟨fun p ↦ ⟨?_, ?_⟩, fun ⟨hf₁, hf₂⟩ ↦ Multipliable.of_nat_of_neg hf₁ hf₂⟩ <;>\n  apply p.comp_injective\n  exacts [Nat.cast_injective, neg_injective.comp Nat.cast_injective]\n\n"}
{"name":"summable_int_iff_summable_nat_and_neg","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"G : Type u_2\ninst✝³ : AddCommGroup G\ninst✝² : UniformSpace G\ninst✝¹ : UniformAddGroup G\ninst✝ : CompleteSpace G\nf : Int → G\n⊢ Iff (Summable f) (And (Summable fun n => f ↑n) (Summable fun n => f (Neg.neg ↑n)))","decl":"/-- \"iff\" version of `Multipliable.of_nat_of_neg`. -/\n@[to_additive \"\\\"iff\\\" version of `Summable.of_nat_of_neg`.\"]\nlemma multipliable_int_iff_multipliable_nat_and_neg {f : ℤ → G} :\n    Multipliable f ↔ (Multipliable fun n : ℕ ↦ f n) ∧ (Multipliable fun n : ℕ ↦ f (-n)) := by\n  refine ⟨fun p ↦ ⟨?_, ?_⟩, fun ⟨hf₁, hf₂⟩ ↦ Multipliable.of_nat_of_neg hf₁ hf₂⟩ <;>\n  apply p.comp_injective\n  exacts [Nat.cast_injective, neg_injective.comp Nat.cast_injective]\n\n"}
{"name":"pnat_multipliable_iff_multipliable_succ","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"α : Type u_3\ninst✝¹ : TopologicalSpace α\ninst✝ : CommMonoid α\nf : Nat → α\n⊢ Iff (Multipliable fun x => f ↑x) (Multipliable fun x => f (HAdd.hAdd x 1))","decl":"@[to_additive]\ntheorem pnat_multipliable_iff_multipliable_succ {α : Type*} [TopologicalSpace α] [CommMonoid α]\n    {f : ℕ → α} : Multipliable (fun x : ℕ+ => f x) ↔ Multipliable fun x : ℕ => f (x + 1) :=\n  Equiv.pnatEquivNat.symm.multipliable_iff.symm\n\n"}
{"name":"pnat_summable_iff_summable_succ","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"α : Type u_3\ninst✝¹ : TopologicalSpace α\ninst✝ : AddCommMonoid α\nf : Nat → α\n⊢ Iff (Summable fun x => f ↑x) (Summable fun x => f (HAdd.hAdd x 1))","decl":"@[to_additive]\ntheorem pnat_multipliable_iff_multipliable_succ {α : Type*} [TopologicalSpace α] [CommMonoid α]\n    {f : ℕ → α} : Multipliable (fun x : ℕ+ => f x) ↔ Multipliable fun x : ℕ => f (x + 1) :=\n  Equiv.pnatEquivNat.symm.multipliable_iff.symm\n\n"}
{"name":"tsum_pnat_eq_tsum_succ","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"α : Type u_3\ninst✝¹ : TopologicalSpace α\ninst✝ : AddCommMonoid α\nf : Nat → α\n⊢ Eq (tsum fun n => f ↑n) (tsum fun n => f (HAdd.hAdd n 1))","decl":"@[to_additive]\ntheorem tprod_pnat_eq_tprod_succ {α : Type*} [TopologicalSpace α] [CommMonoid α] (f : ℕ → α) :\n    ∏' n : ℕ+, f n = ∏' n, f (n + 1) := (Equiv.pnatEquivNat.symm.tprod_eq _).symm\n\n"}
{"name":"tprod_pnat_eq_tprod_succ","module":"Mathlib.Topology.Algebra.InfiniteSum.NatInt","initialProofState":"α : Type u_3\ninst✝¹ : TopologicalSpace α\ninst✝ : CommMonoid α\nf : Nat → α\n⊢ Eq (tprod fun n => f ↑n) (tprod fun n => f (HAdd.hAdd n 1))","decl":"@[to_additive]\ntheorem tprod_pnat_eq_tprod_succ {α : Type*} [TopologicalSpace α] [CommMonoid α] (f : ℕ → α) :\n    ∏' n : ℕ+, f n = ∏' n, f (n + 1) := (Equiv.pnatEquivNat.symm.tprod_eq _).symm\n\n"}
