{"name":"IsCofinal.of_isEmpty","module":"Mathlib.Order.Cofinal","initialProofState":"α : Type u_1\ninst✝¹ : LE α\ninst✝ : IsEmpty α\ns : Set α\n⊢ IsCofinal s","decl":"theorem IsCofinal.of_isEmpty [IsEmpty α] (s : Set α) : IsCofinal s :=\n  fun a ↦ isEmptyElim a\n\n"}
{"name":"isCofinal_empty_iff","module":"Mathlib.Order.Cofinal","initialProofState":"α : Type u_1\ninst✝ : LE α\n⊢ Iff (IsCofinal EmptyCollection.emptyCollection) (IsEmpty α)","decl":"theorem isCofinal_empty_iff : IsCofinal (∅ : Set α) ↔ IsEmpty α := by\n  refine ⟨fun h ↦ ⟨fun a ↦ ?_⟩, fun h ↦ .of_isEmpty _⟩\n  simpa using h a\n\n"}
{"name":"IsCofinal.singleton_top","module":"Mathlib.Order.Cofinal","initialProofState":"α : Type u_1\ninst✝¹ : LE α\ninst✝ : OrderTop α\n⊢ IsCofinal (Singleton.singleton Top.top)","decl":"theorem IsCofinal.singleton_top [OrderTop α] : IsCofinal {(⊤ : α)} :=\n  fun _ ↦ ⟨⊤, Set.mem_singleton _, le_top⟩\n\n"}
{"name":"IsCofinal.mono","module":"Mathlib.Order.Cofinal","initialProofState":"α : Type u_1\ninst✝ : LE α\ns t : Set α\nh : HasSubset.Subset s t\nhs : IsCofinal s\n⊢ IsCofinal t","decl":"theorem IsCofinal.mono {s t : Set α} (h : s ⊆ t) (hs : IsCofinal s) : IsCofinal t := by\n  intro a\n  obtain ⟨b, hb, hb'⟩ := hs a\n  exact ⟨b, h hb, hb'⟩\n\n"}
{"name":"IsCofinal.univ","module":"Mathlib.Order.Cofinal","initialProofState":"α : Type u_1\ninst✝ : Preorder α\n⊢ IsCofinal Set.univ","decl":"theorem IsCofinal.univ : IsCofinal (@Set.univ α) :=\n  fun a ↦ ⟨a, ⟨⟩, le_rfl⟩\n\n"}
{"name":"IsCofinal.trans","module":"Mathlib.Order.Cofinal","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns : Set α\nt : Set ↑s\nhs : IsCofinal s\nht : IsCofinal t\n⊢ IsCofinal (Set.image Subtype.val t)","decl":"/-- A cofinal subset of a cofinal subset is cofinal. -/\ntheorem IsCofinal.trans {s : Set α} {t : Set s} (hs : IsCofinal s) (ht : IsCofinal t) :\n    IsCofinal (Subtype.val '' t) := by\n  intro a\n  obtain ⟨b, hb, hb'⟩ := hs a\n  obtain ⟨c, hc, hc'⟩ := ht ⟨b, hb⟩\n  exact ⟨c, Set.mem_image_of_mem _ hc, hb'.trans hc'⟩\n\n"}
{"name":"GaloisConnection.map_cofinal","module":"Mathlib.Order.Cofinal","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nf : β → α\ng : α → β\nh : GaloisConnection f g\ns : Set α\nhs : IsCofinal s\n⊢ IsCofinal (Set.image g s)","decl":"theorem GaloisConnection.map_cofinal [Preorder β] {f : β → α} {g : α → β}\n    (h : GaloisConnection f g) {s : Set α} (hs : IsCofinal s) : IsCofinal (g '' s) := by\n  intro a\n  obtain ⟨b, hb, hb'⟩ := hs (f a)\n  exact ⟨g b, Set.mem_image_of_mem _ hb, h.le_iff_le.1 hb'⟩\n\n"}
{"name":"OrderIso.map_cofinal","module":"Mathlib.Order.Cofinal","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\ne : OrderIso α β\ns : Set α\nhs : IsCofinal s\n⊢ IsCofinal (Set.image (⇑e) s)","decl":"theorem OrderIso.map_cofinal [Preorder β] (e : α ≃o β) {s : Set α} (hs : IsCofinal s) :\n    IsCofinal (e '' s) :=\n  e.symm.to_galoisConnection.map_cofinal hs\n\n"}
{"name":"IsCofinal.mem_of_isMax","module":"Mathlib.Order.Cofinal","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\ns : Set α\na : α\nha : IsMax a\nhs : IsCofinal s\n⊢ Membership.mem s a","decl":"theorem IsCofinal.mem_of_isMax {s : Set α} {a : α} (ha : IsMax a) (hs : IsCofinal s) : a ∈ s := by\n  obtain ⟨b, hb, hb'⟩ := hs a\n  rwa [ha.eq_of_ge hb'] at hb\n\n"}
{"name":"IsCofinal.top_mem","module":"Mathlib.Order.Cofinal","initialProofState":"α : Type u_1\ninst✝¹ : PartialOrder α\ninst✝ : OrderTop α\ns : Set α\nhs : IsCofinal s\n⊢ Membership.mem s Top.top","decl":"theorem IsCofinal.top_mem [OrderTop α] {s : Set α} (hs : IsCofinal s) : ⊤ ∈ s :=\n  hs.mem_of_isMax isMax_top\n\n"}
{"name":"isCofinal_iff_top_mem","module":"Mathlib.Order.Cofinal","initialProofState":"α : Type u_1\ninst✝¹ : PartialOrder α\ninst✝ : OrderTop α\ns : Set α\n⊢ Iff (IsCofinal s) (Membership.mem s Top.top)","decl":"@[simp]\ntheorem isCofinal_iff_top_mem [OrderTop α] {s : Set α} : IsCofinal s ↔ ⊤ ∈ s :=\n  ⟨IsCofinal.top_mem, fun hs _ ↦ ⟨⊤, hs, le_top⟩⟩\n\n"}
{"name":"not_isCofinal_iff","module":"Mathlib.Order.Cofinal","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\ns : Set α\n⊢ Iff (Not (IsCofinal s)) (Exists fun x => ∀ (y : α), Membership.mem s y → LT.lt y x)","decl":"theorem not_isCofinal_iff {s : Set α} : ¬ IsCofinal s ↔ ∃ x, ∀ y ∈ s, y < x := by\n  simp [IsCofinal]\n\n"}
{"name":"BddAbove.of_not_isCofinal","module":"Mathlib.Order.Cofinal","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\ns : Set α\nh : Not (IsCofinal s)\n⊢ BddAbove s","decl":"theorem BddAbove.of_not_isCofinal {s : Set α} (h : ¬ IsCofinal s) : BddAbove s := by\n  rw [not_isCofinal_iff] at h\n  obtain ⟨x, h⟩ := h\n  exact ⟨x, fun y hy ↦ (h y hy).le⟩\n\n"}
{"name":"IsCofinal.of_not_bddAbove","module":"Mathlib.Order.Cofinal","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\ns : Set α\nh : Not (BddAbove s)\n⊢ IsCofinal s","decl":"theorem IsCofinal.of_not_bddAbove {s : Set α} (h : ¬ BddAbove s) : IsCofinal s := by\n  contrapose! h\n  exact .of_not_isCofinal h\n\n"}
{"name":"not_isCofinal_iff_bddAbove","module":"Mathlib.Order.Cofinal","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrder α\ninst✝ : NoMaxOrder α\ns : Set α\n⊢ Iff (Not (IsCofinal s)) (BddAbove s)","decl":"/-- In a linear order with no maximum, cofinal sets are the same as unbounded sets. -/\ntheorem not_isCofinal_iff_bddAbove [NoMaxOrder α] {s : Set α} : ¬ IsCofinal s ↔ BddAbove s := by\n  use .of_not_isCofinal\n  rw [not_isCofinal_iff]\n  rintro ⟨x, h⟩\n  obtain ⟨z, hz⟩ := exists_gt x\n  exact ⟨z, fun y hy ↦ (h hy).trans_lt hz⟩\n\n"}
{"name":"not_bddAbove_iff_isCofinal","module":"Mathlib.Order.Cofinal","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrder α\ninst✝ : NoMaxOrder α\ns : Set α\n⊢ Iff (Not (BddAbove s)) (IsCofinal s)","decl":"/-- In a linear order with no maximum, cofinal sets are the same as unbounded sets. -/\ntheorem not_bddAbove_iff_isCofinal [NoMaxOrder α] {s : Set α} : ¬ BddAbove s ↔ IsCofinal s :=\n  not_iff_comm.1 not_isCofinal_iff_bddAbove\n\n"}
{"name":"isCofinal_setOf_imp_lt","module":"Mathlib.Order.Cofinal","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\nr : α → α → Prop\nh : IsWellFounded α r\n⊢ IsCofinal (setOf fun a => ∀ (b : α), r b a → LT.lt b a)","decl":"/-- The set of \"records\" (the smallest inputs yielding the highest values) with respect to a\nwell-ordering of `α` is a cofinal set. -/\ntheorem isCofinal_setOf_imp_lt (r : α → α → Prop) [h : IsWellFounded α r] :\n    IsCofinal { a | ∀ b, r b a → b < a } := by\n  intro a\n  obtain ⟨b, hb, hb'⟩ := h.wf.has_min (Set.Ici a) Set.nonempty_Ici\n  refine ⟨b, fun c hc ↦ ?_, hb⟩\n  by_contra! hc'\n  exact hb' c (hb.trans hc') hc\n\n"}
