{"name":"Order.exists_between_finsets","module":"Mathlib.Order.CountableDenseLinearOrder","initialProofState":"α : Type u_1\ninst✝³ : LinearOrder α\ninst✝² : DenselyOrdered α\ninst✝¹ : NoMinOrder α\ninst✝ : NoMaxOrder α\nnonem : Nonempty α\nlo hi : Finset α\nlo_lt_hi : ∀ (x : α), Membership.mem lo x → ∀ (y : α), Membership.mem hi y → LT.lt x y\n⊢ Exists fun m => And (∀ (x : α), Membership.mem lo x → LT.lt x m) (∀ (y : α), Membership.mem hi y → LT.lt m y)","decl":"/-- Suppose `α` is a nonempty dense linear order without endpoints, and\n    suppose `lo`, `hi`, are finite subsets with all of `lo` strictly\n    before `hi`. Then there is an element of `α` strictly between `lo`\n    and `hi`. -/\ntheorem exists_between_finsets [DenselyOrdered α] [NoMinOrder α]\n    [NoMaxOrder α] [nonem : Nonempty α] (lo hi : Finset α) (lo_lt_hi : ∀ x ∈ lo, ∀ y ∈ hi, x < y) :\n    ∃ m : α, (∀ x ∈ lo, x < m) ∧ ∀ y ∈ hi, m < y :=\n  if nlo : lo.Nonempty then\n    if nhi : hi.Nonempty then\n      -- both sets are nonempty, use `DenselyOrdered`\n        Exists.elim\n        (exists_between (lo_lt_hi _ (Finset.max'_mem _ nlo) _ (Finset.min'_mem _ nhi))) fun m hm ↦\n        ⟨m, fun x hx ↦ lt_of_le_of_lt (Finset.le_max' lo x hx) hm.1, fun y hy ↦\n          lt_of_lt_of_le hm.2 (Finset.min'_le hi y hy)⟩\n    else-- upper set is empty, use `NoMaxOrder`\n        Exists.elim\n        (exists_gt (Finset.max' lo nlo)) fun m hm ↦\n        ⟨m, fun x hx ↦ lt_of_le_of_lt (Finset.le_max' lo x hx) hm, fun y hy ↦ (nhi ⟨y, hy⟩).elim⟩\n  else\n    if nhi : hi.Nonempty then\n      -- lower set is empty, use `NoMinOrder`\n        Exists.elim\n        (exists_lt (Finset.min' hi nhi)) fun m hm ↦\n        ⟨m, fun x hx ↦ (nlo ⟨x, hx⟩).elim, fun y hy ↦ lt_of_lt_of_le hm (Finset.min'_le hi y hy)⟩\n    else -- both sets are empty, use `Nonempty`\n          nonem.elim\n        fun m ↦ ⟨m, fun x hx ↦ (nlo ⟨x, hx⟩).elim, fun y hy ↦ (nhi ⟨y, hy⟩).elim⟩\n\n"}
{"name":"Order.exists_orderEmbedding_insert","module":"Mathlib.Order.CountableDenseLinearOrder","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁴ : LinearOrder α\ninst✝³ : LinearOrder β\ninst✝² : DenselyOrdered β\ninst✝¹ : NoMinOrder β\ninst✝ : NoMaxOrder β\nnonem : Nonempty β\nS : Finset α\nf : OrderEmbedding (Subtype fun x => Membership.mem S x) β\na : α\n⊢ Exists fun g => Eq (Function.comp (⇑g) (Set.inclusion ⋯)) ⇑f","decl":"lemma exists_orderEmbedding_insert [DenselyOrdered β] [NoMinOrder β] [NoMaxOrder β]\n    [nonem : Nonempty β]  (S : Finset α) (f : S ↪o β) (a : α) :\n    ∃ (g : (insert a S : Finset α) ↪o β),\n      g ∘ (Set.inclusion ((S.subset_insert a) : ↑S ⊆ ↑(insert a S))) = f := by\n  let Slt := (S.attach.filter (fun (x : S) => x < a)).image f\n  let Sgt := (S.attach.filter (fun (x : S) => a < x)).image f\n  obtain ⟨b, hb, hb'⟩ := Order.exists_between_finsets Slt Sgt (fun x hx y hy => by\n    simp only [Finset.mem_image, Finset.mem_filter, Finset.mem_attach, true_and, Subtype.exists,\n      exists_and_left, Slt, Sgt] at hx hy\n    obtain ⟨_, hx, _, rfl⟩ := hx\n    obtain ⟨_, hy, _, rfl⟩ := hy\n    exact f.strictMono (hx.trans hy))\n  refine ⟨OrderEmbedding.ofStrictMono\n    (fun (x : (insert a S : Finset α)) => if hx : x.1 ∈ S then f ⟨x.1, hx⟩ else b) ?_, ?_⟩\n  · rintro ⟨x, hx⟩ ⟨y, hy⟩ hxy\n    if hxS : x ∈ S\n    then if hyS : y ∈ S\n      then simpa only [hxS, hyS, ↓reduceDIte, OrderEmbedding.lt_iff_lt, Subtype.mk_lt_mk]\n      else\n        obtain rfl := Finset.eq_of_mem_insert_of_not_mem hy hyS\n        simp only [hxS, hyS, ↓reduceDIte]\n        exact hb _ (Finset.mem_image_of_mem _ (Finset.mem_filter.2 ⟨Finset.mem_attach _ _, hxy⟩))\n    else\n      obtain rfl := Finset.eq_of_mem_insert_of_not_mem hx hxS\n      if hyS : y ∈ S\n      then\n        simp only [hxS, hyS, ↓reduceDIte]\n        exact hb' _ (Finset.mem_image_of_mem _ (Finset.mem_filter.2 ⟨Finset.mem_attach _ _, hxy⟩))\n      else simp only [Finset.eq_of_mem_insert_of_not_mem hy hyS, lt_self_iff_false] at hxy\n  · ext x\n    simp only [Finset.coe_sort_coe, OrderEmbedding.coe_ofStrictMono, Finset.insert_val,\n      Function.comp_apply, Finset.coe_mem, ↓reduceDIte, Subtype.coe_eta]\n\n"}
{"name":"Order.PartialIso.exists_across","module":"Mathlib.Order.CountableDenseLinearOrder","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁵ : LinearOrder α\ninst✝⁴ : LinearOrder β\ninst✝³ : DenselyOrdered β\ninst✝² : NoMinOrder β\ninst✝¹ : NoMaxOrder β\ninst✝ : Nonempty β\nf : Order.PartialIso α β\na : α\n⊢ Exists fun b => ∀ (p : Prod α β), Membership.mem (↑f) p → Eq (cmp p.1 a) (cmp p.2 b)","decl":"/-- For each `a`, we can find a `b` in the codomain, such that `a`'s relation to\nthe domain of `f` is `b`'s relation to the image of `f`.\n\nThus, if `a` is not already in `f`, then we can extend `f` by sending `a` to `b`.\n-/\ntheorem exists_across [DenselyOrdered β] [NoMinOrder β] [NoMaxOrder β] [Nonempty β]\n    (f : PartialIso α β) (a : α) :\n    ∃ b : β, ∀ p ∈ f.val, cmp (Prod.fst p) a = cmp (Prod.snd p) b := by\n  by_cases h : ∃ b, (a, b) ∈ f.val\n  · cases' h with b hb\n    exact ⟨b, fun p hp ↦ f.prop _ hp _ hb⟩\n  have :\n    ∀ x ∈ (f.val.filter fun p : α × β ↦ p.fst < a).image Prod.snd,\n      ∀ y ∈ (f.val.filter fun p : α × β ↦ a < p.fst).image Prod.snd, x < y := by\n    intro x hx y hy\n    rw [Finset.mem_image] at hx hy\n    rcases hx with ⟨p, hp1, rfl⟩\n    rcases hy with ⟨q, hq1, rfl⟩\n    rw [Finset.mem_filter] at hp1 hq1\n    rw [← lt_iff_lt_of_cmp_eq_cmp (f.prop _ hp1.1 _ hq1.1)]\n    exact lt_trans hp1.right hq1.right\n  cases' exists_between_finsets _ _ this with b hb\n  use b\n  rintro ⟨p1, p2⟩ hp\n  have : p1 ≠ a := fun he ↦ h ⟨p2, he ▸ hp⟩\n  cases' lt_or_gt_of_ne this with hl hr\n  · have : p1 < a ∧ p2 < b :=\n      ⟨hl, hb.1 _ (Finset.mem_image.mpr ⟨(p1, p2), Finset.mem_filter.mpr ⟨hp, hl⟩, rfl⟩)⟩\n    rw [← cmp_eq_lt_iff, ← cmp_eq_lt_iff] at this\n    exact this.1.trans this.2.symm\n  · have : a < p1 ∧ b < p2 :=\n      ⟨hr, hb.2 _ (Finset.mem_image.mpr ⟨(p1, p2), Finset.mem_filter.mpr ⟨hp, hr⟩, rfl⟩)⟩\n    rw [← cmp_eq_gt_iff, ← cmp_eq_gt_iff] at this\n    exact this.1.trans this.2.symm\n\n"}
{"name":"Order.embedding_from_countable_to_dense","module":"Mathlib.Order.CountableDenseLinearOrder","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁴ : LinearOrder α\ninst✝³ : LinearOrder β\ninst✝² : Countable α\ninst✝¹ : DenselyOrdered β\ninst✝ : Nontrivial β\n⊢ Nonempty (OrderEmbedding α β)","decl":"/-- Any countable linear order embeds in any nontrivial dense linear order. -/\ntheorem embedding_from_countable_to_dense [Countable α] [DenselyOrdered β] [Nontrivial β] :\n    Nonempty (α ↪o β) := by\n  cases nonempty_encodable α\n  rcases exists_pair_lt β with ⟨x, y, hxy⟩\n  cases' exists_between hxy with a ha\n  haveI : Nonempty (Set.Ioo x y) := ⟨⟨a, ha⟩⟩\n  let our_ideal : Ideal (PartialIso α _) :=\n    idealOfCofinals default (definedAtLeft (Set.Ioo x y))\n  let F a := funOfIdeal a our_ideal (cofinal_meets_idealOfCofinals _ _ a)\n  refine\n    ⟨RelEmbedding.trans (OrderEmbedding.ofStrictMono (fun a ↦ (F a).val) fun a₁ a₂ ↦ ?_)\n        (OrderEmbedding.subtype _)⟩\n  rcases (F a₁).prop with ⟨f, hf, ha₁⟩\n  rcases (F a₂).prop with ⟨g, hg, ha₂⟩\n  rcases our_ideal.directed _ hf _ hg with ⟨m, _hm, fm, gm⟩\n  exact (lt_iff_lt_of_cmp_eq_cmp <| m.prop (a₁, _) (fm ha₁) (a₂, _) (gm ha₂)).mp\n\n"}
{"name":"Order.iso_of_countable_dense","module":"Mathlib.Order.CountableDenseLinearOrder","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹¹ : LinearOrder α\ninst✝¹⁰ : LinearOrder β\ninst✝⁹ : Countable α\ninst✝⁸ : DenselyOrdered α\ninst✝⁷ : NoMinOrder α\ninst✝⁶ : NoMaxOrder α\ninst✝⁵ : Nonempty α\ninst✝⁴ : Countable β\ninst✝³ : DenselyOrdered β\ninst✝² : NoMinOrder β\ninst✝¹ : NoMaxOrder β\ninst✝ : Nonempty β\n⊢ Nonempty (OrderIso α β)","decl":"/-- Any two countable dense, nonempty linear orders without endpoints are order isomorphic. -/\ntheorem iso_of_countable_dense [Countable α] [DenselyOrdered α] [NoMinOrder α] [NoMaxOrder α]\n    [Nonempty α] [Countable β] [DenselyOrdered β] [NoMinOrder β] [NoMaxOrder β] [Nonempty β] :\n    Nonempty (α ≃o β) := by\n  cases nonempty_encodable α\n  cases nonempty_encodable β\n  let to_cofinal : α ⊕ β → Cofinal (PartialIso α β) := fun p ↦\n    Sum.recOn p (definedAtLeft β) (definedAtRight α)\n  let our_ideal : Ideal (PartialIso α β) := idealOfCofinals default to_cofinal\n  let F a := funOfIdeal a our_ideal (cofinal_meets_idealOfCofinals _ to_cofinal (Sum.inl a))\n  let G b := invOfIdeal b our_ideal (cofinal_meets_idealOfCofinals _ to_cofinal (Sum.inr b))\n  exact ⟨OrderIso.ofCmpEqCmp (fun a ↦ (F a).val) (fun b ↦ (G b).val) fun a b ↦ by\n      rcases (F a).prop with ⟨f, hf, ha⟩\n      rcases (G b).prop with ⟨g, hg, hb⟩\n      rcases our_ideal.directed _ hf _ hg with ⟨m, _, fm, gm⟩\n      exact m.prop (a, _) (fm ha) (_, b) (gm hb)⟩\n\n"}
