{"name":"irrational_pi","module":"Mathlib.Data.Real.Pi.Irrational","initialProofState":"⊢ Irrational Real.pi","decl":"@[simp] theorem irrational_pi : Irrational π := by\n  apply Irrational.of_div_nat 2\n  rw [Nat.cast_two]\n  by_contra h'\n  obtain ⟨a, b, hb, h⟩ := not_irrational_exists_rep h'\n  have ha : (0 : ℝ) < a := by\n    have : 0 < (a : ℝ) / b := h ▸ pi_div_two_pos\n    rwa [lt_div_iff₀ (by positivity), zero_mul] at this\n  have k (n : ℕ) : 0 < (a : ℝ) ^ (2 * n + 1) / n ! := by positivity\n  have j : ∀ᶠ n : ℕ in atTop, (a : ℝ) ^ (2 * n + 1) / n ! * I n (π / 2) < 1 := by\n    have := (tendsto_pow_div_factorial_at_top_aux a).eventually_lt_const\n      (show (0 : ℝ) < 1 / 2 by norm_num)\n    filter_upwards [this] with n hn\n    rw [lt_div_iff₀ (zero_lt_two : (0 : ℝ) < 2)] at hn\n    exact hn.trans_le' (mul_le_mul_of_nonneg_left (I_le _) (by positivity))\n  obtain ⟨n, hn⟩ := j.exists\n  have hn' : 0 < a ^ (2 * n + 1) / n ! * I n (π / 2) := mul_pos (k _) I_pos\n  obtain ⟨z, hz⟩ : ∃ z : ℤ, (sinPoly n).eval₂ (Int.castRingHom ℝ) (a / b) * b ^ (2 * n + 1) = z :=\n    is_integer a b ((sinPoly_natDegree_le _).trans (by omega))\n  have e := sinPoly_add_cosPoly_eval (π / 2) n\n  rw [cos_pi_div_two, sin_pi_div_two, mul_zero, mul_one, add_zero] at e\n  have : a ^ (2 * n + 1) / n ! * I n (π / 2) =\n      eval₂ (Int.castRingHom ℝ) (π / 2) (sinPoly n) * b ^ (2 * n + 1) := by\n    nth_rw 2 [h] at e\n    field_simp at e ⊢\n    linear_combination e\n  have : (0 : ℝ) < z ∧ (z : ℝ) < 1 := by simp [← hz, ← h, ← this, hn', hn]\n  norm_cast at this\n  omega\n\n"}
