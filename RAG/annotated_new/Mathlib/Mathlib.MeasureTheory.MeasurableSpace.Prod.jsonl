{"name":"generateFrom_prod_eq","module":"Mathlib.MeasureTheory.MeasurableSpace.Prod","initialProofState":"α : Type u_3\nβ : Type u_4\nC : Set (Set α)\nD : Set (Set β)\nhC : IsCountablySpanning C\nhD : IsCountablySpanning D\n⊢ Eq Prod.instMeasurableSpace (MeasurableSpace.generateFrom (Set.image2 (fun x1 x2 => SProd.sprod x1 x2) C D))","decl":"/-- The product of generated σ-algebras is the one generated by rectangles, if both generating sets\n  are countably spanning. -/\ntheorem generateFrom_prod_eq {α β} {C : Set (Set α)} {D : Set (Set β)} (hC : IsCountablySpanning C)\n    (hD : IsCountablySpanning D) :\n    @Prod.instMeasurableSpace _ _ (generateFrom C) (generateFrom D) =\n      generateFrom (image2 (· ×ˢ ·) C D) := by\n  apply le_antisymm\n  · refine sup_le ?_ ?_ <;> rw [comap_generateFrom] <;> apply generateFrom_le <;>\n      rintro _ ⟨s, hs, rfl⟩\n    · rcases hD with ⟨t, h1t, h2t⟩\n      rw [← prod_univ, ← h2t, prod_iUnion]\n      apply MeasurableSet.iUnion\n      intro n\n      apply measurableSet_generateFrom\n      exact ⟨s, hs, t n, h1t n, rfl⟩\n    · rcases hC with ⟨t, h1t, h2t⟩\n      rw [← univ_prod, ← h2t, iUnion_prod_const]\n      apply MeasurableSet.iUnion\n      rintro n\n      apply measurableSet_generateFrom\n      exact mem_image2_of_mem (h1t n) hs\n  · apply generateFrom_le\n    rintro _ ⟨s, hs, t, ht, rfl⟩\n    dsimp only\n    rw [prod_eq]\n    apply (measurable_fst _).inter (measurable_snd _)\n    · exact measurableSet_generateFrom hs\n    · exact measurableSet_generateFrom ht\n\n"}
{"name":"generateFrom_eq_prod","module":"Mathlib.MeasureTheory.MeasurableSpace.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace β\nC : Set (Set α)\nD : Set (Set β)\nhC : Eq (MeasurableSpace.generateFrom C) inst✝¹\nhD : Eq (MeasurableSpace.generateFrom D) inst✝\nh2C : IsCountablySpanning C\nh2D : IsCountablySpanning D\n⊢ Eq (MeasurableSpace.generateFrom (Set.image2 (fun x1 x2 => SProd.sprod x1 x2) C D)) Prod.instMeasurableSpace","decl":"/-- If `C` and `D` generate the σ-algebras on `α` resp. `β`, then rectangles formed by `C` and `D`\n  generate the σ-algebra on `α × β`. -/\ntheorem generateFrom_eq_prod {C : Set (Set α)} {D : Set (Set β)} (hC : generateFrom C = ‹_›)\n    (hD : generateFrom D = ‹_›) (h2C : IsCountablySpanning C) (h2D : IsCountablySpanning D) :\n    generateFrom (image2 (· ×ˢ ·) C D) = Prod.instMeasurableSpace := by\n  rw [← hC, ← hD, generateFrom_prod_eq h2C h2D]\n\n"}
{"name":"generateFrom_prod","module":"Mathlib.MeasureTheory.MeasurableSpace.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace β\n⊢ Eq (MeasurableSpace.generateFrom (Set.image2 (fun x1 x2 => SProd.sprod x1 x2) (setOf fun s => MeasurableSet s) (setOf fun t => MeasurableSet t))) Prod.instMeasurableSpace","decl":"/-- The product σ-algebra is generated from boxes, i.e. `s ×ˢ t` for sets `s : Set α` and\n  `t : Set β`. -/\nlemma generateFrom_prod :\n    generateFrom (image2 (· ×ˢ ·) { s : Set α | MeasurableSet s } { t : Set β | MeasurableSet t }) =\n      Prod.instMeasurableSpace :=\n  generateFrom_eq_prod generateFrom_measurableSet generateFrom_measurableSet\n    isCountablySpanning_measurableSet isCountablySpanning_measurableSet\n\n"}
{"name":"isPiSystem_prod","module":"Mathlib.MeasureTheory.MeasurableSpace.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace β\n⊢ IsPiSystem (Set.image2 (fun x1 x2 => SProd.sprod x1 x2) (setOf fun s => MeasurableSet s) (setOf fun t => MeasurableSet t))","decl":"/-- Rectangles form a π-system. -/\nlemma isPiSystem_prod :\n    IsPiSystem (image2 (· ×ˢ ·) { s : Set α | MeasurableSet s } { t : Set β | MeasurableSet t }) :=\n  isPiSystem_measurableSet.prod isPiSystem_measurableSet\n\n"}
{"name":"MeasurableEmbedding.prodMap","module":"Mathlib.MeasureTheory.MeasurableSpace.Prod","initialProofState":"α : Type u_3\nβ : Type u_4\nγ : Type u_5\nδ : Type u_6\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nmγ : MeasurableSpace γ\nmδ : MeasurableSpace δ\nf : α → β\ng : γ → δ\nhg : MeasurableEmbedding g\nhf : MeasurableEmbedding f\n⊢ MeasurableEmbedding (Prod.map g f)","decl":"lemma MeasurableEmbedding.prodMap {α β γ δ : Type*} {mα : MeasurableSpace α}\n    {mβ : MeasurableSpace β} {mγ : MeasurableSpace γ} {mδ : MeasurableSpace δ} {f : α → β}\n    {g : γ → δ} (hg : MeasurableEmbedding g) (hf : MeasurableEmbedding f) :\n    MeasurableEmbedding (Prod.map g f) := by\n  refine ⟨hg.injective.prodMap hf.injective, ?_, ?_⟩\n  · exact (hg.measurable.comp measurable_fst).prod_mk (hf.measurable.comp measurable_snd)\n  · intro s hs\n    -- Induction using the π-system of rectangles\n    induction s, hs using induction_on_inter generateFrom_prod.symm isPiSystem_prod with\n    | empty =>\n      simp only [Set.image_empty, MeasurableSet.empty]\n    | basic s hs =>\n      obtain ⟨t₁, ht₁, t₂, ht₂, rfl⟩ := hs\n      simp_rw [Prod.map, ← prod_image_image_eq]\n      exact (hg.measurableSet_image.mpr ht₁).prod (hf.measurableSet_image.mpr ht₂)\n    | compl s _ ihs =>\n      rw [← range_diff_image (hg.injective.prodMap hf.injective), range_prod_map]\n      exact .diff (.prod hg.measurableSet_range hf.measurableSet_range) ihs\n    | iUnion f _ _ ihf =>\n      simpa only [image_iUnion] using .iUnion ihf\n\n"}
{"name":"MeasurableEmbedding.prod_mk","module":"Mathlib.MeasureTheory.MeasurableSpace.Prod","initialProofState":"α : Type u_3\nβ : Type u_4\nγ : Type u_5\nδ : Type u_6\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nmγ : MeasurableSpace γ\nmδ : MeasurableSpace δ\nf : α → β\ng : γ → δ\nhg : MeasurableEmbedding g\nhf : MeasurableEmbedding f\n⊢ MeasurableEmbedding (Prod.map g f)","decl":"@[deprecated (since := \"2024-12-11\")]\nalias MeasurableEmbedding.prod_mk := MeasurableEmbedding.prodMap\n\n"}
{"name":"MeasurableEmbedding.prod_mk_left","module":"Mathlib.MeasureTheory.MeasurableSpace.Prod","initialProofState":"α : Type u_1\ninst✝¹ : MeasurableSpace α\nβ : Type u_3\nγ : Type u_4\ninst✝ : MeasurableSingletonClass α\nmβ : MeasurableSpace β\nmγ : MeasurableSpace γ\nx : α\nf : γ → β\nhf : MeasurableEmbedding f\n⊢ MeasurableEmbedding fun y => { fst := x, snd := f y }","decl":"lemma MeasurableEmbedding.prod_mk_left {β γ : Type*} [MeasurableSingletonClass α]\n    {mβ : MeasurableSpace β} {mγ : MeasurableSpace γ}\n    (x : α) {f : γ → β} (hf : MeasurableEmbedding f) :\n    MeasurableEmbedding (fun y ↦ (x, f y)) where\n  injective := by\n    intro y y'\n    simp only [Prod.mk.injEq, true_and]\n    exact fun h ↦ hf.injective h\n  measurable := Measurable.prod_mk measurable_const hf.measurable\n  measurableSet_image' := by\n    intro s hs\n    convert (MeasurableSet.singleton x).prod (hf.measurableSet_image.mpr hs)\n    ext x\n    simp\n\n"}
{"name":"measurableEmbedding_prod_mk_left","module":"Mathlib.MeasureTheory.MeasurableSpace.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\ninst✝ : MeasurableSingletonClass α\nx : α\n⊢ MeasurableEmbedding (Prod.mk x)","decl":"lemma measurableEmbedding_prod_mk_left [MeasurableSingletonClass α] (x : α) :\n    MeasurableEmbedding (Prod.mk x : β → α × β) :=\n  MeasurableEmbedding.prod_mk_left x MeasurableEmbedding.id\n\n"}
{"name":"MeasurableEmbedding.prod_mk_right","module":"Mathlib.MeasureTheory.MeasurableSpace.Prod","initialProofState":"α : Type u_1\ninst✝¹ : MeasurableSpace α\nβ : Type u_3\nγ : Type u_4\ninst✝ : MeasurableSingletonClass α\nmβ : MeasurableSpace β\nmγ : MeasurableSpace γ\nf : γ → β\nhf : MeasurableEmbedding f\nx : α\n⊢ MeasurableEmbedding fun y => { fst := f y, snd := x }","decl":"lemma MeasurableEmbedding.prod_mk_right {β γ : Type*} [MeasurableSingletonClass α]\n    {mβ : MeasurableSpace β} {mγ : MeasurableSpace γ}\n    {f : γ → β} (hf : MeasurableEmbedding f) (x : α) :\n    MeasurableEmbedding (fun y ↦ (f y, x)) where\n  injective := by\n    intro y y'\n    simp only [Prod.mk.injEq, and_true]\n    exact fun h ↦ hf.injective h\n  measurable := Measurable.prod_mk hf.measurable measurable_const\n  measurableSet_image' := by\n    intro s hs\n    convert (hf.measurableSet_image.mpr hs).prod (MeasurableSet.singleton x)\n    ext x\n    simp\n\n"}
{"name":"measurableEmbedding_prod_mk_right","module":"Mathlib.MeasureTheory.MeasurableSpace.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\ninst✝ : MeasurableSingletonClass α\nx : α\n⊢ MeasurableEmbedding fun y => { fst := y, snd := x }","decl":"lemma measurableEmbedding_prod_mk_right [MeasurableSingletonClass α] (x : α) :\n    MeasurableEmbedding (fun y ↦ (y, x) : β → β × α) :=\n  MeasurableEmbedding.prod_mk_right MeasurableEmbedding.id x\n"}
