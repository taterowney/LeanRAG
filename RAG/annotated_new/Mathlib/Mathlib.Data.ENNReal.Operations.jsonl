{"name":"ENNReal.mul_lt_mul","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"a b c d : ENNReal\nac : LT.lt a c\nbd : LT.lt b d\n⊢ LT.lt (HMul.hMul a b) (HMul.hMul c d)","decl":"@[mono, gcongr]\ntheorem mul_lt_mul (ac : a < c) (bd : b < d) : a * b < c * d := WithTop.mul_lt_mul ac bd\n\n"}
{"name":"ENNReal.mul_left_mono","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"a : ENNReal\n⊢ Monotone fun x => HMul.hMul a x","decl":"@[deprecated mul_left_mono (since := \"2024-10-15\")]\nprotected theorem mul_left_mono : Monotone (a * ·) := mul_left_mono\n\n"}
{"name":"ENNReal.mul_right_mono","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"a : ENNReal\n⊢ Monotone fun x => HMul.hMul x a","decl":"@[deprecated mul_right_mono (since := \"2024-10-15\")]\nprotected theorem mul_right_mono : Monotone (· * a) := mul_right_mono\n\n"}
{"name":"ENNReal.pow_right_strictMono","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"n : Nat\nhn : Ne n 0\n⊢ StrictMono fun a => HPow.hPow a n","decl":"protected lemma pow_right_strictMono {n : ℕ} (hn : n ≠ 0) : StrictMono fun a : ℝ≥0∞ ↦ a ^ n :=\n  WithTop.pow_right_strictMono hn\n\n"}
{"name":"ENNReal.pow_strictMono","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"n : Nat\nhn : Ne n 0\n⊢ StrictMono fun a => HPow.hPow a n","decl":"@[deprecated (since := \"2024-10-15\")] alias pow_strictMono := ENNReal.pow_right_strictMono\n\n"}
{"name":"ENNReal.pow_lt_pow_left","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"a b : ENNReal\nhab : LT.lt a b\nn : Nat\nhn : Ne n 0\n⊢ LT.lt (HPow.hPow a n) (HPow.hPow b n)","decl":"@[gcongr] protected lemma pow_lt_pow_left (hab : a < b) {n : ℕ} (hn : n ≠ 0) : a ^ n < b ^ n :=\n  WithTop.pow_lt_pow_left hab hn\n\n"}
{"name":"ENNReal.max_mul","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"a b c : ENNReal\n⊢ Eq (HMul.hMul (Max.max a b) c) (Max.max (HMul.hMul a c) (HMul.hMul b c))","decl":"@[deprecated max_mul (since := \"2024-10-15\")]\nprotected theorem max_mul : max a b * c = max (a * c) (b * c) := mul_right_mono.map_max\n\n"}
{"name":"ENNReal.mul_max","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"a b c : ENNReal\n⊢ Eq (HMul.hMul a (Max.max b c)) (Max.max (HMul.hMul a b) (HMul.hMul a c))","decl":"@[deprecated mul_max (since := \"2024-10-15\")]\nprotected theorem mul_max : a * max b c = max (a * b) (a * c) := mul_left_mono.map_max\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO: generalize to `WithTop`\n"}
{"name":"ENNReal.mul_left_strictMono","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"a : ENNReal\nh0 : Ne a 0\nhinf : Ne a Top.top\n⊢ StrictMono fun x => HMul.hMul a x","decl":"theorem mul_left_strictMono (h0 : a ≠ 0) (hinf : a ≠ ∞) : StrictMono (a * ·) := by\n  lift a to ℝ≥0 using hinf\n  rw [coe_ne_zero] at h0\n  intro x y h\n  contrapose! h\n  simpa only [← mul_assoc, ← coe_mul, inv_mul_cancel₀ h0, coe_one, one_mul]\n    using mul_le_mul_left' h (↑a⁻¹)\n\n"}
{"name":"ENNReal.mul_lt_mul_left'","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"a b c : ENNReal\nh0 : Ne a 0\nhinf : Ne a Top.top\nbc : LT.lt b c\n⊢ LT.lt (HMul.hMul a b) (HMul.hMul a c)","decl":"@[gcongr] protected theorem mul_lt_mul_left' (h0 : a ≠ 0) (hinf : a ≠ ⊤) (bc : b < c) :\n    a * b < a * c :=\n  ENNReal.mul_left_strictMono h0 hinf bc\n\n"}
{"name":"ENNReal.mul_lt_mul_right'","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"a b c : ENNReal\nh0 : Ne a 0\nhinf : Ne a Top.top\nbc : LT.lt b c\n⊢ LT.lt (HMul.hMul b a) (HMul.hMul c a)","decl":"@[gcongr] protected theorem mul_lt_mul_right' (h0 : a ≠ 0) (hinf : a ≠ ⊤) (bc : b < c) :\n    b * a < c * a :=\n  mul_comm b a ▸ mul_comm c a ▸ ENNReal.mul_left_strictMono h0 hinf bc\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO: generalize to `WithTop`\n"}
{"name":"ENNReal.mul_right_inj","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"a b c : ENNReal\nh0 : Ne a 0\nhinf : Ne a Top.top\n⊢ Iff (Eq (HMul.hMul a b) (HMul.hMul a c)) (Eq b c)","decl":"protected theorem mul_right_inj (h0 : a ≠ 0) (hinf : a ≠ ∞) : a * b = a * c ↔ b = c :=\n  (mul_left_strictMono h0 hinf).injective.eq_iff\n\n"}
{"name":"ENNReal.mul_eq_mul_left","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"a b c : ENNReal\nh0 : Ne a 0\nhinf : Ne a Top.top\n⊢ Iff (Eq (HMul.hMul a b) (HMul.hMul a c)) (Eq b c)","decl":"@[deprecated (since := \"2025-01-20\")]\nalias mul_eq_mul_left := ENNReal.mul_right_inj\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO: generalize to `WithTop`\n"}
{"name":"ENNReal.mul_left_inj","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"a b c : ENNReal\nh0 : Ne c 0\nhinf : Ne c Top.top\n⊢ Iff (Eq (HMul.hMul a c) (HMul.hMul b c)) (Eq a b)","decl":"protected theorem mul_left_inj (h0 : c ≠ 0) (hinf : c ≠ ∞) : a * c = b * c ↔ a = b :=\n  mul_comm c a ▸ mul_comm c b ▸ ENNReal.mul_right_inj h0 hinf\n\n"}
{"name":"ENNReal.mul_eq_mul_right","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"a b c : ENNReal\nh0 : Ne c 0\nhinf : Ne c Top.top\n⊢ Iff (Eq (HMul.hMul a c) (HMul.hMul b c)) (Eq a b)","decl":"@[deprecated (since := \"2025-01-20\")]\nalias mul_eq_mul_right := ENNReal.mul_left_inj\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO: generalize to `WithTop`\n"}
{"name":"ENNReal.mul_le_mul_left","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"a b c : ENNReal\nh0 : Ne a 0\nhinf : Ne a Top.top\n⊢ Iff (LE.le (HMul.hMul a b) (HMul.hMul a c)) (LE.le b c)","decl":"theorem mul_le_mul_left (h0 : a ≠ 0) (hinf : a ≠ ∞) : a * b ≤ a * c ↔ b ≤ c :=\n  (mul_left_strictMono h0 hinf).le_iff_le\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO: generalize to `WithTop`\n"}
{"name":"ENNReal.mul_le_mul_right","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"a b c : ENNReal\na✝¹ : Ne c 0\na✝ : Ne c Top.top\n⊢ Iff (LE.le (HMul.hMul a c) (HMul.hMul b c)) (LE.le a b)","decl":"theorem mul_le_mul_right : c ≠ 0 → c ≠ ∞ → (a * c ≤ b * c ↔ a ≤ b) :=\n  mul_comm c a ▸ mul_comm c b ▸ mul_le_mul_left\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO: generalize to `WithTop`\n"}
{"name":"ENNReal.mul_lt_mul_left","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"a b c : ENNReal\nh0 : Ne a 0\nhinf : Ne a Top.top\n⊢ Iff (LT.lt (HMul.hMul a b) (HMul.hMul a c)) (LT.lt b c)","decl":"theorem mul_lt_mul_left (h0 : a ≠ 0) (hinf : a ≠ ∞) : a * b < a * c ↔ b < c :=\n  (mul_left_strictMono h0 hinf).lt_iff_lt\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO: generalize to `WithTop`\n"}
{"name":"ENNReal.mul_lt_mul_right","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"a b c : ENNReal\na✝¹ : Ne c 0\na✝ : Ne c Top.top\n⊢ Iff (LT.lt (HMul.hMul a c) (HMul.hMul b c)) (LT.lt a b)","decl":"theorem mul_lt_mul_right : c ≠ 0 → c ≠ ∞ → (a * c < b * c ↔ a < b) :=\n  mul_comm c a ▸ mul_comm c b ▸ mul_lt_mul_left\n\n"}
{"name":"ENNReal.mul_eq_left","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"a b : ENNReal\nha₀ : Ne a 0\nha : Ne a Top.top\n⊢ Iff (Eq (HMul.hMul a b) a) (Eq b 1)","decl":"protected lemma mul_eq_left (ha₀ : a ≠ 0) (ha : a ≠ ∞) : a * b = a ↔ b = 1 := by\n  simpa using ENNReal.mul_right_inj ha₀ ha (c := 1)\n\n"}
{"name":"ENNReal.mul_eq_right","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"a b : ENNReal\nhb₀ : Ne b 0\nhb : Ne b Top.top\n⊢ Iff (Eq (HMul.hMul a b) b) (Eq a 1)","decl":"protected lemma mul_eq_right (hb₀ : b ≠ 0) (hb : b ≠ ∞) : a * b = b ↔ a = 1 := by\n  simpa using ENNReal.mul_left_inj hb₀ hb (b := 1)\n\n"}
{"name":"ENNReal.pow_pos","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"a : ENNReal\na✝ : LT.lt 0 a\nn : Nat\n⊢ LT.lt 0 (HPow.hPow a n)","decl":"protected theorem pow_pos : 0 < a → ∀ n : ℕ, 0 < a ^ n :=\n  CanonicallyOrderedAdd.pow_pos\n\n"}
{"name":"ENNReal.pow_ne_zero","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"a : ENNReal\na✝ : Ne a 0\nn : Nat\n⊢ Ne (HPow.hPow a n) 0","decl":"protected theorem pow_ne_zero : a ≠ 0 → ∀ n : ℕ, a ^ n ≠ 0 := by\n  simpa only [pos_iff_ne_zero] using ENNReal.pow_pos\n\n"}
{"name":"ENNReal.not_lt_zero","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"a : ENNReal\n⊢ Not (LT.lt a 0)","decl":"theorem not_lt_zero : ¬a < 0 := by simp\n\n"}
{"name":"ENNReal.le_of_add_le_add_left","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"a b c : ENNReal\na✝¹ : Ne a Top.top\na✝ : LE.le (HAdd.hAdd a b) (HAdd.hAdd a c)\n⊢ LE.le b c","decl":"protected theorem le_of_add_le_add_left : a ≠ ∞ → a + b ≤ a + c → b ≤ c :=\n  WithTop.le_of_add_le_add_left\n\n"}
{"name":"ENNReal.le_of_add_le_add_right","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"a b c : ENNReal\na✝¹ : Ne a Top.top\na✝ : LE.le (HAdd.hAdd b a) (HAdd.hAdd c a)\n⊢ LE.le b c","decl":"protected theorem le_of_add_le_add_right : a ≠ ∞ → b + a ≤ c + a → b ≤ c :=\n  WithTop.le_of_add_le_add_right\n\n"}
{"name":"ENNReal.add_lt_add_left","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"a b c : ENNReal\na✝¹ : Ne a Top.top\na✝ : LT.lt b c\n⊢ LT.lt (HAdd.hAdd a b) (HAdd.hAdd a c)","decl":"@[gcongr] protected theorem add_lt_add_left : a ≠ ∞ → b < c → a + b < a + c :=\n  WithTop.add_lt_add_left\n\n"}
{"name":"ENNReal.add_lt_add_right","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"a b c : ENNReal\na✝¹ : Ne a Top.top\na✝ : LT.lt b c\n⊢ LT.lt (HAdd.hAdd b a) (HAdd.hAdd c a)","decl":"@[gcongr] protected theorem add_lt_add_right : a ≠ ∞ → b < c → b + a < c + a :=\n  WithTop.add_lt_add_right\n\n"}
{"name":"ENNReal.add_le_add_iff_left","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"a b c : ENNReal\na✝ : Ne a Top.top\n⊢ Iff (LE.le (HAdd.hAdd a b) (HAdd.hAdd a c)) (LE.le b c)","decl":"protected theorem add_le_add_iff_left : a ≠ ∞ → (a + b ≤ a + c ↔ b ≤ c) :=\n  WithTop.add_le_add_iff_left\n\n"}
{"name":"ENNReal.add_le_add_iff_right","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"a b c : ENNReal\na✝ : Ne a Top.top\n⊢ Iff (LE.le (HAdd.hAdd b a) (HAdd.hAdd c a)) (LE.le b c)","decl":"protected theorem add_le_add_iff_right : a ≠ ∞ → (b + a ≤ c + a ↔ b ≤ c) :=\n  WithTop.add_le_add_iff_right\n\n"}
{"name":"ENNReal.add_lt_add_iff_left","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"a b c : ENNReal\na✝ : Ne a Top.top\n⊢ Iff (LT.lt (HAdd.hAdd a b) (HAdd.hAdd a c)) (LT.lt b c)","decl":"protected theorem add_lt_add_iff_left : a ≠ ∞ → (a + b < a + c ↔ b < c) :=\n  WithTop.add_lt_add_iff_left\n\n"}
{"name":"ENNReal.add_lt_add_iff_right","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"a b c : ENNReal\na✝ : Ne a Top.top\n⊢ Iff (LT.lt (HAdd.hAdd b a) (HAdd.hAdd c a)) (LT.lt b c)","decl":"protected theorem add_lt_add_iff_right : a ≠ ∞ → (b + a < c + a ↔ b < c) :=\n  WithTop.add_lt_add_iff_right\n\n"}
{"name":"ENNReal.add_lt_add_of_le_of_lt","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"a b c d : ENNReal\na✝² : Ne a Top.top\na✝¹ : LE.le a b\na✝ : LT.lt c d\n⊢ LT.lt (HAdd.hAdd a c) (HAdd.hAdd b d)","decl":"protected theorem add_lt_add_of_le_of_lt : a ≠ ∞ → a ≤ b → c < d → a + c < b + d :=\n  WithTop.add_lt_add_of_le_of_lt\n\n"}
{"name":"ENNReal.add_lt_add_of_lt_of_le","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"a b c d : ENNReal\na✝² : Ne c Top.top\na✝¹ : LT.lt a b\na✝ : LE.le c d\n⊢ LT.lt (HAdd.hAdd a c) (HAdd.hAdd b d)","decl":"protected theorem add_lt_add_of_lt_of_le : c ≠ ∞ → a < b → c ≤ d → a + c < b + d :=\n  WithTop.add_lt_add_of_lt_of_le\n\n"}
{"name":"ENNReal.addLeftReflectLT","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"⊢ AddLeftReflectLT ENNReal","decl":"instance addLeftReflectLT : AddLeftReflectLT ℝ≥0∞ :=\n  WithTop.addLeftReflectLT\n\n"}
{"name":"ENNReal.lt_add_right","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"a b : ENNReal\nha : Ne a Top.top\nhb : Ne b 0\n⊢ LT.lt a (HAdd.hAdd a b)","decl":"theorem lt_add_right (ha : a ≠ ∞) (hb : b ≠ 0) : a < a + b := by\n  rwa [← pos_iff_ne_zero, ← ENNReal.add_lt_add_iff_left ha, add_zero] at hb\n\n"}
{"name":"ENNReal.add_eq_top","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"a b : ENNReal\n⊢ Iff (Eq (HAdd.hAdd a b) Top.top) (Or (Eq a Top.top) (Eq b Top.top))","decl":"@[simp] theorem add_eq_top : a + b = ∞ ↔ a = ∞ ∨ b = ∞ := WithTop.add_eq_top\n\n"}
{"name":"ENNReal.add_lt_top","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"a b : ENNReal\n⊢ Iff (LT.lt (HAdd.hAdd a b) Top.top) (And (LT.lt a Top.top) (LT.lt b Top.top))","decl":"@[simp] theorem add_lt_top : a + b < ∞ ↔ a < ∞ ∧ b < ∞ := WithTop.add_lt_top\n\n"}
{"name":"ENNReal.toNNReal_add","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"r₁ r₂ : ENNReal\nh₁ : Ne r₁ Top.top\nh₂ : Ne r₂ Top.top\n⊢ Eq (HAdd.hAdd r₁ r₂).toNNReal (HAdd.hAdd r₁.toNNReal r₂.toNNReal)","decl":"theorem toNNReal_add {r₁ r₂ : ℝ≥0∞} (h₁ : r₁ ≠ ∞) (h₂ : r₂ ≠ ∞) :\n    (r₁ + r₂).toNNReal = r₁.toNNReal + r₂.toNNReal := by\n  lift r₁ to ℝ≥0 using h₁\n  lift r₂ to ℝ≥0 using h₂\n  rfl\n\n"}
{"name":"ENNReal.not_lt_top","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"x : ENNReal\n⊢ Iff (Not (LT.lt x Top.top)) (Eq x Top.top)","decl":"theorem not_lt_top {x : ℝ≥0∞} : ¬x < ∞ ↔ x = ∞ := by rw [lt_top_iff_ne_top, Classical.not_not]\n\n"}
{"name":"ENNReal.add_ne_top","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"a b : ENNReal\n⊢ Iff (Ne (HAdd.hAdd a b) Top.top) (And (Ne a Top.top) (Ne b Top.top))","decl":"theorem add_ne_top : a + b ≠ ∞ ↔ a ≠ ∞ ∧ b ≠ ∞ := by simpa only [lt_top_iff_ne_top] using add_lt_top\n\n"}
{"name":"ENNReal.Finiteness.add_ne_top","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"a b : ENNReal\nha : Ne a Top.top\nhb : Ne b Top.top\n⊢ Ne (HAdd.hAdd a b) Top.top","decl":"@[aesop (rule_sets := [finiteness]) safe apply]\nprotected lemma Finiteness.add_ne_top {a b : ℝ≥0∞} (ha : a ≠ ∞) (hb : b ≠ ∞) : a + b ≠ ∞ :=\n  ENNReal.add_ne_top.2 ⟨ha, hb⟩\n\n"}
{"name":"ENNReal.mul_top'","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"a : ENNReal\n⊢ Eq (HMul.hMul a Top.top) (ite (Eq a 0) 0 Top.top)","decl":"theorem mul_top' : a * ∞ = if a = 0 then 0 else ∞ := by convert WithTop.mul_top' a\n\n-- Porting note: added because `simp` no longer uses `WithTop` lemmas for `ℝ≥0∞`\n"}
{"name":"ENNReal.mul_top","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"a : ENNReal\nh : Ne a 0\n⊢ Eq (HMul.hMul a Top.top) Top.top","decl":"@[simp] theorem mul_top (h : a ≠ 0) : a * ∞ = ∞ := WithTop.mul_top h\n\n"}
{"name":"ENNReal.top_mul'","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"a : ENNReal\n⊢ Eq (HMul.hMul Top.top a) (ite (Eq a 0) 0 Top.top)","decl":"theorem top_mul' : ∞ * a = if a = 0 then 0 else ∞ := by convert WithTop.top_mul' a\n\n-- Porting note: added because `simp` no longer uses `WithTop` lemmas for `ℝ≥0∞`\n"}
{"name":"ENNReal.top_mul","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"a : ENNReal\nh : Ne a 0\n⊢ Eq (HMul.hMul Top.top a) Top.top","decl":"@[simp] theorem top_mul (h : a ≠ 0) : ∞ * a = ∞ := WithTop.top_mul h\n\n"}
{"name":"ENNReal.top_mul_top","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"⊢ Eq (HMul.hMul Top.top Top.top) Top.top","decl":"theorem top_mul_top : ∞ * ∞ = ∞ := WithTop.top_mul_top\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO: assume `n ≠ 0` instead of `0 < n`\n"}
{"name":"ENNReal.top_pow","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"n : Nat\nn_pos : LT.lt 0 n\n⊢ Eq (HPow.hPow Top.top n) Top.top","decl":"theorem top_pow {n : ℕ} (n_pos : 0 < n) : (∞ : ℝ≥0∞) ^ n = ∞ := WithTop.top_pow n_pos\n\n"}
{"name":"ENNReal.mul_eq_top","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"a b : ENNReal\n⊢ Iff (Eq (HMul.hMul a b) Top.top) (Or (And (Ne a 0) (Eq b Top.top)) (And (Eq a Top.top) (Ne b 0)))","decl":"theorem mul_eq_top : a * b = ∞ ↔ a ≠ 0 ∧ b = ∞ ∨ a = ∞ ∧ b ≠ 0 :=\n  WithTop.mul_eq_top_iff\n\n"}
{"name":"ENNReal.mul_lt_top","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"a b : ENNReal\na✝¹ : LT.lt a Top.top\na✝ : LT.lt b Top.top\n⊢ LT.lt (HMul.hMul a b) Top.top","decl":"theorem mul_lt_top : a < ∞ → b < ∞ → a * b < ∞ := WithTop.mul_lt_top\n\n-- This is unsafe because we could have `a = ∞` and `b = 0` or vice-versa\n"}
{"name":"ENNReal.mul_ne_top","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"a b : ENNReal\na✝¹ : Ne a Top.top\na✝ : Ne b Top.top\n⊢ Ne (HMul.hMul a b) Top.top","decl":"@[aesop (rule_sets := [finiteness]) unsafe 75% apply]\ntheorem mul_ne_top : a ≠ ∞ → b ≠ ∞ → a * b ≠ ∞ := WithTop.mul_ne_top\n\n"}
{"name":"ENNReal.lt_top_of_mul_ne_top_left","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"a b : ENNReal\nh : Ne (HMul.hMul a b) Top.top\nhb : Ne b 0\n⊢ LT.lt a Top.top","decl":"theorem lt_top_of_mul_ne_top_left (h : a * b ≠ ∞) (hb : b ≠ 0) : a < ∞ :=\n  lt_top_iff_ne_top.2 fun ha => h <| mul_eq_top.2 (Or.inr ⟨ha, hb⟩)\n\n"}
{"name":"ENNReal.lt_top_of_mul_ne_top_right","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"a b : ENNReal\nh : Ne (HMul.hMul a b) Top.top\nha : Ne a 0\n⊢ LT.lt b Top.top","decl":"theorem lt_top_of_mul_ne_top_right (h : a * b ≠ ∞) (ha : a ≠ 0) : b < ∞ :=\n  lt_top_of_mul_ne_top_left (by rwa [mul_comm]) ha\n\n"}
{"name":"ENNReal.mul_lt_top_iff","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"a b : ENNReal\n⊢ Iff (LT.lt (HMul.hMul a b) Top.top) (Or (And (LT.lt a Top.top) (LT.lt b Top.top)) (Or (Eq a 0) (Eq b 0)))","decl":"theorem mul_lt_top_iff {a b : ℝ≥0∞} : a * b < ∞ ↔ a < ∞ ∧ b < ∞ ∨ a = 0 ∨ b = 0 := by\n  constructor\n  · intro h\n    rw [← or_assoc, or_iff_not_imp_right, or_iff_not_imp_right]\n    intro hb ha\n    exact ⟨lt_top_of_mul_ne_top_left h.ne hb, lt_top_of_mul_ne_top_right h.ne ha⟩\n  · rintro (⟨ha, hb⟩ | rfl | rfl) <;> [exact mul_lt_top ha hb; simp; simp]\n\n"}
{"name":"ENNReal.mul_self_lt_top_iff","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"a : ENNReal\n⊢ Iff (LT.lt (HMul.hMul a a) Top.top) (LT.lt a Top.top)","decl":"theorem mul_self_lt_top_iff {a : ℝ≥0∞} : a * a < ⊤ ↔ a < ⊤ := by\n  rw [ENNReal.mul_lt_top_iff, and_self, or_self, or_iff_left_iff_imp]\n  rintro rfl\n  exact zero_lt_top\n\n"}
{"name":"ENNReal.mul_pos_iff","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"a b : ENNReal\n⊢ Iff (LT.lt 0 (HMul.hMul a b)) (And (LT.lt 0 a) (LT.lt 0 b))","decl":"theorem mul_pos_iff : 0 < a * b ↔ 0 < a ∧ 0 < b :=\n  CanonicallyOrderedAdd.mul_pos\n\n"}
{"name":"ENNReal.mul_pos","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"a b : ENNReal\nha : Ne a 0\nhb : Ne b 0\n⊢ LT.lt 0 (HMul.hMul a b)","decl":"theorem mul_pos (ha : a ≠ 0) (hb : b ≠ 0) : 0 < a * b :=\n  mul_pos_iff.2 ⟨pos_iff_ne_zero.2 ha, pos_iff_ne_zero.2 hb⟩\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO: generalize to `WithTop`\n"}
{"name":"ENNReal.pow_eq_top_iff","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"a : ENNReal\nn : Nat\n⊢ Iff (Eq (HPow.hPow a n) Top.top) (And (Eq a Top.top) (Ne n 0))","decl":"@[simp] theorem pow_eq_top_iff {n : ℕ} : a ^ n = ∞ ↔ a = ∞ ∧ n ≠ 0 := by\n  rcases n.eq_zero_or_pos with rfl | (hn : 0 < n)\n  · simp\n  · induction a\n    · simp only [Ne, hn.ne', top_pow hn, not_false_eq_true, and_self]\n    · simp only [← coe_pow, coe_ne_top, false_and]\n\n"}
{"name":"ENNReal.pow_eq_top","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"a : ENNReal\nn : Nat\nh : Eq (HPow.hPow a n) Top.top\n⊢ Eq a Top.top","decl":"theorem pow_eq_top (n : ℕ) (h : a ^ n = ∞) : a = ∞ :=\n  (pow_eq_top_iff.1 h).1\n\n"}
{"name":"ENNReal.pow_ne_top","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"a : ENNReal\nh : Ne a Top.top\nn : Nat\n⊢ Ne (HPow.hPow a n) Top.top","decl":"theorem pow_ne_top (h : a ≠ ∞) {n : ℕ} : a ^ n ≠ ∞ :=\n  mt (pow_eq_top n) h\n\n"}
{"name":"ENNReal.pow_lt_top","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"a : ENNReal\na✝ : LT.lt a Top.top\nn : Nat\n⊢ LT.lt (HPow.hPow a n) Top.top","decl":"theorem pow_lt_top : a < ∞ → ∀ n : ℕ, a ^ n < ∞ := by\n  simpa only [lt_top_iff_ne_top] using pow_ne_top\n\n"}
{"name":"ENNReal.coe_finset_sum","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"α : Type u_1\ns : Finset α\nf : α → NNReal\n⊢ Eq (↑(s.sum fun a => f a)) (s.sum fun a => ↑(f a))","decl":"@[simp, norm_cast]\ntheorem coe_finset_sum {s : Finset α} {f : α → ℝ≥0} : ↑(∑ a ∈ s, f a) = ∑ a ∈ s, (f a : ℝ≥0∞) :=\n  map_sum ofNNRealHom f s\n\n"}
{"name":"ENNReal.coe_finset_prod","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"α : Type u_1\ns : Finset α\nf : α → NNReal\n⊢ Eq (↑(s.prod fun a => f a)) (s.prod fun a => ↑(f a))","decl":"@[simp, norm_cast]\ntheorem coe_finset_prod {s : Finset α} {f : α → ℝ≥0} : ↑(∏ a ∈ s, f a) = ∏ a ∈ s, (f a : ℝ≥0∞) :=\n  map_prod ofNNRealHom f s\n\n"}
{"name":"ENNReal.add_lt_add","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"a b c d : ENNReal\nac : LT.lt a c\nbd : LT.lt b d\n⊢ LT.lt (HAdd.hAdd a b) (HAdd.hAdd c d)","decl":"@[gcongr] protected theorem add_lt_add (ac : a < c) (bd : b < d) : a + b < c + d := by\n  lift a to ℝ≥0 using ac.ne_top\n  lift b to ℝ≥0 using bd.ne_top\n  cases c; · simp\n  cases d; · simp\n  simp only [← coe_add, some_eq_coe, coe_lt_coe] at *\n  exact add_lt_add ac bd\n\n"}
{"name":"ENNReal.addLECancellable_iff_ne","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"a : ENNReal\n⊢ Iff (AddLECancellable a) (Ne a Top.top)","decl":"/-- An element `a` is `AddLECancellable` if `a + b ≤ a + c` implies `b ≤ c` for all `b` and `c`.\n  This is true in `ℝ≥0∞` for all elements except `∞`. -/\n@[simp]\ntheorem addLECancellable_iff_ne {a : ℝ≥0∞} : AddLECancellable a ↔ a ≠ ∞ := by\n  constructor\n  · rintro h rfl\n    refine zero_lt_one.not_le (h ?_)\n    simp\n  · rintro h b c hbc\n    apply ENNReal.le_of_add_le_add_left h hbc\n\n"}
{"name":"ENNReal.cancel_of_ne","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"a : ENNReal\nh : Ne a Top.top\n⊢ AddLECancellable a","decl":"/-- This lemma has an abbreviated name because it is used frequently. -/\ntheorem cancel_of_ne {a : ℝ≥0∞} (h : a ≠ ∞) : AddLECancellable a :=\n  addLECancellable_iff_ne.mpr h\n\n"}
{"name":"ENNReal.cancel_of_lt","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"a : ENNReal\nh : LT.lt a Top.top\n⊢ AddLECancellable a","decl":"/-- This lemma has an abbreviated name because it is used frequently. -/\ntheorem cancel_of_lt {a : ℝ≥0∞} (h : a < ∞) : AddLECancellable a :=\n  cancel_of_ne h.ne\n\n"}
{"name":"ENNReal.cancel_of_lt'","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"a b : ENNReal\nh : LT.lt a b\n⊢ AddLECancellable a","decl":"/-- This lemma has an abbreviated name because it is used frequently. -/\ntheorem cancel_of_lt' {a b : ℝ≥0∞} (h : a < b) : AddLECancellable a :=\n  cancel_of_ne h.ne_top\n\n"}
{"name":"ENNReal.cancel_coe","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"a : NNReal\n⊢ AddLECancellable ↑a","decl":"/-- This lemma has an abbreviated name because it is used frequently. -/\ntheorem cancel_coe {a : ℝ≥0} : AddLECancellable (a : ℝ≥0∞) :=\n  cancel_of_ne coe_ne_top\n\n"}
{"name":"ENNReal.add_right_inj","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"a b c : ENNReal\nh : Ne a Top.top\n⊢ Iff (Eq (HAdd.hAdd a b) (HAdd.hAdd a c)) (Eq b c)","decl":"theorem add_right_inj (h : a ≠ ∞) : a + b = a + c ↔ b = c :=\n  (cancel_of_ne h).inj\n\n"}
{"name":"ENNReal.add_left_inj","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"a b c : ENNReal\nh : Ne a Top.top\n⊢ Iff (Eq (HAdd.hAdd b a) (HAdd.hAdd c a)) (Eq b c)","decl":"theorem add_left_inj (h : a ≠ ∞) : b + a = c + a ↔ b = c :=\n  (cancel_of_ne h).inj_left\n\n"}
{"name":"ENNReal.sub_eq_sInf","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"a b : ENNReal\n⊢ Eq (HSub.hSub a b) (InfSet.sInf (setOf fun d => LE.le a (HAdd.hAdd d b)))","decl":"theorem sub_eq_sInf {a b : ℝ≥0∞} : a - b = sInf { d | a ≤ d + b } :=\n  le_antisymm (le_sInf fun _ h => tsub_le_iff_right.mpr h) <| sInf_le <| mem_setOf.2 le_tsub_add\n\n"}
{"name":"ENNReal.coe_sub","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"r p : NNReal\n⊢ Eq (↑(HSub.hSub r p)) (HSub.hSub ↑r ↑p)","decl":"/-- This is a special case of `WithTop.coe_sub` in the `ENNReal` namespace -/\n@[simp, norm_cast] theorem coe_sub : (↑(r - p) : ℝ≥0∞) = ↑r - ↑p := WithTop.coe_sub\n\n"}
{"name":"ENNReal.top_sub_coe","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"r : NNReal\n⊢ Eq (HSub.hSub Top.top ↑r) Top.top","decl":"/-- This is a special case of `WithTop.top_sub_coe` in the `ENNReal` namespace -/\n@[simp] theorem top_sub_coe : ∞ - ↑r = ∞ := WithTop.top_sub_coe\n\n"}
{"name":"ENNReal.top_sub","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"a : ENNReal\nha : Ne a Top.top\n⊢ Eq (HSub.hSub Top.top a) Top.top","decl":"@[simp] lemma top_sub (ha : a ≠ ∞) : ∞ - a = ∞ := by lift a to ℝ≥0 using ha; exact top_sub_coe\n\n"}
{"name":"ENNReal.sub_top","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"a : ENNReal\n⊢ Eq (HSub.hSub a Top.top) 0","decl":"/-- This is a special case of `WithTop.sub_top` in the `ENNReal` namespace -/\ntheorem sub_top : a - ∞ = 0 := WithTop.sub_top\n\n"}
{"name":"ENNReal.sub_eq_top_iff","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"a b : ENNReal\n⊢ Iff (Eq (HSub.hSub a b) Top.top) (And (Eq a Top.top) (Ne b Top.top))","decl":"@[simp] theorem sub_eq_top_iff : a - b = ∞ ↔ a = ∞ ∧ b ≠ ∞ := WithTop.sub_eq_top_iff\n"}
{"name":"ENNReal.sub_ne_top_iff","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"a b : ENNReal\n⊢ Iff (Ne (HSub.hSub a b) Top.top) (Or (Ne a Top.top) (Eq b Top.top))","decl":"lemma sub_ne_top_iff : a - b ≠ ∞ ↔ a ≠ ∞ ∨ b = ∞ := WithTop.sub_ne_top_iff\n\n-- This is unsafe because we could have `a = b = ∞`\n"}
{"name":"ENNReal.sub_ne_top","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"a b : ENNReal\nha : Ne a Top.top\n⊢ Ne (HSub.hSub a b) Top.top","decl":"@[aesop (rule_sets := [finiteness]) unsafe 75% apply]\ntheorem sub_ne_top (ha : a ≠ ∞) : a - b ≠ ∞ := mt sub_eq_top_iff.mp <| mt And.left ha\n\n"}
{"name":"ENNReal.natCast_sub","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"m n : Nat\n⊢ Eq (↑(HSub.hSub m n)) (HSub.hSub ↑m ↑n)","decl":"@[simp, norm_cast]\ntheorem natCast_sub (m n : ℕ) : ↑(m - n) = (m - n : ℝ≥0∞) := by\n  rw [← coe_natCast, Nat.cast_tsub, coe_sub, coe_natCast, coe_natCast]\n\n"}
{"name":"ENNReal.sub_eq_of_eq_add","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"a b c : ENNReal\nhb : Ne b Top.top\na✝ : Eq a (HAdd.hAdd c b)\n⊢ Eq (HSub.hSub a b) c","decl":"/-- See `ENNReal.sub_eq_of_eq_add'` for a version assuming that `a = c + b` itself is finite rather\nthan `b`. -/\nprotected theorem sub_eq_of_eq_add (hb : b ≠ ∞) : a = c + b → a - b = c :=\n  (cancel_of_ne hb).tsub_eq_of_eq_add\n\n"}
{"name":"ENNReal.sub_eq_of_eq_add'","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"a b c : ENNReal\nha : Ne a Top.top\na✝ : Eq a (HAdd.hAdd c b)\n⊢ Eq (HSub.hSub a b) c","decl":"/-- Weaker version of `ENNReal.sub_eq_of_eq_add` assuming that `a = c + b` itself is finite rather\nhan `b`. -/\nprotected lemma sub_eq_of_eq_add' (ha : a ≠ ∞) : a = c + b → a - b = c :=\n  (cancel_of_ne ha).tsub_eq_of_eq_add'\n\n"}
{"name":"ENNReal.eq_sub_of_add_eq","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"a b c : ENNReal\nhc : Ne c Top.top\na✝ : Eq (HAdd.hAdd a c) b\n⊢ Eq a (HSub.hSub b c)","decl":"/-- See `ENNReal.eq_sub_of_add_eq'` for a version assuming that `b = a + c` itself is finite rather\nthan `c`. -/\nprotected theorem eq_sub_of_add_eq (hc : c ≠ ∞) : a + c = b → a = b - c :=\n  (cancel_of_ne hc).eq_tsub_of_add_eq\n\n"}
{"name":"ENNReal.eq_sub_of_add_eq'","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"a b c : ENNReal\nhb : Ne b Top.top\na✝ : Eq (HAdd.hAdd a c) b\n⊢ Eq a (HSub.hSub b c)","decl":"/-- Weaker version of `ENNReal.eq_sub_of_add_eq` assuming that `b = a + c` itself is finite rather\nthan `c`. -/\nprotected lemma eq_sub_of_add_eq' (hb : b ≠ ∞) : a + c = b → a = b - c :=\n  (cancel_of_ne hb).eq_tsub_of_add_eq'\n\n"}
{"name":"ENNReal.sub_eq_of_eq_add_rev","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"a b c : ENNReal\nhb : Ne b Top.top\na✝ : Eq a (HAdd.hAdd b c)\n⊢ Eq (HSub.hSub a b) c","decl":"/-- See `ENNReal.sub_eq_of_eq_add_rev'` for a version assuming that `a = b + c` itself is finite\nrather than `b`. -/\nprotected theorem sub_eq_of_eq_add_rev (hb : b ≠ ∞) : a = b + c → a - b = c :=\n  (cancel_of_ne hb).tsub_eq_of_eq_add_rev\n\n"}
{"name":"ENNReal.sub_eq_of_eq_add_rev'","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"a b c : ENNReal\nha : Ne a Top.top\na✝ : Eq a (HAdd.hAdd b c)\n⊢ Eq (HSub.hSub a b) c","decl":"/-- Weaker version of `ENNReal.sub_eq_of_eq_add_rev` assuming that `a = b + c` itself is finite\nrather than `b`. -/\nprotected lemma sub_eq_of_eq_add_rev' (ha : a ≠ ∞) : a = b + c → a - b = c :=\n  (cancel_of_ne ha).tsub_eq_of_eq_add_rev'\n\n"}
{"name":"ENNReal.sub_eq_of_add_eq","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"a b c : ENNReal\nhb : Ne b Top.top\nhc : Eq (HAdd.hAdd a b) c\n⊢ Eq (HSub.hSub c b) a","decl":"@[deprecated ENNReal.sub_eq_of_eq_add (since := \"2024-09-30\")]\ntheorem sub_eq_of_add_eq (hb : b ≠ ∞) (hc : a + b = c) : c - b = a :=\n  ENNReal.sub_eq_of_eq_add hb hc.symm\n\n"}
{"name":"ENNReal.add_sub_cancel_left","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"a b : ENNReal\nha : Ne a Top.top\n⊢ Eq (HSub.hSub (HAdd.hAdd a b) a) b","decl":"@[simp]\nprotected theorem add_sub_cancel_left (ha : a ≠ ∞) : a + b - a = b :=\n  (cancel_of_ne ha).add_tsub_cancel_left\n\n"}
{"name":"ENNReal.add_sub_cancel_right","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"a b : ENNReal\nhb : Ne b Top.top\n⊢ Eq (HSub.hSub (HAdd.hAdd a b) b) a","decl":"@[simp]\nprotected theorem add_sub_cancel_right (hb : b ≠ ∞) : a + b - b = a :=\n  (cancel_of_ne hb).add_tsub_cancel_right\n\n"}
{"name":"ENNReal.sub_add_eq_add_sub","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"a b c : ENNReal\nhab : LE.le b a\nb_ne_top : Ne b Top.top\n⊢ Eq (HAdd.hAdd (HSub.hSub a b) c) (HSub.hSub (HAdd.hAdd a c) b)","decl":"protected theorem sub_add_eq_add_sub (hab : b ≤ a) (b_ne_top : b ≠ ∞) :\n    a - b + c = a + c - b := by\n  by_cases c_top : c = ∞\n  · simpa [c_top] using ENNReal.eq_sub_of_add_eq b_ne_top rfl\n  refine ENNReal.eq_sub_of_add_eq b_ne_top ?_\n  simp only [add_assoc, add_comm c b]\n  simpa only [← add_assoc] using (add_left_inj c_top).mpr <| tsub_add_cancel_of_le hab\n\n"}
{"name":"ENNReal.lt_add_of_sub_lt_left","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"a b c : ENNReal\nh : Or (Ne a Top.top) (Ne b Top.top)\na✝ : LT.lt (HSub.hSub a b) c\n⊢ LT.lt a (HAdd.hAdd b c)","decl":"protected theorem lt_add_of_sub_lt_left (h : a ≠ ∞ ∨ b ≠ ∞) : a - b < c → a < b + c := by\n  obtain rfl | hb := eq_or_ne b ∞\n  · rw [top_add, lt_top_iff_ne_top]\n    exact fun _ => h.resolve_right (Classical.not_not.2 rfl)\n  · exact (cancel_of_ne hb).lt_add_of_tsub_lt_left\n\n"}
{"name":"ENNReal.lt_add_of_sub_lt_right","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"a b c : ENNReal\nh : Or (Ne a Top.top) (Ne c Top.top)\na✝ : LT.lt (HSub.hSub a c) b\n⊢ LT.lt a (HAdd.hAdd b c)","decl":"protected theorem lt_add_of_sub_lt_right (h : a ≠ ∞ ∨ c ≠ ∞) : a - c < b → a < b + c :=\n  add_comm c b ▸ ENNReal.lt_add_of_sub_lt_left h\n\n"}
{"name":"ENNReal.le_sub_of_add_le_left","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"a b c : ENNReal\nha : Ne a Top.top\na✝ : LE.le (HAdd.hAdd a b) c\n⊢ LE.le b (HSub.hSub c a)","decl":"theorem le_sub_of_add_le_left (ha : a ≠ ∞) : a + b ≤ c → b ≤ c - a :=\n  (cancel_of_ne ha).le_tsub_of_add_le_left\n\n"}
{"name":"ENNReal.le_sub_of_add_le_right","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"a b c : ENNReal\nhb : Ne b Top.top\na✝ : LE.le (HAdd.hAdd a b) c\n⊢ LE.le a (HSub.hSub c b)","decl":"theorem le_sub_of_add_le_right (hb : b ≠ ∞) : a + b ≤ c → a ≤ c - b :=\n  (cancel_of_ne hb).le_tsub_of_add_le_right\n\n"}
{"name":"ENNReal.sub_lt_of_lt_add","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"a b c : ENNReal\nhac : LE.le c a\nh : LT.lt a (HAdd.hAdd b c)\n⊢ LT.lt (HSub.hSub a c) b","decl":"protected theorem sub_lt_of_lt_add (hac : c ≤ a) (h : a < b + c) : a - c < b :=\n  ((cancel_of_lt' <| hac.trans_lt h).tsub_lt_iff_right hac).mpr h\n\n"}
{"name":"ENNReal.sub_lt_iff_lt_right","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"a b c : ENNReal\nhb : Ne b Top.top\nhab : LE.le b a\n⊢ Iff (LT.lt (HSub.hSub a b) c) (LT.lt a (HAdd.hAdd c b))","decl":"protected theorem sub_lt_iff_lt_right (hb : b ≠ ∞) (hab : b ≤ a) : a - b < c ↔ a < c + b :=\n  (cancel_of_ne hb).tsub_lt_iff_right hab\n\n"}
{"name":"ENNReal.sub_lt_self","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"a b : ENNReal\nha : Ne a Top.top\nha₀ : Ne a 0\nhb : Ne b 0\n⊢ LT.lt (HSub.hSub a b) a","decl":"protected theorem sub_lt_self (ha : a ≠ ∞) (ha₀ : a ≠ 0) (hb : b ≠ 0) : a - b < a :=\n  (cancel_of_ne ha).tsub_lt_self (pos_iff_ne_zero.2 ha₀) (pos_iff_ne_zero.2 hb)\n\n"}
{"name":"ENNReal.sub_lt_self_iff","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"a b : ENNReal\nha : Ne a Top.top\n⊢ Iff (LT.lt (HSub.hSub a b) a) (And (LT.lt 0 a) (LT.lt 0 b))","decl":"protected theorem sub_lt_self_iff (ha : a ≠ ∞) : a - b < a ↔ 0 < a ∧ 0 < b :=\n  (cancel_of_ne ha).tsub_lt_self_iff\n\n"}
{"name":"ENNReal.sub_lt_of_sub_lt","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"a b c : ENNReal\nh₂ : LE.le c a\nh₃ : Or (Ne a Top.top) (Ne b Top.top)\nh₁ : LT.lt (HSub.hSub a b) c\n⊢ LT.lt (HSub.hSub a c) b","decl":"theorem sub_lt_of_sub_lt (h₂ : c ≤ a) (h₃ : a ≠ ∞ ∨ b ≠ ∞) (h₁ : a - b < c) : a - c < b :=\n  ENNReal.sub_lt_of_lt_add h₂ (add_comm c b ▸ ENNReal.lt_add_of_sub_lt_right h₃ h₁)\n\n"}
{"name":"ENNReal.sub_sub_cancel","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"a b : ENNReal\nh : Ne a Top.top\nh2 : LE.le b a\n⊢ Eq (HSub.hSub a (HSub.hSub a b)) b","decl":"theorem sub_sub_cancel (h : a ≠ ∞) (h2 : b ≤ a) : a - (a - b) = b :=\n  (cancel_of_ne <| sub_ne_top h).tsub_tsub_cancel_of_le h2\n\n"}
{"name":"ENNReal.sub_right_inj","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"a b c : ENNReal\nha : Ne a Top.top\nhb : LE.le b a\nhc : LE.le c a\n⊢ Iff (Eq (HSub.hSub a b) (HSub.hSub a c)) (Eq b c)","decl":"theorem sub_right_inj {a b c : ℝ≥0∞} (ha : a ≠ ∞) (hb : b ≤ a) (hc : c ≤ a) :\n    a - b = a - c ↔ b = c :=\n  (cancel_of_ne ha).tsub_right_inj (cancel_of_ne <| ne_top_of_le_ne_top ha hb)\n    (cancel_of_ne <| ne_top_of_le_ne_top ha hc) hb hc\n\n"}
{"name":"ENNReal.sub_mul","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"a b c : ENNReal\nh : LT.lt 0 b → LT.lt b a → Ne c Top.top\n⊢ Eq (HMul.hMul (HSub.hSub a b) c) (HSub.hSub (HMul.hMul a c) (HMul.hMul b c))","decl":"protected theorem sub_mul (h : 0 < b → b < a → c ≠ ∞) : (a - b) * c = a * c - b * c := by\n  rcases le_or_lt a b with hab | hab; · simp [hab, mul_right_mono hab, tsub_eq_zero_of_le]\n  rcases eq_or_lt_of_le (zero_le b) with (rfl | hb); · simp\n  exact (cancel_of_ne <| mul_ne_top hab.ne_top (h hb hab)).tsub_mul\n\n"}
{"name":"ENNReal.mul_sub","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"a b c : ENNReal\nh : LT.lt 0 c → LT.lt c b → Ne a Top.top\n⊢ Eq (HMul.hMul a (HSub.hSub b c)) (HSub.hSub (HMul.hMul a b) (HMul.hMul a c))","decl":"protected theorem mul_sub (h : 0 < c → c < b → a ≠ ∞) : a * (b - c) = a * b - a * c := by\n  simp only [mul_comm a]\n  exact ENNReal.sub_mul h\n\n"}
{"name":"ENNReal.sub_le_sub_iff_left","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"a b c : ENNReal\nh : LE.le c a\nh' : Ne a Top.top\n⊢ Iff (LE.le (HSub.hSub a b) (HSub.hSub a c)) (LE.le c b)","decl":"theorem sub_le_sub_iff_left (h : c ≤ a) (h' : a ≠ ∞) :\n    (a - b ≤ a - c) ↔ c ≤ b :=\n  (cancel_of_ne h').tsub_le_tsub_iff_left (cancel_of_ne (ne_top_of_le_ne_top h' h)) h\n\n"}
{"name":"ENNReal.prod_ne_top","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"α : Type u_1\ns : Finset α\nf : α → ENNReal\nh : ∀ (a : α), Membership.mem s a → Ne (f a) Top.top\n⊢ Ne (s.prod fun a => f a) Top.top","decl":"/-- A product of finite numbers is still finite. -/\nlemma prod_ne_top (h : ∀ a ∈ s, f a ≠ ∞) : ∏ a ∈ s, f a ≠ ∞ := WithTop.prod_ne_top h\n\n"}
{"name":"ENNReal.prod_lt_top","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"α : Type u_1\ns : Finset α\nf : α → ENNReal\nh : ∀ (a : α), Membership.mem s a → LT.lt (f a) Top.top\n⊢ LT.lt (s.prod fun a => f a) Top.top","decl":"/-- A product of finite numbers is still finite. -/\nlemma prod_lt_top (h : ∀ a ∈ s, f a < ∞) : ∏ a ∈ s, f a < ∞ := WithTop.prod_lt_top h\n\n"}
{"name":"ENNReal.sum_eq_top","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"α : Type u_1\ns : Finset α\nf : α → ENNReal\n⊢ Iff (Eq (s.sum fun x => f x) Top.top) (Exists fun a => And (Membership.mem s a) (Eq (f a) Top.top))","decl":"/-- A sum is infinite iff one of the summands is infinite. -/\n@[simp] lemma sum_eq_top : ∑ x ∈ s, f x = ∞ ↔ ∃ a ∈ s, f a = ∞ := WithTop.sum_eq_top\n\n"}
{"name":"ENNReal.sum_ne_top","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"α : Type u_1\ns : Finset α\nf : α → ENNReal\n⊢ Iff (Ne (s.sum fun a => f a) Top.top) (∀ (a : α), Membership.mem s a → Ne (f a) Top.top)","decl":"/-- A sum is finite iff all summands are finite. -/\nlemma sum_ne_top : ∑ a ∈ s, f a ≠ ∞ ↔ ∀ a ∈ s, f a ≠ ∞ := WithTop.sum_ne_top\n\n"}
{"name":"ENNReal.sum_lt_top","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"α : Type u_1\ns : Finset α\nf : α → ENNReal\n⊢ Iff (LT.lt (s.sum fun a => f a) Top.top) (∀ (a : α), Membership.mem s a → LT.lt (f a) Top.top)","decl":"/-- A sum is finite iff all summands are finite. -/\n@[simp] lemma sum_lt_top : ∑ a ∈ s, f a < ∞ ↔ ∀ a ∈ s, f a < ∞ := WithTop.sum_lt_top\n\n"}
{"name":"ENNReal.sum_lt_top_iff","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"α : Type u_1\ns : Finset α\nf : α → ENNReal\n⊢ Iff (LT.lt (s.sum fun a => f a) Top.top) (∀ (a : α), Membership.mem s a → LT.lt (f a) Top.top)","decl":"@[deprecated (since := \"2024-08-25\")] alias sum_lt_top_iff := sum_lt_top\n\n"}
{"name":"ENNReal.lt_top_of_sum_ne_top","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"α : Type u_1\ns : Finset α\nf : α → ENNReal\nh : Ne (s.sum fun x => f x) Top.top\na : α\nha : Membership.mem s a\n⊢ LT.lt (f a) Top.top","decl":"theorem lt_top_of_sum_ne_top {s : Finset α} {f : α → ℝ≥0∞} (h : ∑ x ∈ s, f x ≠ ∞) {a : α}\n    (ha : a ∈ s) : f a < ∞ :=\n  sum_lt_top.1 h.lt_top a ha\n\n"}
{"name":"ENNReal.toNNReal_sum","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"α : Type u_1\ns : Finset α\nf : α → ENNReal\nhf : ∀ (a : α), Membership.mem s a → Ne (f a) Top.top\n⊢ Eq (s.sum fun a => f a).toNNReal (s.sum fun a => (f a).toNNReal)","decl":"/-- Seeing `ℝ≥0∞` as `ℝ≥0` does not change their sum, unless one of the `ℝ≥0∞` is\ninfinity -/\ntheorem toNNReal_sum {s : Finset α} {f : α → ℝ≥0∞} (hf : ∀ a ∈ s, f a ≠ ∞) :\n    ENNReal.toNNReal (∑ a ∈ s, f a) = ∑ a ∈ s, ENNReal.toNNReal (f a) := by\n  rw [← coe_inj, coe_toNNReal, coe_finset_sum, sum_congr rfl]\n  · intro x hx\n    exact (coe_toNNReal (hf x hx)).symm\n  · exact sum_ne_top.2 hf\n\n"}
{"name":"ENNReal.toReal_sum","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"α : Type u_1\ns : Finset α\nf : α → ENNReal\nhf : ∀ (a : α), Membership.mem s a → Ne (f a) Top.top\n⊢ Eq (s.sum fun a => f a).toReal (s.sum fun a => (f a).toReal)","decl":"/-- seeing `ℝ≥0∞` as `Real` does not change their sum, unless one of the `ℝ≥0∞` is infinity -/\ntheorem toReal_sum {s : Finset α} {f : α → ℝ≥0∞} (hf : ∀ a ∈ s, f a ≠ ∞) :\n    ENNReal.toReal (∑ a ∈ s, f a) = ∑ a ∈ s, ENNReal.toReal (f a) := by\n  rw [ENNReal.toReal, toNNReal_sum hf, NNReal.coe_sum]\n  rfl\n\n"}
{"name":"ENNReal.ofReal_sum_of_nonneg","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"α : Type u_1\ns : Finset α\nf : α → Real\nhf : ∀ (i : α), Membership.mem s i → LE.le 0 (f i)\n⊢ Eq (ENNReal.ofReal (s.sum fun i => f i)) (s.sum fun i => ENNReal.ofReal (f i))","decl":"theorem ofReal_sum_of_nonneg {s : Finset α} {f : α → ℝ} (hf : ∀ i, i ∈ s → 0 ≤ f i) :\n    ENNReal.ofReal (∑ i ∈ s, f i) = ∑ i ∈ s, ENNReal.ofReal (f i) := by\n  simp_rw [ENNReal.ofReal, ← coe_finset_sum, coe_inj]\n  exact Real.toNNReal_sum_of_nonneg hf\n\n"}
{"name":"ENNReal.sum_lt_sum_of_nonempty","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"α : Type u_1\ns : Finset α\nhs : s.Nonempty\nf g : α → ENNReal\nHlt : ∀ (i : α), Membership.mem s i → LT.lt (f i) (g i)\n⊢ LT.lt (s.sum fun i => f i) (s.sum fun i => g i)","decl":"theorem sum_lt_sum_of_nonempty {s : Finset α} (hs : s.Nonempty) {f g : α → ℝ≥0∞}\n    (Hlt : ∀ i ∈ s, f i < g i) : ∑ i ∈ s, f i < ∑ i ∈ s, g i := by\n  induction hs using Finset.Nonempty.cons_induction with\n  | singleton => simp [Hlt _ (Finset.mem_singleton_self _)]\n  | cons _ _ _ _ ih =>\n    simp only [Finset.sum_cons, forall_mem_cons] at Hlt ⊢\n    exact ENNReal.add_lt_add Hlt.1 (ih Hlt.2)\n\n"}
{"name":"ENNReal.exists_le_of_sum_le","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"α : Type u_1\ns : Finset α\nhs : s.Nonempty\nf g : α → ENNReal\nHle : LE.le (s.sum fun i => f i) (s.sum fun i => g i)\n⊢ Exists fun i => And (Membership.mem s i) (LE.le (f i) (g i))","decl":"theorem exists_le_of_sum_le {s : Finset α} (hs : s.Nonempty) {f g : α → ℝ≥0∞}\n    (Hle : ∑ i ∈ s, f i ≤ ∑ i ∈ s, g i) : ∃ i ∈ s, f i ≤ g i := by\n  contrapose! Hle\n  apply ENNReal.sum_lt_sum_of_nonempty hs Hle\n\n"}
{"name":"ENNReal.Ico_eq_Iio","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"y : ENNReal\n⊢ Eq (Set.Ico 0 y) (Set.Iio y)","decl":"protected theorem Ico_eq_Iio : Ico 0 y = Iio y :=\n  Ico_bot\n\n"}
{"name":"ENNReal.mem_Iio_self_add","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"x ε : ENNReal\na✝¹ : Ne x Top.top\na✝ : Ne ε 0\n⊢ Membership.mem (Set.Iio (HAdd.hAdd x ε)) x","decl":"theorem mem_Iio_self_add : x ≠ ∞ → ε ≠ 0 → x ∈ Iio (x + ε) := fun xt ε0 => lt_add_right xt ε0\n\n"}
{"name":"ENNReal.mem_Ioo_self_sub_add","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"x ε₁ ε₂ : ENNReal\na✝³ : Ne x Top.top\na✝² : Ne x 0\na✝¹ : Ne ε₁ 0\na✝ : Ne ε₂ 0\n⊢ Membership.mem (Set.Ioo (HSub.hSub x ε₁) (HAdd.hAdd x ε₂)) x","decl":"theorem mem_Ioo_self_sub_add : x ≠ ∞ → x ≠ 0 → ε₁ ≠ 0 → ε₂ ≠ 0 → x ∈ Ioo (x - ε₁) (x + ε₂) :=\n  fun xt x0 ε0 ε0' => ⟨ENNReal.sub_lt_self xt x0 ε0, lt_add_right xt ε0'⟩\n\n"}
{"name":"ENNReal.smul_def","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"M : Type u_1\ninst✝ : MulAction ENNReal M\nc : NNReal\nx : M\n⊢ Eq (HSMul.hSMul c x) (HSMul.hSMul (↑c) x)","decl":"theorem smul_def {M : Type*} [MulAction ℝ≥0∞ M] (c : ℝ≥0) (x : M) : c • x = (c : ℝ≥0∞) • x :=\n  rfl\n\n"}
{"name":"ENNReal.instIsScalarTowerNNReal","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝³ : MulAction ENNReal M\ninst✝² : MulAction ENNReal N\ninst✝¹ : SMul M N\ninst✝ : IsScalarTower ENNReal M N\n⊢ IsScalarTower NNReal M N","decl":"instance {M N : Type*} [MulAction ℝ≥0∞ M] [MulAction ℝ≥0∞ N] [SMul M N] [IsScalarTower ℝ≥0∞ M N] :\n    IsScalarTower ℝ≥0 M N where smul_assoc r := smul_assoc (r : ℝ≥0∞)\n\n"}
{"name":"ENNReal.smulCommClass_left","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : MulAction ENNReal N\ninst✝¹ : SMul M N\ninst✝ : SMulCommClass ENNReal M N\n⊢ SMulCommClass NNReal M N","decl":"instance smulCommClass_left {M N : Type*} [MulAction ℝ≥0∞ N] [SMul M N] [SMulCommClass ℝ≥0∞ M N] :\n    SMulCommClass ℝ≥0 M N where smul_comm r := smul_comm (r : ℝ≥0∞)\n\n"}
{"name":"ENNReal.smulCommClass_right","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝² : MulAction ENNReal N\ninst✝¹ : SMul M N\ninst✝ : SMulCommClass M ENNReal N\n⊢ SMulCommClass M NNReal N","decl":"instance smulCommClass_right {M N : Type*} [MulAction ℝ≥0∞ N] [SMul M N] [SMulCommClass M ℝ≥0∞ N] :\n    SMulCommClass M ℝ≥0 N where smul_comm m r := smul_comm m (r : ℝ≥0∞)\n\n"}
{"name":"ENNReal.coe_smul","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"R : Type u_1\nr : R\ns : NNReal\ninst✝³ : SMul R NNReal\ninst✝² : SMul R ENNReal\ninst✝¹ : IsScalarTower R NNReal NNReal\ninst✝ : IsScalarTower R NNReal ENNReal\n⊢ Eq (↑(HSMul.hSMul r s)) (HSMul.hSMul r ↑s)","decl":"theorem coe_smul {R} (r : R) (s : ℝ≥0) [SMul R ℝ≥0] [SMul R ℝ≥0∞] [IsScalarTower R ℝ≥0 ℝ≥0]\n    [IsScalarTower R ℝ≥0 ℝ≥0∞] : (↑(r • s) : ℝ≥0∞) = (r : R) • (s : ℝ≥0∞) := by\n  rw [← smul_one_smul ℝ≥0 r (s : ℝ≥0∞), smul_def, smul_eq_mul, ← ENNReal.coe_mul, smul_mul_assoc,\n    one_mul]\n\n-- Porting note: added missing `DecidableEq R`\n"}
{"name":"ENNReal.smul_top","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"R : Type u_1\ninst✝⁴ : Zero R\ninst✝³ : SMulWithZero R ENNReal\ninst✝² : IsScalarTower R ENNReal ENNReal\ninst✝¹ : NoZeroSMulDivisors R ENNReal\ninst✝ : DecidableEq R\nc : R\n⊢ Eq (HSMul.hSMul c Top.top) (ite (Eq c 0) 0 Top.top)","decl":"theorem smul_top {R} [Zero R] [SMulWithZero R ℝ≥0∞] [IsScalarTower R ℝ≥0∞ ℝ≥0∞]\n    [NoZeroSMulDivisors R ℝ≥0∞] [DecidableEq R] (c : R) :\n    c • ∞ = if c = 0 then 0 else ∞ := by\n  rw [← smul_one_mul, mul_top']\n  -- Porting note: need the primed version of `one_ne_zero` now\n  simp_rw [smul_eq_zero, or_iff_left (one_ne_zero' ℝ≥0∞)]\n\n"}
{"name":"ENNReal.nnreal_smul_lt_top","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"x : NNReal\ny : ENNReal\nhy : LT.lt y Top.top\n⊢ LT.lt (HSMul.hSMul x y) Top.top","decl":"lemma nnreal_smul_lt_top {x : ℝ≥0} {y : ℝ≥0∞} (hy : y < ⊤) : x • y < ⊤ := mul_lt_top (by simp) hy\n"}
{"name":"ENNReal.nnreal_smul_ne_top","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"x : NNReal\ny : ENNReal\nhy : Ne y Top.top\n⊢ Ne (HSMul.hSMul x y) Top.top","decl":"lemma nnreal_smul_ne_top {x : ℝ≥0} {y : ℝ≥0∞} (hy : y ≠ ⊤) : x • y ≠ ⊤ := mul_ne_top (by simp) hy\n\n"}
{"name":"ENNReal.nnreal_smul_ne_top_iff","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"x : NNReal\ny : ENNReal\nhx : Ne x 0\n⊢ Iff (Ne (HSMul.hSMul x y) Top.top) (Ne y Top.top)","decl":"lemma nnreal_smul_ne_top_iff {x : ℝ≥0} {y : ℝ≥0∞} (hx : x ≠ 0) : x • y ≠ ⊤ ↔ y ≠ ⊤ :=\n  ⟨by rintro h rfl; simp [smul_top, hx] at h, nnreal_smul_ne_top⟩\n\n"}
{"name":"ENNReal.nnreal_smul_lt_top_iff","module":"Mathlib.Data.ENNReal.Operations","initialProofState":"x : NNReal\ny : ENNReal\nhx : Ne x 0\n⊢ Iff (LT.lt (HSMul.hSMul x y) Top.top) (LT.lt y Top.top)","decl":"lemma nnreal_smul_lt_top_iff {x : ℝ≥0} {y : ℝ≥0∞} (hx : x ≠ 0) : x • y < ⊤ ↔ y < ⊤ := by\n  rw [lt_top_iff_ne_top, lt_top_iff_ne_top, nnreal_smul_ne_top_iff hx]\n\n"}
