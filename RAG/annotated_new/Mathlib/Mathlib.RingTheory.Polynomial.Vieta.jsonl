{"name":"Multiset.prod_X_add_C_eq_sum_esymm","module":"Mathlib.RingTheory.Polynomial.Vieta","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\ns : Multiset R\n⊢ Eq (Multiset.map (fun r => HAdd.hAdd Polynomial.X (Polynomial.C r)) s).prod ((Finset.range (HAdd.hAdd s.card 1)).sum fun j => HMul.hMul (Polynomial.C (s.esymm j)) (HPow.hPow Polynomial.X (HSub.hSub s.card j)))","decl":"/-- A sum version of **Vieta's formula** for `Multiset`: the product of the linear terms `X + λ`\nwhere `λ` runs through a multiset `s` is equal to a linear combination of the symmetric functions\n`esymm s` of the `λ`'s . -/\ntheorem prod_X_add_C_eq_sum_esymm (s : Multiset R) :\n    (s.map fun r => X + C r).prod =\n      ∑ j ∈ Finset.range (Multiset.card s + 1), (C (s.esymm j) * X ^ (Multiset.card s - j)) := by\n  classical\n    rw [prod_map_add, antidiagonal_eq_map_powerset, map_map, ← bind_powerset_len,\n      map_bind, sum_bind, Finset.sum_eq_multiset_sum, Finset.range_val, map_congr (Eq.refl _)]\n    intro _ _\n    rw [esymm, ← sum_hom', ← sum_map_mul_right, map_congr (Eq.refl _)]\n    intro s ht\n    rw [mem_powersetCard] at ht\n    dsimp\n    rw [prod_hom' s (Polynomial.C : R →+* R[X])]\n    simp [ht, map_const, prod_replicate, prod_hom', map_id', card_sub]\n\n"}
{"name":"Multiset.prod_X_add_C_coeff","module":"Mathlib.RingTheory.Polynomial.Vieta","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\ns : Multiset R\nk : Nat\nh : LE.le k s.card\n⊢ Eq ((Multiset.map (fun r => HAdd.hAdd Polynomial.X (Polynomial.C r)) s).prod.coeff k) (s.esymm (HSub.hSub s.card k))","decl":"/-- Vieta's formula for the coefficients of the product of linear terms `X + λ` where `λ` runs\nthrough a multiset `s` : the `k`th coefficient is the symmetric function `esymm (card s - k) s`. -/\ntheorem prod_X_add_C_coeff (s : Multiset R) {k : ℕ} (h : k ≤ Multiset.card s) :\n    (s.map fun r => X + C r).prod.coeff k = s.esymm (Multiset.card s - k) := by\n  convert Polynomial.ext_iff.mp (prod_X_add_C_eq_sum_esymm s) k using 1\n  simp_rw [finset_sum_coeff, coeff_C_mul_X_pow]\n  rw [Finset.sum_eq_single_of_mem (Multiset.card s - k) _]\n  · rw [if_pos (Nat.sub_sub_self h).symm]\n  · intro j hj1 hj2\n    suffices k ≠ card s - j by rw [if_neg this]\n    intro hn\n    rw [hn, Nat.sub_sub_self (Nat.lt_succ_iff.mp (Finset.mem_range.mp hj1))] at hj2\n    exact Ne.irrefl hj2\n  · rw [Finset.mem_range]\n    exact Nat.lt_succ_of_le (Nat.sub_le (Multiset.card s) k)\n\n"}
{"name":"Multiset.prod_X_add_C_coeff'","module":"Mathlib.RingTheory.Polynomial.Vieta","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nσ : Type u_2\ns : Multiset σ\nr : σ → R\nk : Nat\nh : LE.le k s.card\n⊢ Eq ((Multiset.map (fun i => HAdd.hAdd Polynomial.X (Polynomial.C (r i))) s).prod.coeff k) ((Multiset.map r s).esymm (HSub.hSub s.card k))","decl":"theorem prod_X_add_C_coeff' {σ} (s : Multiset σ) (r : σ → R) {k : ℕ} (h : k ≤ Multiset.card s) :\n    (s.map fun i => X + C (r i)).prod.coeff k = (s.map r).esymm (Multiset.card s - k) := by\n  erw [← map_map (fun r => X + C r) r, prod_X_add_C_coeff] <;> rw [s.card_map r]; assumption\n\n"}
{"name":"Finset.prod_X_add_C_coeff","module":"Mathlib.RingTheory.Polynomial.Vieta","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nσ : Type u_2\ns : Finset σ\nr : σ → R\nk : Nat\nh : LE.le k s.card\n⊢ Eq ((s.prod fun i => HAdd.hAdd Polynomial.X (Polynomial.C (r i))).coeff k) ((Finset.powersetCard (HSub.hSub s.card k) s).sum fun t => t.prod fun i => r i)","decl":"theorem _root_.Finset.prod_X_add_C_coeff {σ} (s : Finset σ) (r : σ → R) {k : ℕ} (h : k ≤ #s) :\n    (∏ i ∈ s, (X + C (r i))).coeff k = ∑ t ∈ s.powersetCard (#s - k), ∏ i ∈ t, r i := by\n  rw [Finset.prod, prod_X_add_C_coeff' _ r h, Finset.esymm_map_val]\n  rfl\n\n"}
{"name":"Multiset.esymm_neg","module":"Mathlib.RingTheory.Polynomial.Vieta","initialProofState":"R : Type u_1\ninst✝ : CommRing R\ns : Multiset R\nk : Nat\n⊢ Eq ((Multiset.map Neg.neg s).esymm k) (HMul.hMul (HPow.hPow (-1) k) (s.esymm k))","decl":"theorem esymm_neg (s : Multiset R) (k : ℕ) : (map Neg.neg s).esymm k = (-1) ^ k * esymm s k := by\n  rw [esymm, esymm, ← Multiset.sum_map_mul_left, Multiset.powersetCard_map, Multiset.map_map,\n    map_congr rfl]\n  intro x hx\n  rw [(mem_powersetCard.mp hx).right.symm, ← prod_replicate, ← Multiset.map_const]\n  nth_rw 3 [← map_id' x]\n  rw [← prod_map_mul, map_congr rfl, Function.comp_apply]\n  exact fun z _ => neg_one_mul z\n\n"}
{"name":"Multiset.prod_X_sub_X_eq_sum_esymm","module":"Mathlib.RingTheory.Polynomial.Vieta","initialProofState":"R : Type u_1\ninst✝ : CommRing R\ns : Multiset R\n⊢ Eq (Multiset.map (fun t => HSub.hSub Polynomial.X (Polynomial.C t)) s).prod ((Finset.range (HAdd.hAdd s.card 1)).sum fun j => HMul.hMul (HPow.hPow (-1) j) (HMul.hMul (Polynomial.C (s.esymm j)) (HPow.hPow Polynomial.X (HSub.hSub s.card j))))","decl":"theorem prod_X_sub_X_eq_sum_esymm (s : Multiset R) :\n    (s.map fun t => X - C t).prod =\n      ∑ j ∈ Finset.range (Multiset.card s + 1),\n        (-1) ^ j * (C (s.esymm j) * X ^ (Multiset.card s - j)) := by\n  conv_lhs =>\n    congr\n    congr\n    ext x\n    rw [sub_eq_add_neg]\n    rw [← map_neg C x]\n  convert prod_X_add_C_eq_sum_esymm (map (fun t => -t) s) using 1\n  · rw [map_map]; rfl\n  · simp only [esymm_neg, card_map, mul_assoc, map_mul, map_pow, map_neg, map_one]\n\n"}
{"name":"Multiset.prod_X_sub_C_coeff","module":"Mathlib.RingTheory.Polynomial.Vieta","initialProofState":"R : Type u_1\ninst✝ : CommRing R\ns : Multiset R\nk : Nat\nh : LE.le k s.card\n⊢ Eq ((Multiset.map (fun t => HSub.hSub Polynomial.X (Polynomial.C t)) s).prod.coeff k) (HMul.hMul (HPow.hPow (-1) (HSub.hSub s.card k)) (s.esymm (HSub.hSub s.card k)))","decl":"theorem prod_X_sub_C_coeff (s : Multiset R) {k : ℕ} (h : k ≤ Multiset.card s) :\n    (s.map fun t => X - C t).prod.coeff k =\n    (-1) ^ (Multiset.card s - k) * s.esymm (Multiset.card s - k) := by\n  conv_lhs =>\n    congr\n    congr\n    congr\n    ext x\n    rw [sub_eq_add_neg]\n    rw [← map_neg C x]\n  convert prod_X_add_C_coeff (map (fun t => -t) s) _ using 1\n  · rw [map_map]; rfl\n  · rw [esymm_neg, card_map]\n  · rwa [card_map]\n\n"}
{"name":"Polynomial.coeff_eq_esymm_roots_of_card","module":"Mathlib.RingTheory.Polynomial.Vieta","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\np : Polynomial R\nhroots : Eq p.roots.card p.natDegree\nk : Nat\nh : LE.le k p.natDegree\n⊢ Eq (p.coeff k) (HMul.hMul (HMul.hMul p.leadingCoeff (HPow.hPow (-1) (HSub.hSub p.natDegree k))) (p.roots.esymm (HSub.hSub p.natDegree k)))","decl":"/-- Vieta's formula for the coefficients and the roots of a polynomial over an integral domain\n  with as many roots as its degree. -/\ntheorem _root_.Polynomial.coeff_eq_esymm_roots_of_card [IsDomain R] {p : R[X]}\n    (hroots : Multiset.card p.roots = p.natDegree) {k : ℕ} (h : k ≤ p.natDegree) :\n    p.coeff k = p.leadingCoeff * (-1) ^ (p.natDegree - k) * p.roots.esymm (p.natDegree - k) := by\n  conv_lhs => rw [← C_leadingCoeff_mul_prod_multiset_X_sub_C hroots]\n  rw [coeff_C_mul, mul_assoc]; congr\n  have : k ≤ card (roots p) := by rw [hroots]; exact h\n  convert p.roots.prod_X_sub_C_coeff this using 3 <;> rw [hroots]\n\n"}
{"name":"Polynomial.coeff_eq_esymm_roots_of_splits","module":"Mathlib.RingTheory.Polynomial.Vieta","initialProofState":"F : Type u_2\ninst✝ : Field F\np : Polynomial F\nhsplit : Polynomial.Splits (RingHom.id F) p\nk : Nat\nh : LE.le k p.natDegree\n⊢ Eq (p.coeff k) (HMul.hMul (HMul.hMul p.leadingCoeff (HPow.hPow (-1) (HSub.hSub p.natDegree k))) (p.roots.esymm (HSub.hSub p.natDegree k)))","decl":"/-- Vieta's formula for split polynomials over a field. -/\ntheorem _root_.Polynomial.coeff_eq_esymm_roots_of_splits {F} [Field F] {p : F[X]}\n    (hsplit : p.Splits (RingHom.id F)) {k : ℕ} (h : k ≤ p.natDegree) :\n    p.coeff k = p.leadingCoeff * (-1) ^ (p.natDegree - k) * p.roots.esymm (p.natDegree - k) :=\n  Polynomial.coeff_eq_esymm_roots_of_card (splits_iff_card_roots.1 hsplit) h\n\n"}
{"name":"MvPolynomial.prod_C_add_X_eq_sum_esymm","module":"Mathlib.RingTheory.Polynomial.Vieta","initialProofState":"R : Type u_1\nσ : Type u_2\ninst✝¹ : CommSemiring R\ninst✝ : Fintype σ\n⊢ Eq (Finset.univ.prod fun i => HAdd.hAdd Polynomial.X (Polynomial.C (MvPolynomial.X i))) ((Finset.range (HAdd.hAdd (Fintype.card σ) 1)).sum fun j => HMul.hMul (Polynomial.C (MvPolynomial.esymm σ R j)) (HPow.hPow Polynomial.X (HSub.hSub (Fintype.card σ) j)))","decl":"/-- A sum version of Vieta's formula for `MvPolynomial`: viewing `X i` as variables,\nthe product of linear terms `λ + X i` is equal to a linear combination of\nthe symmetric polynomials `esymm σ R j`. -/\ntheorem MvPolynomial.prod_C_add_X_eq_sum_esymm :\n    (∏ i : σ, (Polynomial.X + Polynomial.C (MvPolynomial.X i))) =\n      ∑ j ∈ range (card σ + 1), Polynomial.C\n        (MvPolynomial.esymm σ R j) * Polynomial.X ^ (card σ - j) := by\n  let s := Finset.univ.val.map fun i : σ => (MvPolynomial.X i : MvPolynomial σ R)\n  have : Fintype.card σ = Multiset.card s := by\n    rw [Multiset.card_map, ← Finset.card_univ, Finset.card_def]\n  simp_rw [this, MvPolynomial.esymm_eq_multiset_esymm σ R, Finset.prod_eq_multiset_prod]\n  convert Multiset.prod_X_add_C_eq_sum_esymm s\n  simp_rw [s, Multiset.map_map, Function.comp_apply]\n\n"}
{"name":"MvPolynomial.prod_X_add_C_coeff","module":"Mathlib.RingTheory.Polynomial.Vieta","initialProofState":"R : Type u_1\nσ : Type u_2\ninst✝¹ : CommSemiring R\ninst✝ : Fintype σ\nk : Nat\nh : LE.le k (Fintype.card σ)\n⊢ Eq ((Finset.univ.prod fun i => HAdd.hAdd Polynomial.X (Polynomial.C (MvPolynomial.X i))).coeff k) (MvPolynomial.esymm σ R (HSub.hSub (Fintype.card σ) k))","decl":"theorem MvPolynomial.prod_X_add_C_coeff (k : ℕ) (h : k ≤ card σ) :\n    (∏ i : σ, (Polynomial.X + Polynomial.C (MvPolynomial.X i)) : Polynomial _).coeff k =\n    MvPolynomial.esymm σ R (card σ - k) := by\n  let s := Finset.univ.val.map fun i => (MvPolynomial.X i : MvPolynomial σ R)\n  have : Fintype.card σ = Multiset.card s := by\n    rw [Multiset.card_map, ← Finset.card_univ, Finset.card_def]\n  rw [this] at h ⊢\n  rw [MvPolynomial.esymm_eq_multiset_esymm σ R, Finset.prod_eq_multiset_prod]\n  convert Multiset.prod_X_add_C_coeff s h\n  dsimp\n  simp_rw [s, Multiset.map_map, Function.comp_apply]\n\n"}
