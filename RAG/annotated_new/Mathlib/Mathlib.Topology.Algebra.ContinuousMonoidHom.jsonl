{"name":"ContinuousAddMonoidHom.mk.inj","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"A : Type u_7\nB : Type u_8\ninst✝³ : AddMonoid A\ninst✝² : AddMonoid B\ninst✝¹ : TopologicalSpace A\ninst✝ : TopologicalSpace B\ntoAddMonoidHom✝ : AddMonoidHom A B\ncontinuous_toFun✝ : autoParam (Continuous (↑toAddMonoidHom✝).toFun) _auto✝\ntoAddMonoidHom : AddMonoidHom A B\ncontinuous_toFun : autoParam (Continuous (↑toAddMonoidHom).toFun) _auto✝\nx✝ : Eq { toAddMonoidHom := toAddMonoidHom✝, continuous_toFun := continuous_toFun✝ } { toAddMonoidHom := toAddMonoidHom, continuous_toFun := continuous_toFun }\n⊢ Eq toAddMonoidHom✝ toAddMonoidHom","decl":"/-- The type of continuous additive monoid homomorphisms from `A` to `B`.\n\nWhen possible, instead of parametrizing results over `(f : ContinuousAddMonoidHom A B)`,\nyou should parametrize\nover `(F : Type*) [FunLike F A B] [ContinuousMapClass F A B] [AddMonoidHomClass F A B] (f : F)`.\n\nWhen you extend this structure,\nmake sure to extend `ContinuousMapClass` and/or `AddMonoidHomClass`, if needed. -/\nstructure ContinuousAddMonoidHom (A B : Type*) [AddMonoid A] [AddMonoid B] [TopologicalSpace A]\n  [TopologicalSpace B] extends A →+ B, C(A, B)\n\n"}
{"name":"ContinuousAddMonoidHom.continuous_toFun","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"A : Type u_7\nB : Type u_8\ninst✝³ : AddMonoid A\ninst✝² : AddMonoid B\ninst✝¹ : TopologicalSpace A\ninst✝ : TopologicalSpace B\nself : ContinuousAddMonoidHom A B\n⊢ Continuous (↑self.toAddMonoidHom).toFun","decl":"/-- The type of continuous additive monoid homomorphisms from `A` to `B`.\n\nWhen possible, instead of parametrizing results over `(f : ContinuousAddMonoidHom A B)`,\nyou should parametrize\nover `(F : Type*) [FunLike F A B] [ContinuousMapClass F A B] [AddMonoidHomClass F A B] (f : F)`.\n\nWhen you extend this structure,\nmake sure to extend `ContinuousMapClass` and/or `AddMonoidHomClass`, if needed. -/\nstructure ContinuousAddMonoidHom (A B : Type*) [AddMonoid A] [AddMonoid B] [TopologicalSpace A]\n  [TopologicalSpace B] extends A →+ B, C(A, B)\n\n"}
{"name":"ContinuousAddMonoidHom.mk.sizeOf_spec","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"A : Type u_7\nB : Type u_8\ninst✝⁵ : AddMonoid A\ninst✝⁴ : AddMonoid B\ninst✝³ : TopologicalSpace A\ninst✝² : TopologicalSpace B\ninst✝¹ : SizeOf A\ninst✝ : SizeOf B\ntoAddMonoidHom : AddMonoidHom A B\ncontinuous_toFun : autoParam (Continuous (↑toAddMonoidHom).toFun) _auto✝\n⊢ Eq (SizeOf.sizeOf { toAddMonoidHom := toAddMonoidHom, continuous_toFun := continuous_toFun }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf toAddMonoidHom)) (SizeOf.sizeOf continuous_toFun))","decl":"/-- The type of continuous additive monoid homomorphisms from `A` to `B`.\n\nWhen possible, instead of parametrizing results over `(f : ContinuousAddMonoidHom A B)`,\nyou should parametrize\nover `(F : Type*) [FunLike F A B] [ContinuousMapClass F A B] [AddMonoidHomClass F A B] (f : F)`.\n\nWhen you extend this structure,\nmake sure to extend `ContinuousMapClass` and/or `AddMonoidHomClass`, if needed. -/\nstructure ContinuousAddMonoidHom (A B : Type*) [AddMonoid A] [AddMonoid B] [TopologicalSpace A]\n  [TopologicalSpace B] extends A →+ B, C(A, B)\n\n"}
{"name":"ContinuousAddMonoidHom.mk.injEq","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"A : Type u_7\nB : Type u_8\ninst✝³ : AddMonoid A\ninst✝² : AddMonoid B\ninst✝¹ : TopologicalSpace A\ninst✝ : TopologicalSpace B\ntoAddMonoidHom✝ : AddMonoidHom A B\ncontinuous_toFun✝ : autoParam (Continuous (↑toAddMonoidHom✝).toFun) _auto✝\ntoAddMonoidHom : AddMonoidHom A B\ncontinuous_toFun : autoParam (Continuous (↑toAddMonoidHom).toFun) _auto✝\n⊢ Eq (Eq { toAddMonoidHom := toAddMonoidHom✝, continuous_toFun := continuous_toFun✝ } { toAddMonoidHom := toAddMonoidHom, continuous_toFun := continuous_toFun }) (Eq toAddMonoidHom✝ toAddMonoidHom)","decl":"/-- The type of continuous additive monoid homomorphisms from `A` to `B`.\n\nWhen possible, instead of parametrizing results over `(f : ContinuousAddMonoidHom A B)`,\nyou should parametrize\nover `(F : Type*) [FunLike F A B] [ContinuousMapClass F A B] [AddMonoidHomClass F A B] (f : F)`.\n\nWhen you extend this structure,\nmake sure to extend `ContinuousMapClass` and/or `AddMonoidHomClass`, if needed. -/\nstructure ContinuousAddMonoidHom (A B : Type*) [AddMonoid A] [AddMonoid B] [TopologicalSpace A]\n  [TopologicalSpace B] extends A →+ B, C(A, B)\n\n"}
{"name":"ContinuousMonoidHom.mk.injEq","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"A : Type u_2\nB : Type u_3\ninst✝³ : Monoid A\ninst✝² : Monoid B\ninst✝¹ : TopologicalSpace A\ninst✝ : TopologicalSpace B\ntoMonoidHom✝ : MonoidHom A B\ncontinuous_toFun✝ : autoParam (Continuous (↑toMonoidHom✝).toFun) _auto✝\ntoMonoidHom : MonoidHom A B\ncontinuous_toFun : autoParam (Continuous (↑toMonoidHom).toFun) _auto✝\n⊢ Eq (Eq { toMonoidHom := toMonoidHom✝, continuous_toFun := continuous_toFun✝ } { toMonoidHom := toMonoidHom, continuous_toFun := continuous_toFun }) (Eq toMonoidHom✝ toMonoidHom)","decl":"/-- The type of continuous monoid homomorphisms from `A` to `B`.\n\nWhen possible, instead of parametrizing results over `(f : ContinuousMonoidHom A B)`,\nyou should parametrize\nover `(F : Type*) [FunLike F A B] [ContinuousMapClass F A B] [MonoidHomClass F A B] (f : F)`.\n\nWhen you extend this structure,\nmake sure to extend `ContinuousMapClass` and/or `MonoidHomClass`, if needed. -/\n@[to_additive \"The type of continuous additive monoid homomorphisms from `A` to `B`.\"]\nstructure ContinuousMonoidHom extends A →* B, C(A, B)\n\n"}
{"name":"ContinuousMonoidHom.mk.inj","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"A : Type u_2\nB : Type u_3\ninst✝³ : Monoid A\ninst✝² : Monoid B\ninst✝¹ : TopologicalSpace A\ninst✝ : TopologicalSpace B\ntoMonoidHom✝ : MonoidHom A B\ncontinuous_toFun✝ : autoParam (Continuous (↑toMonoidHom✝).toFun) _auto✝\ntoMonoidHom : MonoidHom A B\ncontinuous_toFun : autoParam (Continuous (↑toMonoidHom).toFun) _auto✝\nx✝ : Eq { toMonoidHom := toMonoidHom✝, continuous_toFun := continuous_toFun✝ } { toMonoidHom := toMonoidHom, continuous_toFun := continuous_toFun }\n⊢ Eq toMonoidHom✝ toMonoidHom","decl":"/-- The type of continuous monoid homomorphisms from `A` to `B`.\n\nWhen possible, instead of parametrizing results over `(f : ContinuousMonoidHom A B)`,\nyou should parametrize\nover `(F : Type*) [FunLike F A B] [ContinuousMapClass F A B] [MonoidHomClass F A B] (f : F)`.\n\nWhen you extend this structure,\nmake sure to extend `ContinuousMapClass` and/or `MonoidHomClass`, if needed. -/\n@[to_additive \"The type of continuous additive monoid homomorphisms from `A` to `B`.\"]\nstructure ContinuousMonoidHom extends A →* B, C(A, B)\n\n"}
{"name":"ContinuousMonoidHom.mk.sizeOf_spec","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"A : Type u_2\nB : Type u_3\ninst✝⁵ : Monoid A\ninst✝⁴ : Monoid B\ninst✝³ : TopologicalSpace A\ninst✝² : TopologicalSpace B\ninst✝¹ : SizeOf A\ninst✝ : SizeOf B\ntoMonoidHom : MonoidHom A B\ncontinuous_toFun : autoParam (Continuous (↑toMonoidHom).toFun) _auto✝\n⊢ Eq (SizeOf.sizeOf { toMonoidHom := toMonoidHom, continuous_toFun := continuous_toFun }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf toMonoidHom)) (SizeOf.sizeOf continuous_toFun))","decl":"/-- The type of continuous monoid homomorphisms from `A` to `B`.\n\nWhen possible, instead of parametrizing results over `(f : ContinuousMonoidHom A B)`,\nyou should parametrize\nover `(F : Type*) [FunLike F A B] [ContinuousMapClass F A B] [MonoidHomClass F A B] (f : F)`.\n\nWhen you extend this structure,\nmake sure to extend `ContinuousMapClass` and/or `MonoidHomClass`, if needed. -/\n@[to_additive \"The type of continuous additive monoid homomorphisms from `A` to `B`.\"]\nstructure ContinuousMonoidHom extends A →* B, C(A, B)\n\n"}
{"name":"ContinuousMonoidHom.continuous_toFun","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"A : Type u_2\nB : Type u_3\ninst✝³ : Monoid A\ninst✝² : Monoid B\ninst✝¹ : TopologicalSpace A\ninst✝ : TopologicalSpace B\nself : ContinuousMonoidHom A B\n⊢ Continuous (↑self.toMonoidHom).toFun","decl":"/-- The type of continuous monoid homomorphisms from `A` to `B`.\n\nWhen possible, instead of parametrizing results over `(f : ContinuousMonoidHom A B)`,\nyou should parametrize\nover `(F : Type*) [FunLike F A B] [ContinuousMapClass F A B] [MonoidHomClass F A B] (f : F)`.\n\nWhen you extend this structure,\nmake sure to extend `ContinuousMapClass` and/or `MonoidHomClass`, if needed. -/\n@[to_additive \"The type of continuous additive monoid homomorphisms from `A` to `B`.\"]\nstructure ContinuousMonoidHom extends A →* B, C(A, B)\n\n"}
{"name":"ContinuousAddMonoidHomClass.toAddMonoidHomClass","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"F : Type u_1\nA : outParam (Type u_7)\nB : outParam (Type u_8)\ninst✝⁴ : AddMonoid A\ninst✝³ : AddMonoid B\ninst✝² : TopologicalSpace A\ninst✝¹ : TopologicalSpace B\ninst✝ : FunLike F A B\nself : ContinuousAddMonoidHomClass F A B\n⊢ AddMonoidHomClass F A B","decl":"/-- `ContinuousAddMonoidHomClass F A B` states that `F` is a type of continuous additive monoid\nhomomorphisms.\n\nDeprecated and changed from a `class` to a `structure`.\nUse `[AddMonoidHomClass F A B] [ContinuousMapClass F A B]` instead. -/\nstructure ContinuousAddMonoidHomClass (A B : outParam Type*) [AddMonoid A] [AddMonoid B]\n    [TopologicalSpace A] [TopologicalSpace B] [FunLike F A B]\n    extends AddMonoidHomClass F A B, ContinuousMapClass F A B : Prop\n\n"}
{"name":"ContinuousAddMonoidHomClass.toContinuousMapClass","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"F : Type u_1\nA : outParam (Type u_7)\nB : outParam (Type u_8)\ninst✝⁴ : AddMonoid A\ninst✝³ : AddMonoid B\ninst✝² : TopologicalSpace A\ninst✝¹ : TopologicalSpace B\ninst✝ : FunLike F A B\nself : ContinuousAddMonoidHomClass F A B\n⊢ ContinuousMapClass F A B","decl":"/-- `ContinuousAddMonoidHomClass F A B` states that `F` is a type of continuous additive monoid\nhomomorphisms.\n\nDeprecated and changed from a `class` to a `structure`.\nUse `[AddMonoidHomClass F A B] [ContinuousMapClass F A B]` instead. -/\nstructure ContinuousAddMonoidHomClass (A B : outParam Type*) [AddMonoid A] [AddMonoid B]\n    [TopologicalSpace A] [TopologicalSpace B] [FunLike F A B]\n    extends AddMonoidHomClass F A B, ContinuousMapClass F A B : Prop\n\n"}
{"name":"ContinuousMonoidHomClass.toContinuousMapClass","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"F : Type u_1\nA : outParam (Type u_7)\nB : outParam (Type u_8)\ninst✝⁴ : Monoid A\ninst✝³ : Monoid B\ninst✝² : TopologicalSpace A\ninst✝¹ : TopologicalSpace B\ninst✝ : FunLike F A B\nself : ContinuousMonoidHomClass F A B\n⊢ ContinuousMapClass F A B","decl":"/-- `ContinuousMonoidHomClass F A B` states that `F` is a type of continuous monoid\nhomomorphisms.\n\nDeprecated and changed from a `class` to a `structure`.\nUse `[MonoidHomClass F A B] [ContinuousMapClass F A B]` instead. -/\n@[to_additive (attr := deprecated \"Use `[MonoidHomClass F A B] [ContinuousMapClass F A B]` instead.\"\n  (since := \"2024-10-08\"))]\nstructure ContinuousMonoidHomClass (A B : outParam Type*) [Monoid A] [Monoid B]\n    [TopologicalSpace A] [TopologicalSpace B] [FunLike F A B]\n    extends MonoidHomClass F A B, ContinuousMapClass F A B : Prop\n\n"}
{"name":"ContinuousMonoidHomClass.toMonoidHomClass","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"F : Type u_1\nA : outParam (Type u_7)\nB : outParam (Type u_8)\ninst✝⁴ : Monoid A\ninst✝³ : Monoid B\ninst✝² : TopologicalSpace A\ninst✝¹ : TopologicalSpace B\ninst✝ : FunLike F A B\nself : ContinuousMonoidHomClass F A B\n⊢ MonoidHomClass F A B","decl":"/-- `ContinuousMonoidHomClass F A B` states that `F` is a type of continuous monoid\nhomomorphisms.\n\nDeprecated and changed from a `class` to a `structure`.\nUse `[MonoidHomClass F A B] [ContinuousMapClass F A B]` instead. -/\n@[to_additive (attr := deprecated \"Use `[MonoidHomClass F A B] [ContinuousMapClass F A B]` instead.\"\n  (since := \"2024-10-08\"))]\nstructure ContinuousMonoidHomClass (A B : outParam Type*) [Monoid A] [Monoid B]\n    [TopologicalSpace A] [TopologicalSpace B] [FunLike F A B]\n    extends MonoidHomClass F A B, ContinuousMapClass F A B : Prop\n\n"}
{"name":"ContinuousMonoidHom.instMonoidHomClass","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"A : Type u_2\nB : Type u_3\ninst✝³ : Monoid A\ninst✝² : Monoid B\ninst✝¹ : TopologicalSpace A\ninst✝ : TopologicalSpace B\n⊢ MonoidHomClass (ContinuousMonoidHom A B) A B","decl":"@[to_additive]\ninstance instMonoidHomClass : MonoidHomClass (ContinuousMonoidHom A B) A B where\n  map_mul f := f.map_mul'\n  map_one f := f.map_one'\n\n"}
{"name":"ContinuousAddMonoidHom.instAddMonoidHomClass","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"A : Type u_2\nB : Type u_3\ninst✝³ : AddMonoid A\ninst✝² : AddMonoid B\ninst✝¹ : TopologicalSpace A\ninst✝ : TopologicalSpace B\n⊢ AddMonoidHomClass (ContinuousAddMonoidHom A B) A B","decl":"@[to_additive]\ninstance instMonoidHomClass : MonoidHomClass (ContinuousMonoidHom A B) A B where\n  map_mul f := f.map_mul'\n  map_one f := f.map_one'\n\n"}
{"name":"ContinuousMonoidHom.instContinuousMapClass","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"A : Type u_2\nB : Type u_3\ninst✝³ : Monoid A\ninst✝² : Monoid B\ninst✝¹ : TopologicalSpace A\ninst✝ : TopologicalSpace B\n⊢ ContinuousMapClass (ContinuousMonoidHom A B) A B","decl":"@[to_additive]\ninstance instContinuousMapClass : ContinuousMapClass (ContinuousMonoidHom A B) A B where\n  map_continuous f := f.continuous_toFun\n\n"}
{"name":"ContinuousAddMonoidHom.instContinuousMapClass","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"A : Type u_2\nB : Type u_3\ninst✝³ : AddMonoid A\ninst✝² : AddMonoid B\ninst✝¹ : TopologicalSpace A\ninst✝ : TopologicalSpace B\n⊢ ContinuousMapClass (ContinuousAddMonoidHom A B) A B","decl":"@[to_additive]\ninstance instContinuousMapClass : ContinuousMapClass (ContinuousMonoidHom A B) A B where\n  map_continuous f := f.continuous_toFun\n\n"}
{"name":"ContinuousAddMonoidHom.coe_toAddMonoidHom","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"A : Type u_2\nB : Type u_3\ninst✝³ : AddMonoid A\ninst✝² : AddMonoid B\ninst✝¹ : TopologicalSpace A\ninst✝ : TopologicalSpace B\nf : ContinuousAddMonoidHom A B\n⊢ Eq f.toAddMonoidHom ↑f","decl":"@[to_additive (attr := simp)]\nlemma coe_toMonoidHom (f : ContinuousMonoidHom A B) : f.toMonoidHom = f := rfl\n\n"}
{"name":"ContinuousMonoidHom.coe_toMonoidHom","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"A : Type u_2\nB : Type u_3\ninst✝³ : Monoid A\ninst✝² : Monoid B\ninst✝¹ : TopologicalSpace A\ninst✝ : TopologicalSpace B\nf : ContinuousMonoidHom A B\n⊢ Eq f.toMonoidHom ↑f","decl":"@[to_additive (attr := simp)]\nlemma coe_toMonoidHom (f : ContinuousMonoidHom A B) : f.toMonoidHom = f := rfl\n\n"}
{"name":"ContinuousMonoidHom.coe_toContinuousMap","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"A : Type u_2\nB : Type u_3\ninst✝³ : Monoid A\ninst✝² : Monoid B\ninst✝¹ : TopologicalSpace A\ninst✝ : TopologicalSpace B\nf : ContinuousMonoidHom A B\n⊢ Eq f.toContinuousMap ↑f","decl":"@[to_additive (attr := simp)]\nlemma coe_toContinuousMap (f : ContinuousMonoidHom A B) : f.toContinuousMap = f := rfl\n\n"}
{"name":"ContinuousAddMonoidHom.coe_toContinuousMap","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"A : Type u_2\nB : Type u_3\ninst✝³ : AddMonoid A\ninst✝² : AddMonoid B\ninst✝¹ : TopologicalSpace A\ninst✝ : TopologicalSpace B\nf : ContinuousAddMonoidHom A B\n⊢ Eq f.toContinuousMap ↑f","decl":"@[to_additive (attr := simp)]\nlemma coe_toContinuousMap (f : ContinuousMonoidHom A B) : f.toContinuousMap = f := rfl\n\n"}
{"name":"ContinuousAddMonoidHom.coe_coe","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"A : Type u_7\nB : Type u_8\ninst✝⁶ : AddMonoid A\ninst✝⁵ : AddMonoid B\ninst✝⁴ : TopologicalSpace A\ninst✝³ : TopologicalSpace B\nF : Type u_9\ninst✝² : FunLike F A B\ninst✝¹ : AddMonoidHomClass F A B\ninst✝ : ContinuousMapClass F A B\nf : F\n⊢ Eq ⇑↑f ⇑f","decl":"@[to_additive (attr := simp)]\nlemma coe_coe [MonoidHomClass F A B] [ContinuousMapClass F A B] (f : F) :\n    ⇑(f : ContinuousMonoidHom A B) = f := rfl\n\n"}
{"name":"ContinuousMonoidHom.coe_coe","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"A : Type u_7\nB : Type u_8\ninst✝⁶ : Monoid A\ninst✝⁵ : Monoid B\ninst✝⁴ : TopologicalSpace A\ninst✝³ : TopologicalSpace B\nF : Type u_9\ninst✝² : FunLike F A B\ninst✝¹ : MonoidHomClass F A B\ninst✝ : ContinuousMapClass F A B\nf : F\n⊢ Eq ⇑↑f ⇑f","decl":"@[to_additive (attr := simp)]\nlemma coe_coe [MonoidHomClass F A B] [ContinuousMapClass F A B] (f : F) :\n    ⇑(f : ContinuousMonoidHom A B) = f := rfl\n\n"}
{"name":"ContinuousAddMonoidHom.toAddMonoidHom_toContinuousAddMonoidHom","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"A : Type u_7\nB : Type u_8\ninst✝⁶ : AddMonoid A\ninst✝⁵ : AddMonoid B\ninst✝⁴ : TopologicalSpace A\ninst✝³ : TopologicalSpace B\nF : Type u_9\ninst✝² : FunLike F A B\ninst✝¹ : AddMonoidHomClass F A B\ninst✝ : ContinuousMapClass F A B\nf : F\n⊢ Eq ↑↑f ↑f","decl":"@[to_additive (attr := simp, norm_cast)]\nlemma toMonoidHom_toContinuousMonoidHom [MonoidHomClass F A B] [ContinuousMapClass F A B] (f : F) :\n    ((f : ContinuousMonoidHom A B) : A →* B) = f := rfl\n\n"}
{"name":"ContinuousMonoidHom.toMonoidHom_toContinuousMonoidHom","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"A : Type u_7\nB : Type u_8\ninst✝⁶ : Monoid A\ninst✝⁵ : Monoid B\ninst✝⁴ : TopologicalSpace A\ninst✝³ : TopologicalSpace B\nF : Type u_9\ninst✝² : FunLike F A B\ninst✝¹ : MonoidHomClass F A B\ninst✝ : ContinuousMapClass F A B\nf : F\n⊢ Eq ↑↑f ↑f","decl":"@[to_additive (attr := simp, norm_cast)]\nlemma toMonoidHom_toContinuousMonoidHom [MonoidHomClass F A B] [ContinuousMapClass F A B] (f : F) :\n    ((f : ContinuousMonoidHom A B) : A →* B) = f := rfl\n\n"}
{"name":"ContinuousAddMonoidHom.toContinuousMap_toContinuousAddMonoidHom","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"A : Type u_7\nB : Type u_8\ninst✝⁶ : AddMonoid A\ninst✝⁵ : AddMonoid B\ninst✝⁴ : TopologicalSpace A\ninst✝³ : TopologicalSpace B\nF : Type u_9\ninst✝² : FunLike F A B\ninst✝¹ : AddMonoidHomClass F A B\ninst✝ : ContinuousMapClass F A B\nf : F\n⊢ Eq ↑↑f ↑f","decl":"@[to_additive (attr := simp, norm_cast)]\nlemma toContinuousMap_toContinuousMonoidHom [MonoidHomClass F A B] [ContinuousMapClass F A B]\n    (f : F) : ((f : ContinuousMonoidHom A B) : C(A, B)) = f := rfl\n\n"}
{"name":"ContinuousMonoidHom.toContinuousMap_toContinuousMonoidHom","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"A : Type u_7\nB : Type u_8\ninst✝⁶ : Monoid A\ninst✝⁵ : Monoid B\ninst✝⁴ : TopologicalSpace A\ninst✝³ : TopologicalSpace B\nF : Type u_9\ninst✝² : FunLike F A B\ninst✝¹ : MonoidHomClass F A B\ninst✝ : ContinuousMapClass F A B\nf : F\n⊢ Eq ↑↑f ↑f","decl":"@[to_additive (attr := simp, norm_cast)]\nlemma toContinuousMap_toContinuousMonoidHom [MonoidHomClass F A B] [ContinuousMapClass F A B]\n    (f : F) : ((f : ContinuousMonoidHom A B) : C(A, B)) = f := rfl\n\n"}
{"name":"ContinuousMonoidHom.ext","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"A : Type u_2\nB : Type u_3\ninst✝³ : Monoid A\ninst✝² : Monoid B\ninst✝¹ : TopologicalSpace A\ninst✝ : TopologicalSpace B\nf g : ContinuousMonoidHom A B\nh : ∀ (x : A), Eq (f x) (g x)\n⊢ Eq f g","decl":"@[to_additive (attr := ext)]\ntheorem ext {f g : ContinuousMonoidHom A B} (h : ∀ x, f x = g x) : f = g :=\n  DFunLike.ext _ _ h\n\n"}
{"name":"ContinuousAddMonoidHom.ext","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"A : Type u_2\nB : Type u_3\ninst✝³ : AddMonoid A\ninst✝² : AddMonoid B\ninst✝¹ : TopologicalSpace A\ninst✝ : TopologicalSpace B\nf g : ContinuousAddMonoidHom A B\nh : ∀ (x : A), Eq (f x) (g x)\n⊢ Eq f g","decl":"@[to_additive (attr := ext)]\ntheorem ext {f g : ContinuousMonoidHom A B} (h : ∀ x, f x = g x) : f = g :=\n  DFunLike.ext _ _ h\n\n"}
{"name":"ContinuousMonoidHom.ext_iff","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"A : Type u_2\nB : Type u_3\ninst✝³ : Monoid A\ninst✝² : Monoid B\ninst✝¹ : TopologicalSpace A\ninst✝ : TopologicalSpace B\nf g : ContinuousMonoidHom A B\n⊢ Iff (Eq f g) (∀ (x : A), Eq (f x) (g x))","decl":"@[to_additive (attr := ext)]\ntheorem ext {f g : ContinuousMonoidHom A B} (h : ∀ x, f x = g x) : f = g :=\n  DFunLike.ext _ _ h\n\n"}
{"name":"ContinuousAddMonoidHom.ext_iff","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"A : Type u_2\nB : Type u_3\ninst✝³ : AddMonoid A\ninst✝² : AddMonoid B\ninst✝¹ : TopologicalSpace A\ninst✝ : TopologicalSpace B\nf g : ContinuousAddMonoidHom A B\n⊢ Iff (Eq f g) (∀ (x : A), Eq (f x) (g x))","decl":"@[to_additive (attr := ext)]\ntheorem ext {f g : ContinuousMonoidHom A B} (h : ∀ x, f x = g x) : f = g :=\n  DFunLike.ext _ _ h\n\n"}
{"name":"ContinuousAddMonoidHom.toContinuousMap_injective","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"A : Type u_2\nB : Type u_3\ninst✝³ : AddMonoid A\ninst✝² : AddMonoid B\ninst✝¹ : TopologicalSpace A\ninst✝ : TopologicalSpace B\n⊢ Function.Injective ContinuousAddMonoidHom.toContinuousMap","decl":"@[to_additive]\ntheorem toContinuousMap_injective : Injective (toContinuousMap : _ → C(A, B)) := fun f g h =>\n  ext <| by convert DFunLike.ext_iff.1 h\n\n"}
{"name":"ContinuousMonoidHom.toContinuousMap_injective","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"A : Type u_2\nB : Type u_3\ninst✝³ : Monoid A\ninst✝² : Monoid B\ninst✝¹ : TopologicalSpace A\ninst✝ : TopologicalSpace B\n⊢ Function.Injective ContinuousMonoidHom.toContinuousMap","decl":"@[to_additive]\ntheorem toContinuousMap_injective : Injective (toContinuousMap : _ → C(A, B)) := fun f g h =>\n  ext <| by convert DFunLike.ext_iff.1 h\n\n"}
{"name":"ContinuousAddMonoidHom.comp_toFun","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"A : Type u_2\nB : Type u_3\nC : Type u_4\ninst✝⁵ : AddMonoid A\ninst✝⁴ : AddMonoid B\ninst✝³ : AddMonoid C\ninst✝² : TopologicalSpace A\ninst✝¹ : TopologicalSpace B\ninst✝ : TopologicalSpace C\ng : ContinuousAddMonoidHom B C\nf : ContinuousAddMonoidHom A B\na✝ : A\n⊢ Eq ((g.comp f) a✝) (g (f a✝))","decl":"/-- Composition of two continuous homomorphisms. -/\n@[to_additive (attr := simps!) \"Composition of two continuous homomorphisms.\"]\ndef comp (g : ContinuousMonoidHom B C) (f : ContinuousMonoidHom A B) : ContinuousMonoidHom A C :=\n  ⟨g.toMonoidHom.comp f.toMonoidHom, (map_continuous g).comp (map_continuous f)⟩\n\n"}
{"name":"ContinuousMonoidHom.comp_toFun","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"A : Type u_2\nB : Type u_3\nC : Type u_4\ninst✝⁵ : Monoid A\ninst✝⁴ : Monoid B\ninst✝³ : Monoid C\ninst✝² : TopologicalSpace A\ninst✝¹ : TopologicalSpace B\ninst✝ : TopologicalSpace C\ng : ContinuousMonoidHom B C\nf : ContinuousMonoidHom A B\na✝ : A\n⊢ Eq ((g.comp f) a✝) (g (f a✝))","decl":"/-- Composition of two continuous homomorphisms. -/\n@[to_additive (attr := simps!) \"Composition of two continuous homomorphisms.\"]\ndef comp (g : ContinuousMonoidHom B C) (f : ContinuousMonoidHom A B) : ContinuousMonoidHom A C :=\n  ⟨g.toMonoidHom.comp f.toMonoidHom, (map_continuous g).comp (map_continuous f)⟩\n\n"}
{"name":"ContinuousMonoidHom.coe_comp","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"A : Type u_2\nB : Type u_3\nC : Type u_4\ninst✝⁵ : Monoid A\ninst✝⁴ : Monoid B\ninst✝³ : Monoid C\ninst✝² : TopologicalSpace A\ninst✝¹ : TopologicalSpace B\ninst✝ : TopologicalSpace C\ng : ContinuousMonoidHom B C\nf : ContinuousMonoidHom A B\n⊢ Eq (⇑(g.comp f)) (Function.comp ⇑g ⇑f)","decl":"@[to_additive (attr := simp)]\nlemma coe_comp (g : ContinuousMonoidHom B C) (f : ContinuousMonoidHom A B) :\n    ⇑(g.comp f) = ⇑g ∘ ⇑f := rfl\n\n"}
{"name":"ContinuousAddMonoidHom.coe_comp","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"A : Type u_2\nB : Type u_3\nC : Type u_4\ninst✝⁵ : AddMonoid A\ninst✝⁴ : AddMonoid B\ninst✝³ : AddMonoid C\ninst✝² : TopologicalSpace A\ninst✝¹ : TopologicalSpace B\ninst✝ : TopologicalSpace C\ng : ContinuousAddMonoidHom B C\nf : ContinuousAddMonoidHom A B\n⊢ Eq (⇑(g.comp f)) (Function.comp ⇑g ⇑f)","decl":"@[to_additive (attr := simp)]\nlemma coe_comp (g : ContinuousMonoidHom B C) (f : ContinuousMonoidHom A B) :\n    ⇑(g.comp f) = ⇑g ∘ ⇑f := rfl\n\n"}
{"name":"ContinuousMonoidHom.prod_toFun","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"A : Type u_2\nB : Type u_3\nC : Type u_4\ninst✝⁵ : Monoid A\ninst✝⁴ : Monoid B\ninst✝³ : Monoid C\ninst✝² : TopologicalSpace A\ninst✝¹ : TopologicalSpace B\ninst✝ : TopologicalSpace C\nf : ContinuousMonoidHom A B\ng : ContinuousMonoidHom A C\ni : A\n⊢ Eq ((f.prod g) i) { fst := f i, snd := g i }","decl":"/-- Product of two continuous homomorphisms on the same space. -/\n@[to_additive (attr := simps!) prod \"Product of two continuous homomorphisms on the same space.\"]\ndef prod (f : ContinuousMonoidHom A B) (g : ContinuousMonoidHom A C) :\n    ContinuousMonoidHom A (B × C) :=\n  ⟨f.toMonoidHom.prod g.toMonoidHom, f.continuous_toFun.prod_mk g.continuous_toFun⟩\n\n"}
{"name":"ContinuousAddMonoidHom.prod_toFun","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"A : Type u_2\nB : Type u_3\nC : Type u_4\ninst✝⁵ : AddMonoid A\ninst✝⁴ : AddMonoid B\ninst✝³ : AddMonoid C\ninst✝² : TopologicalSpace A\ninst✝¹ : TopologicalSpace B\ninst✝ : TopologicalSpace C\nf : ContinuousAddMonoidHom A B\ng : ContinuousAddMonoidHom A C\ni : A\n⊢ Eq ((f.prod g) i) { fst := f i, snd := g i }","decl":"/-- Product of two continuous homomorphisms on the same space. -/\n@[to_additive (attr := simps!) prod \"Product of two continuous homomorphisms on the same space.\"]\ndef prod (f : ContinuousMonoidHom A B) (g : ContinuousMonoidHom A C) :\n    ContinuousMonoidHom A (B × C) :=\n  ⟨f.toMonoidHom.prod g.toMonoidHom, f.continuous_toFun.prod_mk g.continuous_toFun⟩\n\n"}
{"name":"ContinuousMonoidHom.prodMap_toFun","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"A : Type u_2\nB : Type u_3\nC : Type u_4\nD : Type u_5\ninst✝⁷ : Monoid A\ninst✝⁶ : Monoid B\ninst✝⁵ : Monoid C\ninst✝⁴ : Monoid D\ninst✝³ : TopologicalSpace A\ninst✝² : TopologicalSpace B\ninst✝¹ : TopologicalSpace C\ninst✝ : TopologicalSpace D\nf : ContinuousMonoidHom A C\ng : ContinuousMonoidHom B D\ni : Prod A B\n⊢ Eq ((f.prodMap g) i) { fst := f i.1, snd := g i.2 }","decl":"/-- Product of two continuous homomorphisms on different spaces. -/\n@[to_additive (attr := simps!) prodMap\n  \"Product of two continuous homomorphisms on different spaces.\"]\ndef prodMap (f : ContinuousMonoidHom A C) (g : ContinuousMonoidHom B D) :\n    ContinuousMonoidHom (A × B) (C × D) :=\n  ⟨f.toMonoidHom.prodMap g.toMonoidHom, f.continuous_toFun.prodMap g.continuous_toFun⟩\n\n"}
{"name":"ContinuousAddMonoidHom.prodMap_toFun","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"A : Type u_2\nB : Type u_3\nC : Type u_4\nD : Type u_5\ninst✝⁷ : AddMonoid A\ninst✝⁶ : AddMonoid B\ninst✝⁵ : AddMonoid C\ninst✝⁴ : AddMonoid D\ninst✝³ : TopologicalSpace A\ninst✝² : TopologicalSpace B\ninst✝¹ : TopologicalSpace C\ninst✝ : TopologicalSpace D\nf : ContinuousAddMonoidHom A C\ng : ContinuousAddMonoidHom B D\ni : Prod A B\n⊢ Eq ((f.prodMap g) i) { fst := f i.1, snd := g i.2 }","decl":"/-- Product of two continuous homomorphisms on different spaces. -/\n@[to_additive (attr := simps!) prodMap\n  \"Product of two continuous homomorphisms on different spaces.\"]\ndef prodMap (f : ContinuousMonoidHom A C) (g : ContinuousMonoidHom B D) :\n    ContinuousMonoidHom (A × B) (C × D) :=\n  ⟨f.toMonoidHom.prodMap g.toMonoidHom, f.continuous_toFun.prodMap g.continuous_toFun⟩\n\n"}
{"name":"ContinuousMonoidHom.one_toFun","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"A : Type u_2\nB : Type u_3\ninst✝³ : Monoid A\ninst✝² : Monoid B\ninst✝¹ : TopologicalSpace A\ninst✝ : TopologicalSpace B\nx✝ : A\n⊢ Eq ((ContinuousMonoidHom.one A B) x✝) 1","decl":"/-- The trivial continuous homomorphism. -/\n@[to_additive (attr := simps!) \"The trivial continuous homomorphism.\"]\ndef one : ContinuousMonoidHom A B :=\n  ⟨1, continuous_const⟩\n\n"}
{"name":"ContinuousAddMonoidHom.zero_toFun","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"A : Type u_2\nB : Type u_3\ninst✝³ : AddMonoid A\ninst✝² : AddMonoid B\ninst✝¹ : TopologicalSpace A\ninst✝ : TopologicalSpace B\nx✝ : A\n⊢ Eq ((ContinuousAddMonoidHom.zero A B) x✝) 0","decl":"/-- The trivial continuous homomorphism. -/\n@[to_additive (attr := simps!) \"The trivial continuous homomorphism.\"]\ndef one : ContinuousMonoidHom A B :=\n  ⟨1, continuous_const⟩\n\n"}
{"name":"ContinuousAddMonoidHom.id_toFun","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"A : Type u_2\ninst✝¹ : AddMonoid A\ninst✝ : TopologicalSpace A\nx : A\n⊢ Eq ((ContinuousAddMonoidHom.id A) x) x","decl":"/-- The identity continuous homomorphism. -/\n@[to_additive (attr := simps!) \"The identity continuous homomorphism.\"]\ndef id : ContinuousMonoidHom A A :=\n  ⟨.id A, continuous_id⟩\n\n"}
{"name":"ContinuousMonoidHom.id_toFun","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"A : Type u_2\ninst✝¹ : Monoid A\ninst✝ : TopologicalSpace A\nx : A\n⊢ Eq ((ContinuousMonoidHom.id A) x) x","decl":"/-- The identity continuous homomorphism. -/\n@[to_additive (attr := simps!) \"The identity continuous homomorphism.\"]\ndef id : ContinuousMonoidHom A A :=\n  ⟨.id A, continuous_id⟩\n\n"}
{"name":"ContinuousAddMonoidHom.coe_id","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"A : Type u_2\ninst✝¹ : AddMonoid A\ninst✝ : TopologicalSpace A\n⊢ Eq (⇑(ContinuousAddMonoidHom.id A)) id","decl":"@[to_additive (attr := simp)]\nlemma coe_id : ⇑(ContinuousMonoidHom.id A) = _root_.id :=\n  rfl\n\n"}
{"name":"ContinuousMonoidHom.coe_id","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"A : Type u_2\ninst✝¹ : Monoid A\ninst✝ : TopologicalSpace A\n⊢ Eq (⇑(ContinuousMonoidHom.id A)) id","decl":"@[to_additive (attr := simp)]\nlemma coe_id : ⇑(ContinuousMonoidHom.id A) = _root_.id :=\n  rfl\n\n"}
{"name":"ContinuousMonoidHom.fst_toFun","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"A : Type u_2\nB : Type u_3\ninst✝³ : Monoid A\ninst✝² : Monoid B\ninst✝¹ : TopologicalSpace A\ninst✝ : TopologicalSpace B\nself : Prod A B\n⊢ Eq ((ContinuousMonoidHom.fst A B) self) self.1","decl":"/-- The continuous homomorphism given by projection onto the first factor. -/\n@[to_additive (attr := simps!)\n  \"The continuous homomorphism given by projection onto the first factor.\"]\ndef fst : ContinuousMonoidHom (A × B) A :=\n  ⟨MonoidHom.fst A B, continuous_fst⟩\n\n"}
{"name":"ContinuousAddMonoidHom.fst_toFun","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"A : Type u_2\nB : Type u_3\ninst✝³ : AddMonoid A\ninst✝² : AddMonoid B\ninst✝¹ : TopologicalSpace A\ninst✝ : TopologicalSpace B\nself : Prod A B\n⊢ Eq ((ContinuousAddMonoidHom.fst A B) self) self.1","decl":"/-- The continuous homomorphism given by projection onto the first factor. -/\n@[to_additive (attr := simps!)\n  \"The continuous homomorphism given by projection onto the first factor.\"]\ndef fst : ContinuousMonoidHom (A × B) A :=\n  ⟨MonoidHom.fst A B, continuous_fst⟩\n\n"}
{"name":"ContinuousMonoidHom.snd_toFun","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"A : Type u_2\nB : Type u_3\ninst✝³ : Monoid A\ninst✝² : Monoid B\ninst✝¹ : TopologicalSpace A\ninst✝ : TopologicalSpace B\nself : Prod A B\n⊢ Eq ((ContinuousMonoidHom.snd A B) self) self.2","decl":"/-- The continuous homomorphism given by projection onto the second factor. -/\n@[to_additive (attr := simps!)\n  \"The continuous homomorphism given by projection onto the second factor.\"]\ndef snd : ContinuousMonoidHom (A × B) B :=\n  ⟨MonoidHom.snd A B, continuous_snd⟩\n\n"}
{"name":"ContinuousAddMonoidHom.snd_toFun","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"A : Type u_2\nB : Type u_3\ninst✝³ : AddMonoid A\ninst✝² : AddMonoid B\ninst✝¹ : TopologicalSpace A\ninst✝ : TopologicalSpace B\nself : Prod A B\n⊢ Eq ((ContinuousAddMonoidHom.snd A B) self) self.2","decl":"/-- The continuous homomorphism given by projection onto the second factor. -/\n@[to_additive (attr := simps!)\n  \"The continuous homomorphism given by projection onto the second factor.\"]\ndef snd : ContinuousMonoidHom (A × B) B :=\n  ⟨MonoidHom.snd A B, continuous_snd⟩\n\n"}
{"name":"ContinuousMonoidHom.inl_toFun","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"A : Type u_2\nB : Type u_3\ninst✝³ : Monoid A\ninst✝² : Monoid B\ninst✝¹ : TopologicalSpace A\ninst✝ : TopologicalSpace B\ni : A\n⊢ Eq ((ContinuousMonoidHom.inl A B) i) { fst := i, snd := 1 }","decl":"/-- The continuous homomorphism given by inclusion of the first factor. -/\n@[to_additive (attr := simps!)\n  \"The continuous homomorphism given by inclusion of the first factor.\"]\ndef inl : ContinuousMonoidHom A (A × B) :=\n  prod (id A) (one A B)\n\n"}
{"name":"ContinuousAddMonoidHom.inl_toFun","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"A : Type u_2\nB : Type u_3\ninst✝³ : AddMonoid A\ninst✝² : AddMonoid B\ninst✝¹ : TopologicalSpace A\ninst✝ : TopologicalSpace B\ni : A\n⊢ Eq ((ContinuousAddMonoidHom.inl A B) i) { fst := i, snd := 0 }","decl":"/-- The continuous homomorphism given by inclusion of the first factor. -/\n@[to_additive (attr := simps!)\n  \"The continuous homomorphism given by inclusion of the first factor.\"]\ndef inl : ContinuousMonoidHom A (A × B) :=\n  prod (id A) (one A B)\n\n"}
{"name":"ContinuousAddMonoidHom.inr_toFun","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"A : Type u_2\nB : Type u_3\ninst✝³ : AddMonoid A\ninst✝² : AddMonoid B\ninst✝¹ : TopologicalSpace A\ninst✝ : TopologicalSpace B\ni : B\n⊢ Eq ((ContinuousAddMonoidHom.inr A B) i) { fst := 0, snd := i }","decl":"/-- The continuous homomorphism given by inclusion of the second factor. -/\n@[to_additive (attr := simps!)\n  \"The continuous homomorphism given by inclusion of the second factor.\"]\ndef inr : ContinuousMonoidHom B (A × B) :=\n  prod (one B A) (id B)\n\n"}
{"name":"ContinuousMonoidHom.inr_toFun","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"A : Type u_2\nB : Type u_3\ninst✝³ : Monoid A\ninst✝² : Monoid B\ninst✝¹ : TopologicalSpace A\ninst✝ : TopologicalSpace B\ni : B\n⊢ Eq ((ContinuousMonoidHom.inr A B) i) { fst := 1, snd := i }","decl":"/-- The continuous homomorphism given by inclusion of the second factor. -/\n@[to_additive (attr := simps!)\n  \"The continuous homomorphism given by inclusion of the second factor.\"]\ndef inr : ContinuousMonoidHom B (A × B) :=\n  prod (one B A) (id B)\n\n"}
{"name":"ContinuousAddMonoidHom.diag_toFun","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"A : Type u_2\ninst✝¹ : AddMonoid A\ninst✝ : TopologicalSpace A\ni : A\n⊢ Eq ((ContinuousAddMonoidHom.diag A) i) { fst := i, snd := i }","decl":"/-- The continuous homomorphism given by the diagonal embedding. -/\n@[to_additive (attr := simps!) \"The continuous homomorphism given by the diagonal embedding.\"]\ndef diag : ContinuousMonoidHom A (A × A) :=\n  prod (id A) (id A)\n\n"}
{"name":"ContinuousMonoidHom.diag_toFun","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"A : Type u_2\ninst✝¹ : Monoid A\ninst✝ : TopologicalSpace A\ni : A\n⊢ Eq ((ContinuousMonoidHom.diag A) i) { fst := i, snd := i }","decl":"/-- The continuous homomorphism given by the diagonal embedding. -/\n@[to_additive (attr := simps!) \"The continuous homomorphism given by the diagonal embedding.\"]\ndef diag : ContinuousMonoidHom A (A × A) :=\n  prod (id A) (id A)\n\n"}
{"name":"ContinuousMonoidHom.swap_toFun","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"A : Type u_2\nB : Type u_3\ninst✝³ : Monoid A\ninst✝² : Monoid B\ninst✝¹ : TopologicalSpace A\ninst✝ : TopologicalSpace B\ni : Prod A B\n⊢ Eq ((ContinuousMonoidHom.swap A B) i) { fst := i.2, snd := i.1 }","decl":"/-- The continuous homomorphism given by swapping components. -/\n@[to_additive (attr := simps!) \"The continuous homomorphism given by swapping components.\"]\ndef swap : ContinuousMonoidHom (A × B) (B × A) :=\n  prod (snd A B) (fst A B)\n\n"}
{"name":"ContinuousAddMonoidHom.swap_toFun","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"A : Type u_2\nB : Type u_3\ninst✝³ : AddMonoid A\ninst✝² : AddMonoid B\ninst✝¹ : TopologicalSpace A\ninst✝ : TopologicalSpace B\ni : Prod A B\n⊢ Eq ((ContinuousAddMonoidHom.swap A B) i) { fst := i.2, snd := i.1 }","decl":"/-- The continuous homomorphism given by swapping components. -/\n@[to_additive (attr := simps!) \"The continuous homomorphism given by swapping components.\"]\ndef swap : ContinuousMonoidHom (A × B) (B × A) :=\n  prod (snd A B) (fst A B)\n\n"}
{"name":"ContinuousMonoidHom.mul_toFun","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"E : Type u_6\ninst✝² : CommGroup E\ninst✝¹ : TopologicalSpace E\ninst✝ : TopologicalGroup E\na✝ : Prod E E\n⊢ Eq ((ContinuousMonoidHom.mul E) a✝) (HMul.hMul a✝.1 a✝.2)","decl":"/-- The continuous homomorphism given by multiplication. -/\n@[to_additive (attr := simps!) \"The continuous homomorphism given by addition.\"]\ndef mul : ContinuousMonoidHom (E × E) E :=\n  ⟨mulMonoidHom, continuous_mul⟩\n\n"}
{"name":"ContinuousAddMonoidHom.add_toFun","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"E : Type u_6\ninst✝² : AddCommGroup E\ninst✝¹ : TopologicalSpace E\ninst✝ : TopologicalAddGroup E\na✝ : Prod E E\n⊢ Eq ((ContinuousAddMonoidHom.add E) a✝) (HAdd.hAdd a✝.1 a✝.2)","decl":"/-- The continuous homomorphism given by multiplication. -/\n@[to_additive (attr := simps!) \"The continuous homomorphism given by addition.\"]\ndef mul : ContinuousMonoidHom (E × E) E :=\n  ⟨mulMonoidHom, continuous_mul⟩\n\n"}
{"name":"ContinuousMonoidHom.inv_toFun","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"E : Type u_6\ninst✝² : CommGroup E\ninst✝¹ : TopologicalSpace E\ninst✝ : TopologicalGroup E\na✝ : E\n⊢ Eq ((ContinuousMonoidHom.inv E) a✝) (Inv.inv a✝)","decl":"/-- The continuous homomorphism given by inversion. -/\n@[to_additive (attr := simps!) \"The continuous homomorphism given by negation.\"]\ndef inv : ContinuousMonoidHom E E :=\n  ⟨invMonoidHom, continuous_inv⟩\n\n"}
{"name":"ContinuousAddMonoidHom.neg_toFun","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"E : Type u_6\ninst✝² : AddCommGroup E\ninst✝¹ : TopologicalSpace E\ninst✝ : TopologicalAddGroup E\na✝ : E\n⊢ Eq ((ContinuousAddMonoidHom.neg E) a✝) (Neg.neg a✝)","decl":"/-- The continuous homomorphism given by inversion. -/\n@[to_additive (attr := simps!) \"The continuous homomorphism given by negation.\"]\ndef inv : ContinuousMonoidHom E E :=\n  ⟨invMonoidHom, continuous_inv⟩\n\n"}
{"name":"ContinuousAddMonoidHom.coprod_toFun","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"A : Type u_2\nB : Type u_3\nE : Type u_6\ninst✝⁶ : AddMonoid A\ninst✝⁵ : AddMonoid B\ninst✝⁴ : AddCommGroup E\ninst✝³ : TopologicalSpace A\ninst✝² : TopologicalSpace B\ninst✝¹ : TopologicalSpace E\ninst✝ : TopologicalAddGroup E\nf : ContinuousAddMonoidHom A E\ng : ContinuousAddMonoidHom B E\na✝ : Prod A B\n⊢ Eq ((f.coprod g) a✝) (HAdd.hAdd (f a✝.1) (g a✝.2))","decl":"/-- Coproduct of two continuous homomorphisms to the same space. -/\n@[to_additive (attr := simps!) \"Coproduct of two continuous homomorphisms to the same space.\"]\ndef coprod (f : ContinuousMonoidHom A E) (g : ContinuousMonoidHom B E) :\n    ContinuousMonoidHom (A × B) E :=\n  (mul E).comp (f.prodMap g)\n\n"}
{"name":"ContinuousMonoidHom.coprod_toFun","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"A : Type u_2\nB : Type u_3\nE : Type u_6\ninst✝⁶ : Monoid A\ninst✝⁵ : Monoid B\ninst✝⁴ : CommGroup E\ninst✝³ : TopologicalSpace A\ninst✝² : TopologicalSpace B\ninst✝¹ : TopologicalSpace E\ninst✝ : TopologicalGroup E\nf : ContinuousMonoidHom A E\ng : ContinuousMonoidHom B E\na✝ : Prod A B\n⊢ Eq ((f.coprod g) a✝) (HMul.hMul (f a✝.1) (g a✝.2))","decl":"/-- Coproduct of two continuous homomorphisms to the same space. -/\n@[to_additive (attr := simps!) \"Coproduct of two continuous homomorphisms to the same space.\"]\ndef coprod (f : ContinuousMonoidHom A E) (g : ContinuousMonoidHom B E) :\n    ContinuousMonoidHom (A × B) E :=\n  (mul E).comp (f.prodMap g)\n\n"}
{"name":"ContinuousAddMonoidHom.isInducing_toContinuousMap","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"A : Type u_2\nB : Type u_3\ninst✝³ : AddMonoid A\ninst✝² : AddMonoid B\ninst✝¹ : TopologicalSpace A\ninst✝ : TopologicalSpace B\n⊢ Topology.IsInducing ContinuousAddMonoidHom.toContinuousMap","decl":"@[to_additive]\ntheorem isInducing_toContinuousMap :\n    IsInducing (toContinuousMap : ContinuousMonoidHom A B → C(A, B)) := ⟨rfl⟩\n\n"}
{"name":"ContinuousMonoidHom.isInducing_toContinuousMap","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"A : Type u_2\nB : Type u_3\ninst✝³ : Monoid A\ninst✝² : Monoid B\ninst✝¹ : TopologicalSpace A\ninst✝ : TopologicalSpace B\n⊢ Topology.IsInducing ContinuousMonoidHom.toContinuousMap","decl":"@[to_additive]\ntheorem isInducing_toContinuousMap :\n    IsInducing (toContinuousMap : ContinuousMonoidHom A B → C(A, B)) := ⟨rfl⟩\n\n"}
{"name":"ContinuousMonoidHom.inducing_toContinuousMap","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"A : Type u_2\nB : Type u_3\ninst✝³ : Monoid A\ninst✝² : Monoid B\ninst✝¹ : TopologicalSpace A\ninst✝ : TopologicalSpace B\n⊢ Topology.IsInducing ContinuousMonoidHom.toContinuousMap","decl":"@[deprecated (since := \"2024-10-28\")] alias inducing_toContinuousMap := isInducing_toContinuousMap\n\n"}
{"name":"ContinuousMonoidHom.isEmbedding_toContinuousMap","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"A : Type u_2\nB : Type u_3\ninst✝³ : Monoid A\ninst✝² : Monoid B\ninst✝¹ : TopologicalSpace A\ninst✝ : TopologicalSpace B\n⊢ Topology.IsEmbedding ContinuousMonoidHom.toContinuousMap","decl":"@[to_additive]\ntheorem isEmbedding_toContinuousMap :\n    IsEmbedding (toContinuousMap : ContinuousMonoidHom A B → C(A, B)) :=\n  ⟨isInducing_toContinuousMap A B, toContinuousMap_injective⟩\n\n"}
{"name":"ContinuousAddMonoidHom.isEmbedding_toContinuousMap","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"A : Type u_2\nB : Type u_3\ninst✝³ : AddMonoid A\ninst✝² : AddMonoid B\ninst✝¹ : TopologicalSpace A\ninst✝ : TopologicalSpace B\n⊢ Topology.IsEmbedding ContinuousAddMonoidHom.toContinuousMap","decl":"@[to_additive]\ntheorem isEmbedding_toContinuousMap :\n    IsEmbedding (toContinuousMap : ContinuousMonoidHom A B → C(A, B)) :=\n  ⟨isInducing_toContinuousMap A B, toContinuousMap_injective⟩\n\n"}
{"name":"ContinuousMonoidHom.embedding_toContinuousMap","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"A : Type u_2\nB : Type u_3\ninst✝³ : Monoid A\ninst✝² : Monoid B\ninst✝¹ : TopologicalSpace A\ninst✝ : TopologicalSpace B\n⊢ Topology.IsEmbedding ContinuousMonoidHom.toContinuousMap","decl":"@[deprecated (since := \"2024-10-26\")]\nalias embedding_toContinuousMap := isEmbedding_toContinuousMap\n\n"}
{"name":"ContinuousAddMonoidHom.instContinuousEvalConst","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"A : Type u_2\nB : Type u_3\ninst✝³ : AddMonoid A\ninst✝² : AddMonoid B\ninst✝¹ : TopologicalSpace A\ninst✝ : TopologicalSpace B\n⊢ ContinuousEvalConst (ContinuousAddMonoidHom A B) A B","decl":"@[to_additive]\ninstance instContinuousEvalConst : ContinuousEvalConst (ContinuousMonoidHom A B) A B :=\n  .of_continuous_forget (isInducing_toContinuousMap A B).continuous\n\n"}
{"name":"ContinuousMonoidHom.instContinuousEvalConst","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"A : Type u_2\nB : Type u_3\ninst✝³ : Monoid A\ninst✝² : Monoid B\ninst✝¹ : TopologicalSpace A\ninst✝ : TopologicalSpace B\n⊢ ContinuousEvalConst (ContinuousMonoidHom A B) A B","decl":"@[to_additive]\ninstance instContinuousEvalConst : ContinuousEvalConst (ContinuousMonoidHom A B) A B :=\n  .of_continuous_forget (isInducing_toContinuousMap A B).continuous\n\n"}
{"name":"ContinuousAddMonoidHom.instContinuousEval","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"A : Type u_2\nB : Type u_3\ninst✝⁴ : AddMonoid A\ninst✝³ : AddMonoid B\ninst✝² : TopologicalSpace A\ninst✝¹ : TopologicalSpace B\ninst✝ : LocallyCompactPair A B\n⊢ ContinuousEval (ContinuousAddMonoidHom A B) A B","decl":"@[to_additive]\ninstance instContinuousEval [LocallyCompactPair A B] :\n    ContinuousEval (ContinuousMonoidHom A B) A B :=\n  .of_continuous_forget (isInducing_toContinuousMap A B).continuous\n\n"}
{"name":"ContinuousMonoidHom.instContinuousEval","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"A : Type u_2\nB : Type u_3\ninst✝⁴ : Monoid A\ninst✝³ : Monoid B\ninst✝² : TopologicalSpace A\ninst✝¹ : TopologicalSpace B\ninst✝ : LocallyCompactPair A B\n⊢ ContinuousEval (ContinuousMonoidHom A B) A B","decl":"@[to_additive]\ninstance instContinuousEval [LocallyCompactPair A B] :\n    ContinuousEval (ContinuousMonoidHom A B) A B :=\n  .of_continuous_forget (isInducing_toContinuousMap A B).continuous\n\n"}
{"name":"ContinuousMonoidHom.range_toContinuousMap","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"A : Type u_2\nB : Type u_3\ninst✝³ : Monoid A\ninst✝² : Monoid B\ninst✝¹ : TopologicalSpace A\ninst✝ : TopologicalSpace B\n⊢ Eq (Set.range ContinuousMonoidHom.toContinuousMap) (setOf fun f => And (Eq (f 1) 1) (∀ (x y : A), Eq (f (HMul.hMul x y)) (HMul.hMul (f x) (f y))))","decl":"@[to_additive]\nlemma range_toContinuousMap :\n    Set.range (toContinuousMap : ContinuousMonoidHom A B → C(A, B)) =\n      {f : C(A, B) | f 1 = 1 ∧ ∀ x y, f (x * y) = f x * f y} := by\n  refine Set.Subset.antisymm (Set.range_subset_iff.2 fun f ↦ ⟨map_one f, map_mul f⟩) ?_\n  rintro f ⟨h1, hmul⟩\n  exact ⟨{ f with map_one' := h1, map_mul' := hmul }, rfl⟩\n\n"}
{"name":"ContinuousAddMonoidHom.range_toContinuousMap","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"A : Type u_2\nB : Type u_3\ninst✝³ : AddMonoid A\ninst✝² : AddMonoid B\ninst✝¹ : TopologicalSpace A\ninst✝ : TopologicalSpace B\n⊢ Eq (Set.range ContinuousAddMonoidHom.toContinuousMap) (setOf fun f => And (Eq (f 0) 0) (∀ (x y : A), Eq (f (HAdd.hAdd x y)) (HAdd.hAdd (f x) (f y))))","decl":"@[to_additive]\nlemma range_toContinuousMap :\n    Set.range (toContinuousMap : ContinuousMonoidHom A B → C(A, B)) =\n      {f : C(A, B) | f 1 = 1 ∧ ∀ x y, f (x * y) = f x * f y} := by\n  refine Set.Subset.antisymm (Set.range_subset_iff.2 fun f ↦ ⟨map_one f, map_mul f⟩) ?_\n  rintro f ⟨h1, hmul⟩\n  exact ⟨{ f with map_one' := h1, map_mul' := hmul }, rfl⟩\n\n"}
{"name":"ContinuousMonoidHom.isClosedEmbedding_toContinuousMap","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"A : Type u_2\nB : Type u_3\ninst✝⁵ : Monoid A\ninst✝⁴ : Monoid B\ninst✝³ : TopologicalSpace A\ninst✝² : TopologicalSpace B\ninst✝¹ : ContinuousMul B\ninst✝ : T2Space B\n⊢ Topology.IsClosedEmbedding ContinuousMonoidHom.toContinuousMap","decl":"@[to_additive]\ntheorem isClosedEmbedding_toContinuousMap [ContinuousMul B] [T2Space B] :\n    IsClosedEmbedding (toContinuousMap : ContinuousMonoidHom A B → C(A, B)) where\n  toIsEmbedding := isEmbedding_toContinuousMap A B\n  isClosed_range := by\n    simp only [range_toContinuousMap, Set.setOf_and, Set.setOf_forall]\n    refine .inter (isClosed_singleton.preimage (continuous_eval_const 1)) <|\n      isClosed_iInter fun x ↦ isClosed_iInter fun y ↦ ?_\n    exact isClosed_eq (continuous_eval_const (x * y)) <|\n      .mul (continuous_eval_const x) (continuous_eval_const y)\n\n"}
{"name":"ContinuousAddMonoidHom.isClosedEmbedding_toContinuousMap","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"A : Type u_2\nB : Type u_3\ninst✝⁵ : AddMonoid A\ninst✝⁴ : AddMonoid B\ninst✝³ : TopologicalSpace A\ninst✝² : TopologicalSpace B\ninst✝¹ : ContinuousAdd B\ninst✝ : T2Space B\n⊢ Topology.IsClosedEmbedding ContinuousAddMonoidHom.toContinuousMap","decl":"@[to_additive]\ntheorem isClosedEmbedding_toContinuousMap [ContinuousMul B] [T2Space B] :\n    IsClosedEmbedding (toContinuousMap : ContinuousMonoidHom A B → C(A, B)) where\n  toIsEmbedding := isEmbedding_toContinuousMap A B\n  isClosed_range := by\n    simp only [range_toContinuousMap, Set.setOf_and, Set.setOf_forall]\n    refine .inter (isClosed_singleton.preimage (continuous_eval_const 1)) <|\n      isClosed_iInter fun x ↦ isClosed_iInter fun y ↦ ?_\n    exact isClosed_eq (continuous_eval_const (x * y)) <|\n      .mul (continuous_eval_const x) (continuous_eval_const y)\n\n"}
{"name":"ContinuousMonoidHom.closedEmbedding_toContinuousMap","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"A : Type u_2\nB : Type u_3\ninst✝⁵ : Monoid A\ninst✝⁴ : Monoid B\ninst✝³ : TopologicalSpace A\ninst✝² : TopologicalSpace B\ninst✝¹ : ContinuousMul B\ninst✝ : T2Space B\n⊢ Topology.IsClosedEmbedding ContinuousMonoidHom.toContinuousMap","decl":"@[deprecated (since := \"2024-10-20\")]\nalias closedEmbedding_toContinuousMap := isClosedEmbedding_toContinuousMap\n\n"}
{"name":"ContinuousAddMonoidHom.instT2Space","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"A : Type u_2\nB : Type u_3\ninst✝⁴ : AddMonoid A\ninst✝³ : AddMonoid B\ninst✝² : TopologicalSpace A\ninst✝¹ : TopologicalSpace B\ninst✝ : T2Space B\n⊢ T2Space (ContinuousAddMonoidHom A B)","decl":"@[to_additive]\ninstance [T2Space B] : T2Space (ContinuousMonoidHom A B) :=\n  (isEmbedding_toContinuousMap A B).t2Space\n\n"}
{"name":"ContinuousMonoidHom.instT2Space","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"A : Type u_2\nB : Type u_3\ninst✝⁴ : Monoid A\ninst✝³ : Monoid B\ninst✝² : TopologicalSpace A\ninst✝¹ : TopologicalSpace B\ninst✝ : T2Space B\n⊢ T2Space (ContinuousMonoidHom A B)","decl":"@[to_additive]\ninstance [T2Space B] : T2Space (ContinuousMonoidHom A B) :=\n  (isEmbedding_toContinuousMap A B).t2Space\n\n"}
{"name":"ContinuousAddMonoidHom.instTopologicalAddGroup","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"A : Type u_2\nE : Type u_6\ninst✝⁴ : AddMonoid A\ninst✝³ : AddCommGroup E\ninst✝² : TopologicalSpace A\ninst✝¹ : TopologicalSpace E\ninst✝ : TopologicalAddGroup E\n⊢ TopologicalAddGroup (ContinuousAddMonoidHom A E)","decl":"@[to_additive]\ninstance : TopologicalGroup (ContinuousMonoidHom A E) :=\n  let hi := isInducing_toContinuousMap A E\n  let hc := hi.continuous\n  { continuous_mul := hi.continuous_iff.mpr (continuous_mul.comp (Continuous.prodMap hc hc))\n    continuous_inv := hi.continuous_iff.mpr (continuous_inv.comp hc) }\n\n"}
{"name":"ContinuousMonoidHom.instTopologicalGroup","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"A : Type u_2\nE : Type u_6\ninst✝⁴ : Monoid A\ninst✝³ : CommGroup E\ninst✝² : TopologicalSpace A\ninst✝¹ : TopologicalSpace E\ninst✝ : TopologicalGroup E\n⊢ TopologicalGroup (ContinuousMonoidHom A E)","decl":"@[to_additive]\ninstance : TopologicalGroup (ContinuousMonoidHom A E) :=\n  let hi := isInducing_toContinuousMap A E\n  let hc := hi.continuous\n  { continuous_mul := hi.continuous_iff.mpr (continuous_mul.comp (Continuous.prodMap hc hc))\n    continuous_inv := hi.continuous_iff.mpr (continuous_inv.comp hc) }\n\n"}
{"name":"ContinuousMonoidHom.continuous_of_continuous_uncurry","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"B : Type u_3\nC : Type u_4\ninst✝⁴ : Monoid B\ninst✝³ : Monoid C\ninst✝² : TopologicalSpace B\ninst✝¹ : TopologicalSpace C\nA : Type u_7\ninst✝ : TopologicalSpace A\nf : A → ContinuousMonoidHom B C\nh : Continuous (Function.uncurry fun x y => (f x) y)\n⊢ Continuous f","decl":"@[to_additive]\ntheorem continuous_of_continuous_uncurry {A : Type*} [TopologicalSpace A]\n    (f : A → ContinuousMonoidHom B C) (h : Continuous (Function.uncurry fun x y => f x y)) :\n    Continuous f :=\n  (isInducing_toContinuousMap _ _).continuous_iff.mpr\n    (ContinuousMap.continuous_of_continuous_uncurry _ h)\n\n"}
{"name":"ContinuousAddMonoidHom.continuous_of_continuous_uncurry","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"B : Type u_3\nC : Type u_4\ninst✝⁴ : AddMonoid B\ninst✝³ : AddMonoid C\ninst✝² : TopologicalSpace B\ninst✝¹ : TopologicalSpace C\nA : Type u_7\ninst✝ : TopologicalSpace A\nf : A → ContinuousAddMonoidHom B C\nh : Continuous (Function.uncurry fun x y => (f x) y)\n⊢ Continuous f","decl":"@[to_additive]\ntheorem continuous_of_continuous_uncurry {A : Type*} [TopologicalSpace A]\n    (f : A → ContinuousMonoidHom B C) (h : Continuous (Function.uncurry fun x y => f x y)) :\n    Continuous f :=\n  (isInducing_toContinuousMap _ _).continuous_iff.mpr\n    (ContinuousMap.continuous_of_continuous_uncurry _ h)\n\n"}
{"name":"ContinuousMonoidHom.continuous_comp","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"A : Type u_2\nB : Type u_3\nC : Type u_4\ninst✝⁶ : Monoid A\ninst✝⁵ : Monoid B\ninst✝⁴ : Monoid C\ninst✝³ : TopologicalSpace A\ninst✝² : TopologicalSpace B\ninst✝¹ : TopologicalSpace C\ninst✝ : LocallyCompactSpace B\n⊢ Continuous fun f => f.2.comp f.1","decl":"@[to_additive]\ntheorem continuous_comp [LocallyCompactSpace B] :\n    Continuous fun f : ContinuousMonoidHom A B × ContinuousMonoidHom B C => f.2.comp f.1 :=\n  (isInducing_toContinuousMap A C).continuous_iff.2 <|\n    ContinuousMap.continuous_comp'.comp\n      ((isInducing_toContinuousMap A B).prodMap (isInducing_toContinuousMap B C)).continuous\n\n"}
{"name":"ContinuousAddMonoidHom.continuous_comp","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"A : Type u_2\nB : Type u_3\nC : Type u_4\ninst✝⁶ : AddMonoid A\ninst✝⁵ : AddMonoid B\ninst✝⁴ : AddMonoid C\ninst✝³ : TopologicalSpace A\ninst✝² : TopologicalSpace B\ninst✝¹ : TopologicalSpace C\ninst✝ : LocallyCompactSpace B\n⊢ Continuous fun f => f.2.comp f.1","decl":"@[to_additive]\ntheorem continuous_comp [LocallyCompactSpace B] :\n    Continuous fun f : ContinuousMonoidHom A B × ContinuousMonoidHom B C => f.2.comp f.1 :=\n  (isInducing_toContinuousMap A C).continuous_iff.2 <|\n    ContinuousMap.continuous_comp'.comp\n      ((isInducing_toContinuousMap A B).prodMap (isInducing_toContinuousMap B C)).continuous\n\n"}
{"name":"ContinuousMonoidHom.continuous_comp_left","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"A : Type u_2\nB : Type u_3\nC : Type u_4\ninst✝⁵ : Monoid A\ninst✝⁴ : Monoid B\ninst✝³ : Monoid C\ninst✝² : TopologicalSpace A\ninst✝¹ : TopologicalSpace B\ninst✝ : TopologicalSpace C\nf : ContinuousMonoidHom A B\n⊢ Continuous fun g => g.comp f","decl":"@[to_additive]\ntheorem continuous_comp_left (f : ContinuousMonoidHom A B) :\n    Continuous fun g : ContinuousMonoidHom B C => g.comp f :=\n  (isInducing_toContinuousMap A C).continuous_iff.2 <|\n    f.toContinuousMap.continuous_precomp.comp (isInducing_toContinuousMap B C).continuous\n\n"}
{"name":"ContinuousAddMonoidHom.continuous_comp_left","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"A : Type u_2\nB : Type u_3\nC : Type u_4\ninst✝⁵ : AddMonoid A\ninst✝⁴ : AddMonoid B\ninst✝³ : AddMonoid C\ninst✝² : TopologicalSpace A\ninst✝¹ : TopologicalSpace B\ninst✝ : TopologicalSpace C\nf : ContinuousAddMonoidHom A B\n⊢ Continuous fun g => g.comp f","decl":"@[to_additive]\ntheorem continuous_comp_left (f : ContinuousMonoidHom A B) :\n    Continuous fun g : ContinuousMonoidHom B C => g.comp f :=\n  (isInducing_toContinuousMap A C).continuous_iff.2 <|\n    f.toContinuousMap.continuous_precomp.comp (isInducing_toContinuousMap B C).continuous\n\n"}
{"name":"ContinuousMonoidHom.continuous_comp_right","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"A : Type u_2\nB : Type u_3\nC : Type u_4\ninst✝⁵ : Monoid A\ninst✝⁴ : Monoid B\ninst✝³ : Monoid C\ninst✝² : TopologicalSpace A\ninst✝¹ : TopologicalSpace B\ninst✝ : TopologicalSpace C\nf : ContinuousMonoidHom B C\n⊢ Continuous fun g => f.comp g","decl":"@[to_additive]\ntheorem continuous_comp_right (f : ContinuousMonoidHom B C) :\n    Continuous fun g : ContinuousMonoidHom A B => f.comp g :=\n  (isInducing_toContinuousMap A C).continuous_iff.2 <|\n    f.toContinuousMap.continuous_postcomp.comp (isInducing_toContinuousMap A B).continuous\n\n"}
{"name":"ContinuousAddMonoidHom.continuous_comp_right","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"A : Type u_2\nB : Type u_3\nC : Type u_4\ninst✝⁵ : AddMonoid A\ninst✝⁴ : AddMonoid B\ninst✝³ : AddMonoid C\ninst✝² : TopologicalSpace A\ninst✝¹ : TopologicalSpace B\ninst✝ : TopologicalSpace C\nf : ContinuousAddMonoidHom B C\n⊢ Continuous fun g => f.comp g","decl":"@[to_additive]\ntheorem continuous_comp_right (f : ContinuousMonoidHom B C) :\n    Continuous fun g : ContinuousMonoidHom A B => f.comp g :=\n  (isInducing_toContinuousMap A C).continuous_iff.2 <|\n    f.toContinuousMap.continuous_postcomp.comp (isInducing_toContinuousMap A B).continuous\n\n"}
{"name":"ContinuousAddMonoidHom.locallyCompactSpace_of_equicontinuousAt","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"X : Type u_7\nY : Type u_8\ninst✝⁷ : TopologicalSpace X\ninst✝⁶ : AddGroup X\ninst✝⁵ : TopologicalAddGroup X\ninst✝⁴ : UniformSpace Y\ninst✝³ : AddCommGroup Y\ninst✝² : UniformAddGroup Y\ninst✝¹ : T0Space Y\ninst✝ : CompactSpace Y\nU : Set X\nV : Set Y\nhU : IsCompact U\nhV : Membership.mem (nhds 0) V\nh : EquicontinuousAt (fun f => ⇑↑f) 0\n⊢ LocallyCompactSpace (ContinuousAddMonoidHom X Y)","decl":"@[to_additive]\ntheorem locallyCompactSpace_of_equicontinuousAt (U : Set X) (V : Set Y)\n    (hU : IsCompact U) (hV : V ∈ nhds (1 : Y))\n    (h : EquicontinuousAt (fun f : {f : X →* Y | Set.MapsTo f U V} ↦ (f : X → Y)) 1) :\n    LocallyCompactSpace (ContinuousMonoidHom X Y) := by\n  replace h := equicontinuous_of_equicontinuousAt_one _ h\n  obtain ⟨W, hWo, hWV, hWc⟩ := local_compact_nhds hV\n  let S1 : Set (X →* Y) := {f | Set.MapsTo f U W}\n  let S2 : Set (ContinuousMonoidHom X Y) := {f | Set.MapsTo f U W}\n  let S3 : Set C(X, Y) := (↑) '' S2\n  let S4 : Set (X → Y) := (↑) '' S3\n  replace h : Equicontinuous ((↑) : S1 → X → Y) :=\n    h.comp (Subtype.map _root_.id fun f hf ↦ hf.mono_right hWV)\n  have hS4 : S4 = (↑) '' S1 := by\n    ext\n    constructor\n    · rintro ⟨-, ⟨f, hf, rfl⟩, rfl⟩\n      exact ⟨f, hf, rfl⟩\n    · rintro ⟨f, hf, rfl⟩\n      exact ⟨⟨f, h.continuous ⟨f, hf⟩⟩, ⟨⟨f, h.continuous ⟨f, hf⟩⟩, hf, rfl⟩, rfl⟩\n  replace h : Equicontinuous ((↑) : S3 → X → Y) := by\n    rw [equicontinuous_iff_range, ← Set.image_eq_range] at h ⊢\n    rwa [← hS4] at h\n  replace hS4 : S4 = Set.pi U (fun _ ↦ W) ∩ Set.range ((↑) : (X →* Y) → (X → Y)) := by\n    simp_rw [hS4, Set.ext_iff, Set.mem_image, S1, Set.mem_setOf_eq]\n    exact fun f ↦ ⟨fun ⟨g, hg, hf⟩ ↦ hf ▸ ⟨hg, g, rfl⟩, fun ⟨hg, g, hf⟩ ↦ ⟨g, hf ▸ hg, hf⟩⟩\n  replace hS4 : IsClosed S4 :=\n    hS4.symm ▸ (isClosed_set_pi (fun _ _ ↦ hWc.isClosed)).inter (MonoidHom.isClosed_range_coe X Y)\n  have hS2 : (interior S2).Nonempty := by\n    let T : Set (ContinuousMonoidHom X Y) := {f | Set.MapsTo f U (interior W)}\n    have h1 : T.Nonempty := ⟨1, fun _ _ ↦ mem_interior_iff_mem_nhds.mpr hWo⟩\n    have h2 : T ⊆ S2 := fun f hf ↦ hf.mono_right interior_subset\n    have h3 : IsOpen T := isOpen_induced (ContinuousMap.isOpen_setOf_mapsTo hU isOpen_interior)\n    exact h1.mono (interior_maximal h2 h3)\n  exact TopologicalSpace.PositiveCompacts.locallyCompactSpace_of_group\n    ⟨⟨S2, (isInducing_toContinuousMap X Y).isCompact_iff.mpr\n      (ArzelaAscoli.isCompact_of_equicontinuous S3 hS4.isCompact h)⟩, hS2⟩\n\n"}
{"name":"ContinuousMonoidHom.locallyCompactSpace_of_equicontinuousAt","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"X : Type u_7\nY : Type u_8\ninst✝⁷ : TopologicalSpace X\ninst✝⁶ : Group X\ninst✝⁵ : TopologicalGroup X\ninst✝⁴ : UniformSpace Y\ninst✝³ : CommGroup Y\ninst✝² : UniformGroup Y\ninst✝¹ : T0Space Y\ninst✝ : CompactSpace Y\nU : Set X\nV : Set Y\nhU : IsCompact U\nhV : Membership.mem (nhds 1) V\nh : EquicontinuousAt (fun f => ⇑↑f) 1\n⊢ LocallyCompactSpace (ContinuousMonoidHom X Y)","decl":"@[to_additive]\ntheorem locallyCompactSpace_of_equicontinuousAt (U : Set X) (V : Set Y)\n    (hU : IsCompact U) (hV : V ∈ nhds (1 : Y))\n    (h : EquicontinuousAt (fun f : {f : X →* Y | Set.MapsTo f U V} ↦ (f : X → Y)) 1) :\n    LocallyCompactSpace (ContinuousMonoidHom X Y) := by\n  replace h := equicontinuous_of_equicontinuousAt_one _ h\n  obtain ⟨W, hWo, hWV, hWc⟩ := local_compact_nhds hV\n  let S1 : Set (X →* Y) := {f | Set.MapsTo f U W}\n  let S2 : Set (ContinuousMonoidHom X Y) := {f | Set.MapsTo f U W}\n  let S3 : Set C(X, Y) := (↑) '' S2\n  let S4 : Set (X → Y) := (↑) '' S3\n  replace h : Equicontinuous ((↑) : S1 → X → Y) :=\n    h.comp (Subtype.map _root_.id fun f hf ↦ hf.mono_right hWV)\n  have hS4 : S4 = (↑) '' S1 := by\n    ext\n    constructor\n    · rintro ⟨-, ⟨f, hf, rfl⟩, rfl⟩\n      exact ⟨f, hf, rfl⟩\n    · rintro ⟨f, hf, rfl⟩\n      exact ⟨⟨f, h.continuous ⟨f, hf⟩⟩, ⟨⟨f, h.continuous ⟨f, hf⟩⟩, hf, rfl⟩, rfl⟩\n  replace h : Equicontinuous ((↑) : S3 → X → Y) := by\n    rw [equicontinuous_iff_range, ← Set.image_eq_range] at h ⊢\n    rwa [← hS4] at h\n  replace hS4 : S4 = Set.pi U (fun _ ↦ W) ∩ Set.range ((↑) : (X →* Y) → (X → Y)) := by\n    simp_rw [hS4, Set.ext_iff, Set.mem_image, S1, Set.mem_setOf_eq]\n    exact fun f ↦ ⟨fun ⟨g, hg, hf⟩ ↦ hf ▸ ⟨hg, g, rfl⟩, fun ⟨hg, g, hf⟩ ↦ ⟨g, hf ▸ hg, hf⟩⟩\n  replace hS4 : IsClosed S4 :=\n    hS4.symm ▸ (isClosed_set_pi (fun _ _ ↦ hWc.isClosed)).inter (MonoidHom.isClosed_range_coe X Y)\n  have hS2 : (interior S2).Nonempty := by\n    let T : Set (ContinuousMonoidHom X Y) := {f | Set.MapsTo f U (interior W)}\n    have h1 : T.Nonempty := ⟨1, fun _ _ ↦ mem_interior_iff_mem_nhds.mpr hWo⟩\n    have h2 : T ⊆ S2 := fun f hf ↦ hf.mono_right interior_subset\n    have h3 : IsOpen T := isOpen_induced (ContinuousMap.isOpen_setOf_mapsTo hU isOpen_interior)\n    exact h1.mono (interior_maximal h2 h3)\n  exact TopologicalSpace.PositiveCompacts.locallyCompactSpace_of_group\n    ⟨⟨S2, (isInducing_toContinuousMap X Y).isCompact_iff.mpr\n      (ArzelaAscoli.isCompact_of_equicontinuous S3 hS4.isCompact h)⟩, hS2⟩\n\n"}
{"name":"ContinuousAddMonoidHom.locallyCompactSpace_of_hasBasis","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"X : Type u_7\nY : Type u_8\ninst✝⁸ : TopologicalSpace X\ninst✝⁷ : AddGroup X\ninst✝⁶ : TopologicalAddGroup X\ninst✝⁵ : UniformSpace Y\ninst✝⁴ : AddCommGroup Y\ninst✝³ : UniformAddGroup Y\ninst✝² : T0Space Y\ninst✝¹ : CompactSpace Y\ninst✝ : LocallyCompactSpace X\nV : Nat → Set Y\nhV : ∀ {n : Nat} {x : Y}, Membership.mem (V n) x → Membership.mem (V n) (HAdd.hAdd x x) → Membership.mem (V (HAdd.hAdd n 1)) x\nhVo : (nhds 0).HasBasis (fun x => True) V\n⊢ LocallyCompactSpace (ContinuousAddMonoidHom X Y)","decl":"@[to_additive]\ntheorem locallyCompactSpace_of_hasBasis (V : ℕ → Set Y)\n    (hV : ∀ {n x}, x ∈ V n → x * x ∈ V n → x ∈ V (n + 1))\n    (hVo : Filter.HasBasis (nhds 1) (fun _ ↦ True) V) :\n    LocallyCompactSpace (ContinuousMonoidHom X Y) := by\n  obtain ⟨U0, hU0c, hU0o⟩ := exists_compact_mem_nhds (1 : X)\n  let U_aux : ℕ → {S : Set X | S ∈ nhds 1} :=\n    Nat.rec ⟨U0, hU0o⟩ <| fun _ S ↦ let h := exists_closed_nhds_one_inv_eq_mul_subset S.2\n      ⟨Classical.choose h, (Classical.choose_spec h).1⟩\n  let U : ℕ → Set X := fun n ↦ (U_aux n).1\n  have hU1 : ∀ n, U n ∈ nhds 1 := fun n ↦ (U_aux n).2\n  have hU2 : ∀ n, U (n + 1) * U (n + 1) ⊆ U n :=\n    fun n ↦ (Classical.choose_spec (exists_closed_nhds_one_inv_eq_mul_subset (U_aux n).2)).2.2.2\n  have hU3 : ∀ n, U (n + 1) ⊆ U n :=\n    fun n x hx ↦ hU2 n (mul_one x ▸ Set.mul_mem_mul hx (mem_of_mem_nhds (hU1 (n + 1))))\n  have hU4 : ∀ f : X →* Y, Set.MapsTo f (U 0) (V 0) → ∀ n, Set.MapsTo f (U n) (V n) := by\n    intro f hf n\n    induction' n with n ih\n    · exact hf\n    · exact fun x hx ↦ hV (ih (hU3 n hx)) (map_mul f x x ▸ ih (hU2 n (Set.mul_mem_mul hx hx)))\n  apply locallyCompactSpace_of_equicontinuousAt (U 0) (V 0) hU0c (hVo.mem_of_mem trivial)\n  rw [hVo.uniformity_of_nhds_one.equicontinuousAt_iff_right]\n  refine fun n _ ↦ Filter.eventually_iff_exists_mem.mpr ⟨U n, hU1 n, fun x hx ⟨f, hf⟩ ↦ ?_⟩\n  rw [Set.mem_setOf_eq, map_one, div_one]\n  exact hU4 f hf n hx\n\n"}
{"name":"ContinuousMonoidHom.locallyCompactSpace_of_hasBasis","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"X : Type u_7\nY : Type u_8\ninst✝⁸ : TopologicalSpace X\ninst✝⁷ : Group X\ninst✝⁶ : TopologicalGroup X\ninst✝⁵ : UniformSpace Y\ninst✝⁴ : CommGroup Y\ninst✝³ : UniformGroup Y\ninst✝² : T0Space Y\ninst✝¹ : CompactSpace Y\ninst✝ : LocallyCompactSpace X\nV : Nat → Set Y\nhV : ∀ {n : Nat} {x : Y}, Membership.mem (V n) x → Membership.mem (V n) (HMul.hMul x x) → Membership.mem (V (HAdd.hAdd n 1)) x\nhVo : (nhds 1).HasBasis (fun x => True) V\n⊢ LocallyCompactSpace (ContinuousMonoidHom X Y)","decl":"@[to_additive]\ntheorem locallyCompactSpace_of_hasBasis (V : ℕ → Set Y)\n    (hV : ∀ {n x}, x ∈ V n → x * x ∈ V n → x ∈ V (n + 1))\n    (hVo : Filter.HasBasis (nhds 1) (fun _ ↦ True) V) :\n    LocallyCompactSpace (ContinuousMonoidHom X Y) := by\n  obtain ⟨U0, hU0c, hU0o⟩ := exists_compact_mem_nhds (1 : X)\n  let U_aux : ℕ → {S : Set X | S ∈ nhds 1} :=\n    Nat.rec ⟨U0, hU0o⟩ <| fun _ S ↦ let h := exists_closed_nhds_one_inv_eq_mul_subset S.2\n      ⟨Classical.choose h, (Classical.choose_spec h).1⟩\n  let U : ℕ → Set X := fun n ↦ (U_aux n).1\n  have hU1 : ∀ n, U n ∈ nhds 1 := fun n ↦ (U_aux n).2\n  have hU2 : ∀ n, U (n + 1) * U (n + 1) ⊆ U n :=\n    fun n ↦ (Classical.choose_spec (exists_closed_nhds_one_inv_eq_mul_subset (U_aux n).2)).2.2.2\n  have hU3 : ∀ n, U (n + 1) ⊆ U n :=\n    fun n x hx ↦ hU2 n (mul_one x ▸ Set.mul_mem_mul hx (mem_of_mem_nhds (hU1 (n + 1))))\n  have hU4 : ∀ f : X →* Y, Set.MapsTo f (U 0) (V 0) → ∀ n, Set.MapsTo f (U n) (V n) := by\n    intro f hf n\n    induction' n with n ih\n    · exact hf\n    · exact fun x hx ↦ hV (ih (hU3 n hx)) (map_mul f x x ▸ ih (hU2 n (Set.mul_mem_mul hx hx)))\n  apply locallyCompactSpace_of_equicontinuousAt (U 0) (V 0) hU0c (hVo.mem_of_mem trivial)\n  rw [hVo.uniformity_of_nhds_one.equicontinuousAt_iff_right]\n  refine fun n _ ↦ Filter.eventually_iff_exists_mem.mpr ⟨U n, hU1 n, fun x hx ⟨f, hf⟩ ↦ ?_⟩\n  rw [Set.mem_setOf_eq, map_one, div_one]\n  exact hU4 f hf n hx\n\n"}
{"name":"ContinuousAddEquiv.mk.sizeOf_spec","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"G : Type u\ninst✝⁵ : TopologicalSpace G\nH : Type v\ninst✝⁴ : TopologicalSpace H\ninst✝³ : Add G\ninst✝² : Add H\ninst✝¹ : SizeOf G\ninst✝ : SizeOf H\ntoAddEquiv : AddEquiv G H\ncontinuous_toFun : autoParam (Continuous toAddEquiv.toFun) _auto✝\ncontinuous_invFun : autoParam (Continuous toAddEquiv.invFun) _auto✝\n⊢ Eq (SizeOf.sizeOf { toAddEquiv := toAddEquiv, continuous_toFun := continuous_toFun, continuous_invFun := continuous_invFun }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf toAddEquiv)) (SizeOf.sizeOf continuous_toFun)) (SizeOf.sizeOf continuous_invFun))","decl":"/-- The structure of two-sided continuous isomorphisms between additive groups.\nNote that both the map and its inverse have to be continuous. -/\nstructure ContinuousAddEquiv [Add G] [Add H] extends G ≃+ H , G ≃ₜ H\n\n"}
{"name":"ContinuousAddEquiv.mk.inj","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"G : Type u\ninst✝³ : TopologicalSpace G\nH : Type v\ninst✝² : TopologicalSpace H\ninst✝¹ : Add G\ninst✝ : Add H\ntoAddEquiv✝ : AddEquiv G H\ncontinuous_toFun✝ : autoParam (Continuous toAddEquiv✝.toFun) _auto✝\ncontinuous_invFun✝ : autoParam (Continuous toAddEquiv✝.invFun) _auto✝\ntoAddEquiv : AddEquiv G H\ncontinuous_toFun : autoParam (Continuous toAddEquiv.toFun) _auto✝\ncontinuous_invFun : autoParam (Continuous toAddEquiv.invFun) _auto✝\nx✝ : Eq { toAddEquiv := toAddEquiv✝, continuous_toFun := continuous_toFun✝, continuous_invFun := continuous_invFun✝ } { toAddEquiv := toAddEquiv, continuous_toFun := continuous_toFun, continuous_invFun := continuous_invFun }\n⊢ Eq toAddEquiv✝ toAddEquiv","decl":"/-- The structure of two-sided continuous isomorphisms between additive groups.\nNote that both the map and its inverse have to be continuous. -/\nstructure ContinuousAddEquiv [Add G] [Add H] extends G ≃+ H , G ≃ₜ H\n\n"}
{"name":"ContinuousAddEquiv.mk.injEq","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"G : Type u\ninst✝³ : TopologicalSpace G\nH : Type v\ninst✝² : TopologicalSpace H\ninst✝¹ : Add G\ninst✝ : Add H\ntoAddEquiv✝ : AddEquiv G H\ncontinuous_toFun✝ : autoParam (Continuous toAddEquiv✝.toFun) _auto✝\ncontinuous_invFun✝ : autoParam (Continuous toAddEquiv✝.invFun) _auto✝\ntoAddEquiv : AddEquiv G H\ncontinuous_toFun : autoParam (Continuous toAddEquiv.toFun) _auto✝\ncontinuous_invFun : autoParam (Continuous toAddEquiv.invFun) _auto✝\n⊢ Eq (Eq { toAddEquiv := toAddEquiv✝, continuous_toFun := continuous_toFun✝, continuous_invFun := continuous_invFun✝ } { toAddEquiv := toAddEquiv, continuous_toFun := continuous_toFun, continuous_invFun := continuous_invFun }) (Eq toAddEquiv✝ toAddEquiv)","decl":"/-- The structure of two-sided continuous isomorphisms between additive groups.\nNote that both the map and its inverse have to be continuous. -/\nstructure ContinuousAddEquiv [Add G] [Add H] extends G ≃+ H , G ≃ₜ H\n\n"}
{"name":"ContinuousAddEquiv.continuous_toFun","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"G : Type u\ninst✝³ : TopologicalSpace G\nH : Type v\ninst✝² : TopologicalSpace H\ninst✝¹ : Add G\ninst✝ : Add H\nself : ContinuousAddEquiv G H\n⊢ Continuous self.toFun","decl":"/-- The structure of two-sided continuous isomorphisms between additive groups.\nNote that both the map and its inverse have to be continuous. -/\nstructure ContinuousAddEquiv [Add G] [Add H] extends G ≃+ H , G ≃ₜ H\n\n"}
{"name":"ContinuousAddEquiv.continuous_invFun","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"G : Type u\ninst✝³ : TopologicalSpace G\nH : Type v\ninst✝² : TopologicalSpace H\ninst✝¹ : Add G\ninst✝ : Add H\nself : ContinuousAddEquiv G H\n⊢ Continuous self.invFun","decl":"/-- The structure of two-sided continuous isomorphisms between additive groups.\nNote that both the map and its inverse have to be continuous. -/\nstructure ContinuousAddEquiv [Add G] [Add H] extends G ≃+ H , G ≃ₜ H\n\n"}
{"name":"ContinuousMulEquiv.continuous_toFun","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"G : Type u\ninst✝³ : TopologicalSpace G\nH : Type v\ninst✝² : TopologicalSpace H\ninst✝¹ : Mul G\ninst✝ : Mul H\nself : ContinuousMulEquiv G H\n⊢ Continuous self.toFun","decl":"/-- The structure of two-sided continuous isomorphisms between groups.\nNote that both the map and its inverse have to be continuous. -/\n@[to_additive \"The structure of two-sided continuous isomorphisms between additive groups.\nNote that both the map and its inverse have to be continuous.\"]\nstructure ContinuousMulEquiv [Mul G] [Mul H] extends G ≃* H , G ≃ₜ H\n\n"}
{"name":"ContinuousMulEquiv.continuous_invFun","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"G : Type u\ninst✝³ : TopologicalSpace G\nH : Type v\ninst✝² : TopologicalSpace H\ninst✝¹ : Mul G\ninst✝ : Mul H\nself : ContinuousMulEquiv G H\n⊢ Continuous self.invFun","decl":"/-- The structure of two-sided continuous isomorphisms between groups.\nNote that both the map and its inverse have to be continuous. -/\n@[to_additive \"The structure of two-sided continuous isomorphisms between additive groups.\nNote that both the map and its inverse have to be continuous.\"]\nstructure ContinuousMulEquiv [Mul G] [Mul H] extends G ≃* H , G ≃ₜ H\n\n"}
{"name":"ContinuousMulEquiv.mk.injEq","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"G : Type u\ninst✝³ : TopologicalSpace G\nH : Type v\ninst✝² : TopologicalSpace H\ninst✝¹ : Mul G\ninst✝ : Mul H\ntoMulEquiv✝ : MulEquiv G H\ncontinuous_toFun✝ : autoParam (Continuous toMulEquiv✝.toFun) _auto✝\ncontinuous_invFun✝ : autoParam (Continuous toMulEquiv✝.invFun) _auto✝\ntoMulEquiv : MulEquiv G H\ncontinuous_toFun : autoParam (Continuous toMulEquiv.toFun) _auto✝\ncontinuous_invFun : autoParam (Continuous toMulEquiv.invFun) _auto✝\n⊢ Eq (Eq { toMulEquiv := toMulEquiv✝, continuous_toFun := continuous_toFun✝, continuous_invFun := continuous_invFun✝ } { toMulEquiv := toMulEquiv, continuous_toFun := continuous_toFun, continuous_invFun := continuous_invFun }) (Eq toMulEquiv✝ toMulEquiv)","decl":"/-- The structure of two-sided continuous isomorphisms between groups.\nNote that both the map and its inverse have to be continuous. -/\n@[to_additive \"The structure of two-sided continuous isomorphisms between additive groups.\nNote that both the map and its inverse have to be continuous.\"]\nstructure ContinuousMulEquiv [Mul G] [Mul H] extends G ≃* H , G ≃ₜ H\n\n"}
{"name":"ContinuousMulEquiv.mk.sizeOf_spec","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"G : Type u\ninst✝⁵ : TopologicalSpace G\nH : Type v\ninst✝⁴ : TopologicalSpace H\ninst✝³ : Mul G\ninst✝² : Mul H\ninst✝¹ : SizeOf G\ninst✝ : SizeOf H\ntoMulEquiv : MulEquiv G H\ncontinuous_toFun : autoParam (Continuous toMulEquiv.toFun) _auto✝\ncontinuous_invFun : autoParam (Continuous toMulEquiv.invFun) _auto✝\n⊢ Eq (SizeOf.sizeOf { toMulEquiv := toMulEquiv, continuous_toFun := continuous_toFun, continuous_invFun := continuous_invFun }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf toMulEquiv)) (SizeOf.sizeOf continuous_toFun)) (SizeOf.sizeOf continuous_invFun))","decl":"/-- The structure of two-sided continuous isomorphisms between groups.\nNote that both the map and its inverse have to be continuous. -/\n@[to_additive \"The structure of two-sided continuous isomorphisms between additive groups.\nNote that both the map and its inverse have to be continuous.\"]\nstructure ContinuousMulEquiv [Mul G] [Mul H] extends G ≃* H , G ≃ₜ H\n\n"}
{"name":"ContinuousMulEquiv.mk.inj","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"G : Type u\ninst✝³ : TopologicalSpace G\nH : Type v\ninst✝² : TopologicalSpace H\ninst✝¹ : Mul G\ninst✝ : Mul H\ntoMulEquiv✝ : MulEquiv G H\ncontinuous_toFun✝ : autoParam (Continuous toMulEquiv✝.toFun) _auto✝\ncontinuous_invFun✝ : autoParam (Continuous toMulEquiv✝.invFun) _auto✝\ntoMulEquiv : MulEquiv G H\ncontinuous_toFun : autoParam (Continuous toMulEquiv.toFun) _auto✝\ncontinuous_invFun : autoParam (Continuous toMulEquiv.invFun) _auto✝\nx✝ : Eq { toMulEquiv := toMulEquiv✝, continuous_toFun := continuous_toFun✝, continuous_invFun := continuous_invFun✝ } { toMulEquiv := toMulEquiv, continuous_toFun := continuous_toFun, continuous_invFun := continuous_invFun }\n⊢ Eq toMulEquiv✝ toMulEquiv","decl":"/-- The structure of two-sided continuous isomorphisms between groups.\nNote that both the map and its inverse have to be continuous. -/\n@[to_additive \"The structure of two-sided continuous isomorphisms between additive groups.\nNote that both the map and its inverse have to be continuous.\"]\nstructure ContinuousMulEquiv [Mul G] [Mul H] extends G ≃* H , G ≃ₜ H\n\n"}
{"name":"ContinuousMulEquiv.instMulEquivClass","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝³ : TopologicalSpace M\ninst✝² : TopologicalSpace N\ninst✝¹ : Mul M\ninst✝ : Mul N\n⊢ MulEquivClass (ContinuousMulEquiv M N) M N","decl":"@[to_additive]\ninstance : MulEquivClass (M ≃ₜ* N) M N where\n  map_mul f := f.map_mul'\n\n"}
{"name":"ContinuousAddEquiv.instAddEquivClass","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝³ : TopologicalSpace M\ninst✝² : TopologicalSpace N\ninst✝¹ : Add M\ninst✝ : Add N\n⊢ AddEquivClass (ContinuousAddEquiv M N) M N","decl":"@[to_additive]\ninstance : MulEquivClass (M ≃ₜ* N) M N where\n  map_mul f := f.map_mul'\n\n"}
{"name":"ContinuousMulEquiv.instHomeomorphClass","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝³ : TopologicalSpace M\ninst✝² : TopologicalSpace N\ninst✝¹ : Mul M\ninst✝ : Mul N\n⊢ HomeomorphClass (ContinuousMulEquiv M N) M N","decl":"@[to_additive]\ninstance : HomeomorphClass (M ≃ₜ* N) M N where\n  map_continuous f := f.continuous_toFun\n  inv_continuous f := f.continuous_invFun\n\n"}
{"name":"ContinuousAddEquiv.instHomeomorphClass","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝³ : TopologicalSpace M\ninst✝² : TopologicalSpace N\ninst✝¹ : Add M\ninst✝ : Add N\n⊢ HomeomorphClass (ContinuousAddEquiv M N) M N","decl":"@[to_additive]\ninstance : HomeomorphClass (M ≃ₜ* N) M N where\n  map_continuous f := f.continuous_toFun\n  inv_continuous f := f.continuous_invFun\n\n"}
{"name":"ContinuousMulEquiv.ext_iff","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝³ : TopologicalSpace M\ninst✝² : TopologicalSpace N\ninst✝¹ : Mul M\ninst✝ : Mul N\nf g : ContinuousMulEquiv M N\n⊢ Iff (Eq f g) (∀ (x : M), Eq (f x) (g x))","decl":"/-- Two continuous multiplicative isomorphisms agree if they are defined by the\nsame underlying function. -/\n@[to_additive (attr := ext)\n  \"Two continuous additive isomorphisms agree if they are defined by the same underlying function.\"]\ntheorem ext {f g : M ≃ₜ* N} (h : ∀ x, f x = g x) : f = g :=\n  DFunLike.ext f g h\n\n"}
{"name":"ContinuousAddEquiv.ext_iff","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝³ : TopologicalSpace M\ninst✝² : TopologicalSpace N\ninst✝¹ : Add M\ninst✝ : Add N\nf g : ContinuousAddEquiv M N\n⊢ Iff (Eq f g) (∀ (x : M), Eq (f x) (g x))","decl":"/-- Two continuous multiplicative isomorphisms agree if they are defined by the\nsame underlying function. -/\n@[to_additive (attr := ext)\n  \"Two continuous additive isomorphisms agree if they are defined by the same underlying function.\"]\ntheorem ext {f g : M ≃ₜ* N} (h : ∀ x, f x = g x) : f = g :=\n  DFunLike.ext f g h\n\n"}
{"name":"ContinuousMulEquiv.ext","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝³ : TopologicalSpace M\ninst✝² : TopologicalSpace N\ninst✝¹ : Mul M\ninst✝ : Mul N\nf g : ContinuousMulEquiv M N\nh : ∀ (x : M), Eq (f x) (g x)\n⊢ Eq f g","decl":"/-- Two continuous multiplicative isomorphisms agree if they are defined by the\nsame underlying function. -/\n@[to_additive (attr := ext)\n  \"Two continuous additive isomorphisms agree if they are defined by the same underlying function.\"]\ntheorem ext {f g : M ≃ₜ* N} (h : ∀ x, f x = g x) : f = g :=\n  DFunLike.ext f g h\n\n"}
{"name":"ContinuousAddEquiv.ext","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝³ : TopologicalSpace M\ninst✝² : TopologicalSpace N\ninst✝¹ : Add M\ninst✝ : Add N\nf g : ContinuousAddEquiv M N\nh : ∀ (x : M), Eq (f x) (g x)\n⊢ Eq f g","decl":"/-- Two continuous multiplicative isomorphisms agree if they are defined by the\nsame underlying function. -/\n@[to_additive (attr := ext)\n  \"Two continuous additive isomorphisms agree if they are defined by the same underlying function.\"]\ntheorem ext {f g : M ≃ₜ* N} (h : ∀ x, f x = g x) : f = g :=\n  DFunLike.ext f g h\n\n"}
{"name":"ContinuousMulEquiv.coe_mk","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝³ : TopologicalSpace M\ninst✝² : TopologicalSpace N\ninst✝¹ : Mul M\ninst✝ : Mul N\nf : MulEquiv M N\nhf1 : Continuous f.toFun\nhf2 : Continuous f.invFun\n⊢ Eq ⇑{ toMulEquiv := f, continuous_toFun := hf1, continuous_invFun := hf2 } ⇑f","decl":"@[to_additive (attr := simp)]\ntheorem coe_mk (f : M ≃* N) (hf1 hf2) : ⇑(mk f hf1 hf2) = f := rfl\n\n"}
{"name":"ContinuousAddEquiv.coe_mk","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝³ : TopologicalSpace M\ninst✝² : TopologicalSpace N\ninst✝¹ : Add M\ninst✝ : Add N\nf : AddEquiv M N\nhf1 : Continuous f.toFun\nhf2 : Continuous f.invFun\n⊢ Eq ⇑{ toAddEquiv := f, continuous_toFun := hf1, continuous_invFun := hf2 } ⇑f","decl":"@[to_additive (attr := simp)]\ntheorem coe_mk (f : M ≃* N) (hf1 hf2) : ⇑(mk f hf1 hf2) = f := rfl\n\n"}
{"name":"ContinuousMulEquiv.toEquiv_eq_coe","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝³ : TopologicalSpace M\ninst✝² : TopologicalSpace N\ninst✝¹ : Mul M\ninst✝ : Mul N\nf : ContinuousMulEquiv M N\n⊢ Eq f.toEquiv ↑f","decl":"@[to_additive]\ntheorem toEquiv_eq_coe (f : M ≃ₜ* N) : f.toEquiv = f :=\n  rfl\n\n"}
{"name":"ContinuousAddEquiv.toEquiv_eq_coe","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝³ : TopologicalSpace M\ninst✝² : TopologicalSpace N\ninst✝¹ : Add M\ninst✝ : Add N\nf : ContinuousAddEquiv M N\n⊢ Eq f.toEquiv ↑f","decl":"@[to_additive]\ntheorem toEquiv_eq_coe (f : M ≃ₜ* N) : f.toEquiv = f :=\n  rfl\n\n"}
{"name":"ContinuousAddEquiv.toAddEquiv_eq_coe","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝³ : TopologicalSpace M\ninst✝² : TopologicalSpace N\ninst✝¹ : Add M\ninst✝ : Add N\nf : ContinuousAddEquiv M N\n⊢ Eq f.toAddEquiv ↑f","decl":"@[to_additive (attr := simp)]\ntheorem toMulEquiv_eq_coe (f : M ≃ₜ* N) : f.toMulEquiv = f :=\n  rfl\n\n"}
{"name":"ContinuousMulEquiv.toMulEquiv_eq_coe","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝³ : TopologicalSpace M\ninst✝² : TopologicalSpace N\ninst✝¹ : Mul M\ninst✝ : Mul N\nf : ContinuousMulEquiv M N\n⊢ Eq f.toMulEquiv ↑f","decl":"@[to_additive (attr := simp)]\ntheorem toMulEquiv_eq_coe (f : M ≃ₜ* N) : f.toMulEquiv = f :=\n  rfl\n\n"}
{"name":"ContinuousAddEquiv.toHomeomorph_eq_coe","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝³ : TopologicalSpace M\ninst✝² : TopologicalSpace N\ninst✝¹ : Add M\ninst✝ : Add N\nf : ContinuousAddEquiv M N\n⊢ Eq f.toHomeomorph ↑f","decl":"@[to_additive]\ntheorem toHomeomorph_eq_coe (f : M ≃ₜ* N) : f.toHomeomorph = f :=\n  rfl\n\n"}
{"name":"ContinuousMulEquiv.toHomeomorph_eq_coe","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝³ : TopologicalSpace M\ninst✝² : TopologicalSpace N\ninst✝¹ : Mul M\ninst✝ : Mul N\nf : ContinuousMulEquiv M N\n⊢ Eq f.toHomeomorph ↑f","decl":"@[to_additive]\ntheorem toHomeomorph_eq_coe (f : M ≃ₜ* N) : f.toHomeomorph = f :=\n  rfl\n\n"}
{"name":"ContinuousMulEquiv.coe_mk'","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝³ : TopologicalSpace M\ninst✝² : TopologicalSpace N\ninst✝¹ : Mul M\ninst✝ : Mul N\nf : Homeomorph M N\nh : ∀ (x y : M), Eq (f (HMul.hMul x y)) (HMul.hMul (f x) (f y))\n⊢ Eq ⇑(ContinuousMulEquiv.mk' f h) ⇑f","decl":"set_option linter.docPrime false in -- This is about `ContinuousMulEquiv.mk'`\n@[simp]\nlemma coe_mk' (f : M ≃ₜ N) (h : ∀ x y, f (x * y) = f x * f y)  : ⇑(mk' f h) = f := rfl\n\n"}
{"name":"ContinuousAddEquiv.bijective","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝³ : TopologicalSpace M\ninst✝² : TopologicalSpace N\ninst✝¹ : Add M\ninst✝ : Add N\ne : ContinuousAddEquiv M N\n⊢ Function.Bijective ⇑e","decl":"@[to_additive]\nprotected theorem bijective (e : M ≃ₜ* N) : Function.Bijective e :=\n  EquivLike.bijective e\n\n"}
{"name":"ContinuousMulEquiv.bijective","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝³ : TopologicalSpace M\ninst✝² : TopologicalSpace N\ninst✝¹ : Mul M\ninst✝ : Mul N\ne : ContinuousMulEquiv M N\n⊢ Function.Bijective ⇑e","decl":"@[to_additive]\nprotected theorem bijective (e : M ≃ₜ* N) : Function.Bijective e :=\n  EquivLike.bijective e\n\n"}
{"name":"ContinuousMulEquiv.injective","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝³ : TopologicalSpace M\ninst✝² : TopologicalSpace N\ninst✝¹ : Mul M\ninst✝ : Mul N\ne : ContinuousMulEquiv M N\n⊢ Function.Injective ⇑e","decl":"@[to_additive]\nprotected theorem injective (e : M ≃ₜ* N) : Function.Injective e :=\n  EquivLike.injective e\n\n"}
{"name":"ContinuousAddEquiv.injective","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝³ : TopologicalSpace M\ninst✝² : TopologicalSpace N\ninst✝¹ : Add M\ninst✝ : Add N\ne : ContinuousAddEquiv M N\n⊢ Function.Injective ⇑e","decl":"@[to_additive]\nprotected theorem injective (e : M ≃ₜ* N) : Function.Injective e :=\n  EquivLike.injective e\n\n"}
{"name":"ContinuousMulEquiv.surjective","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝³ : TopologicalSpace M\ninst✝² : TopologicalSpace N\ninst✝¹ : Mul M\ninst✝ : Mul N\ne : ContinuousMulEquiv M N\n⊢ Function.Surjective ⇑e","decl":"@[to_additive]\nprotected theorem surjective (e : M ≃ₜ* N) : Function.Surjective e :=\n  EquivLike.surjective e\n\n"}
{"name":"ContinuousAddEquiv.surjective","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝³ : TopologicalSpace M\ninst✝² : TopologicalSpace N\ninst✝¹ : Add M\ninst✝ : Add N\ne : ContinuousAddEquiv M N\n⊢ Function.Surjective ⇑e","decl":"@[to_additive]\nprotected theorem surjective (e : M ≃ₜ* N) : Function.Surjective e :=\n  EquivLike.surjective e\n\n"}
{"name":"ContinuousMulEquiv.apply_eq_iff_eq","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝³ : TopologicalSpace M\ninst✝² : TopologicalSpace N\ninst✝¹ : Mul M\ninst✝ : Mul N\ne : ContinuousMulEquiv M N\nx y : M\n⊢ Iff (Eq (e x) (e y)) (Eq x y)","decl":"@[to_additive]\ntheorem apply_eq_iff_eq (e : M ≃ₜ* N) {x y : M} : e x = e y ↔ x = y :=\n  e.injective.eq_iff\n\n"}
{"name":"ContinuousAddEquiv.apply_eq_iff_eq","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝³ : TopologicalSpace M\ninst✝² : TopologicalSpace N\ninst✝¹ : Add M\ninst✝ : Add N\ne : ContinuousAddEquiv M N\nx y : M\n⊢ Iff (Eq (e x) (e y)) (Eq x y)","decl":"@[to_additive]\ntheorem apply_eq_iff_eq (e : M ≃ₜ* N) {x y : M} : e x = e y ↔ x = y :=\n  e.injective.eq_iff\n\n"}
{"name":"ContinuousMulEquiv.coe_refl","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"M : Type u_1\ninst✝¹ : TopologicalSpace M\ninst✝ : Mul M\n⊢ Eq (⇑(ContinuousMulEquiv.refl M)) id","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_refl : ↑(refl M) = id := rfl\n\n"}
{"name":"ContinuousAddEquiv.coe_refl","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"M : Type u_1\ninst✝¹ : TopologicalSpace M\ninst✝ : Add M\n⊢ Eq (⇑(ContinuousAddEquiv.refl M)) id","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_refl : ↑(refl M) = id := rfl\n\n"}
{"name":"ContinuousAddEquiv.refl_apply","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"M : Type u_1\ninst✝¹ : TopologicalSpace M\ninst✝ : Add M\nm : M\n⊢ Eq ((ContinuousAddEquiv.refl M) m) m","decl":"@[to_additive (attr := simp)]\ntheorem refl_apply (m : M) : refl M m = m := rfl\n\n"}
{"name":"ContinuousMulEquiv.refl_apply","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"M : Type u_1\ninst✝¹ : TopologicalSpace M\ninst✝ : Mul M\nm : M\n⊢ Eq ((ContinuousMulEquiv.refl M) m) m","decl":"@[to_additive (attr := simp)]\ntheorem refl_apply (m : M) : refl M m = m := rfl\n\n"}
{"name":"ContinuousAddEquiv.invFun_eq_symm","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝³ : TopologicalSpace M\ninst✝² : TopologicalSpace N\ninst✝¹ : Add M\ninst✝ : Add N\nf : ContinuousAddEquiv M N\n⊢ Eq f.invFun ⇑f.symm","decl":"@[to_additive]\ntheorem invFun_eq_symm {f : M ≃ₜ* N} : f.invFun = f.symm := rfl\n\n"}
{"name":"ContinuousMulEquiv.invFun_eq_symm","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝³ : TopologicalSpace M\ninst✝² : TopologicalSpace N\ninst✝¹ : Mul M\ninst✝ : Mul N\nf : ContinuousMulEquiv M N\n⊢ Eq f.invFun ⇑f.symm","decl":"@[to_additive]\ntheorem invFun_eq_symm {f : M ≃ₜ* N} : f.invFun = f.symm := rfl\n\n"}
{"name":"ContinuousAddEquiv.coe_toHomeomorph_symm","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝³ : TopologicalSpace M\ninst✝² : TopologicalSpace N\ninst✝¹ : Add M\ninst✝ : Add N\nf : ContinuousAddEquiv M N\n⊢ Eq (↑f).symm ↑f.symm","decl":"@[to_additive (attr := simp)]\ntheorem coe_toHomeomorph_symm (f : M ≃ₜ* N) : (f : M ≃ₜ N).symm = (f.symm : N ≃ₜ M) := rfl\n\n"}
{"name":"ContinuousMulEquiv.coe_toHomeomorph_symm","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝³ : TopologicalSpace M\ninst✝² : TopologicalSpace N\ninst✝¹ : Mul M\ninst✝ : Mul N\nf : ContinuousMulEquiv M N\n⊢ Eq (↑f).symm ↑f.symm","decl":"@[to_additive (attr := simp)]\ntheorem coe_toHomeomorph_symm (f : M ≃ₜ* N) : (f : M ≃ₜ N).symm = (f.symm : N ≃ₜ M) := rfl\n\n"}
{"name":"ContinuousAddEquiv.equivLike_neg_eq_symm","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝³ : TopologicalSpace M\ninst✝² : TopologicalSpace N\ninst✝¹ : Add M\ninst✝ : Add N\nf : ContinuousAddEquiv M N\n⊢ Eq (EquivLike.inv f) ⇑f.symm","decl":"@[to_additive (attr := simp)]\ntheorem equivLike_inv_eq_symm (f : M ≃ₜ* N) : EquivLike.inv f = f.symm := rfl\n\n"}
{"name":"ContinuousMulEquiv.equivLike_inv_eq_symm","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝³ : TopologicalSpace M\ninst✝² : TopologicalSpace N\ninst✝¹ : Mul M\ninst✝ : Mul N\nf : ContinuousMulEquiv M N\n⊢ Eq (EquivLike.inv f) ⇑f.symm","decl":"@[to_additive (attr := simp)]\ntheorem equivLike_inv_eq_symm (f : M ≃ₜ* N) : EquivLike.inv f = f.symm := rfl\n\n"}
{"name":"ContinuousMulEquiv.symm_symm","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝³ : TopologicalSpace M\ninst✝² : TopologicalSpace N\ninst✝¹ : Mul M\ninst✝ : Mul N\nf : ContinuousMulEquiv M N\n⊢ Eq f.symm.symm f","decl":"@[to_additive (attr := simp)]\ntheorem symm_symm (f : M ≃ₜ* N) : f.symm.symm = f := rfl\n\n"}
{"name":"ContinuousAddEquiv.symm_symm","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝³ : TopologicalSpace M\ninst✝² : TopologicalSpace N\ninst✝¹ : Add M\ninst✝ : Add N\nf : ContinuousAddEquiv M N\n⊢ Eq f.symm.symm f","decl":"@[to_additive (attr := simp)]\ntheorem symm_symm (f : M ≃ₜ* N) : f.symm.symm = f := rfl\n\n"}
{"name":"ContinuousAddEquiv.apply_symm_apply","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝³ : TopologicalSpace M\ninst✝² : TopologicalSpace N\ninst✝¹ : Add M\ninst✝ : Add N\ne : ContinuousAddEquiv M N\ny : N\n⊢ Eq (e (e.symm y)) y","decl":"/-- `e.symm` is a right inverse of `e`, written as `e (e.symm y) = y`. -/\n@[to_additive (attr := simp) \"`e.symm` is a right inverse of `e`, written as `e (e.symm y) = y`.\"]\ntheorem apply_symm_apply (e : M ≃ₜ* N) (y : N) : e (e.symm y) = y :=\n  e.toEquiv.apply_symm_apply y\n\n"}
{"name":"ContinuousMulEquiv.apply_symm_apply","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝³ : TopologicalSpace M\ninst✝² : TopologicalSpace N\ninst✝¹ : Mul M\ninst✝ : Mul N\ne : ContinuousMulEquiv M N\ny : N\n⊢ Eq (e (e.symm y)) y","decl":"/-- `e.symm` is a right inverse of `e`, written as `e (e.symm y) = y`. -/\n@[to_additive (attr := simp) \"`e.symm` is a right inverse of `e`, written as `e (e.symm y) = y`.\"]\ntheorem apply_symm_apply (e : M ≃ₜ* N) (y : N) : e (e.symm y) = y :=\n  e.toEquiv.apply_symm_apply y\n\n"}
{"name":"ContinuousAddEquiv.symm_apply_apply","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝³ : TopologicalSpace M\ninst✝² : TopologicalSpace N\ninst✝¹ : Add M\ninst✝ : Add N\ne : ContinuousAddEquiv M N\nx : M\n⊢ Eq (e.symm (e x)) x","decl":"/-- `e.symm` is a left inverse of `e`, written as `e.symm (e y) = y`. -/\n@[to_additive (attr := simp) \"`e.symm` is a left inverse of `e`, written as `e.symm (e y) = y`.\"]\ntheorem symm_apply_apply (e : M ≃ₜ* N) (x : M) : e.symm (e x) = x :=\n  e.toEquiv.symm_apply_apply x\n\n"}
{"name":"ContinuousMulEquiv.symm_apply_apply","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝³ : TopologicalSpace M\ninst✝² : TopologicalSpace N\ninst✝¹ : Mul M\ninst✝ : Mul N\ne : ContinuousMulEquiv M N\nx : M\n⊢ Eq (e.symm (e x)) x","decl":"/-- `e.symm` is a left inverse of `e`, written as `e.symm (e y) = y`. -/\n@[to_additive (attr := simp) \"`e.symm` is a left inverse of `e`, written as `e.symm (e y) = y`.\"]\ntheorem symm_apply_apply (e : M ≃ₜ* N) (x : M) : e.symm (e x) = x :=\n  e.toEquiv.symm_apply_apply x\n\n"}
{"name":"ContinuousMulEquiv.symm_comp_self","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝³ : TopologicalSpace M\ninst✝² : TopologicalSpace N\ninst✝¹ : Mul M\ninst✝ : Mul N\ne : ContinuousMulEquiv M N\n⊢ Eq (Function.comp ⇑e.symm ⇑e) id","decl":"@[to_additive (attr := simp)]\ntheorem symm_comp_self (e : M ≃ₜ* N) : e.symm ∘ e = id :=\n  funext e.symm_apply_apply\n\n"}
{"name":"ContinuousAddEquiv.symm_comp_self","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝³ : TopologicalSpace M\ninst✝² : TopologicalSpace N\ninst✝¹ : Add M\ninst✝ : Add N\ne : ContinuousAddEquiv M N\n⊢ Eq (Function.comp ⇑e.symm ⇑e) id","decl":"@[to_additive (attr := simp)]\ntheorem symm_comp_self (e : M ≃ₜ* N) : e.symm ∘ e = id :=\n  funext e.symm_apply_apply\n\n"}
{"name":"ContinuousAddEquiv.self_comp_symm","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝³ : TopologicalSpace M\ninst✝² : TopologicalSpace N\ninst✝¹ : Add M\ninst✝ : Add N\ne : ContinuousAddEquiv M N\n⊢ Eq (Function.comp ⇑e ⇑e.symm) id","decl":"@[to_additive (attr := simp)]\ntheorem self_comp_symm (e : M ≃ₜ* N) : e ∘ e.symm = id :=\n  funext e.apply_symm_apply\n\n"}
{"name":"ContinuousMulEquiv.self_comp_symm","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝³ : TopologicalSpace M\ninst✝² : TopologicalSpace N\ninst✝¹ : Mul M\ninst✝ : Mul N\ne : ContinuousMulEquiv M N\n⊢ Eq (Function.comp ⇑e ⇑e.symm) id","decl":"@[to_additive (attr := simp)]\ntheorem self_comp_symm (e : M ≃ₜ* N) : e ∘ e.symm = id :=\n  funext e.apply_symm_apply\n\n"}
{"name":"ContinuousAddEquiv.apply_eq_iff_symm_apply","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝³ : TopologicalSpace M\ninst✝² : TopologicalSpace N\ninst✝¹ : Add M\ninst✝ : Add N\ne : ContinuousAddEquiv M N\nx : M\ny : N\n⊢ Iff (Eq (e x) y) (Eq x (e.symm y))","decl":"@[to_additive]\ntheorem apply_eq_iff_symm_apply (e : M ≃ₜ* N) {x : M} {y : N} : e x = y ↔ x = e.symm y :=\n  e.toEquiv.apply_eq_iff_eq_symm_apply\n\n"}
{"name":"ContinuousMulEquiv.apply_eq_iff_symm_apply","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝³ : TopologicalSpace M\ninst✝² : TopologicalSpace N\ninst✝¹ : Mul M\ninst✝ : Mul N\ne : ContinuousMulEquiv M N\nx : M\ny : N\n⊢ Iff (Eq (e x) y) (Eq x (e.symm y))","decl":"@[to_additive]\ntheorem apply_eq_iff_symm_apply (e : M ≃ₜ* N) {x : M} {y : N} : e x = y ↔ x = e.symm y :=\n  e.toEquiv.apply_eq_iff_eq_symm_apply\n\n"}
{"name":"ContinuousMulEquiv.symm_apply_eq","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝³ : TopologicalSpace M\ninst✝² : TopologicalSpace N\ninst✝¹ : Mul M\ninst✝ : Mul N\ne : ContinuousMulEquiv M N\nx : N\ny : M\n⊢ Iff (Eq (e.symm x) y) (Eq x (e y))","decl":"@[to_additive]\ntheorem symm_apply_eq (e : M ≃ₜ* N) {x y} : e.symm x = y ↔ x = e y :=\n  e.toEquiv.symm_apply_eq\n\n"}
{"name":"ContinuousAddEquiv.symm_apply_eq","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝³ : TopologicalSpace M\ninst✝² : TopologicalSpace N\ninst✝¹ : Add M\ninst✝ : Add N\ne : ContinuousAddEquiv M N\nx : N\ny : M\n⊢ Iff (Eq (e.symm x) y) (Eq x (e y))","decl":"@[to_additive]\ntheorem symm_apply_eq (e : M ≃ₜ* N) {x y} : e.symm x = y ↔ x = e y :=\n  e.toEquiv.symm_apply_eq\n\n"}
{"name":"ContinuousMulEquiv.eq_symm_apply","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝³ : TopologicalSpace M\ninst✝² : TopologicalSpace N\ninst✝¹ : Mul M\ninst✝ : Mul N\ne : ContinuousMulEquiv M N\nx : N\ny : M\n⊢ Iff (Eq y (e.symm x)) (Eq (e y) x)","decl":"@[to_additive]\ntheorem eq_symm_apply (e : M ≃ₜ* N) {x y} : y = e.symm x ↔ e y = x :=\n  e.toEquiv.eq_symm_apply\n\n"}
{"name":"ContinuousAddEquiv.eq_symm_apply","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝³ : TopologicalSpace M\ninst✝² : TopologicalSpace N\ninst✝¹ : Add M\ninst✝ : Add N\ne : ContinuousAddEquiv M N\nx : N\ny : M\n⊢ Iff (Eq y (e.symm x)) (Eq (e y) x)","decl":"@[to_additive]\ntheorem eq_symm_apply (e : M ≃ₜ* N) {x y} : y = e.symm x ↔ e y = x :=\n  e.toEquiv.eq_symm_apply\n\n"}
{"name":"ContinuousMulEquiv.eq_comp_symm","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝³ : TopologicalSpace M\ninst✝² : TopologicalSpace N\ninst✝¹ : Mul M\ninst✝ : Mul N\nα : Type u_3\ne : ContinuousMulEquiv M N\nf : N → α\ng : M → α\n⊢ Iff (Eq f (Function.comp g ⇑e.symm)) (Eq (Function.comp f ⇑e) g)","decl":"@[to_additive]\ntheorem eq_comp_symm {α : Type*} (e : M ≃ₜ* N) (f : N → α) (g : M → α) :\n    f = g ∘ e.symm ↔ f ∘ e = g :=\n  e.toEquiv.eq_comp_symm f g\n\n"}
{"name":"ContinuousAddEquiv.eq_comp_symm","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝³ : TopologicalSpace M\ninst✝² : TopologicalSpace N\ninst✝¹ : Add M\ninst✝ : Add N\nα : Type u_3\ne : ContinuousAddEquiv M N\nf : N → α\ng : M → α\n⊢ Iff (Eq f (Function.comp g ⇑e.symm)) (Eq (Function.comp f ⇑e) g)","decl":"@[to_additive]\ntheorem eq_comp_symm {α : Type*} (e : M ≃ₜ* N) (f : N → α) (g : M → α) :\n    f = g ∘ e.symm ↔ f ∘ e = g :=\n  e.toEquiv.eq_comp_symm f g\n\n"}
{"name":"ContinuousAddEquiv.comp_symm_eq","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝³ : TopologicalSpace M\ninst✝² : TopologicalSpace N\ninst✝¹ : Add M\ninst✝ : Add N\nα : Type u_3\ne : ContinuousAddEquiv M N\nf : N → α\ng : M → α\n⊢ Iff (Eq (Function.comp g ⇑e.symm) f) (Eq g (Function.comp f ⇑e))","decl":"@[to_additive]\ntheorem comp_symm_eq {α : Type*} (e : M ≃ₜ* N) (f : N → α) (g : M → α) :\n    g ∘ e.symm = f ↔ g = f ∘ e :=\n  e.toEquiv.comp_symm_eq f g\n\n"}
{"name":"ContinuousMulEquiv.comp_symm_eq","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝³ : TopologicalSpace M\ninst✝² : TopologicalSpace N\ninst✝¹ : Mul M\ninst✝ : Mul N\nα : Type u_3\ne : ContinuousMulEquiv M N\nf : N → α\ng : M → α\n⊢ Iff (Eq (Function.comp g ⇑e.symm) f) (Eq g (Function.comp f ⇑e))","decl":"@[to_additive]\ntheorem comp_symm_eq {α : Type*} (e : M ≃ₜ* N) (f : N → α) (g : M → α) :\n    g ∘ e.symm = f ↔ g = f ∘ e :=\n  e.toEquiv.comp_symm_eq f g\n\n"}
{"name":"ContinuousAddEquiv.eq_symm_comp","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝³ : TopologicalSpace M\ninst✝² : TopologicalSpace N\ninst✝¹ : Add M\ninst✝ : Add N\nα : Type u_3\ne : ContinuousAddEquiv M N\nf : α → M\ng : α → N\n⊢ Iff (Eq f (Function.comp (⇑e.symm) g)) (Eq (Function.comp (⇑e) f) g)","decl":"@[to_additive]\ntheorem eq_symm_comp {α : Type*} (e : M ≃ₜ* N) (f : α → M) (g : α → N) :\n    f = e.symm ∘ g ↔ e ∘ f = g :=\n  e.toEquiv.eq_symm_comp f g\n\n"}
{"name":"ContinuousMulEquiv.eq_symm_comp","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝³ : TopologicalSpace M\ninst✝² : TopologicalSpace N\ninst✝¹ : Mul M\ninst✝ : Mul N\nα : Type u_3\ne : ContinuousMulEquiv M N\nf : α → M\ng : α → N\n⊢ Iff (Eq f (Function.comp (⇑e.symm) g)) (Eq (Function.comp (⇑e) f) g)","decl":"@[to_additive]\ntheorem eq_symm_comp {α : Type*} (e : M ≃ₜ* N) (f : α → M) (g : α → N) :\n    f = e.symm ∘ g ↔ e ∘ f = g :=\n  e.toEquiv.eq_symm_comp f g\n\n"}
{"name":"ContinuousMulEquiv.symm_comp_eq","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝³ : TopologicalSpace M\ninst✝² : TopologicalSpace N\ninst✝¹ : Mul M\ninst✝ : Mul N\nα : Type u_3\ne : ContinuousMulEquiv M N\nf : α → M\ng : α → N\n⊢ Iff (Eq (Function.comp (⇑e.symm) g) f) (Eq g (Function.comp (⇑e) f))","decl":"@[to_additive]\ntheorem symm_comp_eq {α : Type*} (e : M ≃ₜ* N) (f : α → M) (g : α → N) :\n    e.symm ∘ g = f ↔ g = e ∘ f :=\n  e.toEquiv.symm_comp_eq f g\n\n"}
{"name":"ContinuousAddEquiv.symm_comp_eq","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝³ : TopologicalSpace M\ninst✝² : TopologicalSpace N\ninst✝¹ : Add M\ninst✝ : Add N\nα : Type u_3\ne : ContinuousAddEquiv M N\nf : α → M\ng : α → N\n⊢ Iff (Eq (Function.comp (⇑e.symm) g) f) (Eq g (Function.comp (⇑e) f))","decl":"@[to_additive]\ntheorem symm_comp_eq {α : Type*} (e : M ≃ₜ* N) (f : α → M) (g : α → N) :\n    e.symm ∘ g = f ↔ g = e ∘ f :=\n  e.toEquiv.symm_comp_eq f g\n\n"}
{"name":"ContinuousMulEquiv.coe_trans","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝⁵ : TopologicalSpace M\ninst✝⁴ : TopologicalSpace N\ninst✝³ : Mul M\ninst✝² : Mul N\nL : Type u_3\ninst✝¹ : Mul L\ninst✝ : TopologicalSpace L\ne₁ : ContinuousMulEquiv M N\ne₂ : ContinuousMulEquiv N L\n⊢ Eq (⇑(e₁.trans e₂)) (Function.comp ⇑e₂ ⇑e₁)","decl":"@[to_additive (attr := simp)]\ntheorem coe_trans (e₁ : M ≃ₜ* N) (e₂ : N ≃ₜ* L) : ↑(e₁.trans e₂) = e₂ ∘ e₁ := rfl\n\n"}
{"name":"ContinuousAddEquiv.coe_trans","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝⁵ : TopologicalSpace M\ninst✝⁴ : TopologicalSpace N\ninst✝³ : Add M\ninst✝² : Add N\nL : Type u_3\ninst✝¹ : Add L\ninst✝ : TopologicalSpace L\ne₁ : ContinuousAddEquiv M N\ne₂ : ContinuousAddEquiv N L\n⊢ Eq (⇑(e₁.trans e₂)) (Function.comp ⇑e₂ ⇑e₁)","decl":"@[to_additive (attr := simp)]\ntheorem coe_trans (e₁ : M ≃ₜ* N) (e₂ : N ≃ₜ* L) : ↑(e₁.trans e₂) = e₂ ∘ e₁ := rfl\n\n"}
{"name":"ContinuousMulEquiv.trans_apply","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝⁵ : TopologicalSpace M\ninst✝⁴ : TopologicalSpace N\ninst✝³ : Mul M\ninst✝² : Mul N\nL : Type u_3\ninst✝¹ : Mul L\ninst✝ : TopologicalSpace L\ne₁ : ContinuousMulEquiv M N\ne₂ : ContinuousMulEquiv N L\nm : M\n⊢ Eq ((e₁.trans e₂) m) (e₂ (e₁ m))","decl":"@[to_additive (attr := simp)]\ntheorem trans_apply (e₁ : M ≃ₜ* N) (e₂ : N ≃ₜ* L) (m : M) : e₁.trans e₂ m = e₂ (e₁ m) := rfl\n\n"}
{"name":"ContinuousAddEquiv.trans_apply","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝⁵ : TopologicalSpace M\ninst✝⁴ : TopologicalSpace N\ninst✝³ : Add M\ninst✝² : Add N\nL : Type u_3\ninst✝¹ : Add L\ninst✝ : TopologicalSpace L\ne₁ : ContinuousAddEquiv M N\ne₂ : ContinuousAddEquiv N L\nm : M\n⊢ Eq ((e₁.trans e₂) m) (e₂ (e₁ m))","decl":"@[to_additive (attr := simp)]\ntheorem trans_apply (e₁ : M ≃ₜ* N) (e₂ : N ≃ₜ* L) (m : M) : e₁.trans e₂ m = e₂ (e₁ m) := rfl\n\n"}
{"name":"ContinuousAddEquiv.symm_trans_apply","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝⁵ : TopologicalSpace M\ninst✝⁴ : TopologicalSpace N\ninst✝³ : Add M\ninst✝² : Add N\nL : Type u_3\ninst✝¹ : Add L\ninst✝ : TopologicalSpace L\ne₁ : ContinuousAddEquiv M N\ne₂ : ContinuousAddEquiv N L\nl : L\n⊢ Eq ((e₁.trans e₂).symm l) (e₁.symm (e₂.symm l))","decl":"@[to_additive (attr := simp)]\ntheorem symm_trans_apply (e₁ : M ≃ₜ* N) (e₂ : N ≃ₜ* L) (l : L) :\n    (e₁.trans e₂).symm l = e₁.symm (e₂.symm l) := rfl\n\n"}
{"name":"ContinuousMulEquiv.symm_trans_apply","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝⁵ : TopologicalSpace M\ninst✝⁴ : TopologicalSpace N\ninst✝³ : Mul M\ninst✝² : Mul N\nL : Type u_3\ninst✝¹ : Mul L\ninst✝ : TopologicalSpace L\ne₁ : ContinuousMulEquiv M N\ne₂ : ContinuousMulEquiv N L\nl : L\n⊢ Eq ((e₁.trans e₂).symm l) (e₁.symm (e₂.symm l))","decl":"@[to_additive (attr := simp)]\ntheorem symm_trans_apply (e₁ : M ≃ₜ* N) (e₂ : N ≃ₜ* L) (l : L) :\n    (e₁.trans e₂).symm l = e₁.symm (e₂.symm l) := rfl\n\n"}
{"name":"ContinuousMulEquiv.symm_trans_self","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝³ : TopologicalSpace M\ninst✝² : TopologicalSpace N\ninst✝¹ : Mul M\ninst✝ : Mul N\ne : ContinuousMulEquiv M N\n⊢ Eq (e.symm.trans e) (ContinuousMulEquiv.refl N)","decl":"@[to_additive (attr := simp)]\ntheorem symm_trans_self (e : M ≃ₜ* N) : e.symm.trans e = refl N :=\n  DFunLike.ext _ _ e.apply_symm_apply\n\n"}
{"name":"ContinuousAddEquiv.symm_trans_self","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝³ : TopologicalSpace M\ninst✝² : TopologicalSpace N\ninst✝¹ : Add M\ninst✝ : Add N\ne : ContinuousAddEquiv M N\n⊢ Eq (e.symm.trans e) (ContinuousAddEquiv.refl N)","decl":"@[to_additive (attr := simp)]\ntheorem symm_trans_self (e : M ≃ₜ* N) : e.symm.trans e = refl N :=\n  DFunLike.ext _ _ e.apply_symm_apply\n\n"}
{"name":"ContinuousMulEquiv.self_trans_symm","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝³ : TopologicalSpace M\ninst✝² : TopologicalSpace N\ninst✝¹ : Mul M\ninst✝ : Mul N\ne : ContinuousMulEquiv M N\n⊢ Eq (e.trans e.symm) (ContinuousMulEquiv.refl M)","decl":"@[to_additive (attr := simp)]\ntheorem self_trans_symm (e : M ≃ₜ* N) : e.trans e.symm = refl M :=\n  DFunLike.ext _ _ e.symm_apply_apply\n\n"}
{"name":"ContinuousAddEquiv.self_trans_symm","module":"Mathlib.Topology.Algebra.ContinuousMonoidHom","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝³ : TopologicalSpace M\ninst✝² : TopologicalSpace N\ninst✝¹ : Add M\ninst✝ : Add N\ne : ContinuousAddEquiv M N\n⊢ Eq (e.trans e.symm) (ContinuousAddEquiv.refl M)","decl":"@[to_additive (attr := simp)]\ntheorem self_trans_symm (e : M ≃ₜ* N) : e.trans e.symm = refl M :=\n  DFunLike.ext _ _ e.symm_apply_apply\n\n"}
