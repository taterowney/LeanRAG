{"name":"TopCat.Presheaf.restrictOpenCommRingCat_apply","module":"Mathlib.Topology.Sheaves.CommRingCat","initialProofState":"X : TopCat\nF : TopCat.Presheaf CommRingCat X\nV : TopologicalSpace.Opens ↑X\nf : ↑(F.obj { unop := V })\nU : TopologicalSpace.Opens ↑X\ne : autoParam (LE.le U V) _auto✝\n⊢ Eq (TopCat.Presheaf.restrictOpen f U ⋯) ((CategoryTheory.ConcreteCategory.hom (F.map (CategoryTheory.homOfLE e).op)) f)","decl":"open AlgebraicGeometry in\n/-- Unfold `restrictOpen` in the category of commutative rings (with the correct carrier type).\n\nAlthough unification hints help with applying `TopCat.Presheaf.restrictOpenCommRingCat`,\nso it can be safely de-specialized, this lemma needs to be kept to ensure rewrites go right.\n-/\nlemma restrictOpenCommRingCat_apply {X : TopCat}\n    {F : Presheaf CommRingCat X} {V : Opens ↑X} (f : CommRingCat.carrier (F.obj (op V)))\n    (U : Opens ↑X) (e : U ≤ V := by restrict_tac) :\n    f |_ U = F.map (homOfLE e).op f :=\n  rfl\n\n"}
{"name":"CommRingCat.presheaf_restrict_restrict","module":"Mathlib.Topology.Sheaves.CommRingCat","initialProofState":"X : TopCat\nF : TopCat.Presheaf CommRingCat X\nU V W : TopologicalSpace.Opens ↑X\ne₁ : autoParam (LE.le U V) _auto✝\ne₂ : autoParam (LE.le V W) _auto✝\nf : ↑(F.obj { unop := W })\n⊢ Eq (TopCat.Presheaf.restrictOpen (TopCat.Presheaf.restrictOpen f V ⋯) U ⋯) (TopCat.Presheaf.restrictOpen f U ⋯)","decl":"open AlgebraicGeometry in\n@[deprecated TopCat.Presheaf.restrict_restrict (since := \"2024-12-19\")]\nlemma _root_.CommRingCat.presheaf_restrict_restrict (X : TopCat)\n    {F : TopCat.Presheaf CommRingCat X}\n    {U V W : Opens ↑X} (e₁ : U ≤ V := by restrict_tac) (e₂ : V ≤ W := by restrict_tac)\n    (f : CommRingCat.carrier (F.obj (op W))) :\n    f |_ V |_ U = f |_ U :=\n  TopCat.Presheaf.restrict_restrict e₁ e₂ f\n\n"}
{"name":"TopCat.Presheaf.SubmonoidPresheaf.map","module":"Mathlib.Topology.Sheaves.CommRingCat","initialProofState":"X : TopCat\nF : TopCat.Presheaf CommRingCat X\nself : F.SubmonoidPresheaf\nU V : Opposite (TopologicalSpace.Opens ↑X)\ni : Quiver.Hom U V\n⊢ LE.le (self.obj U) (Submonoid.comap (CommRingCat.Hom.hom (F.map i)) (self.obj V))","decl":"/-- A subpresheaf with a submonoid structure on each of the components. -/\nstructure SubmonoidPresheaf (F : X.Presheaf CommRingCat) where\n  obj : ∀ U, Submonoid (F.obj U)\n  map : ∀ {U V : (Opens X)ᵒᵖ} (i : U ⟶ V), obj U ≤ (obj V).comap (F.map i).hom\n\n"}
{"name":"TopCat.Presheaf.SubmonoidPresheaf.mk.injEq","module":"Mathlib.Topology.Sheaves.CommRingCat","initialProofState":"X : TopCat\nF : TopCat.Presheaf CommRingCat X\nobj✝ : (U : Opposite (TopologicalSpace.Opens ↑X)) → Submonoid ↑(F.obj U)\nmap✝ : ∀ {U V : Opposite (TopologicalSpace.Opens ↑X)} (i : Quiver.Hom U V), LE.le (obj✝ U) (Submonoid.comap (CommRingCat.Hom.hom (F.map i)) (obj✝ V))\nobj : (U : Opposite (TopologicalSpace.Opens ↑X)) → Submonoid ↑(F.obj U)\nmap : ∀ {U V : Opposite (TopologicalSpace.Opens ↑X)} (i : Quiver.Hom U V), LE.le (obj U) (Submonoid.comap (CommRingCat.Hom.hom (F.map i)) (obj V))\n⊢ Eq (Eq { obj := obj✝, map := map✝ } { obj := obj, map := map }) (Eq obj✝ obj)","decl":"/-- A subpresheaf with a submonoid structure on each of the components. -/\nstructure SubmonoidPresheaf (F : X.Presheaf CommRingCat) where\n  obj : ∀ U, Submonoid (F.obj U)\n  map : ∀ {U V : (Opens X)ᵒᵖ} (i : U ⟶ V), obj U ≤ (obj V).comap (F.map i).hom\n\n"}
{"name":"TopCat.Presheaf.SubmonoidPresheaf.mk.sizeOf_spec","module":"Mathlib.Topology.Sheaves.CommRingCat","initialProofState":"X : TopCat\nF : TopCat.Presheaf CommRingCat X\nobj : (U : Opposite (TopologicalSpace.Opens ↑X)) → Submonoid ↑(F.obj U)\nmap : ∀ {U V : Opposite (TopologicalSpace.Opens ↑X)} (i : Quiver.Hom U V), LE.le (obj U) (Submonoid.comap (CommRingCat.Hom.hom (F.map i)) (obj V))\n⊢ Eq (SizeOf.sizeOf { obj := obj, map := map }) 1","decl":"/-- A subpresheaf with a submonoid structure on each of the components. -/\nstructure SubmonoidPresheaf (F : X.Presheaf CommRingCat) where\n  obj : ∀ U, Submonoid (F.obj U)\n  map : ∀ {U V : (Opens X)ᵒᵖ} (i : U ⟶ V), obj U ≤ (obj V).comap (F.map i).hom\n\n"}
{"name":"TopCat.Presheaf.SubmonoidPresheaf.mk.inj","module":"Mathlib.Topology.Sheaves.CommRingCat","initialProofState":"X : TopCat\nF : TopCat.Presheaf CommRingCat X\nobj✝ : (U : Opposite (TopologicalSpace.Opens ↑X)) → Submonoid ↑(F.obj U)\nmap✝ : ∀ {U V : Opposite (TopologicalSpace.Opens ↑X)} (i : Quiver.Hom U V), LE.le (obj✝ U) (Submonoid.comap (CommRingCat.Hom.hom (F.map i)) (obj✝ V))\nobj : (U : Opposite (TopologicalSpace.Opens ↑X)) → Submonoid ↑(F.obj U)\nmap : ∀ {U V : Opposite (TopologicalSpace.Opens ↑X)} (i : Quiver.Hom U V), LE.le (obj U) (Submonoid.comap (CommRingCat.Hom.hom (F.map i)) (obj V))\nx✝ : Eq { obj := obj✝, map := map✝ } { obj := obj, map := map }\n⊢ Eq obj✝ obj","decl":"/-- A subpresheaf with a submonoid structure on each of the components. -/\nstructure SubmonoidPresheaf (F : X.Presheaf CommRingCat) where\n  obj : ∀ U, Submonoid (F.obj U)\n  map : ∀ {U V : (Opens X)ᵒᵖ} (i : U ⟶ V), obj U ≤ (obj V).comap (F.map i).hom\n\n"}
{"name":"TopCat.Presheaf.instIsLocalizationCarrierObjOppositeOpensαTopologicalSpaceCommRingCatObjLocalizationPresheaf","module":"Mathlib.Topology.Sheaves.CommRingCat","initialProofState":"X : TopCat\nF : TopCat.Presheaf CommRingCat X\nG : F.SubmonoidPresheaf\nU : Opposite (TopologicalSpace.Opens ↑X)\n⊢ IsLocalization (G.obj U) ↑(G.localizationPresheaf.obj U)","decl":"instance (U) : IsLocalization (G.obj U) (G.localizationPresheaf.obj U) :=\n  show IsLocalization (G.obj U) (Localization (G.obj U)) from inferInstance\n\n"}
{"name":"TopCat.Presheaf.SubmonoidPresheaf.toLocalizationPresheaf_app","module":"Mathlib.Topology.Sheaves.CommRingCat","initialProofState":"X : TopCat\nF : TopCat.Presheaf CommRingCat X\nG : F.SubmonoidPresheaf\nU : Opposite (TopologicalSpace.Opens ↑X)\n⊢ Eq (G.toLocalizationPresheaf.app U) (CommRingCat.ofHom (algebraMap (↑(F.obj U)) (Localization (G.obj U))))","decl":"/-- The map into the localization presheaf. -/\n@[simps app]\ndef SubmonoidPresheaf.toLocalizationPresheaf : F ⟶ G.localizationPresheaf where\n  app U := CommRingCat.ofHom <| algebraMap (F.obj U) (Localization <| G.obj U)\n  naturality {_ _} i := CommRingCat.hom_ext <| (IsLocalization.map_comp (G.map i)).symm\n\n"}
{"name":"TopCat.Presheaf.epi_toLocalizationPresheaf","module":"Mathlib.Topology.Sheaves.CommRingCat","initialProofState":"X : TopCat\nF : TopCat.Presheaf CommRingCat X\nG : F.SubmonoidPresheaf\n⊢ CategoryTheory.Epi G.toLocalizationPresheaf","decl":"instance epi_toLocalizationPresheaf : Epi G.toLocalizationPresheaf :=\n  @NatTrans.epi_of_epi_app _ _ _ _ _ _ G.toLocalizationPresheaf fun U => Localization.epi' (G.obj U)\n\n"}
{"name":"TopCat.Presheaf.submonoidPresheafOfStalk_obj","module":"Mathlib.Topology.Sheaves.CommRingCat","initialProofState":"X : TopCat\nF : TopCat.Presheaf CommRingCat X\nS : (x : ↑X) → Submonoid ↑(F.stalk x)\nU : Opposite (TopologicalSpace.Opens ↑X)\n⊢ Eq ((F.submonoidPresheafOfStalk S).obj U) (iInf fun x => Submonoid.comap (CommRingCat.Hom.hom (F.germ (Opposite.unop U) ↑x ⋯)) (S ↑x))","decl":"/-- Given a submonoid at each of the stalks, we may define a submonoid presheaf consisting of\nsections whose restriction onto each stalk falls in the given submonoid. -/\n@[simps]\nnoncomputable def submonoidPresheafOfStalk (S : ∀ x : X, Submonoid (F.stalk x)) :\n    F.SubmonoidPresheaf where\n  obj U := ⨅ x : U.unop, Submonoid.comap (F.germ U.unop x.1 x.2).hom (S x)\n  map {U V} i := by\n    intro s hs\n    simp only [Submonoid.mem_comap, Submonoid.mem_iInf] at hs ⊢\n    intro x\n    change (F.map i.unop.op ≫ F.germ V.unop x.1 x.2) s ∈ _\n    rw [F.germ_res]\n    exact hs ⟨_, i.unop.le x.2⟩\n\n"}
{"name":"TopCat.Presheaf.instEpiCommRingCatToTotalQuotientPresheaf","module":"Mathlib.Topology.Sheaves.CommRingCat","initialProofState":"X : TopCat\nF : TopCat.Presheaf CommRingCat X\n⊢ CategoryTheory.Epi F.toTotalQuotientPresheaf","decl":"instance : Epi (toTotalQuotientPresheaf F) := epi_toLocalizationPresheaf _\n\n"}
{"name":"TopCat.Presheaf.instMonoCommRingCatToTotalQuotientPresheafPresheaf","module":"Mathlib.Topology.Sheaves.CommRingCat","initialProofState":"X : TopCat\nF : TopCat.Sheaf CommRingCat X\n⊢ CategoryTheory.Mono F.presheaf.toTotalQuotientPresheaf","decl":"instance (F : X.Sheaf CommRingCat.{w}) : Mono F.presheaf.toTotalQuotientPresheaf := by\n  -- Porting note: was an `apply (config := { instances := false })`\n  -- See https://github.com/leanprover/lean4/issues/2273\n  suffices ∀ (U : (Opens ↑X)ᵒᵖ), Mono (F.presheaf.toTotalQuotientPresheaf.app U) from\n    NatTrans.mono_of_mono_app _\n  intro U\n  apply ConcreteCategory.mono_of_injective\n  dsimp [toTotalQuotientPresheaf, CommRingCat.ofHom]\n  -- Porting note: this is a hack to make the `refine` below works\n  set m := _\n  change Function.Injective (algebraMap _ (Localization m))\n  change Function.Injective (algebraMap (F.presheaf.obj U) _)\n  haveI : IsLocalization _ (Localization m) := Localization.isLocalization\n  -- Porting note: `M` and `S` need to be specified manually, so used a hack to save some typing\n  refine IsLocalization.injective (M := m) (S := Localization m) ?_\n  intro s hs t e\n  apply section_ext F (unop U)\n  intro x hx\n  show (F.presheaf.germ (unop U) x hx) t = (F.presheaf.germ (unop U) x hx) 0\n  rw [RingHom.map_zero]\n  apply Submonoid.mem_iInf.mp hs ⟨x, hx⟩\n  rw [← map_mul, e, map_zero]\n\n"}
{"name":"TopCat.Presheaf.stalk_open_algebraMap","module":"Mathlib.Topology.Sheaves.CommRingCat","initialProofState":"X : TopCat\nF : TopCat.Presheaf CommRingCat X\nU : TopologicalSpace.Opens ↑X\nx : Subtype fun x => Membership.mem U x\n⊢ Eq (algebraMap ↑(F.obj { unop := U }) ↑(F.stalk ↑x)) (CommRingCat.Hom.hom (F.germ U ↑x ⋯))","decl":"@[simp]\ntheorem stalk_open_algebraMap {X : TopCat} (F : X.Presheaf CommRingCat) {U : Opens X} (x : U) :\n    algebraMap (F.obj <| op U) (F.stalk x) = (F.germ U x.1 x.2).hom :=\n  rfl\n\n"}
{"name":"TopCat.Sheaf.objSupIsoProdEqLocus_hom_fst","module":"Mathlib.Topology.Sheaves.CommRingCat","initialProofState":"X : TopCat\nF : TopCat.Sheaf CommRingCat X\nU V : TopologicalSpace.Opens ↑X\nx : ↑(F.val.obj { unop := Max.max U V })\n⊢ Eq (↑((CategoryTheory.ConcreteCategory.hom (F.objSupIsoProdEqLocus U V).hom) x)).1 ((CategoryTheory.ConcreteCategory.hom (F.val.map (CategoryTheory.homOfLE ⋯).op)) x)","decl":"theorem objSupIsoProdEqLocus_hom_fst {X : TopCat} (F : X.Sheaf CommRingCat) (U V : Opens X) (x) :\n    ((F.objSupIsoProdEqLocus U V).hom x).1.fst = F.1.map (homOfLE le_sup_left).op x :=\n  ConcreteCategory.congr_hom\n    ((F.isLimitPullbackCone U V).conePointUniqueUpToIso_hom_comp\n      (CommRingCat.pullbackConeIsLimit _ _) WalkingCospan.left)\n    x\n\n"}
{"name":"TopCat.Sheaf.objSupIsoProdEqLocus_hom_snd","module":"Mathlib.Topology.Sheaves.CommRingCat","initialProofState":"X : TopCat\nF : TopCat.Sheaf CommRingCat X\nU V : TopologicalSpace.Opens ↑X\nx : ↑(F.val.obj { unop := Max.max U V })\n⊢ Eq (↑((CategoryTheory.ConcreteCategory.hom (F.objSupIsoProdEqLocus U V).hom) x)).2 ((CategoryTheory.ConcreteCategory.hom (F.val.map (CategoryTheory.homOfLE ⋯).op)) x)","decl":"theorem objSupIsoProdEqLocus_hom_snd {X : TopCat} (F : X.Sheaf CommRingCat) (U V : Opens X) (x) :\n    ((F.objSupIsoProdEqLocus U V).hom x).1.snd = F.1.map (homOfLE le_sup_right).op x :=\n  ConcreteCategory.congr_hom\n    ((F.isLimitPullbackCone U V).conePointUniqueUpToIso_hom_comp\n      (CommRingCat.pullbackConeIsLimit _ _) WalkingCospan.right)\n    x\n\n"}
{"name":"TopCat.Sheaf.objSupIsoProdEqLocus_inv_fst","module":"Mathlib.Topology.Sheaves.CommRingCat","initialProofState":"X : TopCat\nF : TopCat.Sheaf CommRingCat X\nU V : TopologicalSpace.Opens ↑X\nx : ↑(CommRingCat.of (Subtype fun x => Membership.mem (((CommRingCat.Hom.hom (F.val.map (CategoryTheory.homOfLE ⋯).op)).comp (RingHom.fst ↑(F.val.obj { unop := U }) ↑(F.val.obj { unop := V }))).eqLocus ((CommRingCat.Hom.hom (F.val.map (CategoryTheory.homOfLE ⋯).op)).comp (RingHom.snd ↑(F.val.obj { unop := U }) ↑(F.val.obj { unop := V })))) x))\n⊢ Eq ((CategoryTheory.ConcreteCategory.hom (F.val.map (CategoryTheory.homOfLE ⋯).op)) ((CategoryTheory.ConcreteCategory.hom (F.objSupIsoProdEqLocus U V).inv) x)) (↑x).1","decl":"theorem objSupIsoProdEqLocus_inv_fst {X : TopCat} (F : X.Sheaf CommRingCat) (U V : Opens X) (x) :\n    F.1.map (homOfLE le_sup_left).op ((F.objSupIsoProdEqLocus U V).inv x) = x.1.1 :=\n  ConcreteCategory.congr_hom\n    ((F.isLimitPullbackCone U V).conePointUniqueUpToIso_inv_comp\n      (CommRingCat.pullbackConeIsLimit _ _) WalkingCospan.left)\n    x\n\n"}
{"name":"TopCat.Sheaf.objSupIsoProdEqLocus_inv_snd","module":"Mathlib.Topology.Sheaves.CommRingCat","initialProofState":"X : TopCat\nF : TopCat.Sheaf CommRingCat X\nU V : TopologicalSpace.Opens ↑X\nx : ↑(CommRingCat.of (Subtype fun x => Membership.mem (((CommRingCat.Hom.hom (F.val.map (CategoryTheory.homOfLE ⋯).op)).comp (RingHom.fst ↑(F.val.obj { unop := U }) ↑(F.val.obj { unop := V }))).eqLocus ((CommRingCat.Hom.hom (F.val.map (CategoryTheory.homOfLE ⋯).op)).comp (RingHom.snd ↑(F.val.obj { unop := U }) ↑(F.val.obj { unop := V })))) x))\n⊢ Eq ((CategoryTheory.ConcreteCategory.hom (F.val.map (CategoryTheory.homOfLE ⋯).op)) ((CategoryTheory.ConcreteCategory.hom (F.objSupIsoProdEqLocus U V).inv) x)) (↑x).2","decl":"theorem objSupIsoProdEqLocus_inv_snd {X : TopCat} (F : X.Sheaf CommRingCat) (U V : Opens X) (x) :\n    F.1.map (homOfLE le_sup_right).op ((F.objSupIsoProdEqLocus U V).inv x) = x.1.2 :=\n  ConcreteCategory.congr_hom\n    ((F.isLimitPullbackCone U V).conePointUniqueUpToIso_inv_comp\n      (CommRingCat.pullbackConeIsLimit _ _) WalkingCospan.right)\n    x\n\n"}
{"name":"TopCat.Sheaf.objSupIsoProdEqLocus_inv_eq_iff","module":"Mathlib.Topology.Sheaves.CommRingCat","initialProofState":"X : TopCat\nF : TopCat.Sheaf CommRingCat X\nU V W UW VW : TopologicalSpace.Opens ↑X\ne : LE.le W (Max.max U V)\nx : ↑(CommRingCat.of (Subtype fun x => Membership.mem (((CommRingCat.Hom.hom (F.val.map (CategoryTheory.homOfLE ⋯).op)).comp (RingHom.fst ↑(F.val.obj { unop := U }) ↑(F.val.obj { unop := V }))).eqLocus ((CommRingCat.Hom.hom (F.val.map (CategoryTheory.homOfLE ⋯).op)).comp (RingHom.snd ↑(F.val.obj { unop := U }) ↑(F.val.obj { unop := V })))) x))\ny : ↑(F.val.obj { unop := W })\nh₁ : Eq UW (Min.min U W)\nh₂ : Eq VW (Min.min V W)\n⊢ Iff (Eq ((CategoryTheory.ConcreteCategory.hom (F.val.map (CategoryTheory.homOfLE e).op)) ((CategoryTheory.ConcreteCategory.hom (F.objSupIsoProdEqLocus U V).inv) x)) y) (And (Eq ((CategoryTheory.ConcreteCategory.hom (F.val.map (CategoryTheory.homOfLE ⋯).op)) (↑x).1) ((CategoryTheory.ConcreteCategory.hom (F.val.map (CategoryTheory.homOfLE ⋯).op)) y)) (Eq ((CategoryTheory.ConcreteCategory.hom (F.val.map (CategoryTheory.homOfLE ⋯).op)) (↑x).2) ((CategoryTheory.ConcreteCategory.hom (F.val.map (CategoryTheory.homOfLE ⋯).op)) y)))","decl":"theorem objSupIsoProdEqLocus_inv_eq_iff {X : TopCat.{u}} (F : X.Sheaf CommRingCat.{u})\n    {U V W UW VW : Opens X} (e : W ≤ U ⊔ V) (x) (y : F.1.obj (op W))\n    (h₁ : UW = U ⊓ W) (h₂ : VW = V ⊓ W) :\n    F.1.map (homOfLE e).op ((F.objSupIsoProdEqLocus U V).inv x) = y ↔\n    F.1.map (homOfLE (h₁ ▸ inf_le_left : UW ≤ U)).op x.1.1 =\n      F.1.map (homOfLE <| h₁ ▸ inf_le_right).op y ∧\n    F.1.map (homOfLE (h₂ ▸ inf_le_left : VW ≤ V)).op x.1.2 =\n      F.1.map (homOfLE <| h₂ ▸ inf_le_right).op y := by\n  subst h₁ h₂\n  constructor\n  · rintro rfl\n    rw [← TopCat.Sheaf.objSupIsoProdEqLocus_inv_fst, ← TopCat.Sheaf.objSupIsoProdEqLocus_inv_snd]\n    -- `simp` doesn't see through the type equality of objects in `CommRingCat`, so use `rw` https://github.com/leanprover-community/mathlib4/pull/8386\n    repeat rw [← CommRingCat.comp_apply]\n    simp only [← Functor.map_comp, ← op_comp, Category.assoc, homOfLE_comp, and_self]\n  · rintro ⟨e₁, e₂⟩\n    refine F.eq_of_locally_eq₂\n      (homOfLE (inf_le_right : U ⊓ W ≤ W)) (homOfLE (inf_le_right : V ⊓ W ≤ W)) ?_ _ _ ?_ ?_\n    · rw [← inf_sup_right]\n      exact le_inf e le_rfl\n    · change (F.val.map _)\n        ((F.val.map (homOfLE e).op).hom ((F.objSupIsoProdEqLocus U V).inv.hom x)) = (F.val.map _) y\n      rw [← e₁, ← TopCat.Sheaf.objSupIsoProdEqLocus_inv_fst]\n      -- `simp` doesn't see through the type equality of objects in `CommRingCat`, so use `rw` https://github.com/leanprover-community/mathlib4/pull/8386\n      repeat rw [← CommRingCat.comp_apply]\n      simp only [← Functor.map_comp, ← op_comp, Category.assoc, homOfLE_comp]\n    · show (F.val.map _)\n        ((F.val.map (homOfLE e).op).hom ((F.objSupIsoProdEqLocus U V).inv.hom x)) = (F.val.map _) y\n      rw [← e₂, ← TopCat.Sheaf.objSupIsoProdEqLocus_inv_snd]\n      -- `simp` doesn't see through the type equality of objects in `CommRingCat`, so use `rw` https://github.com/leanprover-community/mathlib4/pull/8386\n      repeat rw [← CommRingCat.comp_apply]\n      simp only [← Functor.map_comp, ← op_comp, Category.assoc, homOfLE_comp]\n\n"}
