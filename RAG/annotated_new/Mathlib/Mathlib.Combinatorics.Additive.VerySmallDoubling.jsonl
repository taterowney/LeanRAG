{"name":"Finset.smul_stabilizer_of_no_doubling","module":"Mathlib.Combinatorics.Additive.VerySmallDoubling","initialProofState":"G : Type u_1\ninst✝¹ : Group G\ninst✝ : DecidableEq G\nA : Finset G\na : G\nhA : LE.le (HMul.hMul A A).card A.card\nha : Membership.mem A a\n⊢ Eq (HSMul.hSMul a ↑(MulAction.stabilizer G A)) ↑A","decl":"/-- A non-empty set with no doubling is the left translate of its stabilizer. -/\n@[to_additive \"A non-empty set with no doubling is the left-translate of its stabilizer.\"]\nlemma smul_stabilizer_of_no_doubling (hA : #(A * A) ≤ #A) (ha : a ∈ A) :\n    a •> (stabilizer G A : Set G) = A := (smul_stabilizer_of_no_doubling_aux hA ha).1\n\n"}
{"name":"Finset.vadd_stabilizer_of_no_doubling","module":"Mathlib.Combinatorics.Additive.VerySmallDoubling","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\ninst✝ : DecidableEq G\nA : Finset G\na : G\nhA : LE.le (HAdd.hAdd A A).card A.card\nha : Membership.mem A a\n⊢ Eq (HVAdd.hVAdd a ↑(AddAction.stabilizer G A)) ↑A","decl":"/-- A non-empty set with no doubling is the left translate of its stabilizer. -/\n@[to_additive \"A non-empty set with no doubling is the left-translate of its stabilizer.\"]\nlemma smul_stabilizer_of_no_doubling (hA : #(A * A) ≤ #A) (ha : a ∈ A) :\n    a •> (stabilizer G A : Set G) = A := (smul_stabilizer_of_no_doubling_aux hA ha).1\n\n"}
{"name":"Finset.op_vadd_stabilizer_of_no_doubling","module":"Mathlib.Combinatorics.Additive.VerySmallDoubling","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\ninst✝ : DecidableEq G\nA : Finset G\na : G\nhA : LE.le (HAdd.hAdd A A).card A.card\nha : Membership.mem A a\n⊢ Eq (HVAdd.hVAdd (AddOpposite.op a) ↑(AddAction.stabilizer G A)) ↑A","decl":"/-- A non-empty set with no doubling is the right translate of its stabilizer. -/\n@[to_additive \"A non-empty set with no doubling is the right translate of its stabilizer.\"]\nlemma op_smul_stabilizer_of_no_doubling (hA : #(A * A) ≤ #A) (ha : a ∈ A) :\n    (stabilizer G A : Set G) <• a = A := (smul_stabilizer_of_no_doubling_aux hA ha).2\n\n"}
{"name":"Finset.op_smul_stabilizer_of_no_doubling","module":"Mathlib.Combinatorics.Additive.VerySmallDoubling","initialProofState":"G : Type u_1\ninst✝¹ : Group G\ninst✝ : DecidableEq G\nA : Finset G\na : G\nhA : LE.le (HMul.hMul A A).card A.card\nha : Membership.mem A a\n⊢ Eq (HSMul.hSMul (MulOpposite.op a) ↑(MulAction.stabilizer G A)) ↑A","decl":"/-- A non-empty set with no doubling is the right translate of its stabilizer. -/\n@[to_additive \"A non-empty set with no doubling is the right translate of its stabilizer.\"]\nlemma op_smul_stabilizer_of_no_doubling (hA : #(A * A) ≤ #A) (ha : a ∈ A) :\n    (stabilizer G A : Set G) <• a = A := (smul_stabilizer_of_no_doubling_aux hA ha).2\n\n"}
{"name":"Finset.mul_inv_eq_inv_mul_of_doubling_lt_two","module":"Mathlib.Combinatorics.Additive.VerySmallDoubling","initialProofState":"G : Type u_1\ninst✝¹ : Group G\ninst✝ : DecidableEq G\nA : Finset G\nh : LT.lt (HMul.hMul A A).card (HMul.hMul 2 A.card)\n⊢ Eq (HMul.hMul A (Inv.inv A)) (HMul.hMul (Inv.inv A) A)","decl":"/-- If `A` has doubling strictly less than `2`, then `A * A⁻¹ = A⁻¹ * A`. -/\nlemma mul_inv_eq_inv_mul_of_doubling_lt_two (h : #(A * A) < 2 * #A) : A * A⁻¹ = A⁻¹ * A := by\n  refine Subset.antisymm ?_ (mul_inv_eq_inv_mul_of_doubling_lt_two_aux h)\n  simpa using\n    mul_inv_eq_inv_mul_of_doubling_lt_two_aux (A := A⁻¹) (by simpa [← mul_inv_rev] using h)\n\n"}
{"name":"Finset.invMulSubgroup_eq_inv_mul","module":"Mathlib.Combinatorics.Additive.VerySmallDoubling","initialProofState":"G : Type u_1\ninst✝¹ : Group G\ninst✝ : DecidableEq G\nA : Finset G\nh : LT.lt (↑(HMul.hMul A A).card) (HMul.hMul (3 / 2) ↑A.card)\n⊢ Eq (↑(A.invMulSubgroup h)) (HMul.hMul ↑(Inv.inv A) ↑A)","decl":"lemma invMulSubgroup_eq_inv_mul (A : Finset G) (h) : (invMulSubgroup A h : Set G) = A⁻¹ * A := rfl\n\n"}
{"name":"Finset.invMulSubgroup_eq_mul_inv","module":"Mathlib.Combinatorics.Additive.VerySmallDoubling","initialProofState":"G : Type u_1\ninst✝¹ : Group G\ninst✝ : DecidableEq G\nA : Finset G\nh : LT.lt (↑(HMul.hMul A A).card) (HMul.hMul (3 / 2) ↑A.card)\n⊢ Eq (↑(A.invMulSubgroup h)) (HMul.hMul ↑A ↑(Inv.inv A))","decl":"lemma invMulSubgroup_eq_mul_inv (A : Finset G) (h) : (invMulSubgroup A h : Set G) = A * A⁻¹ := by\n  rw [invMulSubgroup_eq_inv_mul, eq_comm]\n  norm_cast\n  exact mul_inv_eq_inv_mul_of_doubling_lt_two (by qify at h ⊢; linarith)\n\n"}
{"name":"Finset.smul_inv_mul_opSMul_eq_mul_of_doubling_lt_three_halves","module":"Mathlib.Combinatorics.Additive.VerySmallDoubling","initialProofState":"G : Type u_1\ninst✝¹ : Group G\ninst✝ : DecidableEq G\nA : Finset G\na : G\nh : LT.lt (↑(HMul.hMul A A).card) (HMul.hMul (3 / 2) ↑A.card)\nha : Membership.mem A a\n⊢ Eq (HSMul.hSMul a (HSMul.hSMul (MulOpposite.op a) (HMul.hMul (Inv.inv A) A))) (HMul.hMul A A)","decl":"open scoped RightActions in\nlemma smul_inv_mul_opSMul_eq_mul_of_doubling_lt_three_halves (h : #(A * A) < (3 / 2 : ℚ) * #A)\n    (ha : a ∈ A) : a •> ((A⁻¹ * A) <• a) = A * A :=\n  (subgroup_strong_bound_right h a ha).antisymm (subgroup_strong_bound_left h a ha)\n\n"}
{"name":"Finset.card_inv_mul_of_doubling_lt_three_halves","module":"Mathlib.Combinatorics.Additive.VerySmallDoubling","initialProofState":"G : Type u_1\ninst✝¹ : Group G\ninst✝ : DecidableEq G\nA : Finset G\nh : LT.lt (↑(HMul.hMul A A).card) (HMul.hMul (3 / 2) ↑A.card)\n⊢ Eq (HMul.hMul (Inv.inv A) A).card (HMul.hMul A A).card","decl":"lemma card_inv_mul_of_doubling_lt_three_halves (h : #(A * A) < (3 / 2 : ℚ) * #A) :\n    #(A⁻¹ * A) = #(A * A) := by\n  obtain ⟨a, ha⟩ := nonempty_of_doubling h\n  simp_rw [← smul_inv_mul_opSMul_eq_mul_of_doubling_lt_three_halves h ha, card_smul_finset]\n\n"}
{"name":"Finset.smul_inv_mul_eq_inv_mul_opSMul","module":"Mathlib.Combinatorics.Additive.VerySmallDoubling","initialProofState":"G : Type u_1\ninst✝¹ : Group G\ninst✝ : DecidableEq G\nA : Finset G\na : G\nh : LT.lt (↑(HMul.hMul A A).card) (HMul.hMul (3 / 2) ↑A.card)\nha : Membership.mem A a\n⊢ Eq (HSMul.hSMul a (HMul.hMul (Inv.inv A) A)) (HSMul.hSMul (MulOpposite.op a) (HMul.hMul (Inv.inv A) A))","decl":"lemma smul_inv_mul_eq_inv_mul_opSMul (h : #(A * A) < (3 / 2 : ℚ) * #A) (ha : a ∈ A) :\n    a •> (A⁻¹ * A) = (A⁻¹ * A) <• a := by\n  refine subset_antisymm ?_ ?_\n  · rw [subset_smul_finset_iff, ← op_inv]\n    calc\n      a •> (A⁻¹ * A) <• a⁻¹ ⊆ a •> (A⁻¹ * A) * A⁻¹ := op_smul_finset_subset_mul (by simpa)\n      _ ⊆ A * (A⁻¹ * A) * A⁻¹ := by gcongr; exact smul_finset_subset_mul (by simpa)\n      _ = A⁻¹ * A := by\n        simp_rw [← coe_inj, coe_mul]\n        rw [← mul_assoc, ← invMulSubgroup_eq_mul_inv _ h, mul_assoc,\n          ← invMulSubgroup_eq_mul_inv _ h, coe_mul_coe, invMulSubgroup_eq_inv_mul]\n  · rw [subset_smul_finset_iff]\n    calc\n      a⁻¹ •> ((A⁻¹ * A) <• a) ⊆ A⁻¹ * (A⁻¹ * A) <• a := smul_finset_subset_mul (by simpa)\n      _ ⊆ A⁻¹ * ((A⁻¹ * A) * A) := by gcongr; exact op_smul_finset_subset_mul (by simpa)\n      _ = A⁻¹ * A := by\n        rw [← mul_inv_eq_inv_mul_of_doubling_lt_two <| weaken_doubling h]\n        simp_rw [← coe_inj, coe_mul]\n        rw [mul_assoc, ← invMulSubgroup_eq_inv_mul _ h, ← mul_assoc,\n          ← invMulSubgroup_eq_inv_mul _ h, ← invMulSubgroup_eq_mul_inv _ h, coe_mul_coe]\n\n"}
{"name":"Finset.doubling_lt_three_halves","module":"Mathlib.Combinatorics.Additive.VerySmallDoubling","initialProofState":"G : Type u_1\ninst✝¹ : Group G\ninst✝ : DecidableEq G\nA : Finset G\nh : LT.lt (↑(HMul.hMul A A).card) (HMul.hMul (3 / 2) ↑A.card)\n⊢ Exists fun H => Exists fun x => And (LT.lt (↑(Fintype.card (Subtype fun x => Membership.mem H x))) (HMul.hMul (3 / 2) ↑A.card)) (∀ (a : G), Membership.mem A a → And (HasSubset.Subset (↑A) (HSMul.hSMul a ↑H)) (Eq (HSMul.hSMul a ↑H) (HSMul.hSMul (MulOpposite.op a) ↑H)))","decl":"open scoped RightActions in\n/-- If `A` has doubling strictly less than `3 / 2`, then there exists a subgroup `H` of the\nnormaliser of `A` of size strictly less than `3 / 2 * #A` such that `A` is a subset of a coset of\n`H` (in fact a subset of `a • H` for every `a ∈ A`).\n\nNote that this is sharp: `A = {0, 1}` in `ℤ` has doubling `3 / 2` and can't be covered by a subgroup\nof size at most `2`.\n\nThis is Theorem 2.2.1 in [tointon2020]. -/\ntheorem doubling_lt_three_halves (h : #(A * A) < (3 / 2 : ℚ) * #A) :\n    ∃ (H : Subgroup G) (_ : Fintype H), Fintype.card H < (3 / 2 : ℚ) * #A ∧ ∀ a ∈ A,\n      (A : Set G) ⊆ a • H ∧ a •> (H : Set G) = H <• a := by\n  let H := invMulSubgroup A h\n  refine ⟨H, inferInstance, ?_, fun a ha ↦ ⟨?_, ?_⟩⟩\n  · simp [← Nat.card_eq_fintype_card, invMulSubgroup, ← coe_mul, ← coe_inv, H]\n    rwa [Nat.card_eq_finsetCard, card_inv_mul_of_doubling_lt_three_halves h]\n  · rw [invMulSubgroup_eq_inv_mul]\n    exact_mod_cast A_subset_aH a ha\n  · simpa [H, invMulSubgroup_eq_inv_mul, ← coe_inv, ← coe_mul, ← coe_smul_finset]\n      using smul_inv_mul_eq_inv_mul_opSMul h ha\n\n"}
