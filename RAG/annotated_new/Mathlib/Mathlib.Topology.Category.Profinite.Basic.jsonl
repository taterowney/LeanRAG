{"name":"Profinite.instHasPropTotallyDisconnectedSpaceŒ±TopologicalSpace","module":"Mathlib.Topology.Category.Profinite.Basic","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TotallyDisconnectedSpace X\n‚ä¢ CompHausLike.HasProp (fun Y => TotallyDisconnectedSpace ‚ÜëY) X","decl":"instance (X : Type*) [TopologicalSpace X]\n    [TotallyDisconnectedSpace X] :  HasProp (fun Y ‚Ü¶ TotallyDisconnectedSpace Y) X :=\n  ‚ü®(inferInstance : TotallyDisconnectedSpace X)‚ü©\n\n"}
{"name":"Profinite.instTotallyDisconnectedSpaceŒ±TopologicalSpaceToTop","module":"Mathlib.Topology.Category.Profinite.Basic","initialProofState":"X : Profinite\n‚ä¢ TotallyDisconnectedSpace ‚ÜëX.toTop","decl":"instance {X : Profinite} : TotallyDisconnectedSpace X :=\n  X.prop\n\n"}
{"name":"Profinite.instTotallyDisconnectedSpaceObjForget","module":"Mathlib.Topology.Category.Profinite.Basic","initialProofState":"X : Profinite\n‚ä¢ TotallyDisconnectedSpace ((CategoryTheory.forget Profinite).obj X)","decl":"instance {X : Profinite} : TotallyDisconnectedSpace ((forget Profinite).obj X) := by\n  change TotallyDisconnectedSpace X\n  exact inferInstance\n\n"}
{"name":"instTotallyDisconnectedSpaceŒ±TopologicalSpaceToTopTrueObjProfiniteCompHausProfiniteToCompHaus","module":"Mathlib.Topology.Category.Profinite.Basic","initialProofState":"X : Profinite\n‚ä¢ TotallyDisconnectedSpace ‚Üë(profiniteToCompHaus.obj X).toTop","decl":"instance {X : Profinite} : TotallyDisconnectedSpace (profiniteToCompHaus.obj X) :=\n  X.prop\n\n"}
{"name":"CompHaus.toProfinite_obj'","module":"Mathlib.Topology.Category.Profinite.Basic","initialProofState":"X : CompHaus\n‚ä¢ Eq (‚Üë(CompHaus.toProfinite.obj X).toTop) (ConnectedComponents ‚ÜëX.toTop)","decl":"theorem CompHaus.toProfinite_obj' (X : CompHaus) :\n    ‚Ü•(CompHaus.toProfinite.obj X) = ConnectedComponents X :=\n  rfl\n\n"}
{"name":"FintypeCat.discreteTopology","module":"Mathlib.Topology.Category.Profinite.Basic","initialProofState":"A : FintypeCat\n‚ä¢ DiscreteTopology ‚ÜëA","decl":"theorem FintypeCat.discreteTopology (A : FintypeCat) : DiscreteTopology A :=\n  ‚ü®rfl‚ü©\n\n"}
{"name":"FintypeCat.toProfinite_map_apply","module":"Mathlib.Topology.Category.Profinite.Basic","initialProofState":"X‚úù Y‚úù : FintypeCat\nf : Quiver.Hom X‚úù Y‚úù\na‚úù : ‚ÜëX‚úù\n‚ä¢ Eq ((FintypeCat.toProfinite.map f) a‚úù) (f a‚úù)","decl":"/-- The natural functor from `Fintype` to `Profinite`, endowing a finite type with the\ndiscrete topology. -/\n@[simps -isSimp map_apply]\ndef FintypeCat.toProfinite : FintypeCat ‚•§ Profinite where\n  obj A := Profinite.of A\n  map f := ‚ü®f, by continuity‚ü©\n\n"}
{"name":"instFaithfulFintypeCatProfiniteToProfinite","module":"Mathlib.Topology.Category.Profinite.Basic","initialProofState":"‚ä¢ FintypeCat.toProfinite.Faithful","decl":"instance : FintypeCat.toProfinite.Faithful := FintypeCat.toProfiniteFullyFaithful.faithful\n\n"}
{"name":"instFullFintypeCatProfiniteToProfinite","module":"Mathlib.Topology.Category.Profinite.Basic","initialProofState":"‚ä¢ FintypeCat.toProfinite.Full","decl":"instance : FintypeCat.toProfinite.Full := FintypeCat.toProfiniteFullyFaithful.full\n\n"}
{"name":"Profinite.hasLimits","module":"Mathlib.Topology.Category.Profinite.Basic","initialProofState":"‚ä¢ CategoryTheory.Limits.HasLimits Profinite","decl":"instance hasLimits : Limits.HasLimits Profinite :=\n  hasLimits_of_hasLimits_createsLimits Profinite.toTopCat\n\n"}
{"name":"Profinite.hasColimits","module":"Mathlib.Topology.Category.Profinite.Basic","initialProofState":"‚ä¢ CategoryTheory.Limits.HasColimits Profinite","decl":"instance hasColimits : Limits.HasColimits Profinite :=\n  hasColimits_of_reflective profiniteToCompHaus\n\n"}
{"name":"Profinite.forget_preservesLimits","module":"Mathlib.Topology.Category.Profinite.Basic","initialProofState":"‚ä¢ CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget Profinite)","decl":"instance forget_preservesLimits : Limits.PreservesLimits (forget Profinite) := by\n  apply Limits.comp_preservesLimits Profinite.toTopCat (forget TopCat)\n\n"}
{"name":"Profinite.epi_iff_surjective","module":"Mathlib.Topology.Category.Profinite.Basic","initialProofState":"X Y : Profinite\nf : Quiver.Hom X Y\n‚ä¢ Iff (CategoryTheory.Epi f) (Function.Surjective ‚áëf)","decl":"theorem epi_iff_surjective {X Y : Profinite.{u}} (f : X ‚ü∂ Y) : Epi f ‚Üî Function.Surjective f := by\n  constructor\n  ¬∑ -- Porting note: in mathlib3 `contrapose` saw through `Function.Surjective`.\n    dsimp [Function.Surjective]\n    contrapose!\n    rintro ‚ü®y, hy‚ü© hf\n    let C := Set.range f\n    have hC : IsClosed C := (isCompact_range f.continuous).isClosed\n    let U := C·∂ú\n    have hyU : y ‚àà U := by\n      refine Set.mem_compl ?_\n      rintro ‚ü®y', hy'‚ü©\n      exact hy y' hy'\n    have hUy : U ‚àà ùìù y := hC.compl_mem_nhds hyU\n    obtain ‚ü®V, hV, hyV, hVU‚ü© := isTopologicalBasis_isClopen.mem_nhds_iff.mp hUy\n    classical\n      let Z := of (ULift.{u} <| Fin 2)\n      let g : Y ‚ü∂ Z := ‚ü®(LocallyConstant.ofIsClopen hV).map ULift.up, LocallyConstant.continuous _‚ü©\n      let h : Y ‚ü∂ Z := ‚ü®fun _ => ‚ü®1‚ü©, continuous_const‚ü©\n      have H : h = g := by\n        rw [‚Üê cancel_epi f]\n        ext x\n        apply ULift.ext\n        dsimp [g, LocallyConstant.ofIsClopen]\n        -- This used to be `rw`, but we need `erw` after https://github.com/leanprover/lean4/pull/2644\n        erw [CategoryTheory.comp_apply, ContinuousMap.coe_mk, CategoryTheory.comp_apply,\n          ContinuousMap.coe_mk, Function.comp_apply, if_neg]\n        refine mt (fun Œ± => hVU Œ±) ?_\n        simp only [U, C, Set.mem_range_self, not_true, not_false_iff, Set.mem_compl_iff]\n      apply_fun fun e => (e y).down at H\n      dsimp [g, LocallyConstant.ofIsClopen] at H\n      -- This used to be `rw`, but we need `erw` after https://github.com/leanprover/lean4/pull/2644\n      erw [ContinuousMap.coe_mk, ContinuousMap.coe_mk, Function.comp_apply, if_pos hyV] at H\n      exact top_ne_bot H\n  ¬∑ rw [‚Üê CategoryTheory.epi_iff_surjective]\n    apply (forget Profinite).epi_of_epi_map\n\n"}
