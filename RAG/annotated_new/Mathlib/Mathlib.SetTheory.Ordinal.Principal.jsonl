{"name":"Ordinal.principal_swap_iff","module":"Mathlib.SetTheory.Ordinal.Principal","initialProofState":"o : Ordinal.{u}\nop : Ordinal.{u} → Ordinal.{u} → Ordinal.{u}\n⊢ Iff (Ordinal.Principal (Function.swap op) o) (Ordinal.Principal op o)","decl":"theorem principal_swap_iff : Principal (Function.swap op) o ↔ Principal op o := by\n  constructor <;> exact fun h a b ha hb => h hb ha\n\n"}
{"name":"Ordinal.principal_iff_principal_swap","module":"Mathlib.SetTheory.Ordinal.Principal","initialProofState":"o : Ordinal.{u}\nop : Ordinal.{u} → Ordinal.{u} → Ordinal.{u}\n⊢ Iff (Ordinal.Principal op o) (Ordinal.Principal (Function.swap op) o)","decl":"@[deprecated principal_swap_iff (since := \"2024-08-18\")]\ntheorem principal_iff_principal_swap : Principal op o ↔ Principal (Function.swap op) o :=\n  principal_swap_iff\n\n"}
{"name":"Ordinal.not_principal_iff","module":"Mathlib.SetTheory.Ordinal.Principal","initialProofState":"o : Ordinal.{u}\nop : Ordinal.{u} → Ordinal.{u} → Ordinal.{u}\n⊢ Iff (Not (Ordinal.Principal op o)) (Exists fun a => And (LT.lt a o) (Exists fun b => And (LT.lt b o) (LE.le o (op a b))))","decl":"theorem not_principal_iff : ¬ Principal op o ↔ ∃ a < o, ∃ b < o, o ≤ op a b := by\n  simp [Principal]\n\n"}
{"name":"Ordinal.principal_iff_of_monotone","module":"Mathlib.SetTheory.Ordinal.Principal","initialProofState":"o : Ordinal.{u}\nop : Ordinal.{u} → Ordinal.{u} → Ordinal.{u}\nh₁ : ∀ (a : Ordinal.{u}), Monotone (op a)\nh₂ : ∀ (a : Ordinal.{u}), Monotone (Function.swap op a)\n⊢ Iff (Ordinal.Principal op o) (∀ (a : Ordinal.{u}), LT.lt a o → LT.lt (op a a) o)","decl":"theorem principal_iff_of_monotone\n    (h₁ : ∀ a, Monotone (op a)) (h₂ : ∀ a, Monotone (Function.swap op a)) :\n    Principal op o ↔ ∀ a < o, op a a < o := by\n  use fun h a ha => h ha ha\n  intro H a b ha hb\n  obtain hab | hba := le_or_lt a b\n  · exact (h₂ b hab).trans_lt <| H b hb\n  · exact (h₁ a hba.le).trans_lt <| H a ha\n\n"}
{"name":"Ordinal.not_principal_iff_of_monotone","module":"Mathlib.SetTheory.Ordinal.Principal","initialProofState":"o : Ordinal.{u}\nop : Ordinal.{u} → Ordinal.{u} → Ordinal.{u}\nh₁ : ∀ (a : Ordinal.{u}), Monotone (op a)\nh₂ : ∀ (a : Ordinal.{u}), Monotone (Function.swap op a)\n⊢ Iff (Not (Ordinal.Principal op o)) (Exists fun a => And (LT.lt a o) (LE.le o (op a a)))","decl":"theorem not_principal_iff_of_monotone\n    (h₁ : ∀ a, Monotone (op a)) (h₂ : ∀ a, Monotone (Function.swap op a)) :\n    ¬ Principal op o ↔ ∃ a < o, o ≤ op a a := by\n  simp [principal_iff_of_monotone h₁ h₂]\n\n"}
{"name":"Ordinal.principal_zero","module":"Mathlib.SetTheory.Ordinal.Principal","initialProofState":"op : Ordinal.{u_1} → Ordinal.{u_1} → Ordinal.{u_1}\n⊢ Ordinal.Principal op 0","decl":"theorem principal_zero : Principal op 0 := fun a _ h =>\n  (Ordinal.not_lt_zero a h).elim\n\n"}
{"name":"Ordinal.principal_one_iff","module":"Mathlib.SetTheory.Ordinal.Principal","initialProofState":"op : Ordinal.{u_1} → Ordinal.{u_1} → Ordinal.{u_1}\n⊢ Iff (Ordinal.Principal op 1) (Eq (op 0 0) 0)","decl":"@[simp]\ntheorem principal_one_iff : Principal op 1 ↔ op 0 0 = 0 := by\n  refine ⟨fun h => ?_, fun h a b ha hb => ?_⟩\n  · rw [← lt_one_iff_zero]\n    exact h zero_lt_one zero_lt_one\n  · rwa [lt_one_iff_zero, ha, hb] at *\n\n"}
{"name":"Ordinal.Principal.iterate_lt","module":"Mathlib.SetTheory.Ordinal.Principal","initialProofState":"a o : Ordinal.{u}\nop : Ordinal.{u} → Ordinal.{u} → Ordinal.{u}\nhao : LT.lt a o\nho : Ordinal.Principal op o\nn : Nat\n⊢ LT.lt (Nat.iterate (op a) n a) o","decl":"theorem Principal.iterate_lt (hao : a < o) (ho : Principal op o) (n : ℕ) : (op a)^[n] a < o := by\n  induction' n with n hn\n  · rwa [Function.iterate_zero]\n  · rw [Function.iterate_succ']\n    exact ho hao hn\n\n"}
{"name":"Ordinal.op_eq_self_of_principal","module":"Mathlib.SetTheory.Ordinal.Principal","initialProofState":"a o : Ordinal.{u}\nop : Ordinal.{u} → Ordinal.{u} → Ordinal.{u}\nhao : LT.lt a o\nH : Ordinal.IsNormal (op a)\nho : Ordinal.Principal op o\nho' : o.IsLimit\n⊢ Eq (op a o) o","decl":"theorem op_eq_self_of_principal (hao : a < o) (H : IsNormal (op a))\n    (ho : Principal op o) (ho' : IsLimit o) : op a o = o := by\n  apply H.le_apply.antisymm'\n  rw [← IsNormal.bsup_eq.{u, u} H ho', bsup_le_iff]\n  exact fun b hbo => (ho hao hbo).le\n\n"}
{"name":"Ordinal.nfp_le_of_principal","module":"Mathlib.SetTheory.Ordinal.Principal","initialProofState":"a o : Ordinal.{u}\nop : Ordinal.{u} → Ordinal.{u} → Ordinal.{u}\nhao : LT.lt a o\nho : Ordinal.Principal op o\n⊢ LE.le (Ordinal.nfp (op a) a) o","decl":"theorem nfp_le_of_principal (hao : a < o) (ho : Principal op o) : nfp (op a) a ≤ o :=\n  nfp_le fun n => (ho.iterate_lt hao n).le\n\n"}
{"name":"Ordinal.not_bddAbove_principal","module":"Mathlib.SetTheory.Ordinal.Principal","initialProofState":"op : Ordinal.{u_1} → Ordinal.{u_1} → Ordinal.{u_1}\n⊢ Not (BddAbove (setOf fun o => Ordinal.Principal op o))","decl":"/-- Principal ordinals under any operation are unbounded. -/\ntheorem not_bddAbove_principal (op : Ordinal → Ordinal → Ordinal) :\n    ¬ BddAbove { o | Principal op o } := by\n  rintro ⟨a, ha⟩\n  exact ((le_nfp _ _).trans (ha (principal_nfp_iSup op (succ a)))).not_lt (lt_succ a)\n\n"}
{"name":"Ordinal.principal_nfp_blsub₂","module":"Mathlib.SetTheory.Ordinal.Principal","initialProofState":"op : Ordinal.{u} → Ordinal.{u} → Ordinal.{u}\no : Ordinal.{u}\n⊢ Ordinal.Principal op (Ordinal.nfp (fun o' => o'.blsub₂ o' fun a x b x => op a b) o)","decl":"set_option linter.deprecated false in\n@[deprecated \"No deprecation message was provided.\" (since := \"2024-10-11\")]\ntheorem principal_nfp_blsub₂ (op : Ordinal → Ordinal → Ordinal) (o : Ordinal) :\n    Principal op (nfp (fun o' => blsub₂.{u, u, u} o' o' (@fun a _ b _ => op a b)) o) := by\n  intro a b ha hb\n  rw [lt_nfp] at *\n  cases' ha with m hm\n  cases' hb with n hn\n  cases' le_total\n    ((fun o' => blsub₂.{u, u, u} o' o' (@fun a _ b _ => op a b))^[m] o)\n    ((fun o' => blsub₂.{u, u, u} o' o' (@fun a _ b _ => op a b))^[n] o) with h h\n  · use n + 1\n    rw [Function.iterate_succ']\n    exact lt_blsub₂ (@fun a _ b _ => op a b) (hm.trans_le h) hn\n  · use m + 1\n    rw [Function.iterate_succ']\n    exact lt_blsub₂ (@fun a _ b _ => op a b) hm (hn.trans_le h)\n\n"}
{"name":"Ordinal.unbounded_principal","module":"Mathlib.SetTheory.Ordinal.Principal","initialProofState":"op : Ordinal.{u_1} → Ordinal.{u_1} → Ordinal.{u_1}\n⊢ Set.Unbounded (fun x1 x2 => LT.lt x1 x2) (setOf fun o => Ordinal.Principal op o)","decl":"set_option linter.deprecated false in\n@[deprecated \"No deprecation message was provided.\" (since := \"2024-10-11\")]\ntheorem unbounded_principal (op : Ordinal → Ordinal → Ordinal) :\n    Set.Unbounded (· < ·) { o | Principal op o } := fun o =>\n  ⟨_, principal_nfp_blsub₂ op o, (le_nfp _ o).not_lt⟩\n\n"}
{"name":"Ordinal.principal_add_one","module":"Mathlib.SetTheory.Ordinal.Principal","initialProofState":"⊢ Ordinal.Principal (fun x1 x2 => HAdd.hAdd x1 x2) 1","decl":"theorem principal_add_one : Principal (· + ·) 1 :=\n  principal_one_iff.2 <| zero_add 0\n\n"}
{"name":"Ordinal.principal_add_of_le_one","module":"Mathlib.SetTheory.Ordinal.Principal","initialProofState":"o : Ordinal.{u}\nho : LE.le o 1\n⊢ Ordinal.Principal (fun x1 x2 => HAdd.hAdd x1 x2) o","decl":"theorem principal_add_of_le_one (ho : o ≤ 1) : Principal (· + ·) o := by\n  rcases le_one_iff.1 ho with (rfl | rfl)\n  · exact principal_zero\n  · exact principal_add_one\n\n"}
{"name":"Ordinal.isLimit_of_principal_add","module":"Mathlib.SetTheory.Ordinal.Principal","initialProofState":"o : Ordinal.{u}\nho₁ : LT.lt 1 o\nho : Ordinal.Principal (fun x1 x2 => HAdd.hAdd x1 x2) o\n⊢ o.IsLimit","decl":"theorem isLimit_of_principal_add (ho₁ : 1 < o) (ho : Principal (· + ·) o) : o.IsLimit := by\n  rw [isLimit_iff, isSuccPrelimit_iff_succ_lt]\n  exact ⟨ho₁.ne_bot, fun _ ha ↦ ho ha ho₁⟩\n\n"}
{"name":"Ordinal.principal_add_isLimit","module":"Mathlib.SetTheory.Ordinal.Principal","initialProofState":"o : Ordinal.{u}\nho₁ : LT.lt 1 o\nho : Ordinal.Principal (fun x1 x2 => HAdd.hAdd x1 x2) o\n⊢ o.IsLimit","decl":"@[deprecated (since := \"2024-10-16\")]\nalias principal_add_isLimit := isLimit_of_principal_add\n\n"}
{"name":"Ordinal.principal_add_iff_add_left_eq_self","module":"Mathlib.SetTheory.Ordinal.Principal","initialProofState":"o : Ordinal.{u}\n⊢ Iff (Ordinal.Principal (fun x1 x2 => HAdd.hAdd x1 x2) o) (∀ (a : Ordinal.{u}), LT.lt a o → Eq (HAdd.hAdd a o) o)","decl":"theorem principal_add_iff_add_left_eq_self : Principal (· + ·) o ↔ ∀ a < o, a + o = o := by\n  refine ⟨fun ho a hao => ?_, fun h a b hao hbo => ?_⟩\n  · cases' lt_or_le 1 o with ho₁ ho₁\n    · exact op_eq_self_of_principal hao (isNormal_add_right a) ho (isLimit_of_principal_add ho₁ ho)\n    · rcases le_one_iff.1 ho₁ with (rfl | rfl)\n      · exact (Ordinal.not_lt_zero a hao).elim\n      · rw [lt_one_iff_zero] at hao\n        rw [hao, zero_add]\n  · rw [← h a hao]\n    exact (isNormal_add_right a).strictMono hbo\n\n"}
{"name":"Ordinal.exists_lt_add_of_not_principal_add","module":"Mathlib.SetTheory.Ordinal.Principal","initialProofState":"a : Ordinal.{u}\nha : Not (Ordinal.Principal (fun x1 x2 => HAdd.hAdd x1 x2) a)\n⊢ Exists fun b => And (LT.lt b a) (Exists fun c => And (LT.lt c a) (Eq (HAdd.hAdd b c) a))","decl":"theorem exists_lt_add_of_not_principal_add (ha : ¬ Principal (· + ·) a) :\n    ∃ b < a, ∃ c < a, b + c = a := by\n  rw [not_principal_iff] at ha\n  rcases ha with ⟨b, hb, c, hc, H⟩\n  refine\n    ⟨b, hb, _, lt_of_le_of_ne (sub_le_self a b) fun hab => ?_, Ordinal.add_sub_cancel_of_le hb.le⟩\n  rw [← sub_le, hab] at H\n  exact H.not_lt hc\n\n"}
{"name":"Ordinal.principal_add_iff_add_lt_ne_self","module":"Mathlib.SetTheory.Ordinal.Principal","initialProofState":"a : Ordinal.{u}\n⊢ Iff (Ordinal.Principal (fun x1 x2 => HAdd.hAdd x1 x2) a) (∀ (b : Ordinal.{u}), LT.lt b a → ∀ (c : Ordinal.{u}), LT.lt c a → Ne (HAdd.hAdd b c) a)","decl":"theorem principal_add_iff_add_lt_ne_self : Principal (· + ·) a ↔ ∀ b < a, ∀ c < a, b + c ≠ a :=\n  ⟨fun ha _ hb _ hc => (ha hb hc).ne, fun H => by\n    by_contra! ha\n    rcases exists_lt_add_of_not_principal_add ha with ⟨b, hb, c, hc, rfl⟩\n    exact (H b hb c hc).irrefl⟩\n\n"}
{"name":"Ordinal.principal_add_omega0","module":"Mathlib.SetTheory.Ordinal.Principal","initialProofState":"⊢ Ordinal.Principal (fun x1 x2 => HAdd.hAdd x1 x2) Ordinal.omega0","decl":"theorem principal_add_omega0 : Principal (· + ·) ω :=\n  principal_add_iff_add_left_eq_self.2 fun _ => add_omega0\n\n"}
{"name":"Ordinal.add_omega0_opow","module":"Mathlib.SetTheory.Ordinal.Principal","initialProofState":"a b : Ordinal.{u}\nh : LT.lt a (HPow.hPow Ordinal.omega0 b)\n⊢ Eq (HAdd.hAdd a (HPow.hPow Ordinal.omega0 b)) (HPow.hPow Ordinal.omega0 b)","decl":"theorem add_omega0_opow (h : a < ω ^ b) : a + ω ^ b = ω ^ b := by\n  refine le_antisymm ?_ (le_add_left _ a)\n  induction' b using limitRecOn with b _ b l IH\n  · rw [opow_zero, ← succ_zero, lt_succ_iff, Ordinal.le_zero] at h\n    rw [h, zero_add]\n  · rw [opow_succ] at h\n    rcases (lt_mul_of_limit isLimit_omega0).1 h with ⟨x, xo, ax⟩\n    apply (add_le_add_right ax.le _).trans\n    rw [opow_succ, ← mul_add, add_omega0 xo]\n  · rcases (lt_opow_of_limit omega0_ne_zero l).1 h with ⟨x, xb, ax⟩\n    apply (((isNormal_add_right a).trans <| isNormal_opow one_lt_omega0).limit_le l).2\n    intro y yb\n    calc a + ω ^ y ≤ a + ω ^ max x y :=\n      add_le_add_left (opow_le_opow_right omega0_pos (le_max_right x y)) _\n    _ ≤ ω ^ max x y :=\n      IH _ (max_lt xb yb) <| ax.trans_le <| opow_le_opow_right omega0_pos <| le_max_left x y\n    _ ≤ ω ^ b :=\n      opow_le_opow_right omega0_pos <| (max_lt xb yb).le\n\n"}
{"name":"Ordinal.add_omega_opow","module":"Mathlib.SetTheory.Ordinal.Principal","initialProofState":"a b : Ordinal.{u}\nh : LT.lt a (HPow.hPow Ordinal.omega0 b)\n⊢ Eq (HAdd.hAdd a (HPow.hPow Ordinal.omega0 b)) (HPow.hPow Ordinal.omega0 b)","decl":"@[deprecated (since := \"2024-09-30\")]\nalias add_omega_opow := add_omega0_opow\n\n"}
{"name":"Ordinal.principal_add_omega0_opow","module":"Mathlib.SetTheory.Ordinal.Principal","initialProofState":"o : Ordinal.{u_1}\n⊢ Ordinal.Principal (fun x1 x2 => HAdd.hAdd x1 x2) (HPow.hPow Ordinal.omega0 o)","decl":"theorem principal_add_omega0_opow (o : Ordinal) : Principal (· + ·) (ω ^ o) :=\n  principal_add_iff_add_left_eq_self.2 fun _ => add_omega0_opow\n\n"}
{"name":"Ordinal.principal_add_omega_opow","module":"Mathlib.SetTheory.Ordinal.Principal","initialProofState":"o : Ordinal.{u_1}\n⊢ Ordinal.Principal (fun x1 x2 => HAdd.hAdd x1 x2) (HPow.hPow Ordinal.omega0 o)","decl":"@[deprecated (since := \"2024-09-30\")]\nalias principal_add_omega_opow := principal_add_omega0_opow\n\n"}
{"name":"Ordinal.principal_add_iff_zero_or_omega0_opow","module":"Mathlib.SetTheory.Ordinal.Principal","initialProofState":"o : Ordinal.{u}\n⊢ Iff (Ordinal.Principal (fun x1 x2 => HAdd.hAdd x1 x2) o) (Or (Eq o 0) (Membership.mem (Set.range fun x => HPow.hPow Ordinal.omega0 x) o))","decl":"/-- The main characterization theorem for additive principal ordinals. -/\ntheorem principal_add_iff_zero_or_omega0_opow :\n    Principal (· + ·) o ↔ o = 0 ∨ o ∈ Set.range (ω ^ · : Ordinal → Ordinal) := by\n  rcases eq_or_ne o 0 with (rfl | ho)\n  · simp only [principal_zero, Or.inl]\n  · rw [principal_add_iff_add_left_eq_self]\n    simp only [ho, false_or]\n    refine\n      ⟨fun H => ⟨_, ((lt_or_eq_of_le (opow_log_le_self _ ho)).resolve_left fun h => ?_)⟩,\n        fun ⟨b, e⟩ => e.symm ▸ fun a => add_omega0_opow⟩\n    have := H _ h\n    have := lt_opow_succ_log_self one_lt_omega0 o\n    rw [opow_succ, lt_mul_of_limit isLimit_omega0] at this\n    rcases this with ⟨a, ao, h'⟩\n    rcases lt_omega0.1 ao with ⟨n, rfl⟩\n    clear ao\n    revert h'\n    apply not_lt_of_le\n    suffices e : ω ^ log ω o * n + o = o by\n      simpa only [e] using le_add_right (ω ^ log ω o * ↑n) o\n    induction' n with n IH\n    · simp [Nat.cast_zero, mul_zero, zero_add]\n    · simp only [Nat.cast_succ, mul_add_one, add_assoc, this, IH]\n\n"}
{"name":"Ordinal.principal_add_iff_zero_or_omega_opow","module":"Mathlib.SetTheory.Ordinal.Principal","initialProofState":"o : Ordinal.{u}\n⊢ Iff (Ordinal.Principal (fun x1 x2 => HAdd.hAdd x1 x2) o) (Or (Eq o 0) (Membership.mem (Set.range fun x => HPow.hPow Ordinal.omega0 x) o))","decl":"@[deprecated (since := \"2024-09-30\")]\nalias principal_add_iff_zero_or_omega_opow := principal_add_iff_zero_or_omega0_opow\n\n"}
{"name":"Ordinal.principal_add_opow_of_principal_add","module":"Mathlib.SetTheory.Ordinal.Principal","initialProofState":"a : Ordinal.{u_1}\nha : Ordinal.Principal (fun x1 x2 => HAdd.hAdd x1 x2) a\nb : Ordinal.{u_1}\n⊢ Ordinal.Principal (fun x1 x2 => HAdd.hAdd x1 x2) (HPow.hPow a b)","decl":"theorem principal_add_opow_of_principal_add {a} (ha : Principal (· + ·) a) (b : Ordinal) :\n    Principal (· + ·) (a ^ b) := by\n  rcases principal_add_iff_zero_or_omega0_opow.1 ha with (rfl | ⟨c, rfl⟩)\n  · rcases eq_or_ne b 0 with (rfl | hb)\n    · rw [opow_zero]\n      exact principal_add_one\n    · rwa [zero_opow hb]\n  · rw [← opow_mul]\n    exact principal_add_omega0_opow _\n\n"}
{"name":"Ordinal.opow_principal_add_of_principal_add","module":"Mathlib.SetTheory.Ordinal.Principal","initialProofState":"a : Ordinal.{u_1}\nha : Ordinal.Principal (fun x1 x2 => HAdd.hAdd x1 x2) a\nb : Ordinal.{u_1}\n⊢ Ordinal.Principal (fun x1 x2 => HAdd.hAdd x1 x2) (HPow.hPow a b)","decl":"@[deprecated (since := \"2024-10-16\")]\nalias opow_principal_add_of_principal_add := principal_add_opow_of_principal_add\n\n"}
{"name":"Ordinal.add_absorp","module":"Mathlib.SetTheory.Ordinal.Principal","initialProofState":"a b c : Ordinal.{u}\nh₁ : LT.lt a (HPow.hPow Ordinal.omega0 b)\nh₂ : LE.le (HPow.hPow Ordinal.omega0 b) c\n⊢ Eq (HAdd.hAdd a c) c","decl":"theorem add_absorp (h₁ : a < ω ^ b) (h₂ : ω ^ b ≤ c) : a + c = c := by\n  rw [← Ordinal.add_sub_cancel_of_le h₂, ← add_assoc, add_omega0_opow h₁]\n\n"}
{"name":"Ordinal.principal_add_mul_of_principal_add","module":"Mathlib.SetTheory.Ordinal.Principal","initialProofState":"a b : Ordinal.{u}\nhb₁ : Ne b 1\nhb : Ordinal.Principal (fun x1 x2 => HAdd.hAdd x1 x2) b\n⊢ Ordinal.Principal (fun x1 x2 => HAdd.hAdd x1 x2) (HMul.hMul a b)","decl":"theorem principal_add_mul_of_principal_add (a : Ordinal.{u}) {b : Ordinal.{u}} (hb₁ : b ≠ 1)\n    (hb : Principal (· + ·) b) : Principal (· + ·) (a * b) := by\n  rcases eq_zero_or_pos a with (rfl | _)\n  · rw [zero_mul]\n    exact principal_zero\n  · rcases eq_zero_or_pos b with (rfl | hb₁')\n    · rw [mul_zero]\n      exact principal_zero\n    · rw [← succ_le_iff, succ_zero] at hb₁'\n      intro c d hc hd\n      rw [lt_mul_of_limit (isLimit_of_principal_add (lt_of_le_of_ne hb₁' hb₁.symm) hb)] at *\n      rcases hc with ⟨x, hx, hx'⟩\n      rcases hd with ⟨y, hy, hy'⟩\n      use x + y, hb hx hy\n      rw [mul_add]\n      exact Left.add_lt_add hx' hy'\n\n"}
{"name":"Ordinal.mul_principal_add_is_principal_add","module":"Mathlib.SetTheory.Ordinal.Principal","initialProofState":"a b : Ordinal.{u}\nhb₁ : Ne b 1\nhb : Ordinal.Principal (fun x1 x2 => HAdd.hAdd x1 x2) b\n⊢ Ordinal.Principal (fun x1 x2 => HAdd.hAdd x1 x2) (HMul.hMul a b)","decl":"@[deprecated (since := \"2024-10-16\")]\nalias mul_principal_add_is_principal_add := principal_add_mul_of_principal_add\n\n"}
{"name":"Ordinal.principal_mul_one","module":"Mathlib.SetTheory.Ordinal.Principal","initialProofState":"⊢ Ordinal.Principal (fun x1 x2 => HMul.hMul x1 x2) 1","decl":"theorem principal_mul_one : Principal (· * ·) 1 := by\n  rw [principal_one_iff]\n  exact zero_mul _\n\n"}
{"name":"Ordinal.principal_mul_two","module":"Mathlib.SetTheory.Ordinal.Principal","initialProofState":"⊢ Ordinal.Principal (fun x1 x2 => HMul.hMul x1 x2) 2","decl":"theorem principal_mul_two : Principal (· * ·) 2 := by\n  intro a b ha hb\n  rw [← succ_one, lt_succ_iff] at *\n  convert mul_le_mul' ha hb\n  exact (mul_one 1).symm\n\n"}
{"name":"Ordinal.principal_mul_of_le_two","module":"Mathlib.SetTheory.Ordinal.Principal","initialProofState":"o : Ordinal.{u}\nho : LE.le o 2\n⊢ Ordinal.Principal (fun x1 x2 => HMul.hMul x1 x2) o","decl":"theorem principal_mul_of_le_two (ho : o ≤ 2) : Principal (· * ·) o := by\n  rcases lt_or_eq_of_le ho with (ho | rfl)\n  · rw [← succ_one, lt_succ_iff] at ho\n    rcases lt_or_eq_of_le ho with (ho | rfl)\n    · rw [lt_one_iff_zero.1 ho]\n      exact principal_zero\n    · exact principal_mul_one\n  · exact principal_mul_two\n\n"}
{"name":"Ordinal.principal_add_of_principal_mul","module":"Mathlib.SetTheory.Ordinal.Principal","initialProofState":"o : Ordinal.{u}\nho : Ordinal.Principal (fun x1 x2 => HMul.hMul x1 x2) o\nho₂ : Ne o 2\n⊢ Ordinal.Principal (fun x1 x2 => HAdd.hAdd x1 x2) o","decl":"theorem principal_add_of_principal_mul (ho : Principal (· * ·) o) (ho₂ : o ≠ 2) :\n    Principal (· + ·) o := by\n  cases' lt_or_gt_of_ne ho₂ with ho₁ ho₂\n  · replace ho₁ : o < succ 1 := by rwa [succ_one]\n    rw [lt_succ_iff] at ho₁\n    exact principal_add_of_le_one ho₁\n  · refine fun a b hao hbo => lt_of_le_of_lt ?_ (ho (max_lt hao hbo) ho₂)\n    dsimp only\n    rw [← one_add_one_eq_two, mul_add, mul_one]\n    exact add_le_add (le_max_left a b) (le_max_right a b)\n\n"}
{"name":"Ordinal.isLimit_of_principal_mul","module":"Mathlib.SetTheory.Ordinal.Principal","initialProofState":"o : Ordinal.{u}\nho₂ : LT.lt 2 o\nho : Ordinal.Principal (fun x1 x2 => HMul.hMul x1 x2) o\n⊢ o.IsLimit","decl":"theorem isLimit_of_principal_mul (ho₂ : 2 < o) (ho : Principal (· * ·) o) : o.IsLimit :=\n  isLimit_of_principal_add ((lt_succ 1).trans (succ_one ▸ ho₂))\n    (principal_add_of_principal_mul ho (ne_of_gt ho₂))\n\n"}
{"name":"Ordinal.principal_mul_isLimit","module":"Mathlib.SetTheory.Ordinal.Principal","initialProofState":"o : Ordinal.{u}\nho₂ : LT.lt 2 o\nho : Ordinal.Principal (fun x1 x2 => HMul.hMul x1 x2) o\n⊢ o.IsLimit","decl":"@[deprecated (since := \"2024-10-16\")]\nalias principal_mul_isLimit := isLimit_of_principal_mul\n\n"}
{"name":"Ordinal.principal_mul_iff_mul_left_eq","module":"Mathlib.SetTheory.Ordinal.Principal","initialProofState":"o : Ordinal.{u}\n⊢ Iff (Ordinal.Principal (fun x1 x2 => HMul.hMul x1 x2) o) (∀ (a : Ordinal.{u}), LT.lt 0 a → LT.lt a o → Eq (HMul.hMul a o) o)","decl":"theorem principal_mul_iff_mul_left_eq : Principal (· * ·) o ↔ ∀ a, 0 < a → a < o → a * o = o := by\n  refine ⟨fun h a ha₀ hao => ?_, fun h a b hao hbo => ?_⟩\n  · cases' le_or_gt o 2 with ho ho\n    · convert one_mul o\n      apply le_antisymm\n      · rw [← lt_succ_iff, succ_one]\n        exact hao.trans_le ho\n      · rwa [← succ_le_iff, succ_zero] at ha₀\n    · exact op_eq_self_of_principal hao (isNormal_mul_right ha₀) h (isLimit_of_principal_mul ho h)\n  · rcases eq_or_ne a 0 with (rfl | ha)\n    · dsimp only; rwa [zero_mul]\n    rw [← Ordinal.pos_iff_ne_zero] at ha\n    rw [← h a ha hao]\n    exact (isNormal_mul_right ha).strictMono hbo\n\n"}
{"name":"Ordinal.principal_mul_omega0","module":"Mathlib.SetTheory.Ordinal.Principal","initialProofState":"⊢ Ordinal.Principal (fun x1 x2 => HMul.hMul x1 x2) Ordinal.omega0","decl":"theorem principal_mul_omega0 : Principal (· * ·) ω := fun a b ha hb =>\n  match a, b, lt_omega0.1 ha, lt_omega0.1 hb with\n  | _, _, ⟨m, rfl⟩, ⟨n, rfl⟩ => by\n    dsimp only; rw [← natCast_mul]\n    apply nat_lt_omega0\n\n"}
{"name":"Ordinal.mul_omega0","module":"Mathlib.SetTheory.Ordinal.Principal","initialProofState":"a : Ordinal.{u}\na0 : LT.lt 0 a\nha : LT.lt a Ordinal.omega0\n⊢ Eq (HMul.hMul a Ordinal.omega0) Ordinal.omega0","decl":"theorem mul_omega0 (a0 : 0 < a) (ha : a < ω) : a * ω = ω :=\n  principal_mul_iff_mul_left_eq.1 principal_mul_omega0 a a0 ha\n\n"}
{"name":"Ordinal.mul_omega","module":"Mathlib.SetTheory.Ordinal.Principal","initialProofState":"a : Ordinal.{u}\na0 : LT.lt 0 a\nha : LT.lt a Ordinal.omega0\n⊢ Eq (HMul.hMul a Ordinal.omega0) Ordinal.omega0","decl":"@[deprecated (since := \"2024-09-30\")]\nalias mul_omega := mul_omega0\n\n"}
{"name":"Ordinal.natCast_mul_omega0","module":"Mathlib.SetTheory.Ordinal.Principal","initialProofState":"n : Nat\nhn : LT.lt 0 n\n⊢ Eq (HMul.hMul (↑n) Ordinal.omega0) Ordinal.omega0","decl":"theorem natCast_mul_omega0 {n : ℕ} (hn : 0 < n) : n * ω = ω :=\n  mul_omega0 (mod_cast hn) (nat_lt_omega0 n)\n\n"}
{"name":"Ordinal.mul_lt_omega0_opow","module":"Mathlib.SetTheory.Ordinal.Principal","initialProofState":"a b c : Ordinal.{u}\nc0 : LT.lt 0 c\nha : LT.lt a (HPow.hPow Ordinal.omega0 c)\nhb : LT.lt b Ordinal.omega0\n⊢ LT.lt (HMul.hMul a b) (HPow.hPow Ordinal.omega0 c)","decl":"theorem mul_lt_omega0_opow (c0 : 0 < c) (ha : a < ω ^ c) (hb : b < ω) : a * b < ω ^ c := by\n  rcases zero_or_succ_or_limit c with (rfl | ⟨c, rfl⟩ | l)\n  · exact (lt_irrefl _).elim c0\n  · rw [opow_succ] at ha\n    obtain ⟨n, hn, an⟩ :=\n      ((isNormal_mul_right <| opow_pos _ omega0_pos).limit_lt isLimit_omega0).1 ha\n    apply (mul_le_mul_right' (le_of_lt an) _).trans_lt\n    rw [opow_succ, mul_assoc, mul_lt_mul_iff_left (opow_pos _ omega0_pos)]\n    exact principal_mul_omega0 hn hb\n  · rcases ((isNormal_opow one_lt_omega0).limit_lt l).1 ha with ⟨x, hx, ax⟩\n    refine (mul_le_mul' (le_of_lt ax) (le_of_lt hb)).trans_lt ?_\n    rw [← opow_succ, opow_lt_opow_iff_right one_lt_omega0]\n    exact l.succ_lt hx\n\n"}
{"name":"Ordinal.mul_lt_omega_opow","module":"Mathlib.SetTheory.Ordinal.Principal","initialProofState":"a b c : Ordinal.{u}\nc0 : LT.lt 0 c\nha : LT.lt a (HPow.hPow Ordinal.omega0 c)\nhb : LT.lt b Ordinal.omega0\n⊢ LT.lt (HMul.hMul a b) (HPow.hPow Ordinal.omega0 c)","decl":"@[deprecated (since := \"2024-09-30\")]\nalias mul_lt_omega_opow := mul_lt_omega0_opow\n\n"}
{"name":"Ordinal.mul_omega0_opow_opow","module":"Mathlib.SetTheory.Ordinal.Principal","initialProofState":"a b : Ordinal.{u}\na0 : LT.lt 0 a\nh : LT.lt a (HPow.hPow Ordinal.omega0 (HPow.hPow Ordinal.omega0 b))\n⊢ Eq (HMul.hMul a (HPow.hPow Ordinal.omega0 (HPow.hPow Ordinal.omega0 b))) (HPow.hPow Ordinal.omega0 (HPow.hPow Ordinal.omega0 b))","decl":"theorem mul_omega0_opow_opow (a0 : 0 < a) (h : a < ω ^ ω ^ b) : a * ω ^ ω ^ b = ω ^ ω ^ b := by\n  obtain rfl | b0 := eq_or_ne b 0\n  · rw [opow_zero, opow_one] at h ⊢\n    exact mul_omega0 a0 h\n  · apply le_antisymm\n    · obtain ⟨x, xb, ax⟩ :=\n        (lt_opow_of_limit omega0_ne_zero (isLimit_opow_left isLimit_omega0 b0)).1 h\n      apply (mul_le_mul_right' (le_of_lt ax) _).trans\n      rw [← opow_add, add_omega0_opow xb]\n    · conv_lhs => rw [← one_mul (ω ^ _)]\n      exact mul_le_mul_right' (one_le_iff_pos.2 a0) _\n\n"}
{"name":"Ordinal.mul_omega_opow_opow","module":"Mathlib.SetTheory.Ordinal.Principal","initialProofState":"a b : Ordinal.{u}\na0 : LT.lt 0 a\nh : LT.lt a (HPow.hPow Ordinal.omega0 (HPow.hPow Ordinal.omega0 b))\n⊢ Eq (HMul.hMul a (HPow.hPow Ordinal.omega0 (HPow.hPow Ordinal.omega0 b))) (HPow.hPow Ordinal.omega0 (HPow.hPow Ordinal.omega0 b))","decl":"@[deprecated (since := \"2024-09-30\")]\nalias mul_omega_opow_opow := mul_omega0_opow_opow\n\n"}
{"name":"Ordinal.principal_mul_omega0_opow_opow","module":"Mathlib.SetTheory.Ordinal.Principal","initialProofState":"o : Ordinal.{u_1}\n⊢ Ordinal.Principal (fun x1 x2 => HMul.hMul x1 x2) (HPow.hPow Ordinal.omega0 (HPow.hPow Ordinal.omega0 o))","decl":"theorem principal_mul_omega0_opow_opow (o : Ordinal) : Principal (· * ·) (ω ^ ω ^ o) :=\n  principal_mul_iff_mul_left_eq.2 fun _ => mul_omega0_opow_opow\n\n"}
{"name":"Ordinal.principal_mul_omega_opow_opow","module":"Mathlib.SetTheory.Ordinal.Principal","initialProofState":"o : Ordinal.{u_1}\n⊢ Ordinal.Principal (fun x1 x2 => HMul.hMul x1 x2) (HPow.hPow Ordinal.omega0 (HPow.hPow Ordinal.omega0 o))","decl":"@[deprecated (since := \"2024-09-30\")]\nalias principal_mul_omega_opow_opow := principal_mul_omega0_opow_opow\n\n"}
{"name":"Ordinal.principal_add_of_principal_mul_opow","module":"Mathlib.SetTheory.Ordinal.Principal","initialProofState":"b o : Ordinal.{u}\nhb : LT.lt 1 b\nho : Ordinal.Principal (fun x1 x2 => HMul.hMul x1 x2) (HPow.hPow b o)\n⊢ Ordinal.Principal (fun x1 x2 => HAdd.hAdd x1 x2) o","decl":"theorem principal_add_of_principal_mul_opow (hb : 1 < b) (ho : Principal (· * ·) (b ^ o)) :\n    Principal (· + ·) o := by\n  intro x y hx hy\n  have := ho ((opow_lt_opow_iff_right hb).2 hx) ((opow_lt_opow_iff_right hb).2 hy)\n  dsimp only at *\n  rwa [← opow_add, opow_lt_opow_iff_right hb] at this\n\n"}
{"name":"Ordinal.principal_mul_iff_le_two_or_omega0_opow_opow","module":"Mathlib.SetTheory.Ordinal.Principal","initialProofState":"o : Ordinal.{u}\n⊢ Iff (Ordinal.Principal (fun x1 x2 => HMul.hMul x1 x2) o) (Or (LE.le o 2) (Membership.mem (Set.range fun x => HPow.hPow Ordinal.omega0 (HPow.hPow Ordinal.omega0 x)) o))","decl":"/-- The main characterization theorem for multiplicative principal ordinals. -/\ntheorem principal_mul_iff_le_two_or_omega0_opow_opow :\n    Principal (· * ·) o ↔ o ≤ 2 ∨ o ∈ Set.range (ω ^ ω ^ · : Ordinal → Ordinal) := by\n  refine ⟨fun ho => ?_, ?_⟩\n  · rcases le_or_lt o 2 with ho₂ | ho₂\n    · exact Or.inl ho₂\n    · rcases principal_add_iff_zero_or_omega0_opow.1 (principal_add_of_principal_mul ho ho₂.ne')\n        with (rfl | ⟨a, rfl⟩)\n      · exact (Ordinal.not_lt_zero 2 ho₂).elim\n      · rcases principal_add_iff_zero_or_omega0_opow.1\n          (principal_add_of_principal_mul_opow one_lt_omega0 ho) with (rfl | ⟨b, rfl⟩)\n        · simp\n        · exact Or.inr ⟨b, rfl⟩\n  · rintro (ho₂ | ⟨a, rfl⟩)\n    · exact principal_mul_of_le_two ho₂\n    · exact principal_mul_omega0_opow_opow a\n\n"}
{"name":"Ordinal.principal_mul_iff_le_two_or_omega_opow_opow","module":"Mathlib.SetTheory.Ordinal.Principal","initialProofState":"o : Ordinal.{u}\n⊢ Iff (Ordinal.Principal (fun x1 x2 => HMul.hMul x1 x2) o) (Or (LE.le o 2) (Membership.mem (Set.range fun x => HPow.hPow Ordinal.omega0 (HPow.hPow Ordinal.omega0 x)) o))","decl":"@[deprecated (since := \"2024-09-30\")]\nalias principal_mul_iff_le_two_or_omega_opow_opow := principal_mul_iff_le_two_or_omega0_opow_opow\n\n"}
{"name":"Ordinal.mul_omega0_dvd","module":"Mathlib.SetTheory.Ordinal.Principal","initialProofState":"a : Ordinal.{u}\na0 : LT.lt 0 a\nha : LT.lt a Ordinal.omega0\nb : Ordinal.{u}\na✝ : Dvd.dvd Ordinal.omega0 b\n⊢ Eq (HMul.hMul a b) b","decl":"theorem mul_omega0_dvd (a0 : 0 < a) (ha : a < ω) : ∀ {b}, ω ∣ b → a * b = b\n  | _, ⟨b, rfl⟩ => by rw [← mul_assoc, mul_omega0 a0 ha]\n\n"}
{"name":"Ordinal.mul_omega_dvd","module":"Mathlib.SetTheory.Ordinal.Principal","initialProofState":"a : Ordinal.{u}\na0 : LT.lt 0 a\nha : LT.lt a Ordinal.omega0\nb : Ordinal.{u}\na✝ : Dvd.dvd Ordinal.omega0 b\n⊢ Eq (HMul.hMul a b) b","decl":"@[deprecated (since := \"2024-09-30\")]\nalias mul_omega_dvd := mul_omega0_dvd\n\n"}
{"name":"Ordinal.mul_eq_opow_log_succ","module":"Mathlib.SetTheory.Ordinal.Principal","initialProofState":"a b : Ordinal.{u}\nha : Ne a 0\nhb : Ordinal.Principal (fun x1 x2 => HMul.hMul x1 x2) b\nhb₂ : LT.lt 2 b\n⊢ Eq (HMul.hMul a b) (HPow.hPow b (Order.succ (Ordinal.log b a)))","decl":"theorem mul_eq_opow_log_succ (ha : a ≠ 0) (hb : Principal (· * ·) b) (hb₂ : 2 < b) :\n    a * b = b ^ succ (log b a) := by\n  apply le_antisymm\n  · have hbl := isLimit_of_principal_mul hb₂ hb\n    rw [← (isNormal_mul_right (Ordinal.pos_iff_ne_zero.2 ha)).bsup_eq hbl, bsup_le_iff]\n    intro c hcb\n    have hb₁ : 1 < b := one_lt_two.trans hb₂\n    have hbo₀ : b ^ log b a ≠ 0 := Ordinal.pos_iff_ne_zero.1 (opow_pos _ (zero_lt_one.trans hb₁))\n    apply (mul_le_mul_right' (le_of_lt (lt_mul_succ_div a hbo₀)) c).trans\n    rw [mul_assoc, opow_succ]\n    refine mul_le_mul_left' (hb (hbl.succ_lt ?_) hcb).le _\n    rw [div_lt hbo₀, ← opow_succ]\n    exact lt_opow_succ_log_self hb₁ _\n  · rw [opow_succ]\n    exact mul_le_mul_right' (opow_log_le_self b ha) b\n\n"}
{"name":"Ordinal.principal_opow_omega0","module":"Mathlib.SetTheory.Ordinal.Principal","initialProofState":"⊢ Ordinal.Principal (fun x1 x2 => HPow.hPow x1 x2) Ordinal.omega0","decl":"theorem principal_opow_omega0 : Principal (· ^ ·) ω := fun a b ha hb =>\n  match a, b, lt_omega0.1 ha, lt_omega0.1 hb with\n  | _, _, ⟨m, rfl⟩, ⟨n, rfl⟩ => by\n    simp_rw [← natCast_opow]\n    apply nat_lt_omega0\n\n"}
{"name":"Ordinal.opow_omega0","module":"Mathlib.SetTheory.Ordinal.Principal","initialProofState":"a : Ordinal.{u}\na1 : LT.lt 1 a\nh : LT.lt a Ordinal.omega0\n⊢ Eq (HPow.hPow a Ordinal.omega0) Ordinal.omega0","decl":"theorem opow_omega0 (a1 : 1 < a) (h : a < ω) : a ^ ω = ω :=\n  ((opow_le_of_limit (one_le_iff_ne_zero.1 <| le_of_lt a1) isLimit_omega0).2 fun _ hb =>\n      (principal_opow_omega0 h hb).le).antisymm\n  (right_le_opow _ a1)\n\n"}
{"name":"Ordinal.opow_omega","module":"Mathlib.SetTheory.Ordinal.Principal","initialProofState":"a : Ordinal.{u}\na1 : LT.lt 1 a\nh : LT.lt a Ordinal.omega0\n⊢ Eq (HPow.hPow a Ordinal.omega0) Ordinal.omega0","decl":"@[deprecated (since := \"2024-09-30\")]\nalias opow_omega := opow_omega0\n\n"}
{"name":"Ordinal.natCast_opow_omega0","module":"Mathlib.SetTheory.Ordinal.Principal","initialProofState":"n : Nat\nhn : LT.lt 1 n\n⊢ Eq (HPow.hPow (↑n) Ordinal.omega0) Ordinal.omega0","decl":"theorem natCast_opow_omega0 {n : ℕ} (hn : 1 < n) : n ^ ω = ω :=\n  opow_omega0 (mod_cast hn) (nat_lt_omega0 n)\n\n"}
