{"name":"Real.log_of_ne_zero","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"x : Real\nhx : Ne x 0\n⊢ Eq (Real.log x) (Real.expOrderIso.symm ⟨abs x, ⋯⟩)","decl":"theorem log_of_ne_zero (hx : x ≠ 0) : log x = expOrderIso.symm ⟨|x|, abs_pos.2 hx⟩ :=\n  dif_neg hx\n\n"}
{"name":"Real.log_of_pos","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"x : Real\nhx : LT.lt 0 x\n⊢ Eq (Real.log x) (Real.expOrderIso.symm ⟨x, hx⟩)","decl":"theorem log_of_pos (hx : 0 < x) : log x = expOrderIso.symm ⟨x, hx⟩ := by\n  rw [log_of_ne_zero hx.ne']\n  congr\n  exact abs_of_pos hx\n\n"}
{"name":"Real.exp_log_eq_abs","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"x : Real\nhx : Ne x 0\n⊢ Eq (Real.exp (Real.log x)) (abs x)","decl":"theorem exp_log_eq_abs (hx : x ≠ 0) : exp (log x) = |x| := by\n  rw [log_of_ne_zero hx, ← coe_expOrderIso_apply, OrderIso.apply_symm_apply, Subtype.coe_mk]\n\n"}
{"name":"Real.exp_log","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"x : Real\nhx : LT.lt 0 x\n⊢ Eq (Real.exp (Real.log x)) x","decl":"theorem exp_log (hx : 0 < x) : exp (log x) = x := by\n  rw [exp_log_eq_abs hx.ne']\n  exact abs_of_pos hx\n\n"}
{"name":"Real.exp_log_of_neg","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"x : Real\nhx : LT.lt x 0\n⊢ Eq (Real.exp (Real.log x)) (Neg.neg x)","decl":"theorem exp_log_of_neg (hx : x < 0) : exp (log x) = -x := by\n  rw [exp_log_eq_abs (ne_of_lt hx)]\n  exact abs_of_neg hx\n\n"}
{"name":"Real.le_exp_log","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"x : Real\n⊢ LE.le x (Real.exp (Real.log x))","decl":"theorem le_exp_log (x : ℝ) : x ≤ exp (log x) := by\n  by_cases h_zero : x = 0\n  · rw [h_zero, log, dif_pos rfl, exp_zero]\n    exact zero_le_one\n  · rw [exp_log_eq_abs h_zero]\n    exact le_abs_self _\n\n"}
{"name":"Real.log_exp","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"x : Real\n⊢ Eq (Real.log (Real.exp x)) x","decl":"@[simp]\ntheorem log_exp (x : ℝ) : log (exp x) = x :=\n  exp_injective <| exp_log (exp_pos x)\n\n"}
{"name":"Real.surjOn_log","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"⊢ Set.SurjOn Real.log (Set.Ioi 0) Set.univ","decl":"theorem surjOn_log : SurjOn log (Ioi 0) univ := fun x _ => ⟨exp x, exp_pos x, log_exp x⟩\n\n"}
{"name":"Real.log_surjective","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"⊢ Function.Surjective Real.log","decl":"theorem log_surjective : Surjective log := fun x => ⟨exp x, log_exp x⟩\n\n"}
{"name":"Real.range_log","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"⊢ Eq (Set.range Real.log) Set.univ","decl":"@[simp]\ntheorem range_log : range log = univ :=\n  log_surjective.range_eq\n\n"}
{"name":"Real.log_zero","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"⊢ Eq (Real.log 0) 0","decl":"@[simp]\ntheorem log_zero : log 0 = 0 :=\n  dif_pos rfl\n\n"}
{"name":"Real.log_one","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"⊢ Eq (Real.log 1) 0","decl":"@[simp]\ntheorem log_one : log 1 = 0 :=\n  exp_injective <| by rw [exp_log zero_lt_one, exp_zero]\n\n"}
{"name":"Real.log_div_self","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"x : Real\n⊢ Eq (Real.log (HDiv.hDiv x x)) 0","decl":"/-- This holds true for all `x : \\` because of the junk values `0 / 0 = 0` and `arg 0 = 0`. -/\n@[simp] lemma log_div_self (x : ℝ) : log (x / x) = 0 := by\n  obtain rfl | hx := eq_or_ne x 0 <;> simp [*]\n\n"}
{"name":"Real.log_abs","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"x : Real\n⊢ Eq (Real.log (abs x)) (Real.log x)","decl":"@[simp]\ntheorem log_abs (x : ℝ) : log |x| = log x := by\n  by_cases h : x = 0\n  · simp [h]\n  · rw [← exp_eq_exp, exp_log_eq_abs h, exp_log_eq_abs (abs_pos.2 h).ne', abs_abs]\n\n"}
{"name":"Real.log_neg_eq_log","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"x : Real\n⊢ Eq (Real.log (Neg.neg x)) (Real.log x)","decl":"@[simp]\ntheorem log_neg_eq_log (x : ℝ) : log (-x) = log x := by rw [← log_abs x, ← log_abs (-x), abs_neg]\n\n"}
{"name":"Real.sinh_log","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"x : Real\nhx : LT.lt 0 x\n⊢ Eq (Real.sinh (Real.log x)) (HDiv.hDiv (HSub.hSub x (Inv.inv x)) 2)","decl":"theorem sinh_log {x : ℝ} (hx : 0 < x) : sinh (log x) = (x - x⁻¹) / 2 := by\n  rw [sinh_eq, exp_neg, exp_log hx]\n\n"}
{"name":"Real.cosh_log","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"x : Real\nhx : LT.lt 0 x\n⊢ Eq (Real.cosh (Real.log x)) (HDiv.hDiv (HAdd.hAdd x (Inv.inv x)) 2)","decl":"theorem cosh_log {x : ℝ} (hx : 0 < x) : cosh (log x) = (x + x⁻¹) / 2 := by\n  rw [cosh_eq, exp_neg, exp_log hx]\n\n"}
{"name":"Real.surjOn_log'","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"⊢ Set.SurjOn Real.log (Set.Iio 0) Set.univ","decl":"theorem surjOn_log' : SurjOn log (Iio 0) univ := fun x _ =>\n  ⟨-exp x, neg_lt_zero.2 <| exp_pos x, by rw [log_neg_eq_log, log_exp]⟩\n\n"}
{"name":"Real.log_mul","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"x y : Real\nhx : Ne x 0\nhy : Ne y 0\n⊢ Eq (Real.log (HMul.hMul x y)) (HAdd.hAdd (Real.log x) (Real.log y))","decl":"theorem log_mul (hx : x ≠ 0) (hy : y ≠ 0) : log (x * y) = log x + log y :=\n  exp_injective <| by\n    rw [exp_log_eq_abs (mul_ne_zero hx hy), exp_add, exp_log_eq_abs hx, exp_log_eq_abs hy, abs_mul]\n\n"}
{"name":"Real.log_div","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"x y : Real\nhx : Ne x 0\nhy : Ne y 0\n⊢ Eq (Real.log (HDiv.hDiv x y)) (HSub.hSub (Real.log x) (Real.log y))","decl":"theorem log_div (hx : x ≠ 0) (hy : y ≠ 0) : log (x / y) = log x - log y :=\n  exp_injective <| by\n    rw [exp_log_eq_abs (div_ne_zero hx hy), exp_sub, exp_log_eq_abs hx, exp_log_eq_abs hy, abs_div]\n\n"}
{"name":"Real.log_inv","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"x : Real\n⊢ Eq (Real.log (Inv.inv x)) (Neg.neg (Real.log x))","decl":"@[simp]\ntheorem log_inv (x : ℝ) : log x⁻¹ = -log x := by\n  by_cases hx : x = 0; · simp [hx]\n  rw [← exp_eq_exp, exp_log_eq_abs (inv_ne_zero hx), exp_neg, exp_log_eq_abs hx, abs_inv]\n\n"}
{"name":"Real.log_le_log_iff","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"x y : Real\nh : LT.lt 0 x\nh₁ : LT.lt 0 y\n⊢ Iff (LE.le (Real.log x) (Real.log y)) (LE.le x y)","decl":"theorem log_le_log_iff (h : 0 < x) (h₁ : 0 < y) : log x ≤ log y ↔ x ≤ y := by\n  rw [← exp_le_exp, exp_log h, exp_log h₁]\n\n"}
{"name":"Real.log_le_log","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"x y : Real\nhx : LT.lt 0 x\nhxy : LE.le x y\n⊢ LE.le (Real.log x) (Real.log y)","decl":"@[gcongr, bound]\nlemma log_le_log (hx : 0 < x) (hxy : x ≤ y) : log x ≤ log y :=\n  (log_le_log_iff hx (hx.trans_le hxy)).2 hxy\n\n"}
{"name":"Real.log_lt_log","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"x y : Real\nhx : LT.lt 0 x\nh : LT.lt x y\n⊢ LT.lt (Real.log x) (Real.log y)","decl":"@[gcongr, bound]\ntheorem log_lt_log (hx : 0 < x) (h : x < y) : log x < log y := by\n  rwa [← exp_lt_exp, exp_log hx, exp_log (lt_trans hx h)]\n\n"}
{"name":"Real.log_lt_log_iff","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"x y : Real\nhx : LT.lt 0 x\nhy : LT.lt 0 y\n⊢ Iff (LT.lt (Real.log x) (Real.log y)) (LT.lt x y)","decl":"theorem log_lt_log_iff (hx : 0 < x) (hy : 0 < y) : log x < log y ↔ x < y := by\n  rw [← exp_lt_exp, exp_log hx, exp_log hy]\n\n"}
{"name":"Real.log_le_iff_le_exp","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"x y : Real\nhx : LT.lt 0 x\n⊢ Iff (LE.le (Real.log x) y) (LE.le x (Real.exp y))","decl":"theorem log_le_iff_le_exp (hx : 0 < x) : log x ≤ y ↔ x ≤ exp y := by rw [← exp_le_exp, exp_log hx]\n\n"}
{"name":"Real.log_lt_iff_lt_exp","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"x y : Real\nhx : LT.lt 0 x\n⊢ Iff (LT.lt (Real.log x) y) (LT.lt x (Real.exp y))","decl":"theorem log_lt_iff_lt_exp (hx : 0 < x) : log x < y ↔ x < exp y := by rw [← exp_lt_exp, exp_log hx]\n\n"}
{"name":"Real.le_log_iff_exp_le","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"x y : Real\nhy : LT.lt 0 y\n⊢ Iff (LE.le x (Real.log y)) (LE.le (Real.exp x) y)","decl":"theorem le_log_iff_exp_le (hy : 0 < y) : x ≤ log y ↔ exp x ≤ y := by rw [← exp_le_exp, exp_log hy]\n\n"}
{"name":"Real.lt_log_iff_exp_lt","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"x y : Real\nhy : LT.lt 0 y\n⊢ Iff (LT.lt x (Real.log y)) (LT.lt (Real.exp x) y)","decl":"theorem lt_log_iff_exp_lt (hy : 0 < y) : x < log y ↔ exp x < y := by rw [← exp_lt_exp, exp_log hy]\n\n"}
{"name":"Real.log_pos_iff","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"x : Real\nhx : LE.le 0 x\n⊢ Iff (LT.lt 0 (Real.log x)) (LT.lt 1 x)","decl":"theorem log_pos_iff (hx : 0 ≤ x) : 0 < log x ↔ 1 < x := by\n  rcases hx.eq_or_lt with (rfl | hx)\n  · simp [le_refl, zero_le_one]\n  rw [← log_one]\n  exact log_lt_log_iff zero_lt_one hx\n\n"}
{"name":"Real.log_pos","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"x : Real\nhx : LT.lt 1 x\n⊢ LT.lt 0 (Real.log x)","decl":"@[bound]\ntheorem log_pos (hx : 1 < x) : 0 < log x :=\n  (log_pos_iff (lt_trans zero_lt_one hx).le).2 hx\n\n"}
{"name":"Real.log_pos_of_lt_neg_one","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"x : Real\nhx : LT.lt x (-1)\n⊢ LT.lt 0 (Real.log x)","decl":"theorem log_pos_of_lt_neg_one (hx : x < -1) : 0 < log x := by\n  rw [← neg_neg x, log_neg_eq_log]\n  have : 1 < -x := by linarith\n  exact log_pos this\n\n"}
{"name":"Real.log_neg_iff","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"x : Real\nh : LT.lt 0 x\n⊢ Iff (LT.lt (Real.log x) 0) (LT.lt x 1)","decl":"theorem log_neg_iff (h : 0 < x) : log x < 0 ↔ x < 1 := by\n  rw [← log_one]\n  exact log_lt_log_iff h zero_lt_one\n\n"}
{"name":"Real.log_neg","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"x : Real\nh0 : LT.lt 0 x\nh1 : LT.lt x 1\n⊢ LT.lt (Real.log x) 0","decl":"@[bound]\ntheorem log_neg (h0 : 0 < x) (h1 : x < 1) : log x < 0 :=\n  (log_neg_iff h0).2 h1\n\n"}
{"name":"Real.log_neg_of_lt_zero","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"x : Real\nh0 : LT.lt x 0\nh1 : LT.lt (-1) x\n⊢ LT.lt (Real.log x) 0","decl":"theorem log_neg_of_lt_zero (h0 : x < 0) (h1 : -1 < x) : log x < 0 := by\n  rw [← neg_neg x, log_neg_eq_log]\n  have h0' : 0 < -x := by linarith\n  have h1' : -x < 1 := by linarith\n  exact log_neg h0' h1'\n\n"}
{"name":"Real.log_nonneg_iff","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"x : Real\nhx : LT.lt 0 x\n⊢ Iff (LE.le 0 (Real.log x)) (LE.le 1 x)","decl":"theorem log_nonneg_iff (hx : 0 < x) : 0 ≤ log x ↔ 1 ≤ x := by rw [← not_lt, log_neg_iff hx, not_lt]\n\n"}
{"name":"Real.log_nonneg","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"x : Real\nhx : LE.le 1 x\n⊢ LE.le 0 (Real.log x)","decl":"@[bound]\ntheorem log_nonneg (hx : 1 ≤ x) : 0 ≤ log x :=\n  (log_nonneg_iff (zero_lt_one.trans_le hx)).2 hx\n\n"}
{"name":"Real.log_nonpos_iff","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"x : Real\nhx : LE.le 0 x\n⊢ Iff (LE.le (Real.log x) 0) (LE.le x 1)","decl":"theorem log_nonpos_iff (hx : 0 ≤ x) : log x ≤ 0 ↔ x ≤ 1 := by\n  rcases hx.eq_or_lt with (rfl | hx)\n  · simp [le_refl, zero_le_one]\n  rw [← not_lt, log_pos_iff hx.le, not_lt]\n\n"}
{"name":"Real.log_nonpos_iff'","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"x : Real\nhx : LE.le 0 x\n⊢ Iff (LE.le (Real.log x) 0) (LE.le x 1)","decl":"@[deprecated (since := \"2025-01-16\")]\nalias log_nonpos_iff' := log_nonpos_iff\n\n"}
{"name":"Real.log_nonpos","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"x : Real\nhx : LE.le 0 x\nh'x : LE.le x 1\n⊢ LE.le (Real.log x) 0","decl":"@[bound]\ntheorem log_nonpos (hx : 0 ≤ x) (h'x : x ≤ 1) : log x ≤ 0 :=\n  (log_nonpos_iff hx).2 h'x\n\n"}
{"name":"Real.log_natCast_nonneg","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"n : Nat\n⊢ LE.le 0 (Real.log ↑n)","decl":"theorem log_natCast_nonneg (n : ℕ) : 0 ≤ log n := by\n  if hn : n = 0 then\n    simp [hn]\n  else\n    have : (1 : ℝ) ≤ n := mod_cast Nat.one_le_of_lt <| Nat.pos_of_ne_zero hn\n    exact log_nonneg this\n\n"}
{"name":"Real.log_neg_natCast_nonneg","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"n : Nat\n⊢ LE.le 0 (Real.log (Neg.neg ↑n))","decl":"theorem log_neg_natCast_nonneg (n : ℕ) : 0 ≤ log (-n) := by\n  rw [← log_neg_eq_log, neg_neg]\n  exact log_natCast_nonneg _\n\n"}
{"name":"Real.log_intCast_nonneg","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"n : Int\n⊢ LE.le 0 (Real.log ↑n)","decl":"theorem log_intCast_nonneg (n : ℤ) : 0 ≤ log n := by\n  cases lt_trichotomy 0 n with\n  | inl hn =>\n      have : (1 : ℝ) ≤ n := mod_cast hn\n      exact log_nonneg this\n  | inr hn =>\n      cases hn with\n      | inl hn => simp [hn.symm]\n      | inr hn =>\n          have : (1 : ℝ) ≤ -n := by rw [← neg_zero, ← lt_neg] at hn; exact mod_cast hn\n          rw [← log_neg_eq_log]\n          exact log_nonneg this\n\n"}
{"name":"Real.strictMonoOn_log","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"⊢ StrictMonoOn Real.log (Set.Ioi 0)","decl":"theorem strictMonoOn_log : StrictMonoOn log (Set.Ioi 0) := fun _ hx _ _ hxy => log_lt_log hx hxy\n\n"}
{"name":"Real.strictAntiOn_log","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"⊢ StrictAntiOn Real.log (Set.Iio 0)","decl":"theorem strictAntiOn_log : StrictAntiOn log (Set.Iio 0) := by\n  rintro x (hx : x < 0) y (hy : y < 0) hxy\n  rw [← log_abs y, ← log_abs x]\n  refine log_lt_log (abs_pos.2 hy.ne) ?_\n  rwa [abs_of_neg hy, abs_of_neg hx, neg_lt_neg_iff]\n\n"}
{"name":"Real.log_injOn_pos","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"⊢ Set.InjOn Real.log (Set.Ioi 0)","decl":"theorem log_injOn_pos : Set.InjOn log (Set.Ioi 0) :=\n  strictMonoOn_log.injOn\n\n"}
{"name":"Real.log_lt_sub_one_of_pos","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"x : Real\nhx1 : LT.lt 0 x\nhx2 : Ne x 1\n⊢ LT.lt (Real.log x) (HSub.hSub x 1)","decl":"theorem log_lt_sub_one_of_pos (hx1 : 0 < x) (hx2 : x ≠ 1) : log x < x - 1 := by\n  have h : log x ≠ 0 := by\n    rwa [← log_one, log_injOn_pos.ne_iff hx1]\n    exact mem_Ioi.mpr zero_lt_one\n  linarith [add_one_lt_exp h, exp_log hx1]\n\n"}
{"name":"Real.eq_one_of_pos_of_log_eq_zero","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"x : Real\nh₁ : LT.lt 0 x\nh₂ : Eq (Real.log x) 0\n⊢ Eq x 1","decl":"theorem eq_one_of_pos_of_log_eq_zero {x : ℝ} (h₁ : 0 < x) (h₂ : log x = 0) : x = 1 :=\n  log_injOn_pos (Set.mem_Ioi.2 h₁) (Set.mem_Ioi.2 zero_lt_one) (h₂.trans Real.log_one.symm)\n\n"}
{"name":"Real.log_ne_zero_of_pos_of_ne_one","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"x : Real\nhx_pos : LT.lt 0 x\nhx : Ne x 1\n⊢ Ne (Real.log x) 0","decl":"theorem log_ne_zero_of_pos_of_ne_one {x : ℝ} (hx_pos : 0 < x) (hx : x ≠ 1) : log x ≠ 0 :=\n  mt (eq_one_of_pos_of_log_eq_zero hx_pos) hx\n\n"}
{"name":"Real.log_eq_zero","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"x : Real\n⊢ Iff (Eq (Real.log x) 0) (Or (Eq x 0) (Or (Eq x 1) (Eq x (-1))))","decl":"@[simp]\ntheorem log_eq_zero {x : ℝ} : log x = 0 ↔ x = 0 ∨ x = 1 ∨ x = -1 := by\n  constructor\n  · intro h\n    rcases lt_trichotomy x 0 with (x_lt_zero | rfl | x_gt_zero)\n    · refine Or.inr (Or.inr (neg_eq_iff_eq_neg.mp ?_))\n      rw [← log_neg_eq_log x] at h\n      exact eq_one_of_pos_of_log_eq_zero (neg_pos.mpr x_lt_zero) h\n    · exact Or.inl rfl\n    · exact Or.inr (Or.inl (eq_one_of_pos_of_log_eq_zero x_gt_zero h))\n  · rintro (rfl | rfl | rfl) <;> simp only [log_one, log_zero, log_neg_eq_log]\n\n"}
{"name":"Real.log_ne_zero","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"x : Real\n⊢ Iff (Ne (Real.log x) 0) (And (Ne x 0) (And (Ne x 1) (Ne x (-1))))","decl":"theorem log_ne_zero {x : ℝ} : log x ≠ 0 ↔ x ≠ 0 ∧ x ≠ 1 ∧ x ≠ -1 := by\n  simpa only [not_or] using log_eq_zero.not\n\n"}
{"name":"Real.log_pow","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"x : Real\nn : Nat\n⊢ Eq (Real.log (HPow.hPow x n)) (HMul.hMul (↑n) (Real.log x))","decl":"@[simp]\ntheorem log_pow (x : ℝ) (n : ℕ) : log (x ^ n) = n * log x := by\n  induction n with\n  | zero => simp\n  | succ n ih =>\n    rcases eq_or_ne x 0 with (rfl | hx)\n    · simp\n    · rw [pow_succ, log_mul (pow_ne_zero _ hx) hx, ih, Nat.cast_succ, add_mul, one_mul]\n\n"}
{"name":"Real.log_zpow","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"x : Real\nn : Int\n⊢ Eq (Real.log (HPow.hPow x n)) (HMul.hMul (↑n) (Real.log x))","decl":"@[simp]\ntheorem log_zpow (x : ℝ) (n : ℤ) : log (x ^ n) = n * log x := by\n  induction n\n  · rw [Int.ofNat_eq_coe, zpow_natCast, log_pow, Int.cast_natCast]\n  rw [zpow_negSucc, log_inv, log_pow, Int.cast_negSucc, Nat.cast_add_one, neg_mul_eq_neg_mul]\n\n"}
{"name":"Real.log_sqrt","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"x : Real\nhx : LE.le 0 x\n⊢ Eq (Real.log x.sqrt) (HDiv.hDiv (Real.log x) 2)","decl":"theorem log_sqrt {x : ℝ} (hx : 0 ≤ x) : log (√x) = log x / 2 := by\n  rw [eq_div_iff, mul_comm, ← Nat.cast_two, ← log_pow, sq_sqrt hx]\n  exact two_ne_zero\n\n"}
{"name":"Real.log_le_sub_one_of_pos","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"x : Real\nhx : LT.lt 0 x\n⊢ LE.le (Real.log x) (HSub.hSub x 1)","decl":"theorem log_le_sub_one_of_pos {x : ℝ} (hx : 0 < x) : log x ≤ x - 1 := by\n  rw [le_sub_iff_add_le]\n  convert add_one_le_exp (log x)\n  rw [exp_log hx]\n\n"}
{"name":"Real.one_sub_inv_le_log_of_pos","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"x : Real\nhx : LT.lt 0 x\n⊢ LE.le (HSub.hSub 1 (Inv.inv x)) (Real.log x)","decl":"lemma one_sub_inv_le_log_of_pos (hx : 0 < x) : 1 - x⁻¹ ≤ log x := by\n  simpa [add_comm] using log_le_sub_one_of_pos (inv_pos.2 hx)\n\n"}
{"name":"Real.log_le_self","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"x : Real\nhx : LE.le 0 x\n⊢ LE.le (Real.log x) x","decl":"/-- See `Real.log_le_sub_one_of_pos` for the stronger version when `x ≠ 0`. -/\nlemma log_le_self (hx : 0 ≤ x) : log x ≤ x := by\n  obtain rfl | hx := hx.eq_or_lt\n  · simp\n  · exact (log_le_sub_one_of_pos hx).trans (by linarith)\n\n"}
{"name":"Real.neg_inv_le_log","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"x : Real\nhx : LE.le 0 x\n⊢ LE.le (Neg.neg (Inv.inv x)) (Real.log x)","decl":"/-- See `Real.one_sub_inv_le_log_of_pos` for the stronger version when `x ≠ 0`. -/\nlemma neg_inv_le_log (hx : 0 ≤ x) : -x⁻¹ ≤ log x := by\n  rw [neg_le, ← log_inv]; exact log_le_self <| inv_nonneg.2 hx\n\n"}
{"name":"Real.abs_log_mul_self_lt","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"x : Real\nh1 : LT.lt 0 x\nh2 : LE.le x 1\n⊢ LT.lt (abs (HMul.hMul (Real.log x) x)) 1","decl":"/-- Bound for `|log x * x|` in the interval `(0, 1]`. -/\ntheorem abs_log_mul_self_lt (x : ℝ) (h1 : 0 < x) (h2 : x ≤ 1) : |log x * x| < 1 := by\n  have : 0 < 1 / x := by simpa only [one_div, inv_pos] using h1\n  replace := log_le_sub_one_of_pos this\n  replace : log (1 / x) < 1 / x := by linarith\n  rw [log_div one_ne_zero h1.ne', log_one, zero_sub, lt_div_iff₀ h1] at this\n  have aux : 0 ≤ -log x * x := by\n    refine mul_nonneg ?_ h1.le\n    rw [← log_inv]\n    apply log_nonneg\n    rw [← le_inv_comm₀ h1 zero_lt_one, inv_one]\n    exact h2\n  rw [← abs_of_nonneg aux, neg_mul, abs_neg] at this\n  exact this\n\n"}
{"name":"Real.tendsto_log_atTop","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"⊢ Filter.Tendsto Real.log Filter.atTop Filter.atTop","decl":"/-- The real logarithm function tends to `+∞` at `+∞`. -/\ntheorem tendsto_log_atTop : Tendsto log atTop atTop :=\n  tendsto_comp_exp_atTop.1 <| by simpa only [log_exp] using tendsto_id\n\n"}
{"name":"Real.tendsto_log_nhdsWithin_zero","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"⊢ Filter.Tendsto Real.log (nhdsWithin 0 (HasCompl.compl (Singleton.singleton 0))) Filter.atBot","decl":"theorem tendsto_log_nhdsWithin_zero : Tendsto log (𝓝[≠] 0) atBot := by\n  rw [← show _ = log from funext log_abs]\n  refine Tendsto.comp (g := log) ?_ tendsto_abs_nhdsWithin_zero\n  simpa [← tendsto_comp_exp_atBot] using tendsto_id\n\n"}
{"name":"Real.tendsto_log_nhdsWithin_zero_right","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"⊢ Filter.Tendsto Real.log (nhdsWithin 0 (Set.Ioi 0)) Filter.atBot","decl":"lemma tendsto_log_nhdsWithin_zero_right : Tendsto log (𝓝[>] 0) atBot :=\n  tendsto_log_nhdsWithin_zero.mono_left <| nhdsWithin_mono _ fun _ h ↦ ne_of_gt h\n\n"}
{"name":"Real.continuousOn_log","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"⊢ ContinuousOn Real.log (HasCompl.compl (Singleton.singleton 0))","decl":"theorem continuousOn_log : ContinuousOn log {0}ᶜ := by\n  simp (config := { unfoldPartialApp := true }) only [continuousOn_iff_continuous_restrict,\n    restrict]\n  conv in log _ => rw [log_of_ne_zero (show (x : ℝ) ≠ 0 from x.2)]\n  exact expOrderIso.symm.continuous.comp (continuous_subtype_val.norm.subtype_mk _)\n\n"}
{"name":"Real.continuous_log","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"⊢ Continuous fun x => Real.log ↑x","decl":"/-- The real logarithm is continuous as a function from nonzero reals. -/\n@[fun_prop]\ntheorem continuous_log : Continuous fun x : { x : ℝ // x ≠ 0 } => log x :=\n  continuousOn_iff_continuous_restrict.1 <| continuousOn_log.mono fun _ => id\n\n"}
{"name":"Real.continuous_log'","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"⊢ Continuous fun x => Real.log ↑x","decl":"/-- The real logarithm is continuous as a function from positive reals. -/\n@[fun_prop]\ntheorem continuous_log' : Continuous fun x : { x : ℝ // 0 < x } => log x :=\n  continuousOn_iff_continuous_restrict.1 <| continuousOn_log.mono fun _ hx => ne_of_gt hx\n\n"}
{"name":"Real.continuousAt_log","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"x : Real\nhx : Ne x 0\n⊢ ContinuousAt Real.log x","decl":"theorem continuousAt_log (hx : x ≠ 0) : ContinuousAt log x :=\n  (continuousOn_log x hx).continuousAt <| isOpen_compl_singleton.mem_nhds hx\n\n"}
{"name":"Real.continuousAt_log_iff","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"x : Real\n⊢ Iff (ContinuousAt Real.log x) (Ne x 0)","decl":"@[simp]\ntheorem continuousAt_log_iff : ContinuousAt log x ↔ x ≠ 0 := by\n  refine ⟨?_, continuousAt_log⟩\n  rintro h rfl\n  exact not_tendsto_nhds_of_tendsto_atBot tendsto_log_nhdsWithin_zero _\n    (h.tendsto.mono_left inf_le_left)\n\n"}
{"name":"Real.log_prod","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"α : Type u_1\ns : Finset α\nf : α → Real\nhf : ∀ (x : α), Membership.mem s x → Ne (f x) 0\n⊢ Eq (Real.log (s.prod fun i => f i)) (s.sum fun i => Real.log (f i))","decl":"theorem log_prod {α : Type*} (s : Finset α) (f : α → ℝ) (hf : ∀ x ∈ s, f x ≠ 0) :\n    log (∏ i ∈ s, f i) = ∑ i ∈ s, log (f i) := by\n  induction' s using Finset.cons_induction_on with a s ha ih\n  · simp\n  · rw [Finset.forall_mem_cons] at hf\n    simp [ih hf.2, log_mul hf.1 (Finset.prod_ne_zero_iff.2 hf.2)]\n\n"}
{"name":"Finsupp.log_prod","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : Zero β\nf : Finsupp α β\ng : α → β → Real\nhg : ∀ (a : α), Eq (g a (f a)) 0 → Eq (f a) 0\n⊢ Eq (Real.log (f.prod g)) (f.sum fun a b => Real.log (g a b))","decl":"protected theorem _root_.Finsupp.log_prod {α β : Type*} [Zero β] (f : α →₀ β) (g : α → β → ℝ)\n    (hg : ∀ a, g a (f a) = 0 → f a = 0) : log (f.prod g) = f.sum fun a b ↦ log (g a b) :=\n  log_prod _ _ fun _x hx h₀ ↦ Finsupp.mem_support_iff.1 hx <| hg _ h₀\n\n"}
{"name":"Real.log_nat_eq_sum_factorization","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"n : Nat\n⊢ Eq (Real.log ↑n) (n.factorization.sum fun p t => HMul.hMul (↑t) (Real.log ↑p))","decl":"theorem log_nat_eq_sum_factorization (n : ℕ) :\n    log n = n.factorization.sum fun p t => t * log p := by\n  rcases eq_or_ne n 0 with (rfl | hn)\n  · simp -- relies on junk values of `log` and `Nat.factorization`\n  · simp only [← log_pow, ← Nat.cast_pow]\n    rw [← Finsupp.log_prod, ← Nat.cast_finsupp_prod, Nat.factorization_prod_pow_eq_self hn]\n    intro p hp\n    rw [pow_eq_zero (Nat.cast_eq_zero.1 hp), Nat.factorization_zero_right]\n\n"}
{"name":"Real.tendsto_pow_log_div_mul_add_atTop","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"a b : Real\nn : Nat\nha : Ne a 0\n⊢ Filter.Tendsto (fun x => HDiv.hDiv (HPow.hPow (Real.log x) n) (HAdd.hAdd (HMul.hMul a x) b)) Filter.atTop (nhds 0)","decl":"theorem tendsto_pow_log_div_mul_add_atTop (a b : ℝ) (n : ℕ) (ha : a ≠ 0) :\n    Tendsto (fun x => log x ^ n / (a * x + b)) atTop (𝓝 0) :=\n  ((tendsto_div_pow_mul_exp_add_atTop a b n ha.symm).comp tendsto_log_atTop).congr' <| by\n    filter_upwards [eventually_gt_atTop (0 : ℝ)] with x hx using by simp [exp_log hx]\n\n"}
{"name":"Real.isLittleO_pow_log_id_atTop","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"n : Nat\n⊢ Asymptotics.IsLittleO Filter.atTop (fun x => HPow.hPow (Real.log x) n) id","decl":"theorem isLittleO_pow_log_id_atTop {n : ℕ} : (fun x => log x ^ n) =o[atTop] id := by\n  rw [Asymptotics.isLittleO_iff_tendsto']\n  · simpa using tendsto_pow_log_div_mul_add_atTop 1 0 n one_ne_zero\n  filter_upwards [eventually_ne_atTop (0 : ℝ)] with x h₁ h₂ using (h₁ h₂).elim\n\n"}
{"name":"Real.isLittleO_log_id_atTop","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"⊢ Asymptotics.IsLittleO Filter.atTop Real.log id","decl":"theorem isLittleO_log_id_atTop : log =o[atTop] id :=\n  isLittleO_pow_log_id_atTop.congr_left fun _ => pow_one _\n\n"}
{"name":"Real.isLittleO_const_log_atTop","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"c : Real\n⊢ Asymptotics.IsLittleO Filter.atTop (fun x => c) Real.log","decl":"theorem isLittleO_const_log_atTop {c : ℝ} : (fun _ => c) =o[atTop] log := by\n  refine Asymptotics.isLittleO_of_tendsto' ?_\n    <| Tendsto.div_atTop (a := c) (by simp) tendsto_log_atTop\n  filter_upwards [eventually_gt_atTop 1] with x hx\n  aesop (add safe forward log_pos)\n\n"}
{"name":"Real.expPartialHomeomorph_source","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"⊢ Eq Real.expPartialHomeomorph.source Set.univ","decl":"/-- `Real.exp` as a `PartialHomeomorph` with `source = univ` and `target = {z | 0 < z}`. -/\n@[simps] noncomputable def expPartialHomeomorph : PartialHomeomorph ℝ ℝ where\n  toFun := Real.exp\n  invFun := Real.log\n  source := univ\n  target := Ioi (0 : ℝ)\n  map_source' x _ := exp_pos x\n  map_target' _ _ := mem_univ _\n  left_inv' _ _ := by simp\n  right_inv' _ hx := exp_log hx\n  open_source := isOpen_univ\n  open_target := isOpen_Ioi\n  continuousOn_toFun := continuousOn_exp\n  continuousOn_invFun x hx := (continuousAt_log (ne_of_gt hx)).continuousWithinAt\n\n"}
{"name":"Real.expPartialHomeomorph_apply","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"x : Real\n⊢ Eq (↑Real.expPartialHomeomorph x) (Real.exp x)","decl":"/-- `Real.exp` as a `PartialHomeomorph` with `source = univ` and `target = {z | 0 < z}`. -/\n@[simps] noncomputable def expPartialHomeomorph : PartialHomeomorph ℝ ℝ where\n  toFun := Real.exp\n  invFun := Real.log\n  source := univ\n  target := Ioi (0 : ℝ)\n  map_source' x _ := exp_pos x\n  map_target' _ _ := mem_univ _\n  left_inv' _ _ := by simp\n  right_inv' _ hx := exp_log hx\n  open_source := isOpen_univ\n  open_target := isOpen_Ioi\n  continuousOn_toFun := continuousOn_exp\n  continuousOn_invFun x hx := (continuousAt_log (ne_of_gt hx)).continuousWithinAt\n\n"}
{"name":"Real.expPartialHomeomorph_target","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"⊢ Eq Real.expPartialHomeomorph.target (Set.Ioi 0)","decl":"/-- `Real.exp` as a `PartialHomeomorph` with `source = univ` and `target = {z | 0 < z}`. -/\n@[simps] noncomputable def expPartialHomeomorph : PartialHomeomorph ℝ ℝ where\n  toFun := Real.exp\n  invFun := Real.log\n  source := univ\n  target := Ioi (0 : ℝ)\n  map_source' x _ := exp_pos x\n  map_target' _ _ := mem_univ _\n  left_inv' _ _ := by simp\n  right_inv' _ hx := exp_log hx\n  open_source := isOpen_univ\n  open_target := isOpen_Ioi\n  continuousOn_toFun := continuousOn_exp\n  continuousOn_invFun x hx := (continuousAt_log (ne_of_gt hx)).continuousWithinAt\n\n"}
{"name":"Real.expPartialHomeomorph_symm_apply","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"x : Real\n⊢ Eq (↑Real.expPartialHomeomorph.symm x) (Real.log x)","decl":"/-- `Real.exp` as a `PartialHomeomorph` with `source = univ` and `target = {z | 0 < z}`. -/\n@[simps] noncomputable def expPartialHomeomorph : PartialHomeomorph ℝ ℝ where\n  toFun := Real.exp\n  invFun := Real.log\n  source := univ\n  target := Ioi (0 : ℝ)\n  map_source' x _ := exp_pos x\n  map_target' _ _ := mem_univ _\n  left_inv' _ _ := by simp\n  right_inv' _ hx := exp_log hx\n  open_source := isOpen_univ\n  open_target := isOpen_Ioi\n  continuousOn_toFun := continuousOn_exp\n  continuousOn_invFun x hx := (continuousAt_log (ne_of_gt hx)).continuousWithinAt\n\n"}
{"name":"Filter.Tendsto.log","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"α : Type u_1\nf : α → Real\nl : Filter α\nx : Real\nh : Filter.Tendsto f l (nhds x)\nhx : Ne x 0\n⊢ Filter.Tendsto (fun x => Real.log (f x)) l (nhds (Real.log x))","decl":"theorem Filter.Tendsto.log {f : α → ℝ} {l : Filter α} {x : ℝ} (h : Tendsto f l (𝓝 x)) (hx : x ≠ 0) :\n    Tendsto (fun x => log (f x)) l (𝓝 (log x)) :=\n  (continuousAt_log hx).tendsto.comp h\n\n"}
{"name":"Continuous.log","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"α : Type u_1\ninst✝ : TopologicalSpace α\nf : α → Real\nhf : Continuous f\nh₀ : ∀ (x : α), Ne (f x) 0\n⊢ Continuous fun x => Real.log (f x)","decl":"@[fun_prop]\ntheorem Continuous.log (hf : Continuous f) (h₀ : ∀ x, f x ≠ 0) : Continuous fun x => log (f x) :=\n  continuousOn_log.comp_continuous hf h₀\n\n"}
{"name":"ContinuousAt.log","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"α : Type u_1\ninst✝ : TopologicalSpace α\nf : α → Real\na : α\nhf : ContinuousAt f a\nh₀ : Ne (f a) 0\n⊢ ContinuousAt (fun x => Real.log (f x)) a","decl":"@[fun_prop]\nnonrec theorem ContinuousAt.log (hf : ContinuousAt f a) (h₀ : f a ≠ 0) :\n    ContinuousAt (fun x => log (f x)) a :=\n  hf.log h₀\n\n"}
{"name":"ContinuousWithinAt.log","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"α : Type u_1\ninst✝ : TopologicalSpace α\nf : α → Real\ns : Set α\na : α\nhf : ContinuousWithinAt f s a\nh₀ : Ne (f a) 0\n⊢ ContinuousWithinAt (fun x => Real.log (f x)) s a","decl":"nonrec theorem ContinuousWithinAt.log (hf : ContinuousWithinAt f s a) (h₀ : f a ≠ 0) :\n    ContinuousWithinAt (fun x => log (f x)) s a :=\n  hf.log h₀\n\n"}
{"name":"ContinuousOn.log","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"α : Type u_1\ninst✝ : TopologicalSpace α\nf : α → Real\ns : Set α\nhf : ContinuousOn f s\nh₀ : ∀ (x : α), Membership.mem s x → Ne (f x) 0\n⊢ ContinuousOn (fun x => Real.log (f x)) s","decl":"@[fun_prop]\ntheorem ContinuousOn.log (hf : ContinuousOn f s) (h₀ : ∀ x ∈ s, f x ≠ 0) :\n    ContinuousOn (fun x => log (f x)) s := fun x hx => (hf x hx).log (h₀ x hx)\n\n"}
{"name":"Real.tendsto_log_comp_add_sub_log","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"y : Real\n⊢ Filter.Tendsto (fun x => HSub.hSub (Real.log (HAdd.hAdd x y)) (Real.log x)) Filter.atTop (nhds 0)","decl":"theorem tendsto_log_comp_add_sub_log (y : ℝ) :\n    Tendsto (fun x : ℝ => log (x + y) - log x) atTop (𝓝 0) := by\n  have : Tendsto (fun x ↦ 1 + y / x) atTop (𝓝 (1 + 0)) :=\n    tendsto_const_nhds.add (tendsto_const_nhds.div_atTop tendsto_id)\n  rw [← comap_exp_nhds_exp, exp_zero, tendsto_comap_iff, ← add_zero (1 : ℝ)]\n  refine this.congr' ?_\n  filter_upwards [eventually_gt_atTop (0 : ℝ), eventually_gt_atTop (-y)] with x hx₀ hxy\n  rw [comp_apply, exp_sub, exp_log, exp_log, one_add_div] <;> linarith\n\n"}
{"name":"Real.tendsto_log_nat_add_one_sub_log","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"⊢ Filter.Tendsto (fun k => HSub.hSub (Real.log (HAdd.hAdd (↑k) 1)) (Real.log ↑k)) Filter.atTop (nhds 0)","decl":"theorem tendsto_log_nat_add_one_sub_log : Tendsto (fun k : ℕ => log (k + 1) - log k) atTop (𝓝 0) :=\n  (tendsto_log_comp_add_sub_log 1).comp tendsto_natCast_atTop_atTop\n\n"}
{"name":"Mathlib.Meta.Positivity.log_nonneg_of_isNat","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"e : Real\nn : Nat\nh : Mathlib.Meta.NormNum.IsNat e n\n⊢ LE.le 0 (Real.log e)","decl":"lemma log_nonneg_of_isNat {n : ℕ} (h : NormNum.IsNat e n) : 0 ≤ Real.log (e : ℝ) := by\n  rw [NormNum.IsNat.to_eq h rfl]\n  exact Real.log_natCast_nonneg _\n\n"}
{"name":"Mathlib.Meta.Positivity.log_pos_of_isNat","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"e : Real\nn : Nat\nh : Mathlib.Meta.NormNum.IsNat e n\nw : Eq (Nat.blt 1 n) Bool.true\n⊢ LT.lt 0 (Real.log e)","decl":"lemma log_pos_of_isNat {n : ℕ} (h : NormNum.IsNat e n) (w : Nat.blt 1 n = true) :\n    0 < Real.log (e : ℝ) := by\n  rw [NormNum.IsNat.to_eq h rfl]\n  apply Real.log_pos\n  simpa using w\n\n"}
{"name":"Mathlib.Meta.Positivity.log_nonneg_of_isNegNat","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"e : Real\nn : Nat\nh : Mathlib.Meta.NormNum.IsInt e (Int.negOfNat n)\n⊢ LE.le 0 (Real.log e)","decl":"lemma log_nonneg_of_isNegNat {n : ℕ} (h : NormNum.IsInt e (.negOfNat n)) :\n    0 ≤ Real.log (e : ℝ) := by\n  rw [NormNum.IsInt.neg_to_eq h rfl]\n  exact Real.log_neg_natCast_nonneg _\n\n"}
{"name":"Mathlib.Meta.Positivity.log_pos_of_isNegNat","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"e : Real\nn : Nat\nh : Mathlib.Meta.NormNum.IsInt e (Int.negOfNat n)\nw : Eq (Nat.blt 1 n) Bool.true\n⊢ LT.lt 0 (Real.log e)","decl":"lemma log_pos_of_isNegNat {n : ℕ} (h : NormNum.IsInt e (.negOfNat n)) (w : Nat.blt 1 n = true) :\n    0 < Real.log (e : ℝ) := by\n  rw [NormNum.IsInt.neg_to_eq h rfl]\n  rw [Real.log_neg_eq_log]\n  apply Real.log_pos\n  simpa using w\n\n"}
{"name":"Mathlib.Meta.Positivity.log_pos_of_isRat","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"e : Real\nd : Nat\nn : Int\na✝¹ : Mathlib.Meta.NormNum.IsRat e n d\na✝ : Eq (Decidable.decide (LT.lt 1 (HDiv.hDiv ↑n ↑d))) Bool.true\n⊢ LT.lt 0 (Real.log e)","decl":"lemma log_pos_of_isRat {n : ℤ} :\n    (NormNum.IsRat e n d) → (decide ((1 : ℚ) < n / d)) → (0 < Real.log (e : ℝ))\n  | ⟨inv, eq⟩, h => by\n    rw [eq, invOf_eq_inv, ← div_eq_mul_inv]\n    have : 1 < (n : ℝ) / d := by exact_mod_cast of_decide_eq_true h\n    exact Real.log_pos this\n\n"}
{"name":"Mathlib.Meta.Positivity.log_pos_of_isRat_neg","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"e : Real\nd : Nat\nn : Int\na✝¹ : Mathlib.Meta.NormNum.IsRat e n d\na✝ : Eq (Decidable.decide (LT.lt (HDiv.hDiv ↑n ↑d) (-1))) Bool.true\n⊢ LT.lt 0 (Real.log e)","decl":"lemma log_pos_of_isRat_neg {n : ℤ} :\n    (NormNum.IsRat e n d) → (decide (n / d < (-1 : ℚ))) → (0 < Real.log (e : ℝ))\n  | ⟨inv, eq⟩, h => by\n    rw [eq, invOf_eq_inv, ← div_eq_mul_inv]\n    have : (n : ℝ) / d < -1 := by exact_mod_cast of_decide_eq_true h\n    exact Real.log_pos_of_lt_neg_one this\n\n"}
{"name":"Mathlib.Meta.Positivity.log_nz_of_isRat","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"e : Real\nd : Nat\nn : Int\na✝² : Mathlib.Meta.NormNum.IsRat e n d\na✝¹ : Eq (Decidable.decide (LT.lt 0 (HDiv.hDiv ↑n ↑d))) Bool.true\na✝ : Eq (Decidable.decide (LT.lt (HDiv.hDiv ↑n ↑d) 1)) Bool.true\n⊢ Ne (Real.log e) 0","decl":"lemma log_nz_of_isRat {n : ℤ} : (NormNum.IsRat e n d) → (decide ((0 : ℚ) < n / d))\n    → (decide (n / d < (1 : ℚ))) → (Real.log (e : ℝ) ≠ 0)\n  | ⟨inv, eq⟩, h₁, h₂ => by\n    rw [eq, invOf_eq_inv, ← div_eq_mul_inv]\n    have h₁' : 0 < (n : ℝ) / d := by exact_mod_cast of_decide_eq_true h₁\n    have h₂' : (n : ℝ) / d < 1 := by exact_mod_cast of_decide_eq_true h₂\n    exact ne_of_lt <| Real.log_neg h₁' h₂'\n\n"}
{"name":"Mathlib.Meta.Positivity.log_nz_of_isRat_neg","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"e : Real\nd : Nat\nn : Int\na✝² : Mathlib.Meta.NormNum.IsRat e n d\na✝¹ : Eq (Decidable.decide (LT.lt (HDiv.hDiv ↑n ↑d) 0)) Bool.true\na✝ : Eq (Decidable.decide (LT.lt (-1) (HDiv.hDiv ↑n ↑d))) Bool.true\n⊢ Ne (Real.log e) 0","decl":"lemma log_nz_of_isRat_neg {n : ℤ} : (NormNum.IsRat e n d) → (decide (n / d < (0 : ℚ)))\n    → (decide ((-1 : ℚ) < n / d)) → (Real.log (e : ℝ) ≠ 0)\n  | ⟨inv, eq⟩, h₁, h₂ => by\n    rw [eq, invOf_eq_inv, ← div_eq_mul_inv]\n    have h₁' : (n : ℝ) / d < 0 := by exact_mod_cast of_decide_eq_true h₁\n    have h₂' : -1 < (n : ℝ) / d := by exact_mod_cast of_decide_eq_true h₂\n    exact ne_of_lt <| Real.log_neg_of_lt_zero h₁' h₂'\n\n"}
