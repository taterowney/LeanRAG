{"name":"Real.log_of_ne_zero","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"x : Real\nhx : Ne x 0\n‚ä¢ Eq (Real.log x) (Real.expOrderIso.symm ‚ü®abs x, ‚ãØ‚ü©)","decl":"theorem log_of_ne_zero (hx : x ‚â† 0) : log x = expOrderIso.symm ‚ü®|x|, abs_pos.2 hx‚ü© :=\n  dif_neg hx\n\n"}
{"name":"Real.log_of_pos","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"x : Real\nhx : LT.lt 0 x\n‚ä¢ Eq (Real.log x) (Real.expOrderIso.symm ‚ü®x, hx‚ü©)","decl":"theorem log_of_pos (hx : 0 < x) : log x = expOrderIso.symm ‚ü®x, hx‚ü© := by\n  rw [log_of_ne_zero hx.ne']\n  congr\n  exact abs_of_pos hx\n\n"}
{"name":"Real.exp_log_eq_abs","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"x : Real\nhx : Ne x 0\n‚ä¢ Eq (Real.exp (Real.log x)) (abs x)","decl":"theorem exp_log_eq_abs (hx : x ‚â† 0) : exp (log x) = |x| := by\n  rw [log_of_ne_zero hx, ‚Üê coe_expOrderIso_apply, OrderIso.apply_symm_apply, Subtype.coe_mk]\n\n"}
{"name":"Real.exp_log","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"x : Real\nhx : LT.lt 0 x\n‚ä¢ Eq (Real.exp (Real.log x)) x","decl":"theorem exp_log (hx : 0 < x) : exp (log x) = x := by\n  rw [exp_log_eq_abs hx.ne']\n  exact abs_of_pos hx\n\n"}
{"name":"Real.exp_log_of_neg","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"x : Real\nhx : LT.lt x 0\n‚ä¢ Eq (Real.exp (Real.log x)) (Neg.neg x)","decl":"theorem exp_log_of_neg (hx : x < 0) : exp (log x) = -x := by\n  rw [exp_log_eq_abs (ne_of_lt hx)]\n  exact abs_of_neg hx\n\n"}
{"name":"Real.le_exp_log","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"x : Real\n‚ä¢ LE.le x (Real.exp (Real.log x))","decl":"theorem le_exp_log (x : ‚Ñù) : x ‚â§ exp (log x) := by\n  by_cases h_zero : x = 0\n  ¬∑ rw [h_zero, log, dif_pos rfl, exp_zero]\n    exact zero_le_one\n  ¬∑ rw [exp_log_eq_abs h_zero]\n    exact le_abs_self _\n\n"}
{"name":"Real.log_exp","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"x : Real\n‚ä¢ Eq (Real.log (Real.exp x)) x","decl":"@[simp]\ntheorem log_exp (x : ‚Ñù) : log (exp x) = x :=\n  exp_injective <| exp_log (exp_pos x)\n\n"}
{"name":"Real.surjOn_log","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"‚ä¢ Set.SurjOn Real.log (Set.Ioi 0) Set.univ","decl":"theorem surjOn_log : SurjOn log (Ioi 0) univ := fun x _ => ‚ü®exp x, exp_pos x, log_exp x‚ü©\n\n"}
{"name":"Real.log_surjective","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"‚ä¢ Function.Surjective Real.log","decl":"theorem log_surjective : Surjective log := fun x => ‚ü®exp x, log_exp x‚ü©\n\n"}
{"name":"Real.range_log","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"‚ä¢ Eq (Set.range Real.log) Set.univ","decl":"@[simp]\ntheorem range_log : range log = univ :=\n  log_surjective.range_eq\n\n"}
{"name":"Real.log_zero","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"‚ä¢ Eq (Real.log 0) 0","decl":"@[simp]\ntheorem log_zero : log 0 = 0 :=\n  dif_pos rfl\n\n"}
{"name":"Real.log_one","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"‚ä¢ Eq (Real.log 1) 0","decl":"@[simp]\ntheorem log_one : log 1 = 0 :=\n  exp_injective <| by rw [exp_log zero_lt_one, exp_zero]\n\n"}
{"name":"Real.log_div_self","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"x : Real\n‚ä¢ Eq (Real.log (HDiv.hDiv x x)) 0","decl":"/-- This holds true for all `x : \\` because of the junk values `0 / 0 = 0` and `arg 0 = 0`. -/\n@[simp] lemma log_div_self (x : ‚Ñù) : log (x / x) = 0 := by\n  obtain rfl | hx := eq_or_ne x 0 <;> simp [*]\n\n"}
{"name":"Real.log_abs","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"x : Real\n‚ä¢ Eq (Real.log (abs x)) (Real.log x)","decl":"@[simp]\ntheorem log_abs (x : ‚Ñù) : log |x| = log x := by\n  by_cases h : x = 0\n  ¬∑ simp [h]\n  ¬∑ rw [‚Üê exp_eq_exp, exp_log_eq_abs h, exp_log_eq_abs (abs_pos.2 h).ne', abs_abs]\n\n"}
{"name":"Real.log_neg_eq_log","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"x : Real\n‚ä¢ Eq (Real.log (Neg.neg x)) (Real.log x)","decl":"@[simp]\ntheorem log_neg_eq_log (x : ‚Ñù) : log (-x) = log x := by rw [‚Üê log_abs x, ‚Üê log_abs (-x), abs_neg]\n\n"}
{"name":"Real.sinh_log","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"x : Real\nhx : LT.lt 0 x\n‚ä¢ Eq (Real.sinh (Real.log x)) (HDiv.hDiv (HSub.hSub x (Inv.inv x)) 2)","decl":"theorem sinh_log {x : ‚Ñù} (hx : 0 < x) : sinh (log x) = (x - x‚Åª¬π) / 2 := by\n  rw [sinh_eq, exp_neg, exp_log hx]\n\n"}
{"name":"Real.cosh_log","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"x : Real\nhx : LT.lt 0 x\n‚ä¢ Eq (Real.cosh (Real.log x)) (HDiv.hDiv (HAdd.hAdd x (Inv.inv x)) 2)","decl":"theorem cosh_log {x : ‚Ñù} (hx : 0 < x) : cosh (log x) = (x + x‚Åª¬π) / 2 := by\n  rw [cosh_eq, exp_neg, exp_log hx]\n\n"}
{"name":"Real.surjOn_log'","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"‚ä¢ Set.SurjOn Real.log (Set.Iio 0) Set.univ","decl":"theorem surjOn_log' : SurjOn log (Iio 0) univ := fun x _ =>\n  ‚ü®-exp x, neg_lt_zero.2 <| exp_pos x, by rw [log_neg_eq_log, log_exp]‚ü©\n\n"}
{"name":"Real.log_mul","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"x y : Real\nhx : Ne x 0\nhy : Ne y 0\n‚ä¢ Eq (Real.log (HMul.hMul x y)) (HAdd.hAdd (Real.log x) (Real.log y))","decl":"theorem log_mul (hx : x ‚â† 0) (hy : y ‚â† 0) : log (x * y) = log x + log y :=\n  exp_injective <| by\n    rw [exp_log_eq_abs (mul_ne_zero hx hy), exp_add, exp_log_eq_abs hx, exp_log_eq_abs hy, abs_mul]\n\n"}
{"name":"Real.log_div","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"x y : Real\nhx : Ne x 0\nhy : Ne y 0\n‚ä¢ Eq (Real.log (HDiv.hDiv x y)) (HSub.hSub (Real.log x) (Real.log y))","decl":"theorem log_div (hx : x ‚â† 0) (hy : y ‚â† 0) : log (x / y) = log x - log y :=\n  exp_injective <| by\n    rw [exp_log_eq_abs (div_ne_zero hx hy), exp_sub, exp_log_eq_abs hx, exp_log_eq_abs hy, abs_div]\n\n"}
{"name":"Real.log_inv","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"x : Real\n‚ä¢ Eq (Real.log (Inv.inv x)) (Neg.neg (Real.log x))","decl":"@[simp]\ntheorem log_inv (x : ‚Ñù) : log x‚Åª¬π = -log x := by\n  by_cases hx : x = 0; ¬∑ simp [hx]\n  rw [‚Üê exp_eq_exp, exp_log_eq_abs (inv_ne_zero hx), exp_neg, exp_log_eq_abs hx, abs_inv]\n\n"}
{"name":"Real.log_le_log_iff","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"x y : Real\nh : LT.lt 0 x\nh‚ÇÅ : LT.lt 0 y\n‚ä¢ Iff (LE.le (Real.log x) (Real.log y)) (LE.le x y)","decl":"theorem log_le_log_iff (h : 0 < x) (h‚ÇÅ : 0 < y) : log x ‚â§ log y ‚Üî x ‚â§ y := by\n  rw [‚Üê exp_le_exp, exp_log h, exp_log h‚ÇÅ]\n\n"}
{"name":"Real.log_le_log","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"x y : Real\nhx : LT.lt 0 x\nhxy : LE.le x y\n‚ä¢ LE.le (Real.log x) (Real.log y)","decl":"@[gcongr, bound]\nlemma log_le_log (hx : 0 < x) (hxy : x ‚â§ y) : log x ‚â§ log y :=\n  (log_le_log_iff hx (hx.trans_le hxy)).2 hxy\n\n"}
{"name":"Real.log_lt_log","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"x y : Real\nhx : LT.lt 0 x\nh : LT.lt x y\n‚ä¢ LT.lt (Real.log x) (Real.log y)","decl":"@[gcongr, bound]\ntheorem log_lt_log (hx : 0 < x) (h : x < y) : log x < log y := by\n  rwa [‚Üê exp_lt_exp, exp_log hx, exp_log (lt_trans hx h)]\n\n"}
{"name":"Real.log_lt_log_iff","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"x y : Real\nhx : LT.lt 0 x\nhy : LT.lt 0 y\n‚ä¢ Iff (LT.lt (Real.log x) (Real.log y)) (LT.lt x y)","decl":"theorem log_lt_log_iff (hx : 0 < x) (hy : 0 < y) : log x < log y ‚Üî x < y := by\n  rw [‚Üê exp_lt_exp, exp_log hx, exp_log hy]\n\n"}
{"name":"Real.log_le_iff_le_exp","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"x y : Real\nhx : LT.lt 0 x\n‚ä¢ Iff (LE.le (Real.log x) y) (LE.le x (Real.exp y))","decl":"theorem log_le_iff_le_exp (hx : 0 < x) : log x ‚â§ y ‚Üî x ‚â§ exp y := by rw [‚Üê exp_le_exp, exp_log hx]\n\n"}
{"name":"Real.log_lt_iff_lt_exp","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"x y : Real\nhx : LT.lt 0 x\n‚ä¢ Iff (LT.lt (Real.log x) y) (LT.lt x (Real.exp y))","decl":"theorem log_lt_iff_lt_exp (hx : 0 < x) : log x < y ‚Üî x < exp y := by rw [‚Üê exp_lt_exp, exp_log hx]\n\n"}
{"name":"Real.le_log_iff_exp_le","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"x y : Real\nhy : LT.lt 0 y\n‚ä¢ Iff (LE.le x (Real.log y)) (LE.le (Real.exp x) y)","decl":"theorem le_log_iff_exp_le (hy : 0 < y) : x ‚â§ log y ‚Üî exp x ‚â§ y := by rw [‚Üê exp_le_exp, exp_log hy]\n\n"}
{"name":"Real.lt_log_iff_exp_lt","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"x y : Real\nhy : LT.lt 0 y\n‚ä¢ Iff (LT.lt x (Real.log y)) (LT.lt (Real.exp x) y)","decl":"theorem lt_log_iff_exp_lt (hy : 0 < y) : x < log y ‚Üî exp x < y := by rw [‚Üê exp_lt_exp, exp_log hy]\n\n"}
{"name":"Real.log_pos_iff","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"x : Real\nhx : LE.le 0 x\n‚ä¢ Iff (LT.lt 0 (Real.log x)) (LT.lt 1 x)","decl":"theorem log_pos_iff (hx : 0 ‚â§ x) : 0 < log x ‚Üî 1 < x := by\n  rcases hx.eq_or_lt with (rfl | hx)\n  ¬∑ simp [le_refl, zero_le_one]\n  rw [‚Üê log_one]\n  exact log_lt_log_iff zero_lt_one hx\n\n"}
{"name":"Real.log_pos","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"x : Real\nhx : LT.lt 1 x\n‚ä¢ LT.lt 0 (Real.log x)","decl":"@[bound]\ntheorem log_pos (hx : 1 < x) : 0 < log x :=\n  (log_pos_iff (lt_trans zero_lt_one hx).le).2 hx\n\n"}
{"name":"Real.log_pos_of_lt_neg_one","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"x : Real\nhx : LT.lt x (-1)\n‚ä¢ LT.lt 0 (Real.log x)","decl":"theorem log_pos_of_lt_neg_one (hx : x < -1) : 0 < log x := by\n  rw [‚Üê neg_neg x, log_neg_eq_log]\n  have : 1 < -x := by linarith\n  exact log_pos this\n\n"}
{"name":"Real.log_neg_iff","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"x : Real\nh : LT.lt 0 x\n‚ä¢ Iff (LT.lt (Real.log x) 0) (LT.lt x 1)","decl":"theorem log_neg_iff (h : 0 < x) : log x < 0 ‚Üî x < 1 := by\n  rw [‚Üê log_one]\n  exact log_lt_log_iff h zero_lt_one\n\n"}
{"name":"Real.log_neg","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"x : Real\nh0 : LT.lt 0 x\nh1 : LT.lt x 1\n‚ä¢ LT.lt (Real.log x) 0","decl":"@[bound]\ntheorem log_neg (h0 : 0 < x) (h1 : x < 1) : log x < 0 :=\n  (log_neg_iff h0).2 h1\n\n"}
{"name":"Real.log_neg_of_lt_zero","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"x : Real\nh0 : LT.lt x 0\nh1 : LT.lt (-1) x\n‚ä¢ LT.lt (Real.log x) 0","decl":"theorem log_neg_of_lt_zero (h0 : x < 0) (h1 : -1 < x) : log x < 0 := by\n  rw [‚Üê neg_neg x, log_neg_eq_log]\n  have h0' : 0 < -x := by linarith\n  have h1' : -x < 1 := by linarith\n  exact log_neg h0' h1'\n\n"}
{"name":"Real.log_nonneg_iff","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"x : Real\nhx : LT.lt 0 x\n‚ä¢ Iff (LE.le 0 (Real.log x)) (LE.le 1 x)","decl":"theorem log_nonneg_iff (hx : 0 < x) : 0 ‚â§ log x ‚Üî 1 ‚â§ x := by rw [‚Üê not_lt, log_neg_iff hx, not_lt]\n\n"}
{"name":"Real.log_nonneg","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"x : Real\nhx : LE.le 1 x\n‚ä¢ LE.le 0 (Real.log x)","decl":"@[bound]\ntheorem log_nonneg (hx : 1 ‚â§ x) : 0 ‚â§ log x :=\n  (log_nonneg_iff (zero_lt_one.trans_le hx)).2 hx\n\n"}
{"name":"Real.log_nonpos_iff","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"x : Real\nhx : LE.le 0 x\n‚ä¢ Iff (LE.le (Real.log x) 0) (LE.le x 1)","decl":"theorem log_nonpos_iff (hx : 0 ‚â§ x) : log x ‚â§ 0 ‚Üî x ‚â§ 1 := by\n  rcases hx.eq_or_lt with (rfl | hx)\n  ¬∑ simp [le_refl, zero_le_one]\n  rw [‚Üê not_lt, log_pos_iff hx.le, not_lt]\n\n"}
{"name":"Real.log_nonpos_iff'","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"x : Real\nhx : LE.le 0 x\n‚ä¢ Iff (LE.le (Real.log x) 0) (LE.le x 1)","decl":"@[deprecated (since := \"2025-01-16\")]\nalias log_nonpos_iff' := log_nonpos_iff\n\n"}
{"name":"Real.log_nonpos","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"x : Real\nhx : LE.le 0 x\nh'x : LE.le x 1\n‚ä¢ LE.le (Real.log x) 0","decl":"@[bound]\ntheorem log_nonpos (hx : 0 ‚â§ x) (h'x : x ‚â§ 1) : log x ‚â§ 0 :=\n  (log_nonpos_iff hx).2 h'x\n\n"}
{"name":"Real.log_natCast_nonneg","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"n : Nat\n‚ä¢ LE.le 0 (Real.log ‚Üën)","decl":"theorem log_natCast_nonneg (n : ‚Ñï) : 0 ‚â§ log n := by\n  if hn : n = 0 then\n    simp [hn]\n  else\n    have : (1 : ‚Ñù) ‚â§ n := mod_cast Nat.one_le_of_lt <| Nat.pos_of_ne_zero hn\n    exact log_nonneg this\n\n"}
{"name":"Real.log_neg_natCast_nonneg","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"n : Nat\n‚ä¢ LE.le 0 (Real.log (Neg.neg ‚Üën))","decl":"theorem log_neg_natCast_nonneg (n : ‚Ñï) : 0 ‚â§ log (-n) := by\n  rw [‚Üê log_neg_eq_log, neg_neg]\n  exact log_natCast_nonneg _\n\n"}
{"name":"Real.log_intCast_nonneg","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"n : Int\n‚ä¢ LE.le 0 (Real.log ‚Üën)","decl":"theorem log_intCast_nonneg (n : ‚Ñ§) : 0 ‚â§ log n := by\n  cases lt_trichotomy 0 n with\n  | inl hn =>\n      have : (1 : ‚Ñù) ‚â§ n := mod_cast hn\n      exact log_nonneg this\n  | inr hn =>\n      cases hn with\n      | inl hn => simp [hn.symm]\n      | inr hn =>\n          have : (1 : ‚Ñù) ‚â§ -n := by rw [‚Üê neg_zero, ‚Üê lt_neg] at hn; exact mod_cast hn\n          rw [‚Üê log_neg_eq_log]\n          exact log_nonneg this\n\n"}
{"name":"Real.strictMonoOn_log","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"‚ä¢ StrictMonoOn Real.log (Set.Ioi 0)","decl":"theorem strictMonoOn_log : StrictMonoOn log (Set.Ioi 0) := fun _ hx _ _ hxy => log_lt_log hx hxy\n\n"}
{"name":"Real.strictAntiOn_log","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"‚ä¢ StrictAntiOn Real.log (Set.Iio 0)","decl":"theorem strictAntiOn_log : StrictAntiOn log (Set.Iio 0) := by\n  rintro x (hx : x < 0) y (hy : y < 0) hxy\n  rw [‚Üê log_abs y, ‚Üê log_abs x]\n  refine log_lt_log (abs_pos.2 hy.ne) ?_\n  rwa [abs_of_neg hy, abs_of_neg hx, neg_lt_neg_iff]\n\n"}
{"name":"Real.log_injOn_pos","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"‚ä¢ Set.InjOn Real.log (Set.Ioi 0)","decl":"theorem log_injOn_pos : Set.InjOn log (Set.Ioi 0) :=\n  strictMonoOn_log.injOn\n\n"}
{"name":"Real.log_lt_sub_one_of_pos","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"x : Real\nhx1 : LT.lt 0 x\nhx2 : Ne x 1\n‚ä¢ LT.lt (Real.log x) (HSub.hSub x 1)","decl":"theorem log_lt_sub_one_of_pos (hx1 : 0 < x) (hx2 : x ‚â† 1) : log x < x - 1 := by\n  have h : log x ‚â† 0 := by\n    rwa [‚Üê log_one, log_injOn_pos.ne_iff hx1]\n    exact mem_Ioi.mpr zero_lt_one\n  linarith [add_one_lt_exp h, exp_log hx1]\n\n"}
{"name":"Real.eq_one_of_pos_of_log_eq_zero","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"x : Real\nh‚ÇÅ : LT.lt 0 x\nh‚ÇÇ : Eq (Real.log x) 0\n‚ä¢ Eq x 1","decl":"theorem eq_one_of_pos_of_log_eq_zero {x : ‚Ñù} (h‚ÇÅ : 0 < x) (h‚ÇÇ : log x = 0) : x = 1 :=\n  log_injOn_pos (Set.mem_Ioi.2 h‚ÇÅ) (Set.mem_Ioi.2 zero_lt_one) (h‚ÇÇ.trans Real.log_one.symm)\n\n"}
{"name":"Real.log_ne_zero_of_pos_of_ne_one","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"x : Real\nhx_pos : LT.lt 0 x\nhx : Ne x 1\n‚ä¢ Ne (Real.log x) 0","decl":"theorem log_ne_zero_of_pos_of_ne_one {x : ‚Ñù} (hx_pos : 0 < x) (hx : x ‚â† 1) : log x ‚â† 0 :=\n  mt (eq_one_of_pos_of_log_eq_zero hx_pos) hx\n\n"}
{"name":"Real.log_eq_zero","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"x : Real\n‚ä¢ Iff (Eq (Real.log x) 0) (Or (Eq x 0) (Or (Eq x 1) (Eq x (-1))))","decl":"@[simp]\ntheorem log_eq_zero {x : ‚Ñù} : log x = 0 ‚Üî x = 0 ‚à® x = 1 ‚à® x = -1 := by\n  constructor\n  ¬∑ intro h\n    rcases lt_trichotomy x 0 with (x_lt_zero | rfl | x_gt_zero)\n    ¬∑ refine Or.inr (Or.inr (neg_eq_iff_eq_neg.mp ?_))\n      rw [‚Üê log_neg_eq_log x] at h\n      exact eq_one_of_pos_of_log_eq_zero (neg_pos.mpr x_lt_zero) h\n    ¬∑ exact Or.inl rfl\n    ¬∑ exact Or.inr (Or.inl (eq_one_of_pos_of_log_eq_zero x_gt_zero h))\n  ¬∑ rintro (rfl | rfl | rfl) <;> simp only [log_one, log_zero, log_neg_eq_log]\n\n"}
{"name":"Real.log_ne_zero","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"x : Real\n‚ä¢ Iff (Ne (Real.log x) 0) (And (Ne x 0) (And (Ne x 1) (Ne x (-1))))","decl":"theorem log_ne_zero {x : ‚Ñù} : log x ‚â† 0 ‚Üî x ‚â† 0 ‚àß x ‚â† 1 ‚àß x ‚â† -1 := by\n  simpa only [not_or] using log_eq_zero.not\n\n"}
{"name":"Real.log_pow","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"x : Real\nn : Nat\n‚ä¢ Eq (Real.log (HPow.hPow x n)) (HMul.hMul (‚Üën) (Real.log x))","decl":"@[simp]\ntheorem log_pow (x : ‚Ñù) (n : ‚Ñï) : log (x ^ n) = n * log x := by\n  induction n with\n  | zero => simp\n  | succ n ih =>\n    rcases eq_or_ne x 0 with (rfl | hx)\n    ¬∑ simp\n    ¬∑ rw [pow_succ, log_mul (pow_ne_zero _ hx) hx, ih, Nat.cast_succ, add_mul, one_mul]\n\n"}
{"name":"Real.log_zpow","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"x : Real\nn : Int\n‚ä¢ Eq (Real.log (HPow.hPow x n)) (HMul.hMul (‚Üën) (Real.log x))","decl":"@[simp]\ntheorem log_zpow (x : ‚Ñù) (n : ‚Ñ§) : log (x ^ n) = n * log x := by\n  induction n\n  ¬∑ rw [Int.ofNat_eq_coe, zpow_natCast, log_pow, Int.cast_natCast]\n  rw [zpow_negSucc, log_inv, log_pow, Int.cast_negSucc, Nat.cast_add_one, neg_mul_eq_neg_mul]\n\n"}
{"name":"Real.log_sqrt","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"x : Real\nhx : LE.le 0 x\n‚ä¢ Eq (Real.log x.sqrt) (HDiv.hDiv (Real.log x) 2)","decl":"theorem log_sqrt {x : ‚Ñù} (hx : 0 ‚â§ x) : log (‚àöx) = log x / 2 := by\n  rw [eq_div_iff, mul_comm, ‚Üê Nat.cast_two, ‚Üê log_pow, sq_sqrt hx]\n  exact two_ne_zero\n\n"}
{"name":"Real.log_le_sub_one_of_pos","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"x : Real\nhx : LT.lt 0 x\n‚ä¢ LE.le (Real.log x) (HSub.hSub x 1)","decl":"theorem log_le_sub_one_of_pos {x : ‚Ñù} (hx : 0 < x) : log x ‚â§ x - 1 := by\n  rw [le_sub_iff_add_le]\n  convert add_one_le_exp (log x)\n  rw [exp_log hx]\n\n"}
{"name":"Real.one_sub_inv_le_log_of_pos","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"x : Real\nhx : LT.lt 0 x\n‚ä¢ LE.le (HSub.hSub 1 (Inv.inv x)) (Real.log x)","decl":"lemma one_sub_inv_le_log_of_pos (hx : 0 < x) : 1 - x‚Åª¬π ‚â§ log x := by\n  simpa [add_comm] using log_le_sub_one_of_pos (inv_pos.2 hx)\n\n"}
{"name":"Real.log_le_self","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"x : Real\nhx : LE.le 0 x\n‚ä¢ LE.le (Real.log x) x","decl":"/-- See `Real.log_le_sub_one_of_pos` for the stronger version when `x ‚â† 0`. -/\nlemma log_le_self (hx : 0 ‚â§ x) : log x ‚â§ x := by\n  obtain rfl | hx := hx.eq_or_lt\n  ¬∑ simp\n  ¬∑ exact (log_le_sub_one_of_pos hx).trans (by linarith)\n\n"}
{"name":"Real.neg_inv_le_log","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"x : Real\nhx : LE.le 0 x\n‚ä¢ LE.le (Neg.neg (Inv.inv x)) (Real.log x)","decl":"/-- See `Real.one_sub_inv_le_log_of_pos` for the stronger version when `x ‚â† 0`. -/\nlemma neg_inv_le_log (hx : 0 ‚â§ x) : -x‚Åª¬π ‚â§ log x := by\n  rw [neg_le, ‚Üê log_inv]; exact log_le_self <| inv_nonneg.2 hx\n\n"}
{"name":"Real.abs_log_mul_self_lt","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"x : Real\nh1 : LT.lt 0 x\nh2 : LE.le x 1\n‚ä¢ LT.lt (abs (HMul.hMul (Real.log x) x)) 1","decl":"/-- Bound for `|log x * x|` in the interval `(0, 1]`. -/\ntheorem abs_log_mul_self_lt (x : ‚Ñù) (h1 : 0 < x) (h2 : x ‚â§ 1) : |log x * x| < 1 := by\n  have : 0 < 1 / x := by simpa only [one_div, inv_pos] using h1\n  replace := log_le_sub_one_of_pos this\n  replace : log (1 / x) < 1 / x := by linarith\n  rw [log_div one_ne_zero h1.ne', log_one, zero_sub, lt_div_iff‚ÇÄ h1] at this\n  have aux : 0 ‚â§ -log x * x := by\n    refine mul_nonneg ?_ h1.le\n    rw [‚Üê log_inv]\n    apply log_nonneg\n    rw [‚Üê le_inv_comm‚ÇÄ h1 zero_lt_one, inv_one]\n    exact h2\n  rw [‚Üê abs_of_nonneg aux, neg_mul, abs_neg] at this\n  exact this\n\n"}
{"name":"Real.tendsto_log_atTop","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"‚ä¢ Filter.Tendsto Real.log Filter.atTop Filter.atTop","decl":"/-- The real logarithm function tends to `+‚àû` at `+‚àû`. -/\ntheorem tendsto_log_atTop : Tendsto log atTop atTop :=\n  tendsto_comp_exp_atTop.1 <| by simpa only [log_exp] using tendsto_id\n\n"}
{"name":"Real.tendsto_log_nhdsWithin_zero","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"‚ä¢ Filter.Tendsto Real.log (nhdsWithin 0 (HasCompl.compl (Singleton.singleton 0))) Filter.atBot","decl":"theorem tendsto_log_nhdsWithin_zero : Tendsto log (ùìù[‚â†] 0) atBot := by\n  rw [‚Üê show _ = log from funext log_abs]\n  refine Tendsto.comp (g := log) ?_ tendsto_abs_nhdsWithin_zero\n  simpa [‚Üê tendsto_comp_exp_atBot] using tendsto_id\n\n"}
{"name":"Real.tendsto_log_nhdsWithin_zero_right","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"‚ä¢ Filter.Tendsto Real.log (nhdsWithin 0 (Set.Ioi 0)) Filter.atBot","decl":"lemma tendsto_log_nhdsWithin_zero_right : Tendsto log (ùìù[>] 0) atBot :=\n  tendsto_log_nhdsWithin_zero.mono_left <| nhdsWithin_mono _ fun _ h ‚Ü¶ ne_of_gt h\n\n"}
{"name":"Real.continuousOn_log","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"‚ä¢ ContinuousOn Real.log (HasCompl.compl (Singleton.singleton 0))","decl":"theorem continuousOn_log : ContinuousOn log {0}·∂ú := by\n  simp (config := { unfoldPartialApp := true }) only [continuousOn_iff_continuous_restrict,\n    restrict]\n  conv in log _ => rw [log_of_ne_zero (show (x : ‚Ñù) ‚â† 0 from x.2)]\n  exact expOrderIso.symm.continuous.comp (continuous_subtype_val.norm.subtype_mk _)\n\n"}
{"name":"Real.continuous_log","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"‚ä¢ Continuous fun x => Real.log ‚Üëx","decl":"/-- The real logarithm is continuous as a function from nonzero reals. -/\n@[fun_prop]\ntheorem continuous_log : Continuous fun x : { x : ‚Ñù // x ‚â† 0 } => log x :=\n  continuousOn_iff_continuous_restrict.1 <| continuousOn_log.mono fun _ => id\n\n"}
{"name":"Real.continuous_log'","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"‚ä¢ Continuous fun x => Real.log ‚Üëx","decl":"/-- The real logarithm is continuous as a function from positive reals. -/\n@[fun_prop]\ntheorem continuous_log' : Continuous fun x : { x : ‚Ñù // 0 < x } => log x :=\n  continuousOn_iff_continuous_restrict.1 <| continuousOn_log.mono fun _ hx => ne_of_gt hx\n\n"}
{"name":"Real.continuousAt_log","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"x : Real\nhx : Ne x 0\n‚ä¢ ContinuousAt Real.log x","decl":"theorem continuousAt_log (hx : x ‚â† 0) : ContinuousAt log x :=\n  (continuousOn_log x hx).continuousAt <| isOpen_compl_singleton.mem_nhds hx\n\n"}
{"name":"Real.continuousAt_log_iff","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"x : Real\n‚ä¢ Iff (ContinuousAt Real.log x) (Ne x 0)","decl":"@[simp]\ntheorem continuousAt_log_iff : ContinuousAt log x ‚Üî x ‚â† 0 := by\n  refine ‚ü®?_, continuousAt_log‚ü©\n  rintro h rfl\n  exact not_tendsto_nhds_of_tendsto_atBot tendsto_log_nhdsWithin_zero _\n    (h.tendsto.mono_left inf_le_left)\n\n"}
{"name":"Real.log_prod","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"Œ± : Type u_1\ns : Finset Œ±\nf : Œ± ‚Üí Real\nhf : ‚àÄ (x : Œ±), Membership.mem s x ‚Üí Ne (f x) 0\n‚ä¢ Eq (Real.log (s.prod fun i => f i)) (s.sum fun i => Real.log (f i))","decl":"theorem log_prod {Œ± : Type*} (s : Finset Œ±) (f : Œ± ‚Üí ‚Ñù) (hf : ‚àÄ x ‚àà s, f x ‚â† 0) :\n    log (‚àè i ‚àà s, f i) = ‚àë i ‚àà s, log (f i) := by\n  induction' s using Finset.cons_induction_on with a s ha ih\n  ¬∑ simp\n  ¬∑ rw [Finset.forall_mem_cons] at hf\n    simp [ih hf.2, log_mul hf.1 (Finset.prod_ne_zero_iff.2 hf.2)]\n\n"}
{"name":"Finsupp.log_prod","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù : Zero Œ≤\nf : Finsupp Œ± Œ≤\ng : Œ± ‚Üí Œ≤ ‚Üí Real\nhg : ‚àÄ (a : Œ±), Eq (g a (f a)) 0 ‚Üí Eq (f a) 0\n‚ä¢ Eq (Real.log (f.prod g)) (f.sum fun a b => Real.log (g a b))","decl":"protected theorem _root_.Finsupp.log_prod {Œ± Œ≤ : Type*} [Zero Œ≤] (f : Œ± ‚Üí‚ÇÄ Œ≤) (g : Œ± ‚Üí Œ≤ ‚Üí ‚Ñù)\n    (hg : ‚àÄ a, g a (f a) = 0 ‚Üí f a = 0) : log (f.prod g) = f.sum fun a b ‚Ü¶ log (g a b) :=\n  log_prod _ _ fun _x hx h‚ÇÄ ‚Ü¶ Finsupp.mem_support_iff.1 hx <| hg _ h‚ÇÄ\n\n"}
{"name":"Real.log_nat_eq_sum_factorization","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"n : Nat\n‚ä¢ Eq (Real.log ‚Üën) (n.factorization.sum fun p t => HMul.hMul (‚Üët) (Real.log ‚Üëp))","decl":"theorem log_nat_eq_sum_factorization (n : ‚Ñï) :\n    log n = n.factorization.sum fun p t => t * log p := by\n  rcases eq_or_ne n 0 with (rfl | hn)\n  ¬∑ simp -- relies on junk values of `log` and `Nat.factorization`\n  ¬∑ simp only [‚Üê log_pow, ‚Üê Nat.cast_pow]\n    rw [‚Üê Finsupp.log_prod, ‚Üê Nat.cast_finsupp_prod, Nat.factorization_prod_pow_eq_self hn]\n    intro p hp\n    rw [pow_eq_zero (Nat.cast_eq_zero.1 hp), Nat.factorization_zero_right]\n\n"}
{"name":"Real.tendsto_pow_log_div_mul_add_atTop","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"a b : Real\nn : Nat\nha : Ne a 0\n‚ä¢ Filter.Tendsto (fun x => HDiv.hDiv (HPow.hPow (Real.log x) n) (HAdd.hAdd (HMul.hMul a x) b)) Filter.atTop (nhds 0)","decl":"theorem tendsto_pow_log_div_mul_add_atTop (a b : ‚Ñù) (n : ‚Ñï) (ha : a ‚â† 0) :\n    Tendsto (fun x => log x ^ n / (a * x + b)) atTop (ùìù 0) :=\n  ((tendsto_div_pow_mul_exp_add_atTop a b n ha.symm).comp tendsto_log_atTop).congr' <| by\n    filter_upwards [eventually_gt_atTop (0 : ‚Ñù)] with x hx using by simp [exp_log hx]\n\n"}
{"name":"Real.isLittleO_pow_log_id_atTop","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"n : Nat\n‚ä¢ Asymptotics.IsLittleO Filter.atTop (fun x => HPow.hPow (Real.log x) n) id","decl":"theorem isLittleO_pow_log_id_atTop {n : ‚Ñï} : (fun x => log x ^ n) =o[atTop] id := by\n  rw [Asymptotics.isLittleO_iff_tendsto']\n  ¬∑ simpa using tendsto_pow_log_div_mul_add_atTop 1 0 n one_ne_zero\n  filter_upwards [eventually_ne_atTop (0 : ‚Ñù)] with x h‚ÇÅ h‚ÇÇ using (h‚ÇÅ h‚ÇÇ).elim\n\n"}
{"name":"Real.isLittleO_log_id_atTop","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"‚ä¢ Asymptotics.IsLittleO Filter.atTop Real.log id","decl":"theorem isLittleO_log_id_atTop : log =o[atTop] id :=\n  isLittleO_pow_log_id_atTop.congr_left fun _ => pow_one _\n\n"}
{"name":"Real.isLittleO_const_log_atTop","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"c : Real\n‚ä¢ Asymptotics.IsLittleO Filter.atTop (fun x => c) Real.log","decl":"theorem isLittleO_const_log_atTop {c : ‚Ñù} : (fun _ => c) =o[atTop] log := by\n  refine Asymptotics.isLittleO_of_tendsto' ?_\n    <| Tendsto.div_atTop (a := c) (by simp) tendsto_log_atTop\n  filter_upwards [eventually_gt_atTop 1] with x hx\n  aesop (add safe forward log_pos)\n\n"}
{"name":"Real.expPartialHomeomorph_source","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"‚ä¢ Eq Real.expPartialHomeomorph.source Set.univ","decl":"/-- `Real.exp` as a `PartialHomeomorph` with `source = univ` and `target = {z | 0 < z}`. -/\n@[simps] noncomputable def expPartialHomeomorph : PartialHomeomorph ‚Ñù ‚Ñù where\n  toFun := Real.exp\n  invFun := Real.log\n  source := univ\n  target := Ioi (0 : ‚Ñù)\n  map_source' x _ := exp_pos x\n  map_target' _ _ := mem_univ _\n  left_inv' _ _ := by simp\n  right_inv' _ hx := exp_log hx\n  open_source := isOpen_univ\n  open_target := isOpen_Ioi\n  continuousOn_toFun := continuousOn_exp\n  continuousOn_invFun x hx := (continuousAt_log (ne_of_gt hx)).continuousWithinAt\n\n"}
{"name":"Real.expPartialHomeomorph_apply","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"x : Real\n‚ä¢ Eq (‚ÜëReal.expPartialHomeomorph x) (Real.exp x)","decl":"/-- `Real.exp` as a `PartialHomeomorph` with `source = univ` and `target = {z | 0 < z}`. -/\n@[simps] noncomputable def expPartialHomeomorph : PartialHomeomorph ‚Ñù ‚Ñù where\n  toFun := Real.exp\n  invFun := Real.log\n  source := univ\n  target := Ioi (0 : ‚Ñù)\n  map_source' x _ := exp_pos x\n  map_target' _ _ := mem_univ _\n  left_inv' _ _ := by simp\n  right_inv' _ hx := exp_log hx\n  open_source := isOpen_univ\n  open_target := isOpen_Ioi\n  continuousOn_toFun := continuousOn_exp\n  continuousOn_invFun x hx := (continuousAt_log (ne_of_gt hx)).continuousWithinAt\n\n"}
{"name":"Real.expPartialHomeomorph_target","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"‚ä¢ Eq Real.expPartialHomeomorph.target (Set.Ioi 0)","decl":"/-- `Real.exp` as a `PartialHomeomorph` with `source = univ` and `target = {z | 0 < z}`. -/\n@[simps] noncomputable def expPartialHomeomorph : PartialHomeomorph ‚Ñù ‚Ñù where\n  toFun := Real.exp\n  invFun := Real.log\n  source := univ\n  target := Ioi (0 : ‚Ñù)\n  map_source' x _ := exp_pos x\n  map_target' _ _ := mem_univ _\n  left_inv' _ _ := by simp\n  right_inv' _ hx := exp_log hx\n  open_source := isOpen_univ\n  open_target := isOpen_Ioi\n  continuousOn_toFun := continuousOn_exp\n  continuousOn_invFun x hx := (continuousAt_log (ne_of_gt hx)).continuousWithinAt\n\n"}
{"name":"Real.expPartialHomeomorph_symm_apply","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"x : Real\n‚ä¢ Eq (‚ÜëReal.expPartialHomeomorph.symm x) (Real.log x)","decl":"/-- `Real.exp` as a `PartialHomeomorph` with `source = univ` and `target = {z | 0 < z}`. -/\n@[simps] noncomputable def expPartialHomeomorph : PartialHomeomorph ‚Ñù ‚Ñù where\n  toFun := Real.exp\n  invFun := Real.log\n  source := univ\n  target := Ioi (0 : ‚Ñù)\n  map_source' x _ := exp_pos x\n  map_target' _ _ := mem_univ _\n  left_inv' _ _ := by simp\n  right_inv' _ hx := exp_log hx\n  open_source := isOpen_univ\n  open_target := isOpen_Ioi\n  continuousOn_toFun := continuousOn_exp\n  continuousOn_invFun x hx := (continuousAt_log (ne_of_gt hx)).continuousWithinAt\n\n"}
{"name":"Filter.Tendsto.log","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"Œ± : Type u_1\nf : Œ± ‚Üí Real\nl : Filter Œ±\nx : Real\nh : Filter.Tendsto f l (nhds x)\nhx : Ne x 0\n‚ä¢ Filter.Tendsto (fun x => Real.log (f x)) l (nhds (Real.log x))","decl":"theorem Filter.Tendsto.log {f : Œ± ‚Üí ‚Ñù} {l : Filter Œ±} {x : ‚Ñù} (h : Tendsto f l (ùìù x)) (hx : x ‚â† 0) :\n    Tendsto (fun x => log (f x)) l (ùìù (log x)) :=\n  (continuousAt_log hx).tendsto.comp h\n\n"}
{"name":"Continuous.log","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"Œ± : Type u_1\ninst‚úù : TopologicalSpace Œ±\nf : Œ± ‚Üí Real\nhf : Continuous f\nh‚ÇÄ : ‚àÄ (x : Œ±), Ne (f x) 0\n‚ä¢ Continuous fun x => Real.log (f x)","decl":"@[fun_prop]\ntheorem Continuous.log (hf : Continuous f) (h‚ÇÄ : ‚àÄ x, f x ‚â† 0) : Continuous fun x => log (f x) :=\n  continuousOn_log.comp_continuous hf h‚ÇÄ\n\n"}
{"name":"ContinuousAt.log","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"Œ± : Type u_1\ninst‚úù : TopologicalSpace Œ±\nf : Œ± ‚Üí Real\na : Œ±\nhf : ContinuousAt f a\nh‚ÇÄ : Ne (f a) 0\n‚ä¢ ContinuousAt (fun x => Real.log (f x)) a","decl":"@[fun_prop]\nnonrec theorem ContinuousAt.log (hf : ContinuousAt f a) (h‚ÇÄ : f a ‚â† 0) :\n    ContinuousAt (fun x => log (f x)) a :=\n  hf.log h‚ÇÄ\n\n"}
{"name":"ContinuousWithinAt.log","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"Œ± : Type u_1\ninst‚úù : TopologicalSpace Œ±\nf : Œ± ‚Üí Real\ns : Set Œ±\na : Œ±\nhf : ContinuousWithinAt f s a\nh‚ÇÄ : Ne (f a) 0\n‚ä¢ ContinuousWithinAt (fun x => Real.log (f x)) s a","decl":"nonrec theorem ContinuousWithinAt.log (hf : ContinuousWithinAt f s a) (h‚ÇÄ : f a ‚â† 0) :\n    ContinuousWithinAt (fun x => log (f x)) s a :=\n  hf.log h‚ÇÄ\n\n"}
{"name":"ContinuousOn.log","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"Œ± : Type u_1\ninst‚úù : TopologicalSpace Œ±\nf : Œ± ‚Üí Real\ns : Set Œ±\nhf : ContinuousOn f s\nh‚ÇÄ : ‚àÄ (x : Œ±), Membership.mem s x ‚Üí Ne (f x) 0\n‚ä¢ ContinuousOn (fun x => Real.log (f x)) s","decl":"@[fun_prop]\ntheorem ContinuousOn.log (hf : ContinuousOn f s) (h‚ÇÄ : ‚àÄ x ‚àà s, f x ‚â† 0) :\n    ContinuousOn (fun x => log (f x)) s := fun x hx => (hf x hx).log (h‚ÇÄ x hx)\n\n"}
{"name":"Real.tendsto_log_comp_add_sub_log","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"y : Real\n‚ä¢ Filter.Tendsto (fun x => HSub.hSub (Real.log (HAdd.hAdd x y)) (Real.log x)) Filter.atTop (nhds 0)","decl":"theorem tendsto_log_comp_add_sub_log (y : ‚Ñù) :\n    Tendsto (fun x : ‚Ñù => log (x + y) - log x) atTop (ùìù 0) := by\n  have : Tendsto (fun x ‚Ü¶ 1 + y / x) atTop (ùìù (1 + 0)) :=\n    tendsto_const_nhds.add (tendsto_const_nhds.div_atTop tendsto_id)\n  rw [‚Üê comap_exp_nhds_exp, exp_zero, tendsto_comap_iff, ‚Üê add_zero (1 : ‚Ñù)]\n  refine this.congr' ?_\n  filter_upwards [eventually_gt_atTop (0 : ‚Ñù), eventually_gt_atTop (-y)] with x hx‚ÇÄ hxy\n  rw [comp_apply, exp_sub, exp_log, exp_log, one_add_div] <;> linarith\n\n"}
{"name":"Real.tendsto_log_nat_add_one_sub_log","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"‚ä¢ Filter.Tendsto (fun k => HSub.hSub (Real.log (HAdd.hAdd (‚Üëk) 1)) (Real.log ‚Üëk)) Filter.atTop (nhds 0)","decl":"theorem tendsto_log_nat_add_one_sub_log : Tendsto (fun k : ‚Ñï => log (k + 1) - log k) atTop (ùìù 0) :=\n  (tendsto_log_comp_add_sub_log 1).comp tendsto_natCast_atTop_atTop\n\n"}
{"name":"Mathlib.Meta.Positivity.log_nonneg_of_isNat","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"e : Real\nn : Nat\nh : Mathlib.Meta.NormNum.IsNat e n\n‚ä¢ LE.le 0 (Real.log e)","decl":"lemma log_nonneg_of_isNat {n : ‚Ñï} (h : NormNum.IsNat e n) : 0 ‚â§ Real.log (e : ‚Ñù) := by\n  rw [NormNum.IsNat.to_eq h rfl]\n  exact Real.log_natCast_nonneg _\n\n"}
{"name":"Mathlib.Meta.Positivity.log_pos_of_isNat","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"e : Real\nn : Nat\nh : Mathlib.Meta.NormNum.IsNat e n\nw : Eq (Nat.blt 1 n) Bool.true\n‚ä¢ LT.lt 0 (Real.log e)","decl":"lemma log_pos_of_isNat {n : ‚Ñï} (h : NormNum.IsNat e n) (w : Nat.blt 1 n = true) :\n    0 < Real.log (e : ‚Ñù) := by\n  rw [NormNum.IsNat.to_eq h rfl]\n  apply Real.log_pos\n  simpa using w\n\n"}
{"name":"Mathlib.Meta.Positivity.log_nonneg_of_isNegNat","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"e : Real\nn : Nat\nh : Mathlib.Meta.NormNum.IsInt e (Int.negOfNat n)\n‚ä¢ LE.le 0 (Real.log e)","decl":"lemma log_nonneg_of_isNegNat {n : ‚Ñï} (h : NormNum.IsInt e (.negOfNat n)) :\n    0 ‚â§ Real.log (e : ‚Ñù) := by\n  rw [NormNum.IsInt.neg_to_eq h rfl]\n  exact Real.log_neg_natCast_nonneg _\n\n"}
{"name":"Mathlib.Meta.Positivity.log_pos_of_isNegNat","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"e : Real\nn : Nat\nh : Mathlib.Meta.NormNum.IsInt e (Int.negOfNat n)\nw : Eq (Nat.blt 1 n) Bool.true\n‚ä¢ LT.lt 0 (Real.log e)","decl":"lemma log_pos_of_isNegNat {n : ‚Ñï} (h : NormNum.IsInt e (.negOfNat n)) (w : Nat.blt 1 n = true) :\n    0 < Real.log (e : ‚Ñù) := by\n  rw [NormNum.IsInt.neg_to_eq h rfl]\n  rw [Real.log_neg_eq_log]\n  apply Real.log_pos\n  simpa using w\n\n"}
{"name":"Mathlib.Meta.Positivity.log_pos_of_isRat","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"e : Real\nd : Nat\nn : Int\na‚úù¬π : Mathlib.Meta.NormNum.IsRat e n d\na‚úù : Eq (Decidable.decide (LT.lt 1 (HDiv.hDiv ‚Üën ‚Üëd))) Bool.true\n‚ä¢ LT.lt 0 (Real.log e)","decl":"lemma log_pos_of_isRat {n : ‚Ñ§} :\n    (NormNum.IsRat e n d) ‚Üí (decide ((1 : ‚Ñö) < n / d)) ‚Üí (0 < Real.log (e : ‚Ñù))\n  | ‚ü®inv, eq‚ü©, h => by\n    rw [eq, invOf_eq_inv, ‚Üê div_eq_mul_inv]\n    have : 1 < (n : ‚Ñù) / d := by exact_mod_cast of_decide_eq_true h\n    exact Real.log_pos this\n\n"}
{"name":"Mathlib.Meta.Positivity.log_pos_of_isRat_neg","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"e : Real\nd : Nat\nn : Int\na‚úù¬π : Mathlib.Meta.NormNum.IsRat e n d\na‚úù : Eq (Decidable.decide (LT.lt (HDiv.hDiv ‚Üën ‚Üëd) (-1))) Bool.true\n‚ä¢ LT.lt 0 (Real.log e)","decl":"lemma log_pos_of_isRat_neg {n : ‚Ñ§} :\n    (NormNum.IsRat e n d) ‚Üí (decide (n / d < (-1 : ‚Ñö))) ‚Üí (0 < Real.log (e : ‚Ñù))\n  | ‚ü®inv, eq‚ü©, h => by\n    rw [eq, invOf_eq_inv, ‚Üê div_eq_mul_inv]\n    have : (n : ‚Ñù) / d < -1 := by exact_mod_cast of_decide_eq_true h\n    exact Real.log_pos_of_lt_neg_one this\n\n"}
{"name":"Mathlib.Meta.Positivity.log_nz_of_isRat","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"e : Real\nd : Nat\nn : Int\na‚úù¬≤ : Mathlib.Meta.NormNum.IsRat e n d\na‚úù¬π : Eq (Decidable.decide (LT.lt 0 (HDiv.hDiv ‚Üën ‚Üëd))) Bool.true\na‚úù : Eq (Decidable.decide (LT.lt (HDiv.hDiv ‚Üën ‚Üëd) 1)) Bool.true\n‚ä¢ Ne (Real.log e) 0","decl":"lemma log_nz_of_isRat {n : ‚Ñ§} : (NormNum.IsRat e n d) ‚Üí (decide ((0 : ‚Ñö) < n / d))\n    ‚Üí (decide (n / d < (1 : ‚Ñö))) ‚Üí (Real.log (e : ‚Ñù) ‚â† 0)\n  | ‚ü®inv, eq‚ü©, h‚ÇÅ, h‚ÇÇ => by\n    rw [eq, invOf_eq_inv, ‚Üê div_eq_mul_inv]\n    have h‚ÇÅ' : 0 < (n : ‚Ñù) / d := by exact_mod_cast of_decide_eq_true h‚ÇÅ\n    have h‚ÇÇ' : (n : ‚Ñù) / d < 1 := by exact_mod_cast of_decide_eq_true h‚ÇÇ\n    exact ne_of_lt <| Real.log_neg h‚ÇÅ' h‚ÇÇ'\n\n"}
{"name":"Mathlib.Meta.Positivity.log_nz_of_isRat_neg","module":"Mathlib.Analysis.SpecialFunctions.Log.Basic","initialProofState":"e : Real\nd : Nat\nn : Int\na‚úù¬≤ : Mathlib.Meta.NormNum.IsRat e n d\na‚úù¬π : Eq (Decidable.decide (LT.lt (HDiv.hDiv ‚Üën ‚Üëd) 0)) Bool.true\na‚úù : Eq (Decidable.decide (LT.lt (-1) (HDiv.hDiv ‚Üën ‚Üëd))) Bool.true\n‚ä¢ Ne (Real.log e) 0","decl":"lemma log_nz_of_isRat_neg {n : ‚Ñ§} : (NormNum.IsRat e n d) ‚Üí (decide (n / d < (0 : ‚Ñö)))\n    ‚Üí (decide ((-1 : ‚Ñö) < n / d)) ‚Üí (Real.log (e : ‚Ñù) ‚â† 0)\n  | ‚ü®inv, eq‚ü©, h‚ÇÅ, h‚ÇÇ => by\n    rw [eq, invOf_eq_inv, ‚Üê div_eq_mul_inv]\n    have h‚ÇÅ' : (n : ‚Ñù) / d < 0 := by exact_mod_cast of_decide_eq_true h‚ÇÅ\n    have h‚ÇÇ' : -1 < (n : ‚Ñù) / d := by exact_mod_cast of_decide_eq_true h‚ÇÇ\n    exact ne_of_lt <| Real.log_neg_of_lt_zero h‚ÇÅ' h‚ÇÇ'\n\n"}
