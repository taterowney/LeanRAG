{"name":"MeasurableSpace.mk.injEq","module":"Mathlib.MeasureTheory.MeasurableSpace.Defs","initialProofState":"α : Type u_7\nMeasurableSet'✝ : Set α → Prop\nmeasurableSet_empty✝ : MeasurableSet'✝ EmptyCollection.emptyCollection\nmeasurableSet_compl✝ : ∀ (s : Set α), MeasurableSet'✝ s → MeasurableSet'✝ (HasCompl.compl s)\nmeasurableSet_iUnion✝ : ∀ (f : Nat → Set α), (∀ (i : Nat), MeasurableSet'✝ (f i)) → MeasurableSet'✝ (Set.iUnion fun i => f i)\nMeasurableSet' : Set α → Prop\nmeasurableSet_empty : MeasurableSet' EmptyCollection.emptyCollection\nmeasurableSet_compl : ∀ (s : Set α), MeasurableSet' s → MeasurableSet' (HasCompl.compl s)\nmeasurableSet_iUnion : ∀ (f : Nat → Set α), (∀ (i : Nat), MeasurableSet' (f i)) → MeasurableSet' (Set.iUnion fun i => f i)\n⊢ Eq (Eq { MeasurableSet' := MeasurableSet'✝, measurableSet_empty := measurableSet_empty✝, measurableSet_compl := measurableSet_compl✝, measurableSet_iUnion := measurableSet_iUnion✝ } { MeasurableSet' := MeasurableSet', measurableSet_empty := measurableSet_empty, measurableSet_compl := measurableSet_compl, measurableSet_iUnion := measurableSet_iUnion }) (Eq MeasurableSet'✝ MeasurableSet')","decl":"/-- A measurable space is a space equipped with a σ-algebra. -/\n@[class] structure MeasurableSpace (α : Type*) where\n  /-- Predicate saying that a given set is measurable. Use `MeasurableSet` in the root namespace\n  instead. -/\n  MeasurableSet' : Set α → Prop\n  /-- The empty set is a measurable set. Use `MeasurableSet.empty` instead. -/\n  measurableSet_empty : MeasurableSet' ∅\n  /-- The complement of a measurable set is a measurable set. Use `MeasurableSet.compl` instead. -/\n  measurableSet_compl : ∀ s, MeasurableSet' s → MeasurableSet' sᶜ\n  /-- The union of a sequence of measurable sets is a measurable set. Use a more general\n  `MeasurableSet.iUnion` instead. -/\n  measurableSet_iUnion : ∀ f : ℕ → Set α, (∀ i, MeasurableSet' (f i)) → MeasurableSet' (⋃ i, f i)\n\n"}
{"name":"MeasurableSpace.measurableSet_iUnion","module":"Mathlib.MeasureTheory.MeasurableSpace.Defs","initialProofState":"α : Type u_7\nself : MeasurableSpace α\nf : Nat → Set α\na✝ : ∀ (i : Nat), self.MeasurableSet' (f i)\n⊢ self.MeasurableSet' (Set.iUnion fun i => f i)","decl":"/-- A measurable space is a space equipped with a σ-algebra. -/\n@[class] structure MeasurableSpace (α : Type*) where\n  /-- Predicate saying that a given set is measurable. Use `MeasurableSet` in the root namespace\n  instead. -/\n  MeasurableSet' : Set α → Prop\n  /-- The empty set is a measurable set. Use `MeasurableSet.empty` instead. -/\n  measurableSet_empty : MeasurableSet' ∅\n  /-- The complement of a measurable set is a measurable set. Use `MeasurableSet.compl` instead. -/\n  measurableSet_compl : ∀ s, MeasurableSet' s → MeasurableSet' sᶜ\n  /-- The union of a sequence of measurable sets is a measurable set. Use a more general\n  `MeasurableSet.iUnion` instead. -/\n  measurableSet_iUnion : ∀ f : ℕ → Set α, (∀ i, MeasurableSet' (f i)) → MeasurableSet' (⋃ i, f i)\n\n"}
{"name":"MeasurableSpace.mk.inj","module":"Mathlib.MeasureTheory.MeasurableSpace.Defs","initialProofState":"α : Type u_7\nMeasurableSet'✝ : Set α → Prop\nmeasurableSet_empty✝ : MeasurableSet'✝ EmptyCollection.emptyCollection\nmeasurableSet_compl✝ : ∀ (s : Set α), MeasurableSet'✝ s → MeasurableSet'✝ (HasCompl.compl s)\nmeasurableSet_iUnion✝ : ∀ (f : Nat → Set α), (∀ (i : Nat), MeasurableSet'✝ (f i)) → MeasurableSet'✝ (Set.iUnion fun i => f i)\nMeasurableSet' : Set α → Prop\nmeasurableSet_empty : MeasurableSet' EmptyCollection.emptyCollection\nmeasurableSet_compl : ∀ (s : Set α), MeasurableSet' s → MeasurableSet' (HasCompl.compl s)\nmeasurableSet_iUnion : ∀ (f : Nat → Set α), (∀ (i : Nat), MeasurableSet' (f i)) → MeasurableSet' (Set.iUnion fun i => f i)\nx✝ : Eq { MeasurableSet' := MeasurableSet'✝, measurableSet_empty := measurableSet_empty✝, measurableSet_compl := measurableSet_compl✝, measurableSet_iUnion := measurableSet_iUnion✝ } { MeasurableSet' := MeasurableSet', measurableSet_empty := measurableSet_empty, measurableSet_compl := measurableSet_compl, measurableSet_iUnion := measurableSet_iUnion }\n⊢ Eq MeasurableSet'✝ MeasurableSet'","decl":"/-- A measurable space is a space equipped with a σ-algebra. -/\n@[class] structure MeasurableSpace (α : Type*) where\n  /-- Predicate saying that a given set is measurable. Use `MeasurableSet` in the root namespace\n  instead. -/\n  MeasurableSet' : Set α → Prop\n  /-- The empty set is a measurable set. Use `MeasurableSet.empty` instead. -/\n  measurableSet_empty : MeasurableSet' ∅\n  /-- The complement of a measurable set is a measurable set. Use `MeasurableSet.compl` instead. -/\n  measurableSet_compl : ∀ s, MeasurableSet' s → MeasurableSet' sᶜ\n  /-- The union of a sequence of measurable sets is a measurable set. Use a more general\n  `MeasurableSet.iUnion` instead. -/\n  measurableSet_iUnion : ∀ f : ℕ → Set α, (∀ i, MeasurableSet' (f i)) → MeasurableSet' (⋃ i, f i)\n\n"}
{"name":"MeasurableSpace.measurableSet_compl","module":"Mathlib.MeasureTheory.MeasurableSpace.Defs","initialProofState":"α : Type u_7\nself : MeasurableSpace α\ns : Set α\na✝ : self.MeasurableSet' s\n⊢ self.MeasurableSet' (HasCompl.compl s)","decl":"/-- A measurable space is a space equipped with a σ-algebra. -/\n@[class] structure MeasurableSpace (α : Type*) where\n  /-- Predicate saying that a given set is measurable. Use `MeasurableSet` in the root namespace\n  instead. -/\n  MeasurableSet' : Set α → Prop\n  /-- The empty set is a measurable set. Use `MeasurableSet.empty` instead. -/\n  measurableSet_empty : MeasurableSet' ∅\n  /-- The complement of a measurable set is a measurable set. Use `MeasurableSet.compl` instead. -/\n  measurableSet_compl : ∀ s, MeasurableSet' s → MeasurableSet' sᶜ\n  /-- The union of a sequence of measurable sets is a measurable set. Use a more general\n  `MeasurableSet.iUnion` instead. -/\n  measurableSet_iUnion : ∀ f : ℕ → Set α, (∀ i, MeasurableSet' (f i)) → MeasurableSet' (⋃ i, f i)\n\n"}
{"name":"MeasurableSpace.measurableSet_empty","module":"Mathlib.MeasureTheory.MeasurableSpace.Defs","initialProofState":"α : Type u_7\nself : MeasurableSpace α\n⊢ self.MeasurableSet' EmptyCollection.emptyCollection","decl":"/-- A measurable space is a space equipped with a σ-algebra. -/\n@[class] structure MeasurableSpace (α : Type*) where\n  /-- Predicate saying that a given set is measurable. Use `MeasurableSet` in the root namespace\n  instead. -/\n  MeasurableSet' : Set α → Prop\n  /-- The empty set is a measurable set. Use `MeasurableSet.empty` instead. -/\n  measurableSet_empty : MeasurableSet' ∅\n  /-- The complement of a measurable set is a measurable set. Use `MeasurableSet.compl` instead. -/\n  measurableSet_compl : ∀ s, MeasurableSet' s → MeasurableSet' sᶜ\n  /-- The union of a sequence of measurable sets is a measurable set. Use a more general\n  `MeasurableSet.iUnion` instead. -/\n  measurableSet_iUnion : ∀ f : ℕ → Set α, (∀ i, MeasurableSet' (f i)) → MeasurableSet' (⋃ i, f i)\n\n"}
{"name":"MeasurableSpace.mk.sizeOf_spec","module":"Mathlib.MeasureTheory.MeasurableSpace.Defs","initialProofState":"α : Type u_7\ninst✝ : SizeOf α\nMeasurableSet' : Set α → Prop\nmeasurableSet_empty : MeasurableSet' EmptyCollection.emptyCollection\nmeasurableSet_compl : ∀ (s : Set α), MeasurableSet' s → MeasurableSet' (HasCompl.compl s)\nmeasurableSet_iUnion : ∀ (f : Nat → Set α), (∀ (i : Nat), MeasurableSet' (f i)) → MeasurableSet' (Set.iUnion fun i => f i)\n⊢ Eq (SizeOf.sizeOf { MeasurableSet' := MeasurableSet', measurableSet_empty := measurableSet_empty, measurableSet_compl := measurableSet_compl, measurableSet_iUnion := measurableSet_iUnion }) (HAdd.hAdd 1 (SizeOf.sizeOf measurableSet_empty))","decl":"/-- A measurable space is a space equipped with a σ-algebra. -/\n@[class] structure MeasurableSpace (α : Type*) where\n  /-- Predicate saying that a given set is measurable. Use `MeasurableSet` in the root namespace\n  instead. -/\n  MeasurableSet' : Set α → Prop\n  /-- The empty set is a measurable set. Use `MeasurableSet.empty` instead. -/\n  measurableSet_empty : MeasurableSet' ∅\n  /-- The complement of a measurable set is a measurable set. Use `MeasurableSet.compl` instead. -/\n  measurableSet_compl : ∀ s, MeasurableSet' s → MeasurableSet' sᶜ\n  /-- The union of a sequence of measurable sets is a measurable set. Use a more general\n  `MeasurableSet.iUnion` instead. -/\n  measurableSet_iUnion : ∀ f : ℕ → Set α, (∀ i, MeasurableSet' (f i)) → MeasurableSet' (⋃ i, f i)\n\n"}
{"name":"MeasurableSet.empty","module":"Mathlib.MeasureTheory.MeasurableSpace.Defs","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\n⊢ MeasurableSet EmptyCollection.emptyCollection","decl":"@[simp, measurability]\ntheorem MeasurableSet.empty [MeasurableSpace α] : MeasurableSet (∅ : Set α) :=\n  MeasurableSpace.measurableSet_empty _\n\n"}
{"name":"MeasurableSet.compl","module":"Mathlib.MeasureTheory.MeasurableSpace.Defs","initialProofState":"α : Type u_1\ns : Set α\nm : MeasurableSpace α\na✝ : MeasurableSet s\n⊢ MeasurableSet (HasCompl.compl s)","decl":"@[measurability]\nprotected theorem MeasurableSet.compl : MeasurableSet s → MeasurableSet sᶜ :=\n  MeasurableSpace.measurableSet_compl _ s\n\n"}
{"name":"MeasurableSet.of_compl","module":"Mathlib.MeasureTheory.MeasurableSpace.Defs","initialProofState":"α : Type u_1\ns : Set α\nm : MeasurableSpace α\nh : MeasurableSet (HasCompl.compl s)\n⊢ MeasurableSet s","decl":"protected theorem MeasurableSet.of_compl (h : MeasurableSet sᶜ) : MeasurableSet s :=\n  compl_compl s ▸ h.compl\n\n"}
{"name":"MeasurableSet.compl_iff","module":"Mathlib.MeasureTheory.MeasurableSpace.Defs","initialProofState":"α : Type u_1\ns : Set α\nm : MeasurableSpace α\n⊢ Iff (MeasurableSet (HasCompl.compl s)) (MeasurableSet s)","decl":"@[simp]\ntheorem MeasurableSet.compl_iff : MeasurableSet sᶜ ↔ MeasurableSet s :=\n  ⟨.of_compl, .compl⟩\n\n"}
{"name":"MeasurableSet.univ","module":"Mathlib.MeasureTheory.MeasurableSpace.Defs","initialProofState":"α : Type u_1\nm : MeasurableSpace α\n⊢ MeasurableSet Set.univ","decl":"@[simp, measurability]\nprotected theorem MeasurableSet.univ : MeasurableSet (univ : Set α) :=\n  .of_compl <| by simp\n\n"}
{"name":"Subsingleton.measurableSet","module":"Mathlib.MeasureTheory.MeasurableSpace.Defs","initialProofState":"α : Type u_1\nm : MeasurableSpace α\ninst✝ : Subsingleton α\ns : Set α\n⊢ MeasurableSet s","decl":"@[nontriviality, measurability]\ntheorem Subsingleton.measurableSet [Subsingleton α] {s : Set α} : MeasurableSet s :=\n  Subsingleton.set_cases MeasurableSet.empty MeasurableSet.univ s\n\n"}
{"name":"MeasurableSet.congr","module":"Mathlib.MeasureTheory.MeasurableSpace.Defs","initialProofState":"α : Type u_1\nm : MeasurableSpace α\ns t : Set α\nhs : MeasurableSet s\nh : Eq s t\n⊢ MeasurableSet t","decl":"theorem MeasurableSet.congr {s t : Set α} (hs : MeasurableSet s) (h : s = t) : MeasurableSet t := by\n  rwa [← h]\n\n"}
{"name":"MeasurableSet.iUnion","module":"Mathlib.MeasureTheory.MeasurableSpace.Defs","initialProofState":"α : Type u_1\nι : Sort u_6\nm : MeasurableSpace α\ninst✝ : Countable ι\nf : ι → Set α\nh : ∀ (b : ι), MeasurableSet (f b)\n⊢ MeasurableSet (Set.iUnion fun b => f b)","decl":"@[measurability]\nprotected theorem MeasurableSet.iUnion [Countable ι] ⦃f : ι → Set α⦄\n    (h : ∀ b, MeasurableSet (f b)) : MeasurableSet (⋃ b, f b) := by\n  cases isEmpty_or_nonempty ι\n  · simp\n  · rcases exists_surjective_nat ι with ⟨e, he⟩\n    rw [← iUnion_congr_of_surjective _ he (fun _ => rfl)]\n    exact m.measurableSet_iUnion _ fun _ => h _\n\n"}
{"name":"MeasurableSet.biUnion","module":"Mathlib.MeasureTheory.MeasurableSpace.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nf : β → Set α\ns : Set β\nhs : s.Countable\nh : ∀ (b : β), Membership.mem s b → MeasurableSet (f b)\n⊢ MeasurableSet (Set.iUnion fun b => Set.iUnion fun h => f b)","decl":"protected theorem MeasurableSet.biUnion {f : β → Set α} {s : Set β} (hs : s.Countable)\n    (h : ∀ b ∈ s, MeasurableSet (f b)) : MeasurableSet (⋃ b ∈ s, f b) := by\n  rw [biUnion_eq_iUnion]\n  have := hs.to_subtype\n  exact MeasurableSet.iUnion (by simpa using h)\n\n"}
{"name":"Set.Finite.measurableSet_biUnion","module":"Mathlib.MeasureTheory.MeasurableSpace.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nf : β → Set α\ns : Set β\nhs : s.Finite\nh : ∀ (b : β), Membership.mem s b → MeasurableSet (f b)\n⊢ MeasurableSet (Set.iUnion fun b => Set.iUnion fun h => f b)","decl":"theorem Set.Finite.measurableSet_biUnion {f : β → Set α} {s : Set β} (hs : s.Finite)\n    (h : ∀ b ∈ s, MeasurableSet (f b)) : MeasurableSet (⋃ b ∈ s, f b) :=\n  .biUnion hs.countable h\n\n"}
{"name":"Finset.measurableSet_biUnion","module":"Mathlib.MeasureTheory.MeasurableSpace.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nf : β → Set α\ns : Finset β\nh : ∀ (b : β), Membership.mem s b → MeasurableSet (f b)\n⊢ MeasurableSet (Set.iUnion fun b => Set.iUnion fun h => f b)","decl":"theorem Finset.measurableSet_biUnion {f : β → Set α} (s : Finset β)\n    (h : ∀ b ∈ s, MeasurableSet (f b)) : MeasurableSet (⋃ b ∈ s, f b) :=\n  s.finite_toSet.measurableSet_biUnion h\n\n"}
{"name":"MeasurableSet.sUnion","module":"Mathlib.MeasureTheory.MeasurableSpace.Defs","initialProofState":"α : Type u_1\nm : MeasurableSpace α\ns : Set (Set α)\nhs : s.Countable\nh : ∀ (t : Set α), Membership.mem s t → MeasurableSet t\n⊢ MeasurableSet s.sUnion","decl":"protected theorem MeasurableSet.sUnion {s : Set (Set α)} (hs : s.Countable)\n    (h : ∀ t ∈ s, MeasurableSet t) : MeasurableSet (⋃₀ s) := by\n  rw [sUnion_eq_biUnion]\n  exact .biUnion hs h\n\n"}
{"name":"Set.Finite.measurableSet_sUnion","module":"Mathlib.MeasureTheory.MeasurableSpace.Defs","initialProofState":"α : Type u_1\nm : MeasurableSpace α\ns : Set (Set α)\nhs : s.Finite\nh : ∀ (t : Set α), Membership.mem s t → MeasurableSet t\n⊢ MeasurableSet s.sUnion","decl":"theorem Set.Finite.measurableSet_sUnion {s : Set (Set α)} (hs : s.Finite)\n    (h : ∀ t ∈ s, MeasurableSet t) : MeasurableSet (⋃₀ s) :=\n  MeasurableSet.sUnion hs.countable h\n\n"}
{"name":"MeasurableSet.iInter","module":"Mathlib.MeasureTheory.MeasurableSpace.Defs","initialProofState":"α : Type u_1\nι : Sort u_6\nm : MeasurableSpace α\ninst✝ : Countable ι\nf : ι → Set α\nh : ∀ (b : ι), MeasurableSet (f b)\n⊢ MeasurableSet (Set.iInter fun b => f b)","decl":"@[measurability]\ntheorem MeasurableSet.iInter [Countable ι] {f : ι → Set α} (h : ∀ b, MeasurableSet (f b)) :\n    MeasurableSet (⋂ b, f b) :=\n  .of_compl <| by rw [compl_iInter]; exact .iUnion fun b => (h b).compl\n\n"}
{"name":"MeasurableSet.biInter","module":"Mathlib.MeasureTheory.MeasurableSpace.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nf : β → Set α\ns : Set β\nhs : s.Countable\nh : ∀ (b : β), Membership.mem s b → MeasurableSet (f b)\n⊢ MeasurableSet (Set.iInter fun b => Set.iInter fun h => f b)","decl":"theorem MeasurableSet.biInter {f : β → Set α} {s : Set β} (hs : s.Countable)\n    (h : ∀ b ∈ s, MeasurableSet (f b)) : MeasurableSet (⋂ b ∈ s, f b) :=\n  .of_compl <| by rw [compl_iInter₂]; exact .biUnion hs fun b hb => (h b hb).compl\n\n"}
{"name":"Set.Finite.measurableSet_biInter","module":"Mathlib.MeasureTheory.MeasurableSpace.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nf : β → Set α\ns : Set β\nhs : s.Finite\nh : ∀ (b : β), Membership.mem s b → MeasurableSet (f b)\n⊢ MeasurableSet (Set.iInter fun b => Set.iInter fun h => f b)","decl":"theorem Set.Finite.measurableSet_biInter {f : β → Set α} {s : Set β} (hs : s.Finite)\n    (h : ∀ b ∈ s, MeasurableSet (f b)) : MeasurableSet (⋂ b ∈ s, f b) :=\n .biInter hs.countable h\n\n"}
{"name":"Finset.measurableSet_biInter","module":"Mathlib.MeasureTheory.MeasurableSpace.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nf : β → Set α\ns : Finset β\nh : ∀ (b : β), Membership.mem s b → MeasurableSet (f b)\n⊢ MeasurableSet (Set.iInter fun b => Set.iInter fun h => f b)","decl":"theorem Finset.measurableSet_biInter {f : β → Set α} (s : Finset β)\n    (h : ∀ b ∈ s, MeasurableSet (f b)) : MeasurableSet (⋂ b ∈ s, f b) :=\n  s.finite_toSet.measurableSet_biInter h\n\n"}
{"name":"MeasurableSet.sInter","module":"Mathlib.MeasureTheory.MeasurableSpace.Defs","initialProofState":"α : Type u_1\nm : MeasurableSpace α\ns : Set (Set α)\nhs : s.Countable\nh : ∀ (t : Set α), Membership.mem s t → MeasurableSet t\n⊢ MeasurableSet s.sInter","decl":"theorem MeasurableSet.sInter {s : Set (Set α)} (hs : s.Countable) (h : ∀ t ∈ s, MeasurableSet t) :\n    MeasurableSet (⋂₀ s) := by\n  rw [sInter_eq_biInter]\n  exact MeasurableSet.biInter hs h\n\n"}
{"name":"Set.Finite.measurableSet_sInter","module":"Mathlib.MeasureTheory.MeasurableSpace.Defs","initialProofState":"α : Type u_1\nm : MeasurableSpace α\ns : Set (Set α)\nhs : s.Finite\nh : ∀ (t : Set α), Membership.mem s t → MeasurableSet t\n⊢ MeasurableSet s.sInter","decl":"theorem Set.Finite.measurableSet_sInter {s : Set (Set α)} (hs : s.Finite)\n    (h : ∀ t ∈ s, MeasurableSet t) : MeasurableSet (⋂₀ s) :=\n  MeasurableSet.sInter hs.countable h\n\n"}
{"name":"MeasurableSet.union","module":"Mathlib.MeasureTheory.MeasurableSpace.Defs","initialProofState":"α : Type u_1\nm : MeasurableSpace α\ns₁ s₂ : Set α\nh₁ : MeasurableSet s₁\nh₂ : MeasurableSet s₂\n⊢ MeasurableSet (Union.union s₁ s₂)","decl":"@[simp, measurability]\nprotected theorem MeasurableSet.union {s₁ s₂ : Set α} (h₁ : MeasurableSet s₁)\n    (h₂ : MeasurableSet s₂) : MeasurableSet (s₁ ∪ s₂) := by\n  rw [union_eq_iUnion]\n  exact .iUnion (Bool.forall_bool.2 ⟨h₂, h₁⟩)\n\n"}
{"name":"MeasurableSet.inter","module":"Mathlib.MeasureTheory.MeasurableSpace.Defs","initialProofState":"α : Type u_1\nm : MeasurableSpace α\ns₁ s₂ : Set α\nh₁ : MeasurableSet s₁\nh₂ : MeasurableSet s₂\n⊢ MeasurableSet (Inter.inter s₁ s₂)","decl":"@[simp, measurability]\nprotected theorem MeasurableSet.inter {s₁ s₂ : Set α} (h₁ : MeasurableSet s₁)\n    (h₂ : MeasurableSet s₂) : MeasurableSet (s₁ ∩ s₂) := by\n  rw [inter_eq_compl_compl_union_compl]\n  exact (h₁.compl.union h₂.compl).compl\n\n"}
{"name":"MeasurableSet.diff","module":"Mathlib.MeasureTheory.MeasurableSpace.Defs","initialProofState":"α : Type u_1\nm : MeasurableSpace α\ns₁ s₂ : Set α\nh₁ : MeasurableSet s₁\nh₂ : MeasurableSet s₂\n⊢ MeasurableSet (SDiff.sdiff s₁ s₂)","decl":"@[simp, measurability]\nprotected theorem MeasurableSet.diff {s₁ s₂ : Set α} (h₁ : MeasurableSet s₁)\n    (h₂ : MeasurableSet s₂) : MeasurableSet (s₁ \\ s₂) :=\n  h₁.inter h₂.compl\n\n"}
{"name":"MeasurableSet.himp","module":"Mathlib.MeasureTheory.MeasurableSpace.Defs","initialProofState":"α : Type u_1\nm : MeasurableSpace α\ns₁ s₂ : Set α\nh₁ : MeasurableSet s₁\nh₂ : MeasurableSet s₂\n⊢ MeasurableSet (HImp.himp s₁ s₂)","decl":"@[simp, measurability]\nprotected lemma MeasurableSet.himp {s₁ s₂ : Set α} (h₁ : MeasurableSet s₁) (h₂ : MeasurableSet s₂) :\n    MeasurableSet (s₁ ⇨ s₂) := by rw [himp_eq]; exact h₂.union h₁.compl\n\n"}
{"name":"MeasurableSet.symmDiff","module":"Mathlib.MeasureTheory.MeasurableSpace.Defs","initialProofState":"α : Type u_1\nm : MeasurableSpace α\ns₁ s₂ : Set α\nh₁ : MeasurableSet s₁\nh₂ : MeasurableSet s₂\n⊢ MeasurableSet (symmDiff s₁ s₂)","decl":"@[simp, measurability]\nprotected theorem MeasurableSet.symmDiff {s₁ s₂ : Set α} (h₁ : MeasurableSet s₁)\n    (h₂ : MeasurableSet s₂) : MeasurableSet (s₁ ∆ s₂) :=\n  (h₁.diff h₂).union (h₂.diff h₁)\n\n"}
{"name":"MeasurableSet.bihimp","module":"Mathlib.MeasureTheory.MeasurableSpace.Defs","initialProofState":"α : Type u_1\nm : MeasurableSpace α\ns₁ s₂ : Set α\nh₁ : MeasurableSet s₁\nh₂ : MeasurableSet s₂\n⊢ MeasurableSet (bihimp s₁ s₂)","decl":"@[simp, measurability]\nprotected lemma MeasurableSet.bihimp {s₁ s₂ : Set α} (h₁ : MeasurableSet s₁)\n    (h₂ : MeasurableSet s₂) : MeasurableSet (s₁ ⇔ s₂) := (h₂.himp h₁).inter (h₁.himp h₂)\n\n"}
{"name":"MeasurableSet.ite","module":"Mathlib.MeasureTheory.MeasurableSpace.Defs","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nt s₁ s₂ : Set α\nht : MeasurableSet t\nh₁ : MeasurableSet s₁\nh₂ : MeasurableSet s₂\n⊢ MeasurableSet (t.ite s₁ s₂)","decl":"@[simp, measurability]\nprotected theorem MeasurableSet.ite {t s₁ s₂ : Set α} (ht : MeasurableSet t)\n    (h₁ : MeasurableSet s₁) (h₂ : MeasurableSet s₂) : MeasurableSet (t.ite s₁ s₂) :=\n  (h₁.inter ht).union (h₂.diff ht)\n\n"}
{"name":"MeasurableSet.ite'","module":"Mathlib.MeasureTheory.MeasurableSpace.Defs","initialProofState":"α : Type u_1\nm : MeasurableSpace α\ns t : Set α\np : Prop\nhs : p → MeasurableSet s\nht : Not p → MeasurableSet t\n⊢ MeasurableSet (ite p s t)","decl":"open Classical in\ntheorem MeasurableSet.ite' {s t : Set α} {p : Prop} (hs : p → MeasurableSet s)\n    (ht : ¬p → MeasurableSet t) : MeasurableSet (ite p s t) := by\n  split_ifs with h\n  exacts [hs h, ht h]\n\n"}
{"name":"MeasurableSet.cond","module":"Mathlib.MeasureTheory.MeasurableSpace.Defs","initialProofState":"α : Type u_1\nm : MeasurableSpace α\ns₁ s₂ : Set α\nh₁ : MeasurableSet s₁\nh₂ : MeasurableSet s₂\ni : Bool\n⊢ MeasurableSet (cond i s₁ s₂)","decl":"@[simp, measurability]\nprotected theorem MeasurableSet.cond {s₁ s₂ : Set α} (h₁ : MeasurableSet s₁)\n    (h₂ : MeasurableSet s₂) {i : Bool} : MeasurableSet (cond i s₁ s₂) := by\n  cases i\n  exacts [h₂, h₁]\n\n"}
{"name":"MeasurableSet.disjointed","module":"Mathlib.MeasureTheory.MeasurableSpace.Defs","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nf : Nat → Set α\nh : ∀ (i : Nat), MeasurableSet (f i)\nn : Nat\n⊢ MeasurableSet (disjointed f n)","decl":"@[simp, measurability]\nprotected theorem MeasurableSet.disjointed {f : ℕ → Set α} (h : ∀ i, MeasurableSet (f i)) (n) :\n    MeasurableSet (disjointed f n) :=\n  disjointedRec (fun _ _ ht => MeasurableSet.diff ht <| h _) (h n)\n\n"}
{"name":"MeasurableSet.const","module":"Mathlib.MeasureTheory.MeasurableSpace.Defs","initialProofState":"α : Type u_1\nm : MeasurableSpace α\np : Prop\n⊢ MeasurableSet (setOf fun _a => p)","decl":"protected theorem MeasurableSet.const (p : Prop) : MeasurableSet { _a : α | p } := by\n  by_cases p <;> simp [*]\n\n"}
{"name":"nonempty_measurable_superset","module":"Mathlib.MeasureTheory.MeasurableSpace.Defs","initialProofState":"α : Type u_1\nm : MeasurableSpace α\ns : Set α\n⊢ Nonempty (Subtype fun t => And (HasSubset.Subset s t) (MeasurableSet t))","decl":"/-- Every set has a measurable superset. Declare this as local instance as needed. -/\ntheorem nonempty_measurable_superset (s : Set α) : Nonempty { t // s ⊆ t ∧ MeasurableSet t } :=\n  ⟨⟨univ, subset_univ s, MeasurableSet.univ⟩⟩\n\n"}
{"name":"MeasurableSpace.measurableSet_injective","module":"Mathlib.MeasureTheory.MeasurableSpace.Defs","initialProofState":"α : Type u_1\n⊢ Function.Injective (@MeasurableSet α)","decl":"theorem MeasurableSpace.measurableSet_injective : Injective (@MeasurableSet α)\n  | ⟨_, _, _, _⟩, ⟨_, _, _, _⟩, _ => by congr\n\n"}
{"name":"MeasurableSpace.ext","module":"Mathlib.MeasureTheory.MeasurableSpace.Defs","initialProofState":"α : Type u_1\nm₁ m₂ : MeasurableSpace α\nh : ∀ (s : Set α), Iff (MeasurableSet s) (MeasurableSet s)\n⊢ Eq m₁ m₂","decl":"@[ext]\ntheorem MeasurableSpace.ext {m₁ m₂ : MeasurableSpace α}\n    (h : ∀ s : Set α, MeasurableSet[m₁] s ↔ MeasurableSet[m₂] s) : m₁ = m₂ :=\n  measurableSet_injective <| funext fun s => propext (h s)\n\n"}
{"name":"MeasurableSpace.ext_iff","module":"Mathlib.MeasureTheory.MeasurableSpace.Defs","initialProofState":"α : Type u_1\nm₁ m₂ : MeasurableSpace α\n⊢ Iff (Eq m₁ m₂) (∀ (s : Set α), Iff (MeasurableSet s) (MeasurableSet s))","decl":"@[ext]\ntheorem MeasurableSpace.ext {m₁ m₂ : MeasurableSpace α}\n    (h : ∀ s : Set α, MeasurableSet[m₁] s ↔ MeasurableSet[m₂] s) : m₁ = m₂ :=\n  measurableSet_injective <| funext fun s => propext (h s)\n\n"}
{"name":"MeasurableSingletonClass.measurableSet_singleton","module":"Mathlib.MeasureTheory.MeasurableSpace.Defs","initialProofState":"α : Type u_7\ninst✝ : MeasurableSpace α\nself : MeasurableSingletonClass α\nx : α\n⊢ MeasurableSet (Singleton.singleton x)","decl":"/-- A typeclass mixin for `MeasurableSpace`s such that each singleton is measurable. -/\nclass MeasurableSingletonClass (α : Type*) [MeasurableSpace α] : Prop where\n  /-- A singleton is a measurable set. -/\n  measurableSet_singleton : ∀ x, MeasurableSet ({x} : Set α)\n\n"}
{"name":"MeasurableSet.singleton","module":"Mathlib.MeasureTheory.MeasurableSpace.Defs","initialProofState":"α : Type u_1\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSingletonClass α\na : α\n⊢ MeasurableSet (Singleton.singleton a)","decl":"@[simp]\nlemma MeasurableSet.singleton [MeasurableSpace α] [MeasurableSingletonClass α] (a : α) :\n    MeasurableSet {a} :=\n  measurableSet_singleton a\n\n"}
{"name":"measurableSet_eq","module":"Mathlib.MeasureTheory.MeasurableSpace.Defs","initialProofState":"α : Type u_1\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSingletonClass α\na : α\n⊢ MeasurableSet (setOf fun x => Eq x a)","decl":"@[measurability]\ntheorem measurableSet_eq {a : α} : MeasurableSet { x | x = a } := .singleton a\n\n"}
{"name":"MeasurableSet.insert","module":"Mathlib.MeasureTheory.MeasurableSpace.Defs","initialProofState":"α : Type u_1\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSingletonClass α\ns : Set α\nhs : MeasurableSet s\na : α\n⊢ MeasurableSet (Insert.insert a s)","decl":"@[measurability]\nprotected theorem MeasurableSet.insert {s : Set α} (hs : MeasurableSet s) (a : α) :\n    MeasurableSet (insert a s) :=\n  .union (.singleton a) hs\n\n"}
{"name":"measurableSet_insert","module":"Mathlib.MeasureTheory.MeasurableSpace.Defs","initialProofState":"α : Type u_1\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSingletonClass α\na : α\ns : Set α\n⊢ Iff (MeasurableSet (Insert.insert a s)) (MeasurableSet s)","decl":"@[simp]\ntheorem measurableSet_insert {a : α} {s : Set α} :\n    MeasurableSet (insert a s) ↔ MeasurableSet s := by\n  classical\n  exact ⟨fun h =>\n    if ha : a ∈ s then by rwa [← insert_eq_of_mem ha]\n    else insert_diff_self_of_not_mem ha ▸ h.diff (.singleton _),\n    fun h => h.insert a⟩\n\n"}
{"name":"Set.Subsingleton.measurableSet","module":"Mathlib.MeasureTheory.MeasurableSpace.Defs","initialProofState":"α : Type u_1\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSingletonClass α\ns : Set α\nhs : s.Subsingleton\n⊢ MeasurableSet s","decl":"theorem Set.Subsingleton.measurableSet {s : Set α} (hs : s.Subsingleton) : MeasurableSet s :=\n  hs.induction_on .empty .singleton\n\n"}
{"name":"Set.Finite.measurableSet","module":"Mathlib.MeasureTheory.MeasurableSpace.Defs","initialProofState":"α : Type u_1\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSingletonClass α\ns : Set α\nhs : s.Finite\n⊢ MeasurableSet s","decl":"theorem Set.Finite.measurableSet {s : Set α} (hs : s.Finite) : MeasurableSet s :=\n  Finite.induction_on _ hs .empty fun _ _ hsm => hsm.insert _\n\n"}
{"name":"Finset.measurableSet","module":"Mathlib.MeasureTheory.MeasurableSpace.Defs","initialProofState":"α : Type u_1\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSingletonClass α\ns : Finset α\n⊢ MeasurableSet ↑s","decl":"@[measurability]\nprotected theorem Finset.measurableSet (s : Finset α) : MeasurableSet (↑s : Set α) :=\n  s.finite_toSet.measurableSet\n\n"}
{"name":"Set.Countable.measurableSet","module":"Mathlib.MeasureTheory.MeasurableSpace.Defs","initialProofState":"α : Type u_1\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSingletonClass α\ns : Set α\nhs : s.Countable\n⊢ MeasurableSet s","decl":"theorem Set.Countable.measurableSet {s : Set α} (hs : s.Countable) : MeasurableSet s := by\n  rw [← biUnion_of_singleton s]\n  exact .biUnion hs fun b _ => .singleton b\n\n"}
{"name":"MeasurableSpace.measurableSet_copy","module":"Mathlib.MeasureTheory.MeasurableSpace.Defs","initialProofState":"α : Type u_1\nm : MeasurableSpace α\np : Set α → Prop\nh : ∀ (s : Set α), Iff (p s) (MeasurableSet s)\ns : Set α\n⊢ Iff (MeasurableSet s) (p s)","decl":"lemma measurableSet_copy {m : MeasurableSpace α} {p : Set α → Prop}\n    (h : ∀ s, p s ↔ MeasurableSet[m] s) {s} : MeasurableSet[.copy m p h] s ↔ p s :=\n  Iff.rfl\n\n"}
{"name":"MeasurableSpace.copy_eq","module":"Mathlib.MeasureTheory.MeasurableSpace.Defs","initialProofState":"α : Type u_1\nm : MeasurableSpace α\np : Set α → Prop\nh : ∀ (s : Set α), Iff (p s) (MeasurableSet s)\n⊢ Eq (m.copy p h) m","decl":"lemma copy_eq {m : MeasurableSpace α} {p : Set α → Prop} (h : ∀ s, p s ↔ MeasurableSet[m] s) :\n    m.copy p h = m :=\n  ext h\n\n"}
{"name":"MeasurableSpace.le_def","module":"Mathlib.MeasureTheory.MeasurableSpace.Defs","initialProofState":"α : Type u_7\na b : MeasurableSpace α\n⊢ Iff (LE.le a b) (LE.le a.MeasurableSet' b.MeasurableSet')","decl":"theorem le_def {α} {a b : MeasurableSpace α} : a ≤ b ↔ a.MeasurableSet' ≤ b.MeasurableSet' :=\n  Iff.rfl\n\n"}
{"name":"MeasurableSpace.GenerateMeasurable.brecOn","module":"Mathlib.MeasureTheory.MeasurableSpace.Defs","initialProofState":"α : Type u_1\ns : Set (Set α)\nmotive✝ : (a : Set α) → MeasurableSpace.GenerateMeasurable s a → Prop\na✝ : Set α\nx✝ : MeasurableSpace.GenerateMeasurable s a✝\nih✝ : ∀ (a : Set α) (x : MeasurableSpace.GenerateMeasurable s a), x.below → motive✝ a x\n⊢ motive✝ a✝ x✝","decl":"/-- The smallest σ-algebra containing a collection `s` of basic sets -/\ninductive GenerateMeasurable (s : Set (Set α)) : Set α → Prop\n  | protected basic : ∀ u ∈ s, GenerateMeasurable s u\n  | protected empty : GenerateMeasurable s ∅\n  | protected compl : ∀ t, GenerateMeasurable s t → GenerateMeasurable s tᶜ\n  | protected iUnion : ∀ f : ℕ → Set α, (∀ n, GenerateMeasurable s (f n)) →\n      GenerateMeasurable s (⋃ i, f i)\n\n"}
{"name":"MeasurableSpace.measurableSet_generateFrom","module":"Mathlib.MeasureTheory.MeasurableSpace.Defs","initialProofState":"α : Type u_1\ns : Set (Set α)\nt : Set α\nht : Membership.mem s t\n⊢ MeasurableSet t","decl":"theorem measurableSet_generateFrom {s : Set (Set α)} {t : Set α} (ht : t ∈ s) :\n    MeasurableSet[generateFrom s] t :=\n  .basic t ht\n\n"}
{"name":"MeasurableSpace.generateFrom_induction","module":"Mathlib.MeasureTheory.MeasurableSpace.Defs","initialProofState":"α : Type u_1\nC : Set (Set α)\np : (s : Set α) → MeasurableSet s → Prop\nhC : ∀ (t : Set α), Membership.mem C t → ∀ (ht : MeasurableSet t), p t ht\nempty : p EmptyCollection.emptyCollection ⋯\ncompl : ∀ (t : Set α) (ht : MeasurableSet t), p t ht → p (HasCompl.compl t) ⋯\niUnion : ∀ (s : Nat → Set α) (hs : ∀ (n : Nat), MeasurableSet (s n)), (∀ (n : Nat), p (s n) ⋯) → p (Set.iUnion fun i => s i) ⋯\ns : Set α\nhs : MeasurableSet s\n⊢ p s hs","decl":"@[elab_as_elim]\ntheorem generateFrom_induction (C : Set (Set α))\n    (p : ∀ s : Set α, MeasurableSet[generateFrom C] s → Prop) (hC : ∀ t ∈ C, ∀ ht, p t ht)\n    (empty : p ∅ (measurableSet_empty _)) (compl : ∀ t ht, p t ht → p tᶜ ht.compl)\n    (iUnion : ∀ (s : ℕ → Set α) (hs : ∀ n, MeasurableSet[generateFrom C] (s n)),\n      (∀ n, p (s n) (hs n)) → p (⋃ i, s i) (.iUnion hs)) (s : Set α)\n    (hs : MeasurableSet[generateFrom C] s) : p s hs := by\n  induction hs\n  exacts [hC _ ‹_› _, empty, compl _ ‹_› ‹_›, iUnion ‹_› ‹_› ‹_›]\n\n"}
{"name":"MeasurableSpace.generateFrom_le","module":"Mathlib.MeasureTheory.MeasurableSpace.Defs","initialProofState":"α : Type u_1\ns : Set (Set α)\nm : MeasurableSpace α\nh : ∀ (t : Set α), Membership.mem s t → MeasurableSet t\n⊢ LE.le (MeasurableSpace.generateFrom s) m","decl":"theorem generateFrom_le {s : Set (Set α)} {m : MeasurableSpace α}\n    (h : ∀ t ∈ s, MeasurableSet[m] t) : generateFrom s ≤ m :=\n  fun t (ht : GenerateMeasurable s t) =>\n  ht.recOn h .empty (fun _ _ => .compl) fun _ _ hf => .iUnion hf\n\n"}
{"name":"MeasurableSpace.generateFrom_le_iff","module":"Mathlib.MeasureTheory.MeasurableSpace.Defs","initialProofState":"α : Type u_1\ns : Set (Set α)\nm : MeasurableSpace α\n⊢ Iff (LE.le (MeasurableSpace.generateFrom s) m) (HasSubset.Subset s (setOf fun t => MeasurableSet t))","decl":"theorem generateFrom_le_iff {s : Set (Set α)} (m : MeasurableSpace α) :\n    generateFrom s ≤ m ↔ s ⊆ { t | MeasurableSet[m] t } :=\n  Iff.intro (fun h _ hu => h _ <| measurableSet_generateFrom hu) fun h => generateFrom_le h\n\n"}
{"name":"MeasurableSpace.generateFrom_measurableSet","module":"Mathlib.MeasureTheory.MeasurableSpace.Defs","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\n⊢ Eq (MeasurableSpace.generateFrom (setOf fun s => MeasurableSet s)) inst✝","decl":"@[simp]\ntheorem generateFrom_measurableSet [MeasurableSpace α] :\n    generateFrom { s : Set α | MeasurableSet s } = ‹_› :=\n  le_antisymm (generateFrom_le fun _ => id) fun _ => measurableSet_generateFrom\n\n"}
{"name":"MeasurableSpace.forall_generateFrom_mem_iff_mem_iff","module":"Mathlib.MeasureTheory.MeasurableSpace.Defs","initialProofState":"α : Type u_1\nS : Set (Set α)\nx y : α\n⊢ Iff (∀ (s : Set α), MeasurableSet s → Iff (Membership.mem s x) (Membership.mem s y)) (∀ (s : Set α), Membership.mem S s → Iff (Membership.mem s x) (Membership.mem s y))","decl":"theorem forall_generateFrom_mem_iff_mem_iff {S : Set (Set α)} {x y : α} :\n    (∀ s, MeasurableSet[generateFrom S] s → (x ∈ s ↔ y ∈ s)) ↔ (∀ s ∈ S, x ∈ s ↔ y ∈ s) := by\n  refine ⟨fun H s hs ↦ H s (.basic s hs), fun H s ↦ ?_⟩\n  apply generateFrom_induction\n  · exact fun s hs _ ↦ H s hs\n  · rfl\n  · exact fun _ _ ↦ Iff.not\n  · intro f _ hf\n    simp only [mem_iUnion, hf]\n\n"}
{"name":"MeasurableSpace.mkOfClosure_sets","module":"Mathlib.MeasureTheory.MeasurableSpace.Defs","initialProofState":"α : Type u_1\ns : Set (Set α)\nhs : Eq (setOf fun t => MeasurableSet t) s\n⊢ Eq (MeasurableSpace.mkOfClosure s hs) (MeasurableSpace.generateFrom s)","decl":"theorem mkOfClosure_sets {s : Set (Set α)} {hs : { t | MeasurableSet[generateFrom s] t } = s} :\n    MeasurableSpace.mkOfClosure s hs = generateFrom s :=\n  copy_eq _\n\n"}
{"name":"MeasurableSpace.generateFrom_mono","module":"Mathlib.MeasureTheory.MeasurableSpace.Defs","initialProofState":"α : Type u_1\ns t : Set (Set α)\nh : HasSubset.Subset s t\n⊢ LE.le (MeasurableSpace.generateFrom s) (MeasurableSpace.generateFrom t)","decl":"@[mono]\ntheorem generateFrom_mono {s t : Set (Set α)} (h : s ⊆ t) : generateFrom s ≤ generateFrom t :=\n  giGenerateFrom.gc.monotone_l h\n\n"}
{"name":"MeasurableSpace.generateFrom_sup_generateFrom","module":"Mathlib.MeasureTheory.MeasurableSpace.Defs","initialProofState":"α : Type u_1\ns t : Set (Set α)\n⊢ Eq (Max.max (MeasurableSpace.generateFrom s) (MeasurableSpace.generateFrom t)) (MeasurableSpace.generateFrom (Union.union s t))","decl":"theorem generateFrom_sup_generateFrom {s t : Set (Set α)} :\n    generateFrom s ⊔ generateFrom t = generateFrom (s ∪ t) :=\n  (@giGenerateFrom α).gc.l_sup.symm\n\n"}
{"name":"MeasurableSpace.iSup_generateFrom","module":"Mathlib.MeasureTheory.MeasurableSpace.Defs","initialProofState":"α : Type u_1\nι : Sort u_6\ns : ι → Set (Set α)\n⊢ Eq (iSup fun i => MeasurableSpace.generateFrom (s i)) (MeasurableSpace.generateFrom (Set.iUnion fun i => s i))","decl":"lemma iSup_generateFrom (s : ι → Set (Set α)) :\n    ⨆ i, generateFrom (s i) = generateFrom (⋃ i, s i) :=\n  (@MeasurableSpace.giGenerateFrom α).gc.l_iSup.symm\n\n"}
{"name":"MeasurableSpace.generateFrom_empty","module":"Mathlib.MeasureTheory.MeasurableSpace.Defs","initialProofState":"α : Type u_1\n⊢ Eq (MeasurableSpace.generateFrom EmptyCollection.emptyCollection) Bot.bot","decl":"@[simp]\nlemma generateFrom_empty : generateFrom (∅ : Set (Set α)) = ⊥ :=\n  le_bot_iff.mp (generateFrom_le (by simp))\n\n"}
{"name":"MeasurableSpace.generateFrom_singleton_empty","module":"Mathlib.MeasureTheory.MeasurableSpace.Defs","initialProofState":"α : Type u_1\n⊢ Eq (MeasurableSpace.generateFrom (Singleton.singleton EmptyCollection.emptyCollection)) Bot.bot","decl":"theorem generateFrom_singleton_empty : generateFrom {∅} = (⊥ : MeasurableSpace α) :=\n  bot_unique <| generateFrom_le <| by simp [@MeasurableSet.empty α ⊥]\n\n"}
{"name":"MeasurableSpace.generateFrom_singleton_univ","module":"Mathlib.MeasureTheory.MeasurableSpace.Defs","initialProofState":"α : Type u_1\n⊢ Eq (MeasurableSpace.generateFrom (Singleton.singleton Set.univ)) Bot.bot","decl":"theorem generateFrom_singleton_univ : generateFrom {Set.univ} = (⊥ : MeasurableSpace α) :=\n  bot_unique <| generateFrom_le <| by simp\n\n"}
{"name":"MeasurableSpace.generateFrom_insert_univ","module":"Mathlib.MeasureTheory.MeasurableSpace.Defs","initialProofState":"α : Type u_1\nS : Set (Set α)\n⊢ Eq (MeasurableSpace.generateFrom (Insert.insert Set.univ S)) (MeasurableSpace.generateFrom S)","decl":"@[simp]\ntheorem generateFrom_insert_univ (S : Set (Set α)) :\n    generateFrom (insert Set.univ S) = generateFrom S := by\n  rw [insert_eq, ← generateFrom_sup_generateFrom, generateFrom_singleton_univ, bot_sup_eq]\n\n"}
{"name":"MeasurableSpace.generateFrom_insert_empty","module":"Mathlib.MeasureTheory.MeasurableSpace.Defs","initialProofState":"α : Type u_1\nS : Set (Set α)\n⊢ Eq (MeasurableSpace.generateFrom (Insert.insert EmptyCollection.emptyCollection S)) (MeasurableSpace.generateFrom S)","decl":"@[simp]\ntheorem generateFrom_insert_empty (S : Set (Set α)) :\n    generateFrom (insert ∅ S) = generateFrom S := by\n  rw [insert_eq, ← generateFrom_sup_generateFrom, generateFrom_singleton_empty, bot_sup_eq]\n\n"}
{"name":"MeasurableSpace.measurableSet_bot_iff","module":"Mathlib.MeasureTheory.MeasurableSpace.Defs","initialProofState":"α : Type u_1\ns : Set α\n⊢ Iff (MeasurableSet s) (Or (Eq s EmptyCollection.emptyCollection) (Eq s Set.univ))","decl":"theorem measurableSet_bot_iff {s : Set α} : MeasurableSet[⊥] s ↔ s = ∅ ∨ s = univ :=\n  let b : MeasurableSpace α :=\n    { MeasurableSet' := fun s => s = ∅ ∨ s = univ\n      measurableSet_empty := Or.inl rfl\n      measurableSet_compl := by simp +contextual [or_imp]\n      measurableSet_iUnion := fun _ hf => sUnion_mem_empty_univ (forall_mem_range.2 hf) }\n  have : b = ⊥ :=\n    bot_unique fun _ hs =>\n      hs.elim (fun s => s.symm ▸ @measurableSet_empty _ ⊥) fun s =>\n        s.symm ▸ @MeasurableSet.univ _ ⊥\n  this ▸ Iff.rfl\n\n"}
{"name":"MeasurableSpace.measurableSet_top","module":"Mathlib.MeasureTheory.MeasurableSpace.Defs","initialProofState":"α : Type u_1\ns : Set α\n⊢ MeasurableSet s","decl":"@[simp, measurability] theorem measurableSet_top {s : Set α} : MeasurableSet[⊤] s := trivial\n\n"}
{"name":"MeasurableSpace.measurableSet_inf","module":"Mathlib.MeasureTheory.MeasurableSpace.Defs","initialProofState":"α : Type u_1\nm₁ m₂ : MeasurableSpace α\ns : Set α\n⊢ Iff (MeasurableSet s) (And (MeasurableSet s) (MeasurableSet s))","decl":"@[simp, nolint simpNF] -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO: `simpNF` claims that\n-- this lemma doesn't simplify LHS\ntheorem measurableSet_inf {m₁ m₂ : MeasurableSpace α} {s : Set α} :\n    MeasurableSet[m₁ ⊓ m₂] s ↔ MeasurableSet[m₁] s ∧ MeasurableSet[m₂] s :=\n  Iff.rfl\n\n"}
{"name":"MeasurableSpace.measurableSet_sInf","module":"Mathlib.MeasureTheory.MeasurableSpace.Defs","initialProofState":"α : Type u_1\nms : Set (MeasurableSpace α)\ns : Set α\n⊢ Iff (MeasurableSet s) (∀ (m : MeasurableSpace α), Membership.mem ms m → MeasurableSet s)","decl":"@[simp]\ntheorem measurableSet_sInf {ms : Set (MeasurableSpace α)} {s : Set α} :\n    MeasurableSet[sInf ms] s ↔ ∀ m ∈ ms, MeasurableSet[m] s :=\n  show s ∈ ⋂₀ _ ↔ _ by simp\n\n"}
{"name":"MeasurableSpace.measurableSet_iInf","module":"Mathlib.MeasureTheory.MeasurableSpace.Defs","initialProofState":"α : Type u_1\nι : Sort u_7\nm : ι → MeasurableSpace α\ns : Set α\n⊢ Iff (MeasurableSet s) (∀ (i : ι), MeasurableSet s)","decl":"theorem measurableSet_iInf {ι} {m : ι → MeasurableSpace α} {s : Set α} :\n    MeasurableSet[iInf m] s ↔ ∀ i, MeasurableSet[m i] s := by\n  rw [iInf, measurableSet_sInf, forall_mem_range]\n\n"}
{"name":"MeasurableSpace.measurableSet_sup","module":"Mathlib.MeasureTheory.MeasurableSpace.Defs","initialProofState":"α : Type u_1\nm₁ m₂ : MeasurableSpace α\ns : Set α\n⊢ Iff (MeasurableSet s) (MeasurableSpace.GenerateMeasurable (Union.union MeasurableSet MeasurableSet) s)","decl":"theorem measurableSet_sup {m₁ m₂ : MeasurableSpace α} {s : Set α} :\n    MeasurableSet[m₁ ⊔ m₂] s ↔ GenerateMeasurable (MeasurableSet[m₁] ∪ MeasurableSet[m₂]) s :=\n  Iff.rfl\n\n"}
{"name":"MeasurableSpace.measurableSet_sSup","module":"Mathlib.MeasureTheory.MeasurableSpace.Defs","initialProofState":"α : Type u_1\nms : Set (MeasurableSpace α)\ns : Set α\n⊢ Iff (MeasurableSet s) (MeasurableSpace.GenerateMeasurable (setOf fun s => Exists fun m => And (Membership.mem ms m) (MeasurableSet s)) s)","decl":"theorem measurableSet_sSup {ms : Set (MeasurableSpace α)} {s : Set α} :\n    MeasurableSet[sSup ms] s ↔\n      GenerateMeasurable { s : Set α | ∃ m ∈ ms, MeasurableSet[m] s } s := by\n  change GenerateMeasurable (⋃₀ _) _ ↔ _\n  simp [← setOf_exists]\n\n"}
{"name":"MeasurableSpace.measurableSet_iSup","module":"Mathlib.MeasureTheory.MeasurableSpace.Defs","initialProofState":"α : Type u_1\nι : Sort u_7\nm : ι → MeasurableSpace α\ns : Set α\n⊢ Iff (MeasurableSet s) (MeasurableSpace.GenerateMeasurable (setOf fun s => Exists fun i => MeasurableSet s) s)","decl":"theorem measurableSet_iSup {ι} {m : ι → MeasurableSpace α} {s : Set α} :\n    MeasurableSet[iSup m] s ↔ GenerateMeasurable { s : Set α | ∃ i, MeasurableSet[m i] s } s := by\n  simp only [iSup, measurableSet_sSup, exists_range_iff]\n\n"}
{"name":"MeasurableSpace.measurableSpace_iSup_eq","module":"Mathlib.MeasureTheory.MeasurableSpace.Defs","initialProofState":"α : Type u_1\nι : Sort u_6\nm : ι → MeasurableSpace α\n⊢ Eq (iSup fun n => m n) (MeasurableSpace.generateFrom (setOf fun s => Exists fun n => MeasurableSet s))","decl":"theorem measurableSpace_iSup_eq (m : ι → MeasurableSpace α) :\n    ⨆ n, m n = generateFrom { s | ∃ n, MeasurableSet[m n] s } := by\n  ext s\n  rw [measurableSet_iSup]\n  rfl\n\n"}
{"name":"MeasurableSpace.generateFrom_iUnion_measurableSet","module":"Mathlib.MeasureTheory.MeasurableSpace.Defs","initialProofState":"α : Type u_1\nι : Sort u_6\nm : ι → MeasurableSpace α\n⊢ Eq (MeasurableSpace.generateFrom (Set.iUnion fun n => setOf fun t => MeasurableSet t)) (iSup fun n => m n)","decl":"theorem generateFrom_iUnion_measurableSet (m : ι → MeasurableSpace α) :\n    generateFrom (⋃ n, { t | MeasurableSet[m n] t }) = ⨆ n, m n :=\n  (@giGenerateFrom α).l_iSup_u m\n\n"}
{"name":"measurable_id","module":"Mathlib.MeasureTheory.MeasurableSpace.Defs","initialProofState":"α : Type u_1\nx✝ : MeasurableSpace α\n⊢ Measurable id","decl":"@[measurability]\ntheorem measurable_id {_ : MeasurableSpace α} : Measurable (@id α) := fun _ => id\n\n"}
{"name":"measurable_id'","module":"Mathlib.MeasureTheory.MeasurableSpace.Defs","initialProofState":"α : Type u_1\nx✝ : MeasurableSpace α\n⊢ Measurable fun a => a","decl":"@[fun_prop, measurability]\ntheorem measurable_id' {_ : MeasurableSpace α} : Measurable fun a : α => a := measurable_id\n\n"}
{"name":"Measurable.comp","module":"Mathlib.MeasureTheory.MeasurableSpace.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nx✝² : MeasurableSpace α\nx✝¹ : MeasurableSpace β\nx✝ : MeasurableSpace γ\ng : β → γ\nf : α → β\nhg : Measurable g\nhf : Measurable f\n⊢ Measurable (Function.comp g f)","decl":"protected theorem Measurable.comp {_ : MeasurableSpace α} {_ : MeasurableSpace β}\n    {_ : MeasurableSpace γ} {g : β → γ} {f : α → β} (hg : Measurable g) (hf : Measurable f) :\n    Measurable (g ∘ f) :=\n  fun _ h => hf (hg h)\n\n-- This is needed due to reducibility issues with the `measurability` tactic.\n"}
{"name":"Measurable.comp'","module":"Mathlib.MeasureTheory.MeasurableSpace.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nx✝² : MeasurableSpace α\nx✝¹ : MeasurableSpace β\nx✝ : MeasurableSpace γ\ng : β → γ\nf : α → β\nhg : Measurable g\nhf : Measurable f\n⊢ Measurable fun x => g (f x)","decl":"@[fun_prop, aesop safe 50 (rule_sets := [Measurable])]\nprotected theorem Measurable.comp' {_ : MeasurableSpace α} {_ : MeasurableSpace β}\n    {_ : MeasurableSpace γ} {g : β → γ} {f : α → β} (hg : Measurable g) (hf : Measurable f) :\n    Measurable (fun x => g (f x)) := Measurable.comp hg hf\n\n"}
{"name":"measurable_const","module":"Mathlib.MeasureTheory.MeasurableSpace.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\nx✝¹ : MeasurableSpace α\nx✝ : MeasurableSpace β\na : α\n⊢ Measurable fun x => a","decl":"@[simp, fun_prop, measurability]\ntheorem measurable_const {_ : MeasurableSpace α} {_ : MeasurableSpace β} {a : α} :\n    Measurable fun _ : β => a := fun s _ => .const (a ∈ s)\n\n"}
{"name":"Measurable.le","module":"Mathlib.MeasureTheory.MeasurableSpace.Defs","initialProofState":"β : Type u_2\nα : Type u_7\nm m0 : MeasurableSpace α\nx✝ : MeasurableSpace β\nhm : LE.le m m0\nf : α → β\nhf : Measurable f\n⊢ Measurable f","decl":"theorem Measurable.le {α} {m m0 : MeasurableSpace α} {_ : MeasurableSpace β} (hm : m ≤ m0)\n    {f : α → β} (hf : Measurable[m] f) : Measurable[m0] f := fun _ hs => hm _ (hf hs)\n\n"}
{"name":"DiscreteMeasurableSpace.forall_measurableSet","module":"Mathlib.MeasureTheory.MeasurableSpace.Defs","initialProofState":"α : Type u_7\ninst✝ : MeasurableSpace α\nself : DiscreteMeasurableSpace α\ns : Set α\n⊢ MeasurableSet s","decl":"/-- A typeclass mixin for `MeasurableSpace`s such that all sets are measurable. -/\nclass DiscreteMeasurableSpace (α : Type*) [MeasurableSpace α] : Prop where\n  /-- Do not use this. Use `MeasurableSet.of_discrete` instead. -/\n  forall_measurableSet : ∀ s : Set α, MeasurableSet s\n\n"}
{"name":"instDiscreteMeasurableSpace","module":"Mathlib.MeasureTheory.MeasurableSpace.Defs","initialProofState":"α : Type u_1\n⊢ DiscreteMeasurableSpace α","decl":"instance : @DiscreteMeasurableSpace α ⊤ :=\n  @DiscreteMeasurableSpace.mk _ (_) fun _ ↦ MeasurableSpace.measurableSet_top\n\n-- See note [lower instance priority]\n"}
{"name":"MeasurableSingletonClass.toDiscreteMeasurableSpace","module":"Mathlib.MeasureTheory.MeasurableSpace.Defs","initialProofState":"α : Type u_1\ninst✝² : MeasurableSpace α\ninst✝¹ : MeasurableSingletonClass α\ninst✝ : Countable α\n⊢ DiscreteMeasurableSpace α","decl":"instance (priority := 100) MeasurableSingletonClass.toDiscreteMeasurableSpace [MeasurableSpace α]\n    [MeasurableSingletonClass α] [Countable α] : DiscreteMeasurableSpace α where\n  forall_measurableSet _ := (Set.to_countable _).measurableSet\n\n"}
{"name":"MeasurableSet.of_discrete","module":"Mathlib.MeasureTheory.MeasurableSpace.Defs","initialProofState":"α : Type u_1\ninst✝¹ : MeasurableSpace α\ninst✝ : DiscreteMeasurableSpace α\ns : Set α\n⊢ MeasurableSet s","decl":"@[measurability] lemma MeasurableSet.of_discrete : MeasurableSet s :=\n  DiscreteMeasurableSpace.forall_measurableSet _\n\n"}
{"name":"Measurable.of_discrete","module":"Mathlib.MeasureTheory.MeasurableSpace.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\ninst✝ : DiscreteMeasurableSpace α\nf : α → β\n⊢ Measurable f","decl":"@[measurability, fun_prop] lemma Measurable.of_discrete : Measurable f := fun _ _ ↦ .of_discrete\n\n"}
{"name":"measurableSet_discrete","module":"Mathlib.MeasureTheory.MeasurableSpace.Defs","initialProofState":"α : Type u_1\ninst✝¹ : MeasurableSpace α\ninst✝ : DiscreteMeasurableSpace α\ns : Set α\n⊢ MeasurableSet s","decl":"@[deprecated MeasurableSet.of_discrete (since := \"2024-08-25\")]\nlemma measurableSet_discrete (s : Set α) : MeasurableSet s := .of_discrete\n\n"}
{"name":"measurable_discrete","module":"Mathlib.MeasureTheory.MeasurableSpace.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\ninst✝ : DiscreteMeasurableSpace α\nf : α → β\n⊢ Measurable f","decl":"@[deprecated Measurable.of_discrete (since := \"2024-08-25\")]\nlemma measurable_discrete (f : α → β) : Measurable f := .of_discrete\n\n"}
{"name":"DiscreteMeasurableSpace.toMeasurableSingletonClass","module":"Mathlib.MeasureTheory.MeasurableSpace.Defs","initialProofState":"α : Type u_1\ninst✝¹ : MeasurableSpace α\ninst✝ : DiscreteMeasurableSpace α\n⊢ MeasurableSingletonClass α","decl":"/-- Warning: Creates a typeclass loop with `MeasurableSingletonClass.toDiscreteMeasurableSpace`.\nTo be monitored. -/\n-- See note [lower instance priority]\ninstance (priority := 100) DiscreteMeasurableSpace.toMeasurableSingletonClass :\n    MeasurableSingletonClass α where\n  measurableSet_singleton _ := .of_discrete\n\n"}
