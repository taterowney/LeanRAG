{"name":"Field.nonempty_algHom_of_exist_roots","module":"Mathlib.FieldTheory.Isaacs","initialProofState":"F : Type u_1\nE : Type u_2\nK : Type u_3\ninst✝⁴ : Field F\ninst✝³ : Field E\ninst✝² : Field K\ninst✝¹ : Algebra F E\ninst✝ : Algebra F K\nalg : Algebra.IsAlgebraic F E\nh : ∀ (x : E), Exists fun y => Eq ((Polynomial.aeval y) (minpoly F x)) 0\n⊢ Nonempty (AlgHom F E K)","decl":"theorem nonempty_algHom_of_exist_roots (h : ∀ x : E, ∃ y : K, aeval y (minpoly F x) = 0) :\n    Nonempty (E →ₐ[F] K) := by\n  refine Lifts.nonempty_algHom_of_exist_lifts_finset fun S ↦ ⟨⟨adjoin F S, ?_⟩, subset_adjoin _ _⟩\n  let p := (S.prod <| minpoly F).map (algebraMap F K)\n  let K' := SplittingField p\n  have splits s (hs : s ∈ S) : (minpoly F s).Splits (algebraMap F K') := by\n    apply splits_of_splits_of_dvd _\n      (Finset.prod_ne_zero_iff.mpr fun _ _ ↦ minpoly.ne_zero <| (alg.isIntegral).1 _)\n      ((splits_map_iff _ _).mp <| SplittingField.splits p) (Finset.dvd_prod_of_mem _ hs)\n  let K₀ := (⊥ : IntermediateField K K').restrictScalars F\n  let FS := adjoin F (S : Set E)\n  let Ω := FS →ₐ[F] K'\n  have := finiteDimensional_adjoin (S := (S : Set E)) fun _ _ ↦ (alg.isIntegral).1 _\n  let M (ω : Ω) := Subalgebra.toSubmodule (K₀.comap ω).toSubalgebra\n  have : ⋃ ω : Ω, (M ω : Set FS) = Set.univ :=\n    Set.eq_univ_of_forall fun ⟨α, hα⟩ ↦ Set.mem_iUnion.mpr <| by\n      have ⟨β, hβ⟩ := h α\n      let ϕ : F⟮α⟯ →ₐ[F] K' := (IsScalarTower.toAlgHom _ _ _).comp ((AdjoinRoot.liftHom _ _ hβ).comp\n        (adjoinRootEquivAdjoin F <| (alg.isIntegral).1 _).symm.toAlgHom)\n      have ⟨ω, hω⟩ := exists_algHom_adjoin_of_splits\n        (fun s hs ↦ ⟨(alg.isIntegral).1 _, splits s hs⟩) ϕ (adjoin_simple_le_iff.mpr hα)\n      refine ⟨ω, β, ((DFunLike.congr_fun hω <| AdjoinSimple.gen F α).trans ?_).symm⟩\n      rw [AlgHom.comp_apply, AlgHom.comp_apply, AlgEquiv.coe_algHom,\n        adjoinRootEquivAdjoin_symm_apply_gen, AdjoinRoot.liftHom_root]\n      rfl\n  have ω : ∃ ω : Ω, ⊤ ≤ M ω := by\n    cases finite_or_infinite F\n    · have ⟨α, hα⟩ := exists_primitive_element_of_finite_bot F FS\n      have ⟨ω, hω⟩ := Set.mem_iUnion.mp (this ▸ Set.mem_univ α)\n      exact ⟨ω, show ⊤ ≤ K₀.comap ω by rwa [← hα, adjoin_simple_le_iff]⟩\n    · simp_rw [top_le_iff, Subspace.exists_eq_top_of_iUnion_eq_univ this]\n  exact ((botEquiv K K').toAlgHom.restrictScalars F).comp\n    (ω.choose.codRestrict K₀.toSubalgebra fun x ↦ ω.choose_spec trivial)\n\n"}
{"name":"Field.nonempty_algHom_of_minpoly_eq","module":"Mathlib.FieldTheory.Isaacs","initialProofState":"F : Type u_1\nE : Type u_2\nK : Type u_3\ninst✝⁴ : Field F\ninst✝³ : Field E\ninst✝² : Field K\ninst✝¹ : Algebra F E\ninst✝ : Algebra F K\nalg : Algebra.IsAlgebraic F E\nh : ∀ (x : E), Exists fun y => Eq (minpoly F x) (minpoly F y)\n⊢ Nonempty (AlgHom F E K)","decl":"theorem nonempty_algHom_of_minpoly_eq\n    (h : ∀ x : E, ∃ y : K, minpoly F x = minpoly F y) :\n    Nonempty (E →ₐ[F] K) :=\n  nonempty_algHom_of_exist_roots fun x ↦ have ⟨y, hy⟩ := h x; ⟨y, by rw [hy, minpoly.aeval]⟩\n\n"}
{"name":"Field.nonempty_algHom_of_range_minpoly_subset","module":"Mathlib.FieldTheory.Isaacs","initialProofState":"F : Type u_1\nE : Type u_2\nK : Type u_3\ninst✝⁴ : Field F\ninst✝³ : Field E\ninst✝² : Field K\ninst✝¹ : Algebra F E\ninst✝ : Algebra F K\nalg : Algebra.IsAlgebraic F E\nh : HasSubset.Subset (Set.range (minpoly F)) (Set.range (minpoly F))\n⊢ Nonempty (AlgHom F E K)","decl":"theorem nonempty_algHom_of_range_minpoly_subset\n    (h : Set.range (@minpoly F E _ _ _) ⊆ Set.range (@minpoly F K _ _ _)) :\n    Nonempty (E →ₐ[F] K) :=\n  nonempty_algHom_of_minpoly_eq fun x ↦ have ⟨y, hy⟩ := h ⟨x, rfl⟩; ⟨y, hy.symm⟩\n\n"}
{"name":"Field.nonempty_algEquiv_of_range_minpoly_eq","module":"Mathlib.FieldTheory.Isaacs","initialProofState":"F : Type u_1\nE : Type u_2\nK : Type u_3\ninst✝⁴ : Field F\ninst✝³ : Field E\ninst✝² : Field K\ninst✝¹ : Algebra F E\ninst✝ : Algebra F K\nalg : Algebra.IsAlgebraic F E\nh : Eq (Set.range (minpoly F)) (Set.range (minpoly F))\n⊢ Nonempty (AlgEquiv F E K)","decl":"theorem nonempty_algEquiv_of_range_minpoly_eq\n    (h : Set.range (@minpoly F E _ _ _) = Set.range (@minpoly F K _ _ _)) :\n    Nonempty (E ≃ₐ[F] K) :=\n  have ⟨σ⟩ := nonempty_algHom_of_range_minpoly_subset h.le\n  have : Algebra.IsAlgebraic F K := ⟨fun y ↦ IsIntegral.isAlgebraic <| by\n    by_contra hy\n    have ⟨x, hx⟩ := h.ge ⟨y, rfl⟩\n    rw [minpoly.eq_zero hy] at hx\n    exact minpoly.ne_zero ((alg.isIntegral).1 x) hx⟩\n  have ⟨τ⟩ := nonempty_algHom_of_range_minpoly_subset h.ge\n  ⟨.ofBijective _ (Algebra.IsAlgebraic.algHom_bijective₂ σ τ).1⟩\n\n"}
{"name":"Field.nonempty_algHom_of_aeval_eq_zero_subset","module":"Mathlib.FieldTheory.Isaacs","initialProofState":"F : Type u_1\nE : Type u_2\nK : Type u_3\ninst✝⁴ : Field F\ninst✝³ : Field E\ninst✝² : Field K\ninst✝¹ : Algebra F E\ninst✝ : Algebra F K\nalg : Algebra.IsAlgebraic F E\nh : HasSubset.Subset (setOf fun p => Exists fun x => Eq ((Polynomial.aeval x) p) 0) (setOf fun p => Exists fun y => Eq ((Polynomial.aeval y) p) 0)\n⊢ Nonempty (AlgHom F E K)","decl":"theorem nonempty_algHom_of_aeval_eq_zero_subset\n    (h : {p : F[X] | ∃ x : E, aeval x p = 0} ⊆ {p | ∃ y : K, aeval y p = 0}) :\n    Nonempty (E →ₐ[F] K) :=\n  nonempty_algHom_of_minpoly_eq fun x ↦\n    have ⟨y, hy⟩ := h ⟨_, minpoly.aeval F x⟩\n    ⟨y, (minpoly.eq_iff_aeval_minpoly_eq_zero <| (alg.isIntegral).1 x).mpr hy⟩\n\n"}
{"name":"Field.nonempty_algEquiv_of_aeval_eq_zero_eq","module":"Mathlib.FieldTheory.Isaacs","initialProofState":"F : Type u_1\nE : Type u_2\nK : Type u_3\ninst✝⁵ : Field F\ninst✝⁴ : Field E\ninst✝³ : Field K\ninst✝² : Algebra F E\ninst✝¹ : Algebra F K\nalg : Algebra.IsAlgebraic F E\ninst✝ : Algebra.IsAlgebraic F K\nh : Eq (setOf fun p => Exists fun x => Eq ((Polynomial.aeval x) p) 0) (setOf fun p => Exists fun y => Eq ((Polynomial.aeval y) p) 0)\n⊢ Nonempty (AlgEquiv F E K)","decl":"theorem nonempty_algEquiv_of_aeval_eq_zero_eq [Algebra.IsAlgebraic F K]\n    (h : {p : F[X] | ∃ x : E, aeval x p = 0} = {p | ∃ y : K, aeval y p = 0}) :\n    Nonempty (E ≃ₐ[F] K) :=\n  have ⟨σ⟩ := nonempty_algHom_of_aeval_eq_zero_subset h.le\n  have ⟨τ⟩ := nonempty_algHom_of_aeval_eq_zero_subset h.ge\n  ⟨.ofBijective _ (Algebra.IsAlgebraic.algHom_bijective₂ σ τ).1⟩\n\n"}
{"name":"IsAlgClosure.of_exist_roots","module":"Mathlib.FieldTheory.Isaacs","initialProofState":"F : Type u_1\nE : Type u_2\ninst✝² : Field F\ninst✝¹ : Field E\ninst✝ : Algebra F E\nalg : Algebra.IsAlgebraic F E\nh : ∀ (p : Polynomial F), p.Monic → Irreducible p → Exists fun x => Eq ((Polynomial.aeval x) p) 0\n⊢ IsAlgClosure F E","decl":"theorem _root_.IsAlgClosure.of_exist_roots\n    (h : ∀ p : F[X], p.Monic → Irreducible p → ∃ x : E, aeval x p = 0) :\n    IsAlgClosure F E :=\n  .of_splits fun p _ _ ↦\n    have ⟨σ⟩ := nonempty_algHom_of_exist_roots fun x : p.SplittingField ↦\n      have := Algebra.IsAlgebraic.isIntegral (K := F).1 x\n      h _ (minpoly.monic this) (minpoly.irreducible this)\n    splits_of_algHom (SplittingField.splits _) σ\n\n"}
