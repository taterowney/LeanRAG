{"name":"Ideal.mem_pi","module":"Mathlib.RingTheory.Ideal.Basic","initialProofState":"ι : Type u_1\nα : ι → Type u_5\ninst✝ : (i : ι) → Semiring (α i)\nI : (i : ι) → Ideal (α i)\nx : (i : ι) → α i\n⊢ Iff (Membership.mem (Ideal.pi I) x) (∀ (i : ι), Membership.mem (I i) (x i))","decl":"theorem mem_pi (x : Π i, α i) : x ∈ pi I ↔ ∀ i, x i ∈ I i :=\n  Iff.rfl\n\n"}
{"name":"Ideal.add_pow_mem_of_pow_mem_of_le_of_commute","module":"Mathlib.RingTheory.Ideal.Basic","initialProofState":"α : Type u_6\ninst✝ : Semiring α\nI : Ideal α\na b : α\nm n k : Nat\nha : Membership.mem I (HPow.hPow a m)\nhb : Membership.mem I (HPow.hPow b n)\nhk : LE.le (HAdd.hAdd m n) (HAdd.hAdd k 1)\nhab : Commute a b\n⊢ Membership.mem I (HPow.hPow (HAdd.hAdd a b) k)","decl":"theorem add_pow_mem_of_pow_mem_of_le_of_commute {m n k : ℕ}\n    (ha : a ^ m ∈ I) (hb : b ^ n ∈ I) (hk : m + n ≤ k + 1)\n    (hab : Commute a b) :\n    (a + b) ^ k ∈ I := by\n  simp_rw [hab.add_pow, ← Nat.cast_comm]\n  apply I.sum_mem\n  intro c _\n  apply mul_mem_left\n  by_cases h : m ≤ c\n  · rw [hab.pow_pow]\n    exact I.mul_mem_left _ (I.pow_mem_of_pow_mem ha h)\n  · refine I.mul_mem_left _ (I.pow_mem_of_pow_mem hb ?_)\n    omega\n\n"}
{"name":"Ideal.add_pow_add_pred_mem_of_pow_mem_of_commute","module":"Mathlib.RingTheory.Ideal.Basic","initialProofState":"α : Type u_6\ninst✝ : Semiring α\nI : Ideal α\na b : α\nm n : Nat\nha : Membership.mem I (HPow.hPow a m)\nhb : Membership.mem I (HPow.hPow b n)\nhab : Commute a b\n⊢ Membership.mem I (HPow.hPow (HAdd.hAdd a b) (HSub.hSub (HAdd.hAdd m n) 1))","decl":"theorem add_pow_add_pred_mem_of_pow_mem_of_commute  {m n : ℕ}\n    (ha : a ^ m ∈ I) (hb : b ^ n ∈ I) (hab : Commute a b) :\n    (a + b) ^ (m + n - 1) ∈ I :=\n  I.add_pow_mem_of_pow_mem_of_le_of_commute ha hb (by rw [← Nat.sub_le_iff_le_add]) hab\n\n"}
{"name":"Ideal.add_pow_mem_of_pow_mem_of_le","module":"Mathlib.RingTheory.Ideal.Basic","initialProofState":"α : Type u_2\na b : α\ninst✝ : CommSemiring α\nI : Ideal α\nm n k : Nat\nha : Membership.mem I (HPow.hPow a m)\nhb : Membership.mem I (HPow.hPow b n)\nhk : LE.le (HAdd.hAdd m n) (HAdd.hAdd k 1)\n⊢ Membership.mem I (HPow.hPow (HAdd.hAdd a b) k)","decl":"theorem add_pow_mem_of_pow_mem_of_le {m n k : ℕ}\n    (ha : a ^ m ∈ I) (hb : b ^ n ∈ I) (hk : m + n ≤ k + 1) :\n    (a + b) ^ k ∈ I :=\n  I.add_pow_mem_of_pow_mem_of_le_of_commute ha hb hk (Commute.all ..)\n\n"}
{"name":"Ideal.add_pow_add_pred_mem_of_pow_mem","module":"Mathlib.RingTheory.Ideal.Basic","initialProofState":"α : Type u_2\na b : α\ninst✝ : CommSemiring α\nI : Ideal α\nm n : Nat\nha : Membership.mem I (HPow.hPow a m)\nhb : Membership.mem I (HPow.hPow b n)\n⊢ Membership.mem I (HPow.hPow (HAdd.hAdd a b) (HSub.hSub (HAdd.hAdd m n) 1))","decl":"theorem add_pow_add_pred_mem_of_pow_mem  {m n : ℕ}\n    (ha : a ^ m ∈ I) (hb : b ^ n ∈ I) :\n    (a + b) ^ (m + n - 1) ∈ I :=\n  I.add_pow_add_pred_mem_of_pow_mem_of_commute ha hb (Commute.all ..)\n\n"}
{"name":"Ideal.pow_multiset_sum_mem_span_pow","module":"Mathlib.RingTheory.Ideal.Basic","initialProofState":"α : Type u_2\ninst✝¹ : CommSemiring α\ninst✝ : DecidableEq α\ns : Multiset α\nn : Nat\n⊢ Membership.mem (Ideal.span ↑(Multiset.map (fun x => HPow.hPow x (HAdd.hAdd n 1)) s).toFinset) (HPow.hPow s.sum (HAdd.hAdd (HMul.hMul s.card n) 1))","decl":"theorem pow_multiset_sum_mem_span_pow [DecidableEq α] (s : Multiset α) (n : ℕ) :\n    s.sum ^ (Multiset.card s * n + 1) ∈\n    span ((s.map fun (x : α) ↦ x ^ (n + 1)).toFinset : Set α) := by\n  induction' s using Multiset.induction_on with a s hs\n  · simp\n  simp only [Finset.coe_insert, Multiset.map_cons, Multiset.toFinset_cons, Multiset.sum_cons,\n    Multiset.card_cons, add_pow]\n  refine Submodule.sum_mem _ ?_\n  intro c _hc\n  rw [mem_span_insert]\n  by_cases h : n + 1 ≤ c\n  · refine ⟨a ^ (c - (n + 1)) * s.sum ^ ((Multiset.card s + 1) * n + 1 - c) *\n      ((Multiset.card s + 1) * n + 1).choose c, 0, Submodule.zero_mem _, ?_⟩\n    rw [mul_comm _ (a ^ (n + 1))]\n    simp_rw [← mul_assoc]\n    rw [← pow_add, add_zero, add_tsub_cancel_of_le h]\n  · use 0\n    simp_rw [zero_mul, zero_add]\n    refine ⟨_, ?_, rfl⟩\n    replace h : c ≤ n := Nat.lt_succ_iff.mp (not_le.mp h)\n    have : (Multiset.card s + 1) * n + 1 - c = Multiset.card s * n + 1 + (n - c) := by\n      rw [add_mul, one_mul, add_assoc, add_comm n 1, ← add_assoc, add_tsub_assoc_of_le h]\n    rw [this, pow_add]\n    simp_rw [mul_assoc, mul_comm (s.sum ^ (Multiset.card s * n + 1)), ← mul_assoc]\n    exact mul_mem_left _ _ hs\n\n"}
{"name":"Ideal.sum_pow_mem_span_pow","module":"Mathlib.RingTheory.Ideal.Basic","initialProofState":"α : Type u_2\ninst✝ : CommSemiring α\nι : Type u_5\ns : Finset ι\nf : ι → α\nn : Nat\n⊢ Membership.mem (Ideal.span (Set.image (fun i => HPow.hPow (f i) (HAdd.hAdd n 1)) ↑s)) (HPow.hPow (s.sum fun i => f i) (HAdd.hAdd (HMul.hMul s.card n) 1))","decl":"theorem sum_pow_mem_span_pow {ι} (s : Finset ι) (f : ι → α) (n : ℕ) :\n    (∑ i ∈ s, f i) ^ (s.card * n + 1) ∈ span ((fun i => f i ^ (n + 1)) '' s) := by\n  classical\n  simpa only [Multiset.card_map, Multiset.map_map, comp_apply, Multiset.toFinset_map,\n    Finset.coe_image, Finset.val_toFinset] using pow_multiset_sum_mem_span_pow (s.1.map f) n\n\n"}
{"name":"Ideal.span_pow_eq_top","module":"Mathlib.RingTheory.Ideal.Basic","initialProofState":"α : Type u_2\ninst✝ : CommSemiring α\ns : Set α\nhs : Eq (Ideal.span s) Top.top\nn : Nat\n⊢ Eq (Ideal.span (Set.image (fun x => HPow.hPow x n) s)) Top.top","decl":"theorem span_pow_eq_top (s : Set α) (hs : span s = ⊤) (n : ℕ) :\n    span ((fun (x : α) => x ^ n) '' s) = ⊤ := by\n  rw [eq_top_iff_one]\n  cases' n with n\n  · obtain rfl | ⟨x, hx⟩ := eq_empty_or_nonempty s\n    · rw [Set.image_empty, hs]\n      trivial\n    · exact subset_span ⟨_, hx, pow_zero _⟩\n  rw [eq_top_iff_one, span, Finsupp.mem_span_iff_linearCombination] at hs\n  rcases hs with ⟨f, hf⟩\n  have hf : (f.support.sum fun a => f a * a) = 1 := hf -- Porting note: was `change ... at hf`\n  have := sum_pow_mem_span_pow f.support (fun a => f a * a) n\n  rw [hf, one_pow] at this\n  refine span_le.mpr ?_ this\n  rintro _ hx\n  simp_rw [Set.mem_image] at hx\n  rcases hx with ⟨x, _, rfl⟩\n  have : span ({(x : α) ^ (n + 1)} : Set α) ≤ span ((fun x : α => x ^ (n + 1)) '' s) := by\n    rw [span_le, Set.singleton_subset_iff]\n    exact subset_span ⟨x, x.prop, rfl⟩\n  refine this ?_\n  rw [mul_pow, mem_span_singleton]\n  exact ⟨f x ^ (n + 1), mul_comm _ _⟩\n\n"}
{"name":"Ideal.span_range_pow_eq_top","module":"Mathlib.RingTheory.Ideal.Basic","initialProofState":"α : Type u_2\ninst✝ : CommSemiring α\ns : Set α\nhs : Eq (Ideal.span s) Top.top\nn : ↑s → Nat\n⊢ Eq (Ideal.span (Set.range fun x => HPow.hPow (↑x) (n x))) Top.top","decl":"theorem span_range_pow_eq_top (s : Set α) (hs : span s = ⊤) (n : s → ℕ) :\n    span (Set.range fun x ↦ x.1 ^ n x) = ⊤ := by\n  have ⟨t, hts, mem⟩ := Submodule.mem_span_finite_of_mem_span ((eq_top_iff_one _).mp hs)\n  refine top_unique ((span_pow_eq_top _ ((eq_top_iff_one _).mpr mem) <|\n    t.attach.sup fun x ↦ n ⟨x, hts x.2⟩).ge.trans <| span_le.mpr ?_)\n  rintro _ ⟨x, hxt, rfl⟩\n  rw [← Nat.sub_add_cancel (Finset.le_sup <| t.mem_attach ⟨x, hxt⟩)]\n  simp_rw [pow_add]\n  exact mul_mem_left _ _ (subset_span ⟨_, rfl⟩)\n\n"}
{"name":"Ideal.instFinite","module":"Mathlib.RingTheory.Ideal.Basic","initialProofState":"K : Type u_5\ninst✝ : DivisionSemiring K\n⊢ Finite (Ideal K)","decl":"instance : Finite (Ideal K) := let _i := Classical.decEq (Ideal K); ⟨equivFinTwo K⟩\n\n"}
{"name":"Ideal.isSimpleOrder","module":"Mathlib.RingTheory.Ideal.Basic","initialProofState":"K : Type u_5\ninst✝ : DivisionSemiring K\n⊢ IsSimpleOrder (Ideal K)","decl":"/-- Ideals of a `DivisionSemiring` are a simple order. Thanks to the way abbreviations work,\nthis automatically gives an `IsSimpleModule K` instance. -/\ninstance isSimpleOrder : IsSimpleOrder (Ideal K) :=\n  ⟨eq_bot_or_top⟩\n\n"}
{"name":"Ring.exists_not_isUnit_of_not_isField","module":"Mathlib.RingTheory.Ideal.Basic","initialProofState":"R : Type u_5\ninst✝¹ : CommSemiring R\ninst✝ : Nontrivial R\nhf : Not (IsField R)\n⊢ Exists fun x => Exists fun _hx => Not (IsUnit x)","decl":"theorem exists_not_isUnit_of_not_isField [Nontrivial R] (hf : ¬IsField R) :\n    ∃ (x : R) (_hx : x ≠ (0 : R)), ¬IsUnit x := by\n  have : ¬_ := fun h => hf ⟨exists_pair_ne R, mul_comm, h⟩\n  simp_rw [isUnit_iff_exists_inv]\n  push_neg at this ⊢\n  obtain ⟨x, hx, not_unit⟩ := this\n  exact ⟨x, hx, not_unit⟩\n\n"}
{"name":"Ring.not_isField_iff_exists_ideal_bot_lt_and_lt_top","module":"Mathlib.RingTheory.Ideal.Basic","initialProofState":"R : Type u_5\ninst✝¹ : CommSemiring R\ninst✝ : Nontrivial R\n⊢ Iff (Not (IsField R)) (Exists fun I => And (LT.lt Bot.bot I) (LT.lt I Top.top))","decl":"theorem not_isField_iff_exists_ideal_bot_lt_and_lt_top [Nontrivial R] :\n    ¬IsField R ↔ ∃ I : Ideal R, ⊥ < I ∧ I < ⊤ := by\n  constructor\n  · intro h\n    obtain ⟨x, nz, nu⟩ := exists_not_isUnit_of_not_isField h\n    use Ideal.span {x}\n    rw [bot_lt_iff_ne_bot, lt_top_iff_ne_top]\n    exact ⟨mt Ideal.span_singleton_eq_bot.mp nz, mt Ideal.span_singleton_eq_top.mp nu⟩\n  · rintro ⟨I, bot_lt, lt_top⟩ hf\n    obtain ⟨x, mem, ne_zero⟩ := SetLike.exists_of_lt bot_lt\n    rw [Submodule.mem_bot] at ne_zero\n    obtain ⟨y, hy⟩ := hf.mul_inv_cancel ne_zero\n    rw [lt_top_iff_ne_top, Ne, Ideal.eq_top_iff_one, ← hy] at lt_top\n    exact lt_top (I.mul_mem_right _ mem)\n\n"}
{"name":"Ring.not_isField_iff_exists_prime","module":"Mathlib.RingTheory.Ideal.Basic","initialProofState":"R : Type u_5\ninst✝¹ : CommSemiring R\ninst✝ : Nontrivial R\n⊢ Iff (Not (IsField R)) (Exists fun p => And (Ne p Bot.bot) p.IsPrime)","decl":"theorem not_isField_iff_exists_prime [Nontrivial R] :\n    ¬IsField R ↔ ∃ p : Ideal R, p ≠ ⊥ ∧ p.IsPrime :=\n  not_isField_iff_exists_ideal_bot_lt_and_lt_top.trans\n    ⟨fun ⟨I, bot_lt, lt_top⟩ =>\n      let ⟨p, hp, le_p⟩ := I.exists_le_maximal (lt_top_iff_ne_top.mp lt_top)\n      ⟨p, bot_lt_iff_ne_bot.mp (lt_of_lt_of_le bot_lt le_p), hp.isPrime⟩,\n      fun ⟨p, ne_bot, Prime⟩ => ⟨p, bot_lt_iff_ne_bot.mpr ne_bot, lt_top_iff_ne_top.mpr Prime.1⟩⟩\n\n"}
{"name":"Ring.isField_iff_isSimpleOrder_ideal","module":"Mathlib.RingTheory.Ideal.Basic","initialProofState":"R : Type u_5\ninst✝ : CommSemiring R\n⊢ Iff (IsField R) (IsSimpleOrder (Ideal R))","decl":"/-- Also see `Ideal.isSimpleOrder` for the forward direction as an instance when `R` is a\ndivision (semi)ring.\n\nThis result actually holds for all division semirings, but we lack the predicate to state it. -/\ntheorem isField_iff_isSimpleOrder_ideal : IsField R ↔ IsSimpleOrder (Ideal R) := by\n  cases subsingleton_or_nontrivial R\n  · exact\n      ⟨fun h => (not_isField_of_subsingleton _ h).elim, fun h =>\n        (false_of_nontrivial_of_subsingleton <| Ideal R).elim⟩\n  rw [← not_iff_not, Ring.not_isField_iff_exists_ideal_bot_lt_and_lt_top, ← not_iff_not]\n  push_neg\n  simp_rw [lt_top_iff_ne_top, bot_lt_iff_ne_bot, ← or_iff_not_imp_left, not_ne_iff]\n  exact ⟨fun h => ⟨h⟩, fun h => h.2⟩\n\n"}
{"name":"Ring.ne_bot_of_isMaximal_of_not_isField","module":"Mathlib.RingTheory.Ideal.Basic","initialProofState":"R : Type u_5\ninst✝¹ : CommSemiring R\ninst✝ : Nontrivial R\nM : Ideal R\nmax : M.IsMaximal\nnot_field : Not (IsField R)\n⊢ Ne M Bot.bot","decl":"/-- When a ring is not a field, the maximal ideals are nontrivial. -/\ntheorem ne_bot_of_isMaximal_of_not_isField [Nontrivial R] {M : Ideal R} (max : M.IsMaximal)\n    (not_field : ¬IsField R) : M ≠ ⊥ := by\n  rintro h\n  rw [h] at max\n  rcases max with ⟨⟨_h1, h2⟩⟩\n  obtain ⟨I, hIbot, hItop⟩ := not_isField_iff_exists_ideal_bot_lt_and_lt_top.mp not_field\n  exact ne_of_lt hItop (h2 I hIbot)\n\n"}
{"name":"Ideal.bot_lt_of_maximal","module":"Mathlib.RingTheory.Ideal.Basic","initialProofState":"R : Type u_5\ninst✝¹ : CommSemiring R\ninst✝ : Nontrivial R\nM : Ideal R\nhm : M.IsMaximal\nnon_field : Not (IsField R)\n⊢ LT.lt Bot.bot M","decl":"theorem bot_lt_of_maximal (M : Ideal R) [hm : M.IsMaximal] (non_field : ¬IsField R) : ⊥ < M := by\n  rcases Ring.not_isField_iff_exists_ideal_bot_lt_and_lt_top.1 non_field with ⟨I, Ibot, Itop⟩\n  constructor; · simp\n  intro mle\n  apply lt_irrefl (⊤ : Ideal R)\n  have : M = ⊥ := eq_bot_iff.mpr mle\n  rw [← this] at Ibot\n  rwa [hm.1.2 I Ibot] at Itop\n\n"}
