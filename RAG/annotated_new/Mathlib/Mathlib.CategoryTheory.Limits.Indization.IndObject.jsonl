{"name":"CategoryTheory.Limits.IndObjectPresentation.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Limits.Indization.IndObject","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\ninst‚úù : SizeOf C\nI : Type v\n‚Ñê : CategoryTheory.SmallCategory I\nhI : CategoryTheory.IsFiltered I\nF : CategoryTheory.Functor I C\nŒπ : Quiver.Hom (F.comp CategoryTheory.yoneda) ((CategoryTheory.Functor.const I).obj A)\nisColimit : CategoryTheory.Limits.IsColimit { pt := A, Œπ := Œπ }\n‚ä¢ Eq (SizeOf.sizeOf (CategoryTheory.Limits.IndObjectPresentation.mk I F Œπ isColimit)) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf I)) (SizeOf.sizeOf ‚Ñê)) (SizeOf.sizeOf hI)) (SizeOf.sizeOf F)) (SizeOf.sizeOf Œπ)) (SizeOf.sizeOf isColimit))","decl":"/-- The data that witnesses that a presheaf `A` is an ind-object. It consists of a small\n    filtered indexing category `I`, a diagram `F : I ‚•§ C` and the data for a colimit cocone on\n    `F ‚ãô yoneda : I ‚•§ C·µí·µñ ‚•§ Type v` with cocone point `A`. -/\nstructure IndObjectPresentation (A : C·µí·µñ ‚•§ Type v) where\n  /-- The indexing category of the filtered colimit presentation -/\n  I : Type v\n  /-- The indexing category of the filtered colimit presentation -/\n  [‚Ñê : SmallCategory I]\n  [hI : IsFiltered I]\n  /-- The diagram of the filtered colimit presentation -/\n  F : I ‚•§ C\n  /-- Use `IndObjectPresentation.cocone` instead. -/\n  Œπ : F ‚ãô yoneda ‚ü∂ (Functor.const I).obj A\n  /-- Use `IndObjectPresentation.coconeIsColimit` instead. -/\n  isColimit : IsColimit (Cocone.mk A Œπ)\n\n"}
{"name":"CategoryTheory.Limits.IndObjectPresentation.mk.injEq","module":"Mathlib.CategoryTheory.Limits.Indization.IndObject","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nI‚úù : Type v\n‚Ñê‚úù : CategoryTheory.SmallCategory I‚úù\nhI‚úù : CategoryTheory.IsFiltered I‚úù\nF‚úù : CategoryTheory.Functor I‚úù C\nŒπ‚úù : Quiver.Hom (F‚úù.comp CategoryTheory.yoneda) ((CategoryTheory.Functor.const I‚úù).obj A)\nisColimit‚úù : CategoryTheory.Limits.IsColimit { pt := A, Œπ := Œπ‚úù }\nI : Type v\n‚Ñê : CategoryTheory.SmallCategory I\nhI : CategoryTheory.IsFiltered I\nF : CategoryTheory.Functor I C\nŒπ : Quiver.Hom (F.comp CategoryTheory.yoneda) ((CategoryTheory.Functor.const I).obj A)\nisColimit : CategoryTheory.Limits.IsColimit { pt := A, Œπ := Œπ }\n‚ä¢ Eq (Eq (CategoryTheory.Limits.IndObjectPresentation.mk I‚úù F‚úù Œπ‚úù isColimit‚úù) (CategoryTheory.Limits.IndObjectPresentation.mk I F Œπ isColimit)) (And (Eq I‚úù I) (And (HEq ‚Ñê‚úù ‚Ñê) (And (HEq F‚úù F) (And (HEq Œπ‚úù Œπ) (HEq isColimit‚úù isColimit)))))","decl":"/-- The data that witnesses that a presheaf `A` is an ind-object. It consists of a small\n    filtered indexing category `I`, a diagram `F : I ‚•§ C` and the data for a colimit cocone on\n    `F ‚ãô yoneda : I ‚•§ C·µí·µñ ‚•§ Type v` with cocone point `A`. -/\nstructure IndObjectPresentation (A : C·µí·µñ ‚•§ Type v) where\n  /-- The indexing category of the filtered colimit presentation -/\n  I : Type v\n  /-- The indexing category of the filtered colimit presentation -/\n  [‚Ñê : SmallCategory I]\n  [hI : IsFiltered I]\n  /-- The diagram of the filtered colimit presentation -/\n  F : I ‚•§ C\n  /-- Use `IndObjectPresentation.cocone` instead. -/\n  Œπ : F ‚ãô yoneda ‚ü∂ (Functor.const I).obj A\n  /-- Use `IndObjectPresentation.coconeIsColimit` instead. -/\n  isColimit : IsColimit (Cocone.mk A Œπ)\n\n"}
{"name":"CategoryTheory.Limits.IndObjectPresentation.mk.inj","module":"Mathlib.CategoryTheory.Limits.Indization.IndObject","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nI‚úù : Type v\n‚Ñê‚úù : CategoryTheory.SmallCategory I‚úù\nhI‚úù : CategoryTheory.IsFiltered I‚úù\nF‚úù : CategoryTheory.Functor I‚úù C\nŒπ‚úù : Quiver.Hom (F‚úù.comp CategoryTheory.yoneda) ((CategoryTheory.Functor.const I‚úù).obj A)\nisColimit‚úù : CategoryTheory.Limits.IsColimit { pt := A, Œπ := Œπ‚úù }\nI : Type v\n‚Ñê : CategoryTheory.SmallCategory I\nhI : CategoryTheory.IsFiltered I\nF : CategoryTheory.Functor I C\nŒπ : Quiver.Hom (F.comp CategoryTheory.yoneda) ((CategoryTheory.Functor.const I).obj A)\nisColimit : CategoryTheory.Limits.IsColimit { pt := A, Œπ := Œπ }\nx‚úù : Eq (CategoryTheory.Limits.IndObjectPresentation.mk I‚úù F‚úù Œπ‚úù isColimit‚úù) (CategoryTheory.Limits.IndObjectPresentation.mk I F Œπ isColimit)\n‚ä¢ And (Eq I‚úù I) (And (HEq ‚Ñê‚úù ‚Ñê) (And (HEq F‚úù F) (And (HEq Œπ‚úù Œπ) (HEq isColimit‚úù isColimit))))","decl":"/-- The data that witnesses that a presheaf `A` is an ind-object. It consists of a small\n    filtered indexing category `I`, a diagram `F : I ‚•§ C` and the data for a colimit cocone on\n    `F ‚ãô yoneda : I ‚•§ C·µí·µñ ‚•§ Type v` with cocone point `A`. -/\nstructure IndObjectPresentation (A : C·µí·µñ ‚•§ Type v) where\n  /-- The indexing category of the filtered colimit presentation -/\n  I : Type v\n  /-- The indexing category of the filtered colimit presentation -/\n  [‚Ñê : SmallCategory I]\n  [hI : IsFiltered I]\n  /-- The diagram of the filtered colimit presentation -/\n  F : I ‚•§ C\n  /-- Use `IndObjectPresentation.cocone` instead. -/\n  Œπ : F ‚ãô yoneda ‚ü∂ (Functor.const I).obj A\n  /-- Use `IndObjectPresentation.coconeIsColimit` instead. -/\n  isColimit : IsColimit (Cocone.mk A Œπ)\n\n"}
{"name":"CategoryTheory.Limits.IndObjectPresentation.hI","module":"Mathlib.CategoryTheory.Limits.Indization.IndObject","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nself : CategoryTheory.Limits.IndObjectPresentation A\n‚ä¢ CategoryTheory.IsFiltered self.I","decl":"/-- The data that witnesses that a presheaf `A` is an ind-object. It consists of a small\n    filtered indexing category `I`, a diagram `F : I ‚•§ C` and the data for a colimit cocone on\n    `F ‚ãô yoneda : I ‚•§ C·µí·µñ ‚•§ Type v` with cocone point `A`. -/\nstructure IndObjectPresentation (A : C·µí·µñ ‚•§ Type v) where\n  /-- The indexing category of the filtered colimit presentation -/\n  I : Type v\n  /-- The indexing category of the filtered colimit presentation -/\n  [‚Ñê : SmallCategory I]\n  [hI : IsFiltered I]\n  /-- The diagram of the filtered colimit presentation -/\n  F : I ‚•§ C\n  /-- Use `IndObjectPresentation.cocone` instead. -/\n  Œπ : F ‚ãô yoneda ‚ü∂ (Functor.const I).obj A\n  /-- Use `IndObjectPresentation.coconeIsColimit` instead. -/\n  isColimit : IsColimit (Cocone.mk A Œπ)\n\n"}
{"name":"CategoryTheory.Limits.IndObjectPresentation.ofCocone_isColimit","module":"Mathlib.CategoryTheory.Limits.Indization.IndObject","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nI : Type v\ninst‚úù¬π : CategoryTheory.SmallCategory I\ninst‚úù : CategoryTheory.IsFiltered I\nF : CategoryTheory.Functor I C\nc : CategoryTheory.Limits.Cocone (F.comp CategoryTheory.yoneda)\nhc : CategoryTheory.Limits.IsColimit c\n‚ä¢ Eq (CategoryTheory.Limits.IndObjectPresentation.ofCocone c hc).isColimit hc","decl":"/-- Alternative constructor for `IndObjectPresentation` taking a cocone instead of its defining\n    natural transformation. -/\n@[simps]\ndef ofCocone {I : Type v} [SmallCategory I] [IsFiltered I] {F : I ‚•§ C}\n    (c : Cocone (F ‚ãô yoneda)) (hc : IsColimit c) : IndObjectPresentation c.pt where\n  I := I\n  F := F\n  Œπ := c.Œπ\n  isColimit := hc\n\n"}
{"name":"CategoryTheory.Limits.IndObjectPresentation.ofCocone_F","module":"Mathlib.CategoryTheory.Limits.Indization.IndObject","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nI : Type v\ninst‚úù¬π : CategoryTheory.SmallCategory I\ninst‚úù : CategoryTheory.IsFiltered I\nF : CategoryTheory.Functor I C\nc : CategoryTheory.Limits.Cocone (F.comp CategoryTheory.yoneda)\nhc : CategoryTheory.Limits.IsColimit c\n‚ä¢ Eq (CategoryTheory.Limits.IndObjectPresentation.ofCocone c hc).F F","decl":"/-- Alternative constructor for `IndObjectPresentation` taking a cocone instead of its defining\n    natural transformation. -/\n@[simps]\ndef ofCocone {I : Type v} [SmallCategory I] [IsFiltered I] {F : I ‚•§ C}\n    (c : Cocone (F ‚ãô yoneda)) (hc : IsColimit c) : IndObjectPresentation c.pt where\n  I := I\n  F := F\n  Œπ := c.Œπ\n  isColimit := hc\n\n"}
{"name":"CategoryTheory.Limits.IndObjectPresentation.ofCocone_I","module":"Mathlib.CategoryTheory.Limits.Indization.IndObject","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nI : Type v\ninst‚úù¬π : CategoryTheory.SmallCategory I\ninst‚úù : CategoryTheory.IsFiltered I\nF : CategoryTheory.Functor I C\nc : CategoryTheory.Limits.Cocone (F.comp CategoryTheory.yoneda)\nhc : CategoryTheory.Limits.IsColimit c\n‚ä¢ Eq (CategoryTheory.Limits.IndObjectPresentation.ofCocone c hc).I I","decl":"/-- Alternative constructor for `IndObjectPresentation` taking a cocone instead of its defining\n    natural transformation. -/\n@[simps]\ndef ofCocone {I : Type v} [SmallCategory I] [IsFiltered I] {F : I ‚•§ C}\n    (c : Cocone (F ‚ãô yoneda)) (hc : IsColimit c) : IndObjectPresentation c.pt where\n  I := I\n  F := F\n  Œπ := c.Œπ\n  isColimit := hc\n\n"}
{"name":"CategoryTheory.Limits.IndObjectPresentation.ofCocone_Œπ","module":"Mathlib.CategoryTheory.Limits.Indization.IndObject","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nI : Type v\ninst‚úù¬π : CategoryTheory.SmallCategory I\ninst‚úù : CategoryTheory.IsFiltered I\nF : CategoryTheory.Functor I C\nc : CategoryTheory.Limits.Cocone (F.comp CategoryTheory.yoneda)\nhc : CategoryTheory.Limits.IsColimit c\n‚ä¢ Eq (CategoryTheory.Limits.IndObjectPresentation.ofCocone c hc).Œπ c.Œπ","decl":"/-- Alternative constructor for `IndObjectPresentation` taking a cocone instead of its defining\n    natural transformation. -/\n@[simps]\ndef ofCocone {I : Type v} [SmallCategory I] [IsFiltered I] {F : I ‚•§ C}\n    (c : Cocone (F ‚ãô yoneda)) (hc : IsColimit c) : IndObjectPresentation c.pt where\n  I := I\n  F := F\n  Œπ := c.Œπ\n  isColimit := hc\n\n"}
{"name":"CategoryTheory.Limits.IndObjectPresentation.ofCocone_‚Ñê","module":"Mathlib.CategoryTheory.Limits.Indization.IndObject","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nI : Type v\ninst‚úù¬π : CategoryTheory.SmallCategory I\ninst‚úù : CategoryTheory.IsFiltered I\nF : CategoryTheory.Functor I C\nc : CategoryTheory.Limits.Cocone (F.comp CategoryTheory.yoneda)\nhc : CategoryTheory.Limits.IsColimit c\n‚ä¢ Eq (CategoryTheory.Limits.IndObjectPresentation.ofCocone c hc).‚Ñê inst‚úù¬π","decl":"/-- Alternative constructor for `IndObjectPresentation` taking a cocone instead of its defining\n    natural transformation. -/\n@[simps]\ndef ofCocone {I : Type v} [SmallCategory I] [IsFiltered I] {F : I ‚•§ C}\n    (c : Cocone (F ‚ãô yoneda)) (hc : IsColimit c) : IndObjectPresentation c.pt where\n  I := I\n  F := F\n  Œπ := c.Œπ\n  isColimit := hc\n\n"}
{"name":"CategoryTheory.Limits.IndObjectPresentation.instIsFilteredI","module":"Mathlib.CategoryTheory.Limits.Indization.IndObject","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nP : CategoryTheory.Limits.IndObjectPresentation A\n‚ä¢ CategoryTheory.IsFiltered P.I","decl":"instance : IsFiltered P.I := P.hI\n\n"}
{"name":"CategoryTheory.Limits.IndObjectPresentation.cocone_pt","module":"Mathlib.CategoryTheory.Limits.Indization.IndObject","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nP : CategoryTheory.Limits.IndObjectPresentation A\n‚ä¢ Eq P.cocone.pt A","decl":"/-- The (colimit) cocone with cocone point `A`. -/\n@[simps pt]\ndef cocone : Cocone (P.F ‚ãô yoneda) where\n  pt := A\n  Œπ := P.Œπ\n\n"}
{"name":"CategoryTheory.Limits.IndObjectPresentation.extend_Œπ_app_app","module":"Mathlib.CategoryTheory.Limits.Indization.IndObject","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nA B : CategoryTheory.Functor (Opposite C) (Type v)\nP : CategoryTheory.Limits.IndObjectPresentation A\nŒ∑ : Quiver.Hom A B\ninst‚úù : CategoryTheory.IsIso Œ∑\nX‚úù : P.I\nX : Opposite C\na‚úù : ((Opposite.unop { unop := P.F.comp CategoryTheory.yoneda }).obj X‚úù).obj X\n‚ä¢ Eq (((P.extend Œ∑).Œπ.app X‚úù).app X a‚úù) (Œ∑.app X ((P.cocone.Œπ.app X‚úù).app X a‚úù))","decl":"/-- If `A` and `B` are isomorphic, then an ind-object presentation of `A` can be extended to an\n    ind-object presentation of `B`. -/\n@[simps!]\nnoncomputable def extend {A B : C·µí·µñ ‚•§ Type v} (P : IndObjectPresentation A) (Œ∑ : A ‚ü∂ B) [IsIso Œ∑] :\n    IndObjectPresentation B :=\n  .ofCocone (P.cocone.extend Œ∑) (P.coconeIsColimit.extendIso (by exact Œ∑))\n\n"}
{"name":"CategoryTheory.Limits.IndObjectPresentation.extend_F","module":"Mathlib.CategoryTheory.Limits.Indization.IndObject","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nA B : CategoryTheory.Functor (Opposite C) (Type v)\nP : CategoryTheory.Limits.IndObjectPresentation A\nŒ∑ : Quiver.Hom A B\ninst‚úù : CategoryTheory.IsIso Œ∑\n‚ä¢ Eq (P.extend Œ∑).F P.F","decl":"/-- If `A` and `B` are isomorphic, then an ind-object presentation of `A` can be extended to an\n    ind-object presentation of `B`. -/\n@[simps!]\nnoncomputable def extend {A B : C·µí·µñ ‚•§ Type v} (P : IndObjectPresentation A) (Œ∑ : A ‚ü∂ B) [IsIso Œ∑] :\n    IndObjectPresentation B :=\n  .ofCocone (P.cocone.extend Œ∑) (P.coconeIsColimit.extendIso (by exact Œ∑))\n\n"}
{"name":"CategoryTheory.Limits.IndObjectPresentation.extend_‚Ñê","module":"Mathlib.CategoryTheory.Limits.Indization.IndObject","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nA B : CategoryTheory.Functor (Opposite C) (Type v)\nP : CategoryTheory.Limits.IndObjectPresentation A\nŒ∑ : Quiver.Hom A B\ninst‚úù : CategoryTheory.IsIso Œ∑\n‚ä¢ Eq (P.extend Œ∑).‚Ñê P.‚Ñê","decl":"/-- If `A` and `B` are isomorphic, then an ind-object presentation of `A` can be extended to an\n    ind-object presentation of `B`. -/\n@[simps!]\nnoncomputable def extend {A B : C·µí·µñ ‚•§ Type v} (P : IndObjectPresentation A) (Œ∑ : A ‚ü∂ B) [IsIso Œ∑] :\n    IndObjectPresentation B :=\n  .ofCocone (P.cocone.extend Œ∑) (P.coconeIsColimit.extendIso (by exact Œ∑))\n\n"}
{"name":"CategoryTheory.Limits.IndObjectPresentation.extend_isColimit_desc_app","module":"Mathlib.CategoryTheory.Limits.Indization.IndObject","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nA B : CategoryTheory.Functor (Opposite C) (Type v)\nP : CategoryTheory.Limits.IndObjectPresentation A\nŒ∑ : Quiver.Hom A B\ninst‚úù : CategoryTheory.IsIso Œ∑\ns : CategoryTheory.Limits.Cocone (P.F.comp CategoryTheory.yoneda)\nX : Opposite C\na‚úù : (P.cocone.extend Œ∑).pt.obj X\n‚ä¢ Eq (((P.extend Œ∑).isColimit.desc s).app X a‚úù) ((P.coconeIsColimit.desc s).app X (CategoryTheory.inv (Œ∑.app X) a‚úù))","decl":"/-- If `A` and `B` are isomorphic, then an ind-object presentation of `A` can be extended to an\n    ind-object presentation of `B`. -/\n@[simps!]\nnoncomputable def extend {A B : C·µí·µñ ‚•§ Type v} (P : IndObjectPresentation A) (Œ∑ : A ‚ü∂ B) [IsIso Œ∑] :\n    IndObjectPresentation B :=\n  .ofCocone (P.cocone.extend Œ∑) (P.coconeIsColimit.extendIso (by exact Œ∑))\n\n"}
{"name":"CategoryTheory.Limits.IndObjectPresentation.extend_I","module":"Mathlib.CategoryTheory.Limits.Indization.IndObject","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nA B : CategoryTheory.Functor (Opposite C) (Type v)\nP : CategoryTheory.Limits.IndObjectPresentation A\nŒ∑ : Quiver.Hom A B\ninst‚úù : CategoryTheory.IsIso Œ∑\n‚ä¢ Eq (P.extend Œ∑).I P.I","decl":"/-- If `A` and `B` are isomorphic, then an ind-object presentation of `A` can be extended to an\n    ind-object presentation of `B`. -/\n@[simps!]\nnoncomputable def extend {A B : C·µí·µñ ‚•§ Type v} (P : IndObjectPresentation A) (Œ∑ : A ‚ü∂ B) [IsIso Œ∑] :\n    IndObjectPresentation B :=\n  .ofCocone (P.cocone.extend Œ∑) (P.coconeIsColimit.extendIso (by exact Œ∑))\n\n"}
{"name":"CategoryTheory.Limits.IndObjectPresentation.toCostructuredArrow_map_left","module":"Mathlib.CategoryTheory.Limits.Indization.IndObject","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nP : CategoryTheory.Limits.IndObjectPresentation A\nX‚úù Y‚úù : P.I\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (P.toCostructuredArrow.map f).left (P.F.map f)","decl":"/-- The canonical comparison functor between the indexing category of the presentation and the\n    comma category `CostructuredArrow yoneda A`. This functor is always final. -/\n@[simps! obj_left obj_right_as obj_hom map_left]\ndef toCostructuredArrow : P.I ‚•§ CostructuredArrow yoneda A :=\n  P.cocone.toCostructuredArrow ‚ãô CostructuredArrow.pre _ _ _\n\n"}
{"name":"CategoryTheory.Limits.IndObjectPresentation.toCostructuredArrow_obj_right_as","module":"Mathlib.CategoryTheory.Limits.Indization.IndObject","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nP : CategoryTheory.Limits.IndObjectPresentation A\nX : P.I\n‚ä¢ Eq (P.toCostructuredArrow.obj X).right.as PUnit.unit","decl":"/-- The canonical comparison functor between the indexing category of the presentation and the\n    comma category `CostructuredArrow yoneda A`. This functor is always final. -/\n@[simps! obj_left obj_right_as obj_hom map_left]\ndef toCostructuredArrow : P.I ‚•§ CostructuredArrow yoneda A :=\n  P.cocone.toCostructuredArrow ‚ãô CostructuredArrow.pre _ _ _\n\n"}
{"name":"CategoryTheory.Limits.IndObjectPresentation.toCostructuredArrow_obj_left","module":"Mathlib.CategoryTheory.Limits.Indization.IndObject","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nP : CategoryTheory.Limits.IndObjectPresentation A\nX : P.I\n‚ä¢ Eq (P.toCostructuredArrow.obj X).left (P.F.obj X)","decl":"/-- The canonical comparison functor between the indexing category of the presentation and the\n    comma category `CostructuredArrow yoneda A`. This functor is always final. -/\n@[simps! obj_left obj_right_as obj_hom map_left]\ndef toCostructuredArrow : P.I ‚•§ CostructuredArrow yoneda A :=\n  P.cocone.toCostructuredArrow ‚ãô CostructuredArrow.pre _ _ _\n\n"}
{"name":"CategoryTheory.Limits.IndObjectPresentation.toCostructuredArrow_obj_hom","module":"Mathlib.CategoryTheory.Limits.Indization.IndObject","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nP : CategoryTheory.Limits.IndObjectPresentation A\nX : P.I\n‚ä¢ Eq (P.toCostructuredArrow.obj X).hom (P.cocone.Œπ.app X)","decl":"/-- The canonical comparison functor between the indexing category of the presentation and the\n    comma category `CostructuredArrow yoneda A`. This functor is always final. -/\n@[simps! obj_left obj_right_as obj_hom map_left]\ndef toCostructuredArrow : P.I ‚•§ CostructuredArrow yoneda A :=\n  P.cocone.toCostructuredArrow ‚ãô CostructuredArrow.pre _ _ _\n\n"}
{"name":"CategoryTheory.Limits.IndObjectPresentation.instFinalICostructuredArrowFunctorOppositeTypeYonedaToCostructuredArrow","module":"Mathlib.CategoryTheory.Limits.Indization.IndObject","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nP : CategoryTheory.Limits.IndObjectPresentation A\n‚ä¢ P.toCostructuredArrow.Final","decl":"instance : P.toCostructuredArrow.Final :=\n  Presheaf.final_toCostructuredArrow_comp_pre _ P.coconeIsColimit\n\n"}
{"name":"CategoryTheory.Limits.IndObjectPresentation.yoneda_Œπ_app","module":"Mathlib.CategoryTheory.Limits.Indization.IndObject","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : C\nx‚úù : CategoryTheory.Discrete PUnit.{v + 1}\n‚ä¢ Eq ((CategoryTheory.Limits.IndObjectPresentation.yoneda X).Œπ.app x‚úù) (CategoryTheory.CategoryStruct.id (((CategoryTheory.Functor.fromPUnit X).comp CategoryTheory.yoneda).obj x‚úù))","decl":"/-- Representable presheaves are (trivially) ind-objects. -/\n@[simps]\ndef yoneda (X : C) : IndObjectPresentation (yoneda.obj X) where\n  I := Discrete PUnit.{v + 1}\n  F := Functor.fromPUnit X\n  Œπ := { app := fun _ => ùüô _ }\n  isColimit :=\n    { desc := fun s => s.Œπ.app ‚ü®PUnit.unit‚ü©\n      uniq := fun _ _ h => h ‚ü®PUnit.unit‚ü© }\n\n"}
{"name":"CategoryTheory.Limits.IndObjectPresentation.yoneda_F","module":"Mathlib.CategoryTheory.Limits.Indization.IndObject","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : C\n‚ä¢ Eq (CategoryTheory.Limits.IndObjectPresentation.yoneda X).F (CategoryTheory.Functor.fromPUnit X)","decl":"/-- Representable presheaves are (trivially) ind-objects. -/\n@[simps]\ndef yoneda (X : C) : IndObjectPresentation (yoneda.obj X) where\n  I := Discrete PUnit.{v + 1}\n  F := Functor.fromPUnit X\n  Œπ := { app := fun _ => ùüô _ }\n  isColimit :=\n    { desc := fun s => s.Œπ.app ‚ü®PUnit.unit‚ü©\n      uniq := fun _ _ h => h ‚ü®PUnit.unit‚ü© }\n\n"}
{"name":"CategoryTheory.Limits.IndObjectPresentation.yoneda_isColimit_desc","module":"Mathlib.CategoryTheory.Limits.Indization.IndObject","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : C\ns : CategoryTheory.Limits.Cocone ((CategoryTheory.Functor.fromPUnit X).comp CategoryTheory.yoneda)\n‚ä¢ Eq ((CategoryTheory.Limits.IndObjectPresentation.yoneda X).isColimit.desc s) (s.Œπ.app { as := PUnit.unit })","decl":"/-- Representable presheaves are (trivially) ind-objects. -/\n@[simps]\ndef yoneda (X : C) : IndObjectPresentation (yoneda.obj X) where\n  I := Discrete PUnit.{v + 1}\n  F := Functor.fromPUnit X\n  Œπ := { app := fun _ => ùüô _ }\n  isColimit :=\n    { desc := fun s => s.Œπ.app ‚ü®PUnit.unit‚ü©\n      uniq := fun _ _ h => h ‚ü®PUnit.unit‚ü© }\n\n"}
{"name":"CategoryTheory.Limits.IndObjectPresentation.yoneda_I","module":"Mathlib.CategoryTheory.Limits.Indization.IndObject","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : C\n‚ä¢ Eq (CategoryTheory.Limits.IndObjectPresentation.yoneda X).I (CategoryTheory.Discrete PUnit.{v + 1})","decl":"/-- Representable presheaves are (trivially) ind-objects. -/\n@[simps]\ndef yoneda (X : C) : IndObjectPresentation (yoneda.obj X) where\n  I := Discrete PUnit.{v + 1}\n  F := Functor.fromPUnit X\n  Œπ := { app := fun _ => ùüô _ }\n  isColimit :=\n    { desc := fun s => s.Œπ.app ‚ü®PUnit.unit‚ü©\n      uniq := fun _ _ h => h ‚ü®PUnit.unit‚ü© }\n\n"}
{"name":"CategoryTheory.Limits.IndObjectPresentation.yoneda_‚Ñê","module":"Mathlib.CategoryTheory.Limits.Indization.IndObject","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : C\n‚ä¢ Eq (CategoryTheory.Limits.IndObjectPresentation.yoneda X).‚Ñê (CategoryTheory.discreteCategory PUnit.{v + 1})","decl":"/-- Representable presheaves are (trivially) ind-objects. -/\n@[simps]\ndef yoneda (X : C) : IndObjectPresentation (yoneda.obj X) where\n  I := Discrete PUnit.{v + 1}\n  F := Functor.fromPUnit X\n  Œπ := { app := fun _ => ùüô _ }\n  isColimit :=\n    { desc := fun s => s.Œπ.app ‚ü®PUnit.unit‚ü©\n      uniq := fun _ _ h => h ‚ü®PUnit.unit‚ü© }\n\n"}
{"name":"CategoryTheory.Limits.IsIndObject.nonempty_presentation","module":"Mathlib.CategoryTheory.Limits.Indization.IndObject","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nself : CategoryTheory.Limits.IsIndObject A\n‚ä¢ Nonempty (CategoryTheory.Limits.IndObjectPresentation A)","decl":"/-- A presheaf is called an ind-object if it can be written as a filtered colimit of representable\n    presheaves. -/\nstructure IsIndObject (A : C·µí·µñ ‚•§ Type v) : Prop where\n  mk' :: nonempty_presentation : Nonempty (IndObjectPresentation A)\n\n"}
{"name":"CategoryTheory.Limits.IsIndObject.mk","module":"Mathlib.CategoryTheory.Limits.Indization.IndObject","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nP : CategoryTheory.Limits.IndObjectPresentation A\n‚ä¢ CategoryTheory.Limits.IsIndObject A","decl":"theorem IsIndObject.mk {A : C·µí·µñ ‚•§ Type v} (P : IndObjectPresentation A) : IsIndObject A :=\n  ‚ü®‚ü®P‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.Limits.isIndObject_yoneda","module":"Mathlib.CategoryTheory.Limits.Indization.IndObject","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : C\n‚ä¢ CategoryTheory.Limits.IsIndObject (CategoryTheory.yoneda.obj X)","decl":"/-- Representable presheaves are (trivially) ind-objects. -/\ntheorem isIndObject_yoneda (X : C) : IsIndObject (yoneda.obj X) :=\n  .mk <| IndObjectPresentation.yoneda X\n\n"}
{"name":"CategoryTheory.Limits.IsIndObject.map","module":"Mathlib.CategoryTheory.Limits.Indization.IndObject","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nA B : CategoryTheory.Functor (Opposite C) (Type v)\nŒ∑ : Quiver.Hom A B\ninst‚úù : CategoryTheory.IsIso Œ∑\na‚úù : CategoryTheory.Limits.IsIndObject A\n‚ä¢ CategoryTheory.Limits.IsIndObject B","decl":"theorem map {A B : C·µí·µñ ‚•§ Type v} (Œ∑ : A ‚ü∂ B) [IsIso Œ∑] : IsIndObject A ‚Üí IsIndObject B\n  | ‚ü®‚ü®P‚ü©‚ü© => ‚ü®‚ü®P.extend Œ∑‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.Limits.IsIndObject.iff_of_iso","module":"Mathlib.CategoryTheory.Limits.Indization.IndObject","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nA B : CategoryTheory.Functor (Opposite C) (Type v)\nŒ∑ : Quiver.Hom A B\ninst‚úù : CategoryTheory.IsIso Œ∑\n‚ä¢ Iff (CategoryTheory.Limits.IsIndObject A) (CategoryTheory.Limits.IsIndObject B)","decl":"theorem iff_of_iso {A B : C·µí·µñ ‚•§ Type v} (Œ∑ : A ‚ü∂ B) [IsIso Œ∑] : IsIndObject A ‚Üî IsIndObject B :=\n  ‚ü®.map Œ∑, .map (inv Œ∑)‚ü©\n\n"}
{"name":"CategoryTheory.Limits.IsIndObject.instClosedUnderIsomorphismsFunctorOppositeType","module":"Mathlib.CategoryTheory.Limits.Indization.IndObject","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\n‚ä¢ CategoryTheory.ClosedUnderIsomorphisms CategoryTheory.Limits.IsIndObject","decl":"instance : ClosedUnderIsomorphisms (IsIndObject (C := C)) where\n  of_iso i h := h.map i.hom\n\n"}
{"name":"CategoryTheory.Limits.IsIndObject.isFiltered","module":"Mathlib.CategoryTheory.Limits.Indization.IndObject","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nh : CategoryTheory.Limits.IsIndObject A\n‚ä¢ CategoryTheory.IsFiltered (CategoryTheory.CostructuredArrow CategoryTheory.yoneda A)","decl":"theorem isFiltered (h : IsIndObject A) : IsFiltered (CostructuredArrow yoneda A) :=\n  IsFiltered.of_final h.presentation.toCostructuredArrow\n\n"}
{"name":"CategoryTheory.Limits.IsIndObject.finallySmall","module":"Mathlib.CategoryTheory.Limits.Indization.IndObject","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nh : CategoryTheory.Limits.IsIndObject A\n‚ä¢ CategoryTheory.FinallySmall (CategoryTheory.CostructuredArrow CategoryTheory.yoneda A)","decl":"theorem finallySmall (h : IsIndObject A) : FinallySmall.{v} (CostructuredArrow yoneda A) :=\n  FinallySmall.mk' h.presentation.toCostructuredArrow\n\n"}
{"name":"CategoryTheory.Limits.isIndObject_of_isFiltered_of_finallySmall","module":"Mathlib.CategoryTheory.Limits.Indization.IndObject","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\ninst‚úù¬π : CategoryTheory.IsFiltered (CategoryTheory.CostructuredArrow CategoryTheory.yoneda A)\ninst‚úù : CategoryTheory.FinallySmall (CategoryTheory.CostructuredArrow CategoryTheory.yoneda A)\n‚ä¢ CategoryTheory.Limits.IsIndObject A","decl":"theorem isIndObject_of_isFiltered_of_finallySmall (A : C·µí·µñ ‚•§ Type v)\n    [IsFiltered (CostructuredArrow yoneda A)] [FinallySmall.{v} (CostructuredArrow yoneda A)] :\n    IsIndObject A := by\n  have h‚ÇÅ : (factoring (fromFinalModel (CostructuredArrow yoneda A)) ‚ãô\n      inclusion (fromFinalModel (CostructuredArrow yoneda A))).Final := Functor.final_of_natIso\n    (factoringCompInclusion (fromFinalModel <| CostructuredArrow yoneda A)).symm\n  have h‚ÇÇ : Functor.Final (inclusion (fromFinalModel (CostructuredArrow yoneda A))) :=\n    Functor.final_of_comp_full_faithful' (factoring _) (inclusion _)\n  let c := (Presheaf.tautologicalCocone A).whisker\n    (inclusion (fromFinalModel (CostructuredArrow yoneda A)))\n  let hc : IsColimit c := (Functor.Final.isColimitWhiskerEquiv _ _).symm\n    (Presheaf.isColimitTautologicalCocone A)\n  have hq : Nonempty (FinalModel (CostructuredArrow yoneda A)) := Nonempty.map\n    (Functor.Final.lift (fromFinalModel (CostructuredArrow yoneda A))) IsFiltered.nonempty\n  exact ‚ü®_, inclusion (fromFinalModel _) ‚ãô CostructuredArrow.proj yoneda A, c.Œπ, hc‚ü©\n\n"}
{"name":"CategoryTheory.Limits.isIndObject_iff","module":"Mathlib.CategoryTheory.Limits.Indization.IndObject","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\n‚ä¢ Iff (CategoryTheory.Limits.IsIndObject A) (And (CategoryTheory.IsFiltered (CategoryTheory.CostructuredArrow CategoryTheory.yoneda A)) (CategoryTheory.FinallySmall (CategoryTheory.CostructuredArrow CategoryTheory.yoneda A)))","decl":"/-- The recognition theorem for ind-objects: `A : C·µí·µñ ‚•§ Type v` is an ind-object if and only if\n    `CostructuredArrow yoneda A` is filtered and finally `v`-small.\n\n    Theorem 6.1.5 of [Kashiwara2006] -/\ntheorem isIndObject_iff (A : C·µí·µñ ‚•§ Type v) : IsIndObject A ‚Üî\n    (IsFiltered (CostructuredArrow yoneda A) ‚àß FinallySmall.{v} (CostructuredArrow yoneda A)) :=\n  ‚ü®fun h => ‚ü®h.isFiltered, h.finallySmall‚ü©,\n   fun ‚ü®_, _‚ü© => isIndObject_of_isFiltered_of_finallySmall A‚ü©\n\n"}
{"name":"CategoryTheory.Limits.isIndObject_limit_comp_yoneda","module":"Mathlib.CategoryTheory.Limits.Indization.IndObject","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nJ : Type u'\ninst‚úù¬π : CategoryTheory.Category.{v', u'} J\nF : CategoryTheory.Functor J C\ninst‚úù : CategoryTheory.Limits.HasLimit F\n‚ä¢ CategoryTheory.Limits.IsIndObject (CategoryTheory.Limits.limit (F.comp CategoryTheory.yoneda))","decl":"/-- If a limit already exists in `C`, then the limit of the image of the diagram under the Yoneda\nembedding is an ind-object. -/\ntheorem isIndObject_limit_comp_yoneda {J : Type u'} [Category.{v'} J] (F : J ‚•§ C) [HasLimit F] :\n    IsIndObject (limit (F ‚ãô yoneda)) :=\n  IsIndObject.map (preservesLimitIso yoneda F).hom (isIndObject_yoneda (limit F))\n\n"}
