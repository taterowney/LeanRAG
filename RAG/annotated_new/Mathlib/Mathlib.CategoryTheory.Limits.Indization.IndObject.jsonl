{"name":"CategoryTheory.Limits.IndObjectPresentation.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Limits.Indization.IndObject","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\ninst✝ : SizeOf C\nI : Type v\nℐ : CategoryTheory.SmallCategory I\nhI : CategoryTheory.IsFiltered I\nF : CategoryTheory.Functor I C\nι : Quiver.Hom (F.comp CategoryTheory.yoneda) ((CategoryTheory.Functor.const I).obj A)\nisColimit : CategoryTheory.Limits.IsColimit { pt := A, ι := ι }\n⊢ Eq (SizeOf.sizeOf (CategoryTheory.Limits.IndObjectPresentation.mk I F ι isColimit)) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf I)) (SizeOf.sizeOf ℐ)) (SizeOf.sizeOf hI)) (SizeOf.sizeOf F)) (SizeOf.sizeOf ι)) (SizeOf.sizeOf isColimit))","decl":"/-- The data that witnesses that a presheaf `A` is an ind-object. It consists of a small\n    filtered indexing category `I`, a diagram `F : I ⥤ C` and the data for a colimit cocone on\n    `F ⋙ yoneda : I ⥤ Cᵒᵖ ⥤ Type v` with cocone point `A`. -/\nstructure IndObjectPresentation (A : Cᵒᵖ ⥤ Type v) where\n  /-- The indexing category of the filtered colimit presentation -/\n  I : Type v\n  /-- The indexing category of the filtered colimit presentation -/\n  [ℐ : SmallCategory I]\n  [hI : IsFiltered I]\n  /-- The diagram of the filtered colimit presentation -/\n  F : I ⥤ C\n  /-- Use `IndObjectPresentation.cocone` instead. -/\n  ι : F ⋙ yoneda ⟶ (Functor.const I).obj A\n  /-- Use `IndObjectPresentation.coconeIsColimit` instead. -/\n  isColimit : IsColimit (Cocone.mk A ι)\n\n"}
{"name":"CategoryTheory.Limits.IndObjectPresentation.mk.injEq","module":"Mathlib.CategoryTheory.Limits.Indization.IndObject","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nI✝ : Type v\nℐ✝ : CategoryTheory.SmallCategory I✝\nhI✝ : CategoryTheory.IsFiltered I✝\nF✝ : CategoryTheory.Functor I✝ C\nι✝ : Quiver.Hom (F✝.comp CategoryTheory.yoneda) ((CategoryTheory.Functor.const I✝).obj A)\nisColimit✝ : CategoryTheory.Limits.IsColimit { pt := A, ι := ι✝ }\nI : Type v\nℐ : CategoryTheory.SmallCategory I\nhI : CategoryTheory.IsFiltered I\nF : CategoryTheory.Functor I C\nι : Quiver.Hom (F.comp CategoryTheory.yoneda) ((CategoryTheory.Functor.const I).obj A)\nisColimit : CategoryTheory.Limits.IsColimit { pt := A, ι := ι }\n⊢ Eq (Eq (CategoryTheory.Limits.IndObjectPresentation.mk I✝ F✝ ι✝ isColimit✝) (CategoryTheory.Limits.IndObjectPresentation.mk I F ι isColimit)) (And (Eq I✝ I) (And (HEq ℐ✝ ℐ) (And (HEq F✝ F) (And (HEq ι✝ ι) (HEq isColimit✝ isColimit)))))","decl":"/-- The data that witnesses that a presheaf `A` is an ind-object. It consists of a small\n    filtered indexing category `I`, a diagram `F : I ⥤ C` and the data for a colimit cocone on\n    `F ⋙ yoneda : I ⥤ Cᵒᵖ ⥤ Type v` with cocone point `A`. -/\nstructure IndObjectPresentation (A : Cᵒᵖ ⥤ Type v) where\n  /-- The indexing category of the filtered colimit presentation -/\n  I : Type v\n  /-- The indexing category of the filtered colimit presentation -/\n  [ℐ : SmallCategory I]\n  [hI : IsFiltered I]\n  /-- The diagram of the filtered colimit presentation -/\n  F : I ⥤ C\n  /-- Use `IndObjectPresentation.cocone` instead. -/\n  ι : F ⋙ yoneda ⟶ (Functor.const I).obj A\n  /-- Use `IndObjectPresentation.coconeIsColimit` instead. -/\n  isColimit : IsColimit (Cocone.mk A ι)\n\n"}
{"name":"CategoryTheory.Limits.IndObjectPresentation.mk.inj","module":"Mathlib.CategoryTheory.Limits.Indization.IndObject","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nI✝ : Type v\nℐ✝ : CategoryTheory.SmallCategory I✝\nhI✝ : CategoryTheory.IsFiltered I✝\nF✝ : CategoryTheory.Functor I✝ C\nι✝ : Quiver.Hom (F✝.comp CategoryTheory.yoneda) ((CategoryTheory.Functor.const I✝).obj A)\nisColimit✝ : CategoryTheory.Limits.IsColimit { pt := A, ι := ι✝ }\nI : Type v\nℐ : CategoryTheory.SmallCategory I\nhI : CategoryTheory.IsFiltered I\nF : CategoryTheory.Functor I C\nι : Quiver.Hom (F.comp CategoryTheory.yoneda) ((CategoryTheory.Functor.const I).obj A)\nisColimit : CategoryTheory.Limits.IsColimit { pt := A, ι := ι }\nx✝ : Eq (CategoryTheory.Limits.IndObjectPresentation.mk I✝ F✝ ι✝ isColimit✝) (CategoryTheory.Limits.IndObjectPresentation.mk I F ι isColimit)\n⊢ And (Eq I✝ I) (And (HEq ℐ✝ ℐ) (And (HEq F✝ F) (And (HEq ι✝ ι) (HEq isColimit✝ isColimit))))","decl":"/-- The data that witnesses that a presheaf `A` is an ind-object. It consists of a small\n    filtered indexing category `I`, a diagram `F : I ⥤ C` and the data for a colimit cocone on\n    `F ⋙ yoneda : I ⥤ Cᵒᵖ ⥤ Type v` with cocone point `A`. -/\nstructure IndObjectPresentation (A : Cᵒᵖ ⥤ Type v) where\n  /-- The indexing category of the filtered colimit presentation -/\n  I : Type v\n  /-- The indexing category of the filtered colimit presentation -/\n  [ℐ : SmallCategory I]\n  [hI : IsFiltered I]\n  /-- The diagram of the filtered colimit presentation -/\n  F : I ⥤ C\n  /-- Use `IndObjectPresentation.cocone` instead. -/\n  ι : F ⋙ yoneda ⟶ (Functor.const I).obj A\n  /-- Use `IndObjectPresentation.coconeIsColimit` instead. -/\n  isColimit : IsColimit (Cocone.mk A ι)\n\n"}
{"name":"CategoryTheory.Limits.IndObjectPresentation.hI","module":"Mathlib.CategoryTheory.Limits.Indization.IndObject","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nself : CategoryTheory.Limits.IndObjectPresentation A\n⊢ CategoryTheory.IsFiltered self.I","decl":"/-- The data that witnesses that a presheaf `A` is an ind-object. It consists of a small\n    filtered indexing category `I`, a diagram `F : I ⥤ C` and the data for a colimit cocone on\n    `F ⋙ yoneda : I ⥤ Cᵒᵖ ⥤ Type v` with cocone point `A`. -/\nstructure IndObjectPresentation (A : Cᵒᵖ ⥤ Type v) where\n  /-- The indexing category of the filtered colimit presentation -/\n  I : Type v\n  /-- The indexing category of the filtered colimit presentation -/\n  [ℐ : SmallCategory I]\n  [hI : IsFiltered I]\n  /-- The diagram of the filtered colimit presentation -/\n  F : I ⥤ C\n  /-- Use `IndObjectPresentation.cocone` instead. -/\n  ι : F ⋙ yoneda ⟶ (Functor.const I).obj A\n  /-- Use `IndObjectPresentation.coconeIsColimit` instead. -/\n  isColimit : IsColimit (Cocone.mk A ι)\n\n"}
{"name":"CategoryTheory.Limits.IndObjectPresentation.ofCocone_isColimit","module":"Mathlib.CategoryTheory.Limits.Indization.IndObject","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nI : Type v\ninst✝¹ : CategoryTheory.SmallCategory I\ninst✝ : CategoryTheory.IsFiltered I\nF : CategoryTheory.Functor I C\nc : CategoryTheory.Limits.Cocone (F.comp CategoryTheory.yoneda)\nhc : CategoryTheory.Limits.IsColimit c\n⊢ Eq (CategoryTheory.Limits.IndObjectPresentation.ofCocone c hc).isColimit hc","decl":"/-- Alternative constructor for `IndObjectPresentation` taking a cocone instead of its defining\n    natural transformation. -/\n@[simps]\ndef ofCocone {I : Type v} [SmallCategory I] [IsFiltered I] {F : I ⥤ C}\n    (c : Cocone (F ⋙ yoneda)) (hc : IsColimit c) : IndObjectPresentation c.pt where\n  I := I\n  F := F\n  ι := c.ι\n  isColimit := hc\n\n"}
{"name":"CategoryTheory.Limits.IndObjectPresentation.ofCocone_F","module":"Mathlib.CategoryTheory.Limits.Indization.IndObject","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nI : Type v\ninst✝¹ : CategoryTheory.SmallCategory I\ninst✝ : CategoryTheory.IsFiltered I\nF : CategoryTheory.Functor I C\nc : CategoryTheory.Limits.Cocone (F.comp CategoryTheory.yoneda)\nhc : CategoryTheory.Limits.IsColimit c\n⊢ Eq (CategoryTheory.Limits.IndObjectPresentation.ofCocone c hc).F F","decl":"/-- Alternative constructor for `IndObjectPresentation` taking a cocone instead of its defining\n    natural transformation. -/\n@[simps]\ndef ofCocone {I : Type v} [SmallCategory I] [IsFiltered I] {F : I ⥤ C}\n    (c : Cocone (F ⋙ yoneda)) (hc : IsColimit c) : IndObjectPresentation c.pt where\n  I := I\n  F := F\n  ι := c.ι\n  isColimit := hc\n\n"}
{"name":"CategoryTheory.Limits.IndObjectPresentation.ofCocone_I","module":"Mathlib.CategoryTheory.Limits.Indization.IndObject","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nI : Type v\ninst✝¹ : CategoryTheory.SmallCategory I\ninst✝ : CategoryTheory.IsFiltered I\nF : CategoryTheory.Functor I C\nc : CategoryTheory.Limits.Cocone (F.comp CategoryTheory.yoneda)\nhc : CategoryTheory.Limits.IsColimit c\n⊢ Eq (CategoryTheory.Limits.IndObjectPresentation.ofCocone c hc).I I","decl":"/-- Alternative constructor for `IndObjectPresentation` taking a cocone instead of its defining\n    natural transformation. -/\n@[simps]\ndef ofCocone {I : Type v} [SmallCategory I] [IsFiltered I] {F : I ⥤ C}\n    (c : Cocone (F ⋙ yoneda)) (hc : IsColimit c) : IndObjectPresentation c.pt where\n  I := I\n  F := F\n  ι := c.ι\n  isColimit := hc\n\n"}
{"name":"CategoryTheory.Limits.IndObjectPresentation.ofCocone_ι","module":"Mathlib.CategoryTheory.Limits.Indization.IndObject","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nI : Type v\ninst✝¹ : CategoryTheory.SmallCategory I\ninst✝ : CategoryTheory.IsFiltered I\nF : CategoryTheory.Functor I C\nc : CategoryTheory.Limits.Cocone (F.comp CategoryTheory.yoneda)\nhc : CategoryTheory.Limits.IsColimit c\n⊢ Eq (CategoryTheory.Limits.IndObjectPresentation.ofCocone c hc).ι c.ι","decl":"/-- Alternative constructor for `IndObjectPresentation` taking a cocone instead of its defining\n    natural transformation. -/\n@[simps]\ndef ofCocone {I : Type v} [SmallCategory I] [IsFiltered I] {F : I ⥤ C}\n    (c : Cocone (F ⋙ yoneda)) (hc : IsColimit c) : IndObjectPresentation c.pt where\n  I := I\n  F := F\n  ι := c.ι\n  isColimit := hc\n\n"}
{"name":"CategoryTheory.Limits.IndObjectPresentation.ofCocone_ℐ","module":"Mathlib.CategoryTheory.Limits.Indization.IndObject","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nI : Type v\ninst✝¹ : CategoryTheory.SmallCategory I\ninst✝ : CategoryTheory.IsFiltered I\nF : CategoryTheory.Functor I C\nc : CategoryTheory.Limits.Cocone (F.comp CategoryTheory.yoneda)\nhc : CategoryTheory.Limits.IsColimit c\n⊢ Eq (CategoryTheory.Limits.IndObjectPresentation.ofCocone c hc).ℐ inst✝¹","decl":"/-- Alternative constructor for `IndObjectPresentation` taking a cocone instead of its defining\n    natural transformation. -/\n@[simps]\ndef ofCocone {I : Type v} [SmallCategory I] [IsFiltered I] {F : I ⥤ C}\n    (c : Cocone (F ⋙ yoneda)) (hc : IsColimit c) : IndObjectPresentation c.pt where\n  I := I\n  F := F\n  ι := c.ι\n  isColimit := hc\n\n"}
{"name":"CategoryTheory.Limits.IndObjectPresentation.instIsFilteredI","module":"Mathlib.CategoryTheory.Limits.Indization.IndObject","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nP : CategoryTheory.Limits.IndObjectPresentation A\n⊢ CategoryTheory.IsFiltered P.I","decl":"instance : IsFiltered P.I := P.hI\n\n"}
{"name":"CategoryTheory.Limits.IndObjectPresentation.cocone_pt","module":"Mathlib.CategoryTheory.Limits.Indization.IndObject","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nP : CategoryTheory.Limits.IndObjectPresentation A\n⊢ Eq P.cocone.pt A","decl":"/-- The (colimit) cocone with cocone point `A`. -/\n@[simps pt]\ndef cocone : Cocone (P.F ⋙ yoneda) where\n  pt := A\n  ι := P.ι\n\n"}
{"name":"CategoryTheory.Limits.IndObjectPresentation.extend_ι_app_app","module":"Mathlib.CategoryTheory.Limits.Indization.IndObject","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nA B : CategoryTheory.Functor (Opposite C) (Type v)\nP : CategoryTheory.Limits.IndObjectPresentation A\nη : Quiver.Hom A B\ninst✝ : CategoryTheory.IsIso η\nX✝ : P.I\nX : Opposite C\na✝ : ((Opposite.unop { unop := P.F.comp CategoryTheory.yoneda }).obj X✝).obj X\n⊢ Eq (((P.extend η).ι.app X✝).app X a✝) (η.app X ((P.cocone.ι.app X✝).app X a✝))","decl":"/-- If `A` and `B` are isomorphic, then an ind-object presentation of `A` can be extended to an\n    ind-object presentation of `B`. -/\n@[simps!]\nnoncomputable def extend {A B : Cᵒᵖ ⥤ Type v} (P : IndObjectPresentation A) (η : A ⟶ B) [IsIso η] :\n    IndObjectPresentation B :=\n  .ofCocone (P.cocone.extend η) (P.coconeIsColimit.extendIso (by exact η))\n\n"}
{"name":"CategoryTheory.Limits.IndObjectPresentation.extend_F","module":"Mathlib.CategoryTheory.Limits.Indization.IndObject","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nA B : CategoryTheory.Functor (Opposite C) (Type v)\nP : CategoryTheory.Limits.IndObjectPresentation A\nη : Quiver.Hom A B\ninst✝ : CategoryTheory.IsIso η\n⊢ Eq (P.extend η).F P.F","decl":"/-- If `A` and `B` are isomorphic, then an ind-object presentation of `A` can be extended to an\n    ind-object presentation of `B`. -/\n@[simps!]\nnoncomputable def extend {A B : Cᵒᵖ ⥤ Type v} (P : IndObjectPresentation A) (η : A ⟶ B) [IsIso η] :\n    IndObjectPresentation B :=\n  .ofCocone (P.cocone.extend η) (P.coconeIsColimit.extendIso (by exact η))\n\n"}
{"name":"CategoryTheory.Limits.IndObjectPresentation.extend_ℐ","module":"Mathlib.CategoryTheory.Limits.Indization.IndObject","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nA B : CategoryTheory.Functor (Opposite C) (Type v)\nP : CategoryTheory.Limits.IndObjectPresentation A\nη : Quiver.Hom A B\ninst✝ : CategoryTheory.IsIso η\n⊢ Eq (P.extend η).ℐ P.ℐ","decl":"/-- If `A` and `B` are isomorphic, then an ind-object presentation of `A` can be extended to an\n    ind-object presentation of `B`. -/\n@[simps!]\nnoncomputable def extend {A B : Cᵒᵖ ⥤ Type v} (P : IndObjectPresentation A) (η : A ⟶ B) [IsIso η] :\n    IndObjectPresentation B :=\n  .ofCocone (P.cocone.extend η) (P.coconeIsColimit.extendIso (by exact η))\n\n"}
{"name":"CategoryTheory.Limits.IndObjectPresentation.extend_isColimit_desc_app","module":"Mathlib.CategoryTheory.Limits.Indization.IndObject","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nA B : CategoryTheory.Functor (Opposite C) (Type v)\nP : CategoryTheory.Limits.IndObjectPresentation A\nη : Quiver.Hom A B\ninst✝ : CategoryTheory.IsIso η\ns : CategoryTheory.Limits.Cocone (P.F.comp CategoryTheory.yoneda)\nX : Opposite C\na✝ : (P.cocone.extend η).pt.obj X\n⊢ Eq (((P.extend η).isColimit.desc s).app X a✝) ((P.coconeIsColimit.desc s).app X (CategoryTheory.inv (η.app X) a✝))","decl":"/-- If `A` and `B` are isomorphic, then an ind-object presentation of `A` can be extended to an\n    ind-object presentation of `B`. -/\n@[simps!]\nnoncomputable def extend {A B : Cᵒᵖ ⥤ Type v} (P : IndObjectPresentation A) (η : A ⟶ B) [IsIso η] :\n    IndObjectPresentation B :=\n  .ofCocone (P.cocone.extend η) (P.coconeIsColimit.extendIso (by exact η))\n\n"}
{"name":"CategoryTheory.Limits.IndObjectPresentation.extend_I","module":"Mathlib.CategoryTheory.Limits.Indization.IndObject","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nA B : CategoryTheory.Functor (Opposite C) (Type v)\nP : CategoryTheory.Limits.IndObjectPresentation A\nη : Quiver.Hom A B\ninst✝ : CategoryTheory.IsIso η\n⊢ Eq (P.extend η).I P.I","decl":"/-- If `A` and `B` are isomorphic, then an ind-object presentation of `A` can be extended to an\n    ind-object presentation of `B`. -/\n@[simps!]\nnoncomputable def extend {A B : Cᵒᵖ ⥤ Type v} (P : IndObjectPresentation A) (η : A ⟶ B) [IsIso η] :\n    IndObjectPresentation B :=\n  .ofCocone (P.cocone.extend η) (P.coconeIsColimit.extendIso (by exact η))\n\n"}
{"name":"CategoryTheory.Limits.IndObjectPresentation.toCostructuredArrow_map_left","module":"Mathlib.CategoryTheory.Limits.Indization.IndObject","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nP : CategoryTheory.Limits.IndObjectPresentation A\nX✝ Y✝ : P.I\nf : Quiver.Hom X✝ Y✝\n⊢ Eq (P.toCostructuredArrow.map f).left (P.F.map f)","decl":"/-- The canonical comparison functor between the indexing category of the presentation and the\n    comma category `CostructuredArrow yoneda A`. This functor is always final. -/\n@[simps! obj_left obj_right_as obj_hom map_left]\ndef toCostructuredArrow : P.I ⥤ CostructuredArrow yoneda A :=\n  P.cocone.toCostructuredArrow ⋙ CostructuredArrow.pre _ _ _\n\n"}
{"name":"CategoryTheory.Limits.IndObjectPresentation.toCostructuredArrow_obj_right_as","module":"Mathlib.CategoryTheory.Limits.Indization.IndObject","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nP : CategoryTheory.Limits.IndObjectPresentation A\nX : P.I\n⊢ Eq (P.toCostructuredArrow.obj X).right.as PUnit.unit","decl":"/-- The canonical comparison functor between the indexing category of the presentation and the\n    comma category `CostructuredArrow yoneda A`. This functor is always final. -/\n@[simps! obj_left obj_right_as obj_hom map_left]\ndef toCostructuredArrow : P.I ⥤ CostructuredArrow yoneda A :=\n  P.cocone.toCostructuredArrow ⋙ CostructuredArrow.pre _ _ _\n\n"}
{"name":"CategoryTheory.Limits.IndObjectPresentation.toCostructuredArrow_obj_left","module":"Mathlib.CategoryTheory.Limits.Indization.IndObject","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nP : CategoryTheory.Limits.IndObjectPresentation A\nX : P.I\n⊢ Eq (P.toCostructuredArrow.obj X).left (P.F.obj X)","decl":"/-- The canonical comparison functor between the indexing category of the presentation and the\n    comma category `CostructuredArrow yoneda A`. This functor is always final. -/\n@[simps! obj_left obj_right_as obj_hom map_left]\ndef toCostructuredArrow : P.I ⥤ CostructuredArrow yoneda A :=\n  P.cocone.toCostructuredArrow ⋙ CostructuredArrow.pre _ _ _\n\n"}
{"name":"CategoryTheory.Limits.IndObjectPresentation.toCostructuredArrow_obj_hom","module":"Mathlib.CategoryTheory.Limits.Indization.IndObject","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nP : CategoryTheory.Limits.IndObjectPresentation A\nX : P.I\n⊢ Eq (P.toCostructuredArrow.obj X).hom (P.cocone.ι.app X)","decl":"/-- The canonical comparison functor between the indexing category of the presentation and the\n    comma category `CostructuredArrow yoneda A`. This functor is always final. -/\n@[simps! obj_left obj_right_as obj_hom map_left]\ndef toCostructuredArrow : P.I ⥤ CostructuredArrow yoneda A :=\n  P.cocone.toCostructuredArrow ⋙ CostructuredArrow.pre _ _ _\n\n"}
{"name":"CategoryTheory.Limits.IndObjectPresentation.instFinalICostructuredArrowFunctorOppositeTypeYonedaToCostructuredArrow","module":"Mathlib.CategoryTheory.Limits.Indization.IndObject","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nP : CategoryTheory.Limits.IndObjectPresentation A\n⊢ P.toCostructuredArrow.Final","decl":"instance : P.toCostructuredArrow.Final :=\n  Presheaf.final_toCostructuredArrow_comp_pre _ P.coconeIsColimit\n\n"}
{"name":"CategoryTheory.Limits.IndObjectPresentation.yoneda_ι_app","module":"Mathlib.CategoryTheory.Limits.Indization.IndObject","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : C\nx✝ : CategoryTheory.Discrete PUnit.{v + 1}\n⊢ Eq ((CategoryTheory.Limits.IndObjectPresentation.yoneda X).ι.app x✝) (CategoryTheory.CategoryStruct.id (((CategoryTheory.Functor.fromPUnit X).comp CategoryTheory.yoneda).obj x✝))","decl":"/-- Representable presheaves are (trivially) ind-objects. -/\n@[simps]\ndef yoneda (X : C) : IndObjectPresentation (yoneda.obj X) where\n  I := Discrete PUnit.{v + 1}\n  F := Functor.fromPUnit X\n  ι := { app := fun _ => 𝟙 _ }\n  isColimit :=\n    { desc := fun s => s.ι.app ⟨PUnit.unit⟩\n      uniq := fun _ _ h => h ⟨PUnit.unit⟩ }\n\n"}
{"name":"CategoryTheory.Limits.IndObjectPresentation.yoneda_F","module":"Mathlib.CategoryTheory.Limits.Indization.IndObject","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : C\n⊢ Eq (CategoryTheory.Limits.IndObjectPresentation.yoneda X).F (CategoryTheory.Functor.fromPUnit X)","decl":"/-- Representable presheaves are (trivially) ind-objects. -/\n@[simps]\ndef yoneda (X : C) : IndObjectPresentation (yoneda.obj X) where\n  I := Discrete PUnit.{v + 1}\n  F := Functor.fromPUnit X\n  ι := { app := fun _ => 𝟙 _ }\n  isColimit :=\n    { desc := fun s => s.ι.app ⟨PUnit.unit⟩\n      uniq := fun _ _ h => h ⟨PUnit.unit⟩ }\n\n"}
{"name":"CategoryTheory.Limits.IndObjectPresentation.yoneda_isColimit_desc","module":"Mathlib.CategoryTheory.Limits.Indization.IndObject","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : C\ns : CategoryTheory.Limits.Cocone ((CategoryTheory.Functor.fromPUnit X).comp CategoryTheory.yoneda)\n⊢ Eq ((CategoryTheory.Limits.IndObjectPresentation.yoneda X).isColimit.desc s) (s.ι.app { as := PUnit.unit })","decl":"/-- Representable presheaves are (trivially) ind-objects. -/\n@[simps]\ndef yoneda (X : C) : IndObjectPresentation (yoneda.obj X) where\n  I := Discrete PUnit.{v + 1}\n  F := Functor.fromPUnit X\n  ι := { app := fun _ => 𝟙 _ }\n  isColimit :=\n    { desc := fun s => s.ι.app ⟨PUnit.unit⟩\n      uniq := fun _ _ h => h ⟨PUnit.unit⟩ }\n\n"}
{"name":"CategoryTheory.Limits.IndObjectPresentation.yoneda_I","module":"Mathlib.CategoryTheory.Limits.Indization.IndObject","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : C\n⊢ Eq (CategoryTheory.Limits.IndObjectPresentation.yoneda X).I (CategoryTheory.Discrete PUnit.{v + 1})","decl":"/-- Representable presheaves are (trivially) ind-objects. -/\n@[simps]\ndef yoneda (X : C) : IndObjectPresentation (yoneda.obj X) where\n  I := Discrete PUnit.{v + 1}\n  F := Functor.fromPUnit X\n  ι := { app := fun _ => 𝟙 _ }\n  isColimit :=\n    { desc := fun s => s.ι.app ⟨PUnit.unit⟩\n      uniq := fun _ _ h => h ⟨PUnit.unit⟩ }\n\n"}
{"name":"CategoryTheory.Limits.IndObjectPresentation.yoneda_ℐ","module":"Mathlib.CategoryTheory.Limits.Indization.IndObject","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : C\n⊢ Eq (CategoryTheory.Limits.IndObjectPresentation.yoneda X).ℐ (CategoryTheory.discreteCategory PUnit.{v + 1})","decl":"/-- Representable presheaves are (trivially) ind-objects. -/\n@[simps]\ndef yoneda (X : C) : IndObjectPresentation (yoneda.obj X) where\n  I := Discrete PUnit.{v + 1}\n  F := Functor.fromPUnit X\n  ι := { app := fun _ => 𝟙 _ }\n  isColimit :=\n    { desc := fun s => s.ι.app ⟨PUnit.unit⟩\n      uniq := fun _ _ h => h ⟨PUnit.unit⟩ }\n\n"}
{"name":"CategoryTheory.Limits.IsIndObject.nonempty_presentation","module":"Mathlib.CategoryTheory.Limits.Indization.IndObject","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nself : CategoryTheory.Limits.IsIndObject A\n⊢ Nonempty (CategoryTheory.Limits.IndObjectPresentation A)","decl":"/-- A presheaf is called an ind-object if it can be written as a filtered colimit of representable\n    presheaves. -/\nstructure IsIndObject (A : Cᵒᵖ ⥤ Type v) : Prop where\n  mk' :: nonempty_presentation : Nonempty (IndObjectPresentation A)\n\n"}
{"name":"CategoryTheory.Limits.IsIndObject.mk","module":"Mathlib.CategoryTheory.Limits.Indization.IndObject","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nP : CategoryTheory.Limits.IndObjectPresentation A\n⊢ CategoryTheory.Limits.IsIndObject A","decl":"theorem IsIndObject.mk {A : Cᵒᵖ ⥤ Type v} (P : IndObjectPresentation A) : IsIndObject A :=\n  ⟨⟨P⟩⟩\n\n"}
{"name":"CategoryTheory.Limits.isIndObject_yoneda","module":"Mathlib.CategoryTheory.Limits.Indization.IndObject","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : C\n⊢ CategoryTheory.Limits.IsIndObject (CategoryTheory.yoneda.obj X)","decl":"/-- Representable presheaves are (trivially) ind-objects. -/\ntheorem isIndObject_yoneda (X : C) : IsIndObject (yoneda.obj X) :=\n  .mk <| IndObjectPresentation.yoneda X\n\n"}
{"name":"CategoryTheory.Limits.IsIndObject.map","module":"Mathlib.CategoryTheory.Limits.Indization.IndObject","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nA B : CategoryTheory.Functor (Opposite C) (Type v)\nη : Quiver.Hom A B\ninst✝ : CategoryTheory.IsIso η\na✝ : CategoryTheory.Limits.IsIndObject A\n⊢ CategoryTheory.Limits.IsIndObject B","decl":"theorem map {A B : Cᵒᵖ ⥤ Type v} (η : A ⟶ B) [IsIso η] : IsIndObject A → IsIndObject B\n  | ⟨⟨P⟩⟩ => ⟨⟨P.extend η⟩⟩\n\n"}
{"name":"CategoryTheory.Limits.IsIndObject.iff_of_iso","module":"Mathlib.CategoryTheory.Limits.Indization.IndObject","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nA B : CategoryTheory.Functor (Opposite C) (Type v)\nη : Quiver.Hom A B\ninst✝ : CategoryTheory.IsIso η\n⊢ Iff (CategoryTheory.Limits.IsIndObject A) (CategoryTheory.Limits.IsIndObject B)","decl":"theorem iff_of_iso {A B : Cᵒᵖ ⥤ Type v} (η : A ⟶ B) [IsIso η] : IsIndObject A ↔ IsIndObject B :=\n  ⟨.map η, .map (inv η)⟩\n\n"}
{"name":"CategoryTheory.Limits.IsIndObject.instClosedUnderIsomorphismsFunctorOppositeType","module":"Mathlib.CategoryTheory.Limits.Indization.IndObject","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\n⊢ CategoryTheory.ClosedUnderIsomorphisms CategoryTheory.Limits.IsIndObject","decl":"instance : ClosedUnderIsomorphisms (IsIndObject (C := C)) where\n  of_iso i h := h.map i.hom\n\n"}
{"name":"CategoryTheory.Limits.IsIndObject.isFiltered","module":"Mathlib.CategoryTheory.Limits.Indization.IndObject","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nh : CategoryTheory.Limits.IsIndObject A\n⊢ CategoryTheory.IsFiltered (CategoryTheory.CostructuredArrow CategoryTheory.yoneda A)","decl":"theorem isFiltered (h : IsIndObject A) : IsFiltered (CostructuredArrow yoneda A) :=\n  IsFiltered.of_final h.presentation.toCostructuredArrow\n\n"}
{"name":"CategoryTheory.Limits.IsIndObject.finallySmall","module":"Mathlib.CategoryTheory.Limits.Indization.IndObject","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\nh : CategoryTheory.Limits.IsIndObject A\n⊢ CategoryTheory.FinallySmall (CategoryTheory.CostructuredArrow CategoryTheory.yoneda A)","decl":"theorem finallySmall (h : IsIndObject A) : FinallySmall.{v} (CostructuredArrow yoneda A) :=\n  FinallySmall.mk' h.presentation.toCostructuredArrow\n\n"}
{"name":"CategoryTheory.Limits.isIndObject_of_isFiltered_of_finallySmall","module":"Mathlib.CategoryTheory.Limits.Indization.IndObject","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\ninst✝¹ : CategoryTheory.IsFiltered (CategoryTheory.CostructuredArrow CategoryTheory.yoneda A)\ninst✝ : CategoryTheory.FinallySmall (CategoryTheory.CostructuredArrow CategoryTheory.yoneda A)\n⊢ CategoryTheory.Limits.IsIndObject A","decl":"theorem isIndObject_of_isFiltered_of_finallySmall (A : Cᵒᵖ ⥤ Type v)\n    [IsFiltered (CostructuredArrow yoneda A)] [FinallySmall.{v} (CostructuredArrow yoneda A)] :\n    IsIndObject A := by\n  have h₁ : (factoring (fromFinalModel (CostructuredArrow yoneda A)) ⋙\n      inclusion (fromFinalModel (CostructuredArrow yoneda A))).Final := Functor.final_of_natIso\n    (factoringCompInclusion (fromFinalModel <| CostructuredArrow yoneda A)).symm\n  have h₂ : Functor.Final (inclusion (fromFinalModel (CostructuredArrow yoneda A))) :=\n    Functor.final_of_comp_full_faithful' (factoring _) (inclusion _)\n  let c := (Presheaf.tautologicalCocone A).whisker\n    (inclusion (fromFinalModel (CostructuredArrow yoneda A)))\n  let hc : IsColimit c := (Functor.Final.isColimitWhiskerEquiv _ _).symm\n    (Presheaf.isColimitTautologicalCocone A)\n  have hq : Nonempty (FinalModel (CostructuredArrow yoneda A)) := Nonempty.map\n    (Functor.Final.lift (fromFinalModel (CostructuredArrow yoneda A))) IsFiltered.nonempty\n  exact ⟨_, inclusion (fromFinalModel _) ⋙ CostructuredArrow.proj yoneda A, c.ι, hc⟩\n\n"}
{"name":"CategoryTheory.Limits.isIndObject_iff","module":"Mathlib.CategoryTheory.Limits.Indization.IndObject","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nA : CategoryTheory.Functor (Opposite C) (Type v)\n⊢ Iff (CategoryTheory.Limits.IsIndObject A) (And (CategoryTheory.IsFiltered (CategoryTheory.CostructuredArrow CategoryTheory.yoneda A)) (CategoryTheory.FinallySmall (CategoryTheory.CostructuredArrow CategoryTheory.yoneda A)))","decl":"/-- The recognition theorem for ind-objects: `A : Cᵒᵖ ⥤ Type v` is an ind-object if and only if\n    `CostructuredArrow yoneda A` is filtered and finally `v`-small.\n\n    Theorem 6.1.5 of [Kashiwara2006] -/\ntheorem isIndObject_iff (A : Cᵒᵖ ⥤ Type v) : IsIndObject A ↔\n    (IsFiltered (CostructuredArrow yoneda A) ∧ FinallySmall.{v} (CostructuredArrow yoneda A)) :=\n  ⟨fun h => ⟨h.isFiltered, h.finallySmall⟩,\n   fun ⟨_, _⟩ => isIndObject_of_isFiltered_of_finallySmall A⟩\n\n"}
{"name":"CategoryTheory.Limits.isIndObject_limit_comp_yoneda","module":"Mathlib.CategoryTheory.Limits.Indization.IndObject","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nJ : Type u'\ninst✝¹ : CategoryTheory.Category.{v', u'} J\nF : CategoryTheory.Functor J C\ninst✝ : CategoryTheory.Limits.HasLimit F\n⊢ CategoryTheory.Limits.IsIndObject (CategoryTheory.Limits.limit (F.comp CategoryTheory.yoneda))","decl":"/-- If a limit already exists in `C`, then the limit of the image of the diagram under the Yoneda\nembedding is an ind-object. -/\ntheorem isIndObject_limit_comp_yoneda {J : Type u'} [Category.{v'} J] (F : J ⥤ C) [HasLimit F] :\n    IsIndObject (limit (F ⋙ yoneda)) :=\n  IsIndObject.map (preservesLimitIso yoneda F).hom (isIndObject_yoneda (limit F))\n\n"}
