{"name":"NumberField.canonicalEmbedding_injective","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.Basic","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\n‚ä¢ Function.Injective ‚áë(NumberField.canonicalEmbedding K)","decl":"theorem _root_.NumberField.canonicalEmbedding_injective [NumberField K] :\n    Function.Injective (NumberField.canonicalEmbedding K) := RingHom.injective _\n\n"}
{"name":"NumberField.canonicalEmbedding.apply_at","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.Basic","initialProofState":"K : Type u_1\ninst‚úù : Field K\nœÜ : RingHom K Complex\nx : K\n‚ä¢ Eq ((NumberField.canonicalEmbedding K) x œÜ) (œÜ x)","decl":"@[simp]\ntheorem apply_at (œÜ : K ‚Üí+* ‚ÑÇ) (x : K) : (NumberField.canonicalEmbedding K x) œÜ = œÜ x := rfl\n\n"}
{"name":"NumberField.canonicalEmbedding.conj_apply","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.Basic","initialProofState":"K : Type u_1\ninst‚úù : Field K\nx : RingHom K Complex ‚Üí Complex\nœÜ : RingHom K Complex\nhx : Membership.mem (Submodule.span Real (Set.range ‚áë(NumberField.canonicalEmbedding K))) x\n‚ä¢ Eq ((starRingEnd Complex) (x œÜ)) (x (NumberField.ComplexEmbedding.conjugate œÜ))","decl":"/-- The image of `canonicalEmbedding` lives in the `‚Ñù`-submodule of the `x ‚àà ((K ‚Üí+* ‚ÑÇ) ‚Üí ‚ÑÇ)` such\nthat `conj x_œÜ = x_(conj œÜ)` for all `‚àÄ œÜ : K ‚Üí+* ‚ÑÇ`. -/\ntheorem conj_apply {x : ((K ‚Üí+* ‚ÑÇ) ‚Üí ‚ÑÇ)} (œÜ : K ‚Üí+* ‚ÑÇ)\n    (hx : x ‚àà Submodule.span ‚Ñù (Set.range (canonicalEmbedding K))) :\n    conj (x œÜ) = x (ComplexEmbedding.conjugate œÜ) := by\n  refine Submodule.span_induction ?_ ?_ (fun _ _ _ _ hx hy => ?_) (fun a _ _ hx => ?_) hx\n  ¬∑ rintro _ ‚ü®x, rfl‚ü©\n    rw [apply_at, apply_at, ComplexEmbedding.conjugate_coe_eq]\n  ¬∑ rw [Pi.zero_apply, Pi.zero_apply, map_zero]\n  ¬∑ rw [Pi.add_apply, Pi.add_apply, map_add, hx, hy]\n  ¬∑ rw [Pi.smul_apply, Complex.real_smul, map_mul, Complex.conj_ofReal]\n    exact congrArg ((a : ‚ÑÇ) * ¬∑) hx\n\n"}
{"name":"NumberField.canonicalEmbedding.nnnorm_eq","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.Basic","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\nx : K\n‚ä¢ Eq (NNNorm.nnnorm ((NumberField.canonicalEmbedding K) x)) (Finset.univ.sup fun œÜ => NNNorm.nnnorm (œÜ x))","decl":"theorem nnnorm_eq [NumberField K] (x : K) :\n    ‚ÄñcanonicalEmbedding K x‚Äñ‚Çä = Finset.univ.sup (fun œÜ : K ‚Üí+* ‚ÑÇ => ‚ÄñœÜ x‚Äñ‚Çä) := by\n  simp_rw [Pi.nnnorm_def, apply_at]\n\n"}
{"name":"NumberField.canonicalEmbedding.norm_le_iff","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.Basic","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\nx : K\nr : Real\n‚ä¢ Iff (LE.le (Norm.norm ((NumberField.canonicalEmbedding K) x)) r) (‚àÄ (œÜ : RingHom K Complex), LE.le (Norm.norm (œÜ x)) r)","decl":"theorem norm_le_iff [NumberField K] (x : K) (r : ‚Ñù) :\n    ‚ÄñcanonicalEmbedding K x‚Äñ ‚â§ r ‚Üî ‚àÄ œÜ : K ‚Üí+* ‚ÑÇ, ‚ÄñœÜ x‚Äñ ‚â§ r := by\n  obtain hr | hr := lt_or_le r 0\n  ¬∑ obtain ‚ü®œÜ‚ü© := (inferInstance : Nonempty (K ‚Üí+* ‚ÑÇ))\n    refine iff_of_false ?_ ?_\n    ¬∑ exact (hr.trans_le (norm_nonneg _)).not_le\n    ¬∑ exact fun h => hr.not_le (le_trans (norm_nonneg _) (h œÜ))\n  ¬∑ lift r to NNReal using hr\n    simp_rw [‚Üê coe_nnnorm, nnnorm_eq, NNReal.coe_le_coe, Finset.sup_le_iff, Finset.mem_univ,\n      forall_true_left]\n\n"}
{"name":"NumberField.canonicalEmbedding.integerLattice.inter_ball_finite","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.Basic","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\nr : Real\n‚ä¢ (Inter.inter (‚Üë(NumberField.canonicalEmbedding.integerLattice K)) (Metric.closedBall 0 r)).Finite","decl":"theorem integerLattice.inter_ball_finite [NumberField K] (r : ‚Ñù) :\n    ((integerLattice K : Set ((K ‚Üí+* ‚ÑÇ) ‚Üí ‚ÑÇ)) ‚à© Metric.closedBall 0 r).Finite := by\n  obtain hr | _ := lt_or_le r 0\n  ¬∑ simp [Metric.closedBall_eq_empty.2 hr]\n  ¬∑ have heq : ‚àÄ x, canonicalEmbedding K x ‚àà Metric.closedBall 0 r ‚Üî\n        ‚àÄ œÜ : K ‚Üí+* ‚ÑÇ, ‚ÄñœÜ x‚Äñ ‚â§ r := by\n      intro x; rw [‚Üê norm_le_iff, mem_closedBall_zero_iff]\n    convert (Embeddings.finite_of_norm_le K ‚ÑÇ r).image (canonicalEmbedding K)\n    ext; constructor\n    ¬∑ rintro ‚ü®‚ü®_, ‚ü®x, rfl‚ü©, rfl‚ü©, hx‚ü©\n      exact ‚ü®x, ‚ü®SetLike.coe_mem x, fun œÜ => (heq _).mp hx œÜ‚ü©, rfl‚ü©\n    ¬∑ rintro ‚ü®x, ‚ü®hx1, hx2‚ü©, rfl‚ü©\n      exact ‚ü®‚ü®x, ‚ü®‚ü®x, hx1‚ü©, rfl‚ü©, rfl‚ü©, (heq x).mpr hx2‚ü©\n\n"}
{"name":"NumberField.canonicalEmbedding.latticeBasis_apply","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.Basic","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\ni : Module.Free.ChooseBasisIndex Int (NumberField.RingOfIntegers K)\n‚ä¢ Eq ((NumberField.canonicalEmbedding.latticeBasis K) i) ((NumberField.canonicalEmbedding K) ((NumberField.integralBasis K) i))","decl":"@[simp]\ntheorem latticeBasis_apply [NumberField K] (i : Free.ChooseBasisIndex ‚Ñ§ (ùìû K)) :\n    latticeBasis K i = (canonicalEmbedding K) (integralBasis K i) := by\n  simp only [latticeBasis, integralBasis_apply, coe_basisOfLinearIndependentOfCardEqFinrank,\n    Function.comp_apply, Equiv.apply_symm_apply]\n\n"}
{"name":"NumberField.canonicalEmbedding.mem_span_latticeBasis","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.Basic","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\nx : RingHom K Complex ‚Üí Complex\n‚ä¢ Iff (Membership.mem (Submodule.span Int (Set.range ‚áë(NumberField.canonicalEmbedding.latticeBasis K))) x) (Membership.mem ((NumberField.canonicalEmbedding K).comp (algebraMap (NumberField.RingOfIntegers K) K)).range x)","decl":"theorem mem_span_latticeBasis [NumberField K] {x : (K ‚Üí+* ‚ÑÇ) ‚Üí ‚ÑÇ} :\n    x ‚àà Submodule.span ‚Ñ§ (Set.range (latticeBasis K)) ‚Üî\n      x ‚àà ((canonicalEmbedding K).comp (algebraMap (ùìû K) K)).range := by\n  rw [show Set.range (latticeBasis K) =\n      (canonicalEmbedding K).toIntAlgHom.toLinearMap '' (Set.range (integralBasis K)) by\n    rw [‚Üê Set.range_comp]; exact congrArg Set.range (funext (fun i => latticeBasis_apply K i))]\n  rw [‚Üê Submodule.map_span, ‚Üê SetLike.mem_coe, Submodule.map_coe]\n  rw [‚Üê RingHom.map_range, Subring.mem_map, Set.mem_image]\n  simp only [SetLike.mem_coe, mem_span_integralBasis K]\n  rfl\n\n"}
{"name":"NumberField.canonicalEmbedding.mem_rat_span_latticeBasis","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.Basic","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\nx : K\n‚ä¢ Membership.mem (Submodule.span Rat (Set.range ‚áë(NumberField.canonicalEmbedding.latticeBasis K))) ((NumberField.canonicalEmbedding K) x)","decl":"theorem mem_rat_span_latticeBasis [NumberField K] (x : K) :\n    canonicalEmbedding K x ‚àà Submodule.span ‚Ñö (Set.range (latticeBasis K)) := by\n  rw [‚Üê Basis.sum_repr (integralBasis K) x, map_sum]\n  simp_rw [map_rat_smul]\n  refine Submodule.sum_smul_mem _ _ (fun i _ ‚Ü¶ Submodule.subset_span ?_)\n  rw [‚Üê latticeBasis_apply]\n  exact Set.mem_range_self i\n\n"}
{"name":"NumberField.canonicalEmbedding.integralBasis_repr_apply","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.Basic","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\nx : K\ni : Module.Free.ChooseBasisIndex Int (NumberField.RingOfIntegers K)\n‚ä¢ Eq (((NumberField.canonicalEmbedding.latticeBasis K).repr ((NumberField.canonicalEmbedding K) x)) i) ‚Üë(((NumberField.integralBasis K).repr x) i)","decl":"theorem integralBasis_repr_apply [NumberField K] (x : K) (i : Free.ChooseBasisIndex ‚Ñ§ (ùìû K)) :\n    (latticeBasis K).repr (canonicalEmbedding K x) i = (integralBasis K).repr x i := by\n  rw [‚Üê Basis.restrictScalars_repr_apply ‚Ñö _ ‚ü®_, mem_rat_span_latticeBasis K x‚ü©, eq_ratCast,\n    Rat.cast_inj]\n  let f := (canonicalEmbedding K).toRatAlgHom.toLinearMap.codRestrict _\n    (fun x ‚Ü¶ mem_rat_span_latticeBasis K x)\n  suffices ((latticeBasis K).restrictScalars ‚Ñö).repr.toLinearMap ‚àò‚Çó f =\n    (integralBasis K).repr.toLinearMap from DFunLike.congr_fun (LinearMap.congr_fun this x) i\n  refine Basis.ext (integralBasis K) (fun i ‚Ü¶ ?_)\n  have : f (integralBasis K i) = ((latticeBasis K).restrictScalars ‚Ñö) i := by\n    apply Subtype.val_injective\n    rw [LinearMap.codRestrict_apply, AlgHom.toLinearMap_apply, Basis.restrictScalars_apply,\n      latticeBasis_apply]\n    rfl\n  simp_rw [LinearMap.coe_comp, LinearEquiv.coe_coe, Function.comp_apply, this, Basis.repr_self]\n\n"}
{"name":"NumberField.mixedEmbedding.mixedEmbedding_apply_ofIsReal","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.Basic","initialProofState":"K : Type u_1\ninst‚úù : Field K\nx : K\nw : Subtype fun w => w.IsReal\n‚ä¢ Eq (((NumberField.mixedEmbedding K) x).1 w) ((NumberField.InfinitePlace.embedding_of_isReal ‚ãØ) x)","decl":"@[simp]\ntheorem mixedEmbedding_apply_ofIsReal (x : K) (w : {w // IsReal w}) :\n    (mixedEmbedding K x).1 w = embedding_of_isReal w.prop x := by\n  simp_rw [mixedEmbedding, RingHom.prod_apply, Pi.ringHom_apply]\n\n"}
{"name":"NumberField.mixedEmbedding.mixedEmbedding_apply_ofIsComplex","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.Basic","initialProofState":"K : Type u_1\ninst‚úù : Field K\nx : K\nw : Subtype fun w => w.IsComplex\n‚ä¢ Eq (((NumberField.mixedEmbedding K) x).2 w) ((‚Üëw).embedding x)","decl":"@[simp]\ntheorem mixedEmbedding_apply_ofIsComplex (x : K) (w : {w // IsComplex w}) :\n    (mixedEmbedding K x).2 w = w.val.embedding x := by\n  simp_rw [mixedEmbedding, RingHom.prod_apply, Pi.ringHom_apply]\n\n"}
{"name":"NumberField.mixedEmbedding.instNontrivialMixedSpace","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.Basic","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\n‚ä¢ Nontrivial (NumberField.mixedEmbedding.mixedSpace K)","decl":"instance [NumberField K] : Nontrivial (mixedSpace K) := by\n  obtain ‚ü®w‚ü© := (inferInstance : Nonempty (InfinitePlace K))\n  obtain hw | hw := w.isReal_or_isComplex\n  ¬∑ have : Nonempty {w : InfinitePlace K // IsReal w} := ‚ü®‚ü®w, hw‚ü©‚ü©\n    exact nontrivial_prod_left\n  ¬∑ have : Nonempty {w : InfinitePlace K // IsComplex w} := ‚ü®‚ü®w, hw‚ü©‚ü©\n    exact nontrivial_prod_right\n\n"}
{"name":"NumberField.mixedEmbedding.finrank","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.Basic","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\n‚ä¢ Eq (Module.finrank Real (NumberField.mixedEmbedding.mixedSpace K)) (Module.finrank Rat K)","decl":"protected theorem finrank [NumberField K] : finrank ‚Ñù (mixedSpace K) = finrank ‚Ñö K := by\n  classical\n  rw [finrank_prod, finrank_pi, finrank_pi_fintype, Complex.finrank_real_complex, sum_const,\n    card_univ, ‚Üê nrRealPlaces, ‚Üê nrComplexPlaces, ‚Üê card_real_embeddings, Algebra.id.smul_eq_mul,\n    mul_comm, ‚Üê card_complex_embeddings, ‚Üê NumberField.Embeddings.card K ‚ÑÇ,\n    Fintype.card_subtype_compl, Nat.add_sub_of_le (Fintype.card_subtype_le _)]\n\n"}
{"name":"NumberField.mixedEmbedding_injective","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.Basic","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\n‚ä¢ Function.Injective ‚áë(NumberField.mixedEmbedding K)","decl":"theorem _root_.NumberField.mixedEmbedding_injective [NumberField K] :\n    Function.Injective (NumberField.mixedEmbedding K) := by\n  exact RingHom.injective _\n\n"}
{"name":"NumberField.mixedEmbedding.instIsAddHaarMeasureMixedSpaceVolume","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.Basic","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\n‚ä¢ MeasureTheory.MeasureSpace.volume.IsAddHaarMeasure","decl":"open Classical in\ninstance : IsAddHaarMeasure (volume : Measure (mixedSpace K)) :=\n  prod.instIsAddHaarMeasure volume volume\n\n"}
{"name":"NumberField.mixedEmbedding.instNoAtomsMixedSpaceVolume","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.Basic","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\n‚ä¢ MeasureTheory.NoAtoms MeasureTheory.MeasureSpace.volume","decl":"open Classical in\ninstance : NoAtoms (volume : Measure (mixedSpace K)) := by\n  obtain ‚ü®w‚ü© := (inferInstance : Nonempty (InfinitePlace K))\n  by_cases hw : IsReal w\n  ¬∑ have : NoAtoms (volume : Measure ({w : InfinitePlace K // IsReal w} ‚Üí ‚Ñù)) := pi_noAtoms ‚ü®w, hw‚ü©\n    exact prod.instNoAtoms_fst\n  ¬∑ have : NoAtoms (volume : Measure ({w : InfinitePlace K // IsComplex w} ‚Üí ‚ÑÇ)) :=\n      pi_noAtoms ‚ü®w, not_isReal_iff_isComplex.mp hw‚ü©\n    exact prod.instNoAtoms_snd\n\n"}
{"name":"NumberField.mixedEmbedding.volume_eq_zero","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.Basic","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\nw : Subtype fun w => w.IsReal\n‚ä¢ Eq (MeasureTheory.MeasureSpace.volume (setOf fun x => Eq (x.1 w) 0)) 0","decl":"variable {K} in\nopen Classical in\n/-- The set of points in the mixedSpace that are equal to `0` at a fixed (real) place has\nvolume zero. -/\ntheorem volume_eq_zero (w : {w // IsReal w}) :\n    volume ({x : mixedSpace K | x.1 w = 0}) = 0 := by\n  let A : AffineSubspace ‚Ñù (mixedSpace K) :=\n    Submodule.toAffineSubspace (Submodule.mk ‚ü®‚ü®{x | x.1 w = 0}, by aesop‚ü©, rfl‚ü© (by aesop))\n  convert Measure.addHaar_affineSubspace volume A fun h ‚Ü¶ ?_\n  simpa [A] using (h ‚ñ∏ Set.mem_univ _ : 1 ‚àà A)\n\n"}
{"name":"NumberField.mixedEmbedding.commMap_apply_of_isReal","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.Basic","initialProofState":"K : Type u_1\ninst‚úù : Field K\nx : RingHom K Complex ‚Üí Complex\nw : NumberField.InfinitePlace K\nhw : w.IsReal\n‚ä¢ Eq (((NumberField.mixedEmbedding.commMap K) x).1 ‚ü®w, hw‚ü©) (x w.embedding).re","decl":"theorem commMap_apply_of_isReal (x : (K ‚Üí+* ‚ÑÇ) ‚Üí ‚ÑÇ) {w : InfinitePlace K} (hw : IsReal w) :\n    (commMap K x).1 ‚ü®w, hw‚ü© = (x w.embedding).re := rfl\n\n"}
{"name":"NumberField.mixedEmbedding.commMap_apply_of_isComplex","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.Basic","initialProofState":"K : Type u_1\ninst‚úù : Field K\nx : RingHom K Complex ‚Üí Complex\nw : NumberField.InfinitePlace K\nhw : w.IsComplex\n‚ä¢ Eq (((NumberField.mixedEmbedding.commMap K) x).2 ‚ü®w, hw‚ü©) (x w.embedding)","decl":"theorem commMap_apply_of_isComplex (x : (K ‚Üí+* ‚ÑÇ) ‚Üí ‚ÑÇ) {w : InfinitePlace K} (hw : IsComplex w) :\n    (commMap K x).2 ‚ü®w, hw‚ü© = x w.embedding := rfl\n\n"}
{"name":"NumberField.mixedEmbedding.commMap_canonical_eq_mixed","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.Basic","initialProofState":"K : Type u_1\ninst‚úù : Field K\nx : K\n‚ä¢ Eq ((NumberField.mixedEmbedding.commMap K) ((NumberField.canonicalEmbedding K) x)) ((NumberField.mixedEmbedding K) x)","decl":"@[simp]\ntheorem commMap_canonical_eq_mixed (x : K) :\n    commMap K (canonicalEmbedding K x) = mixedEmbedding K x := by\n  simp only [canonicalEmbedding, commMap, LinearMap.coe_mk, AddHom.coe_mk, Pi.ringHom_apply,\n    mixedEmbedding, RingHom.prod_apply, Prod.mk.injEq]\n  exact ‚ü®rfl, rfl‚ü©\n\n"}
{"name":"NumberField.mixedEmbedding.disjoint_span_commMap_ker","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.Basic","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\n‚ä¢ Disjoint (Submodule.span Real (Set.range ‚áë(NumberField.canonicalEmbedding.latticeBasis K))) (LinearMap.ker (NumberField.mixedEmbedding.commMap K))","decl":"/-- This is a technical result to ensure that the image of the `‚ÑÇ`-basis of `‚ÑÇ^n` defined in\n`canonicalEmbedding.latticeBasis` is a `‚Ñù`-basis of the mixed space `‚Ñù^r‚ÇÅ √ó ‚ÑÇ^r‚ÇÇ`,\nsee `mixedEmbedding.latticeBasis`. -/\ntheorem disjoint_span_commMap_ker [NumberField K] :\n    Disjoint (Submodule.span ‚Ñù (Set.range (canonicalEmbedding.latticeBasis K)))\n      (LinearMap.ker (commMap K)) := by\n  refine LinearMap.disjoint_ker.mpr (fun x h_mem h_zero => ?_)\n  replace h_mem : x ‚àà Submodule.span ‚Ñù (Set.range (canonicalEmbedding K)) := by\n    refine (Submodule.span_mono ?_) h_mem\n    rintro _ ‚ü®i, rfl‚ü©\n    exact ‚ü®integralBasis K i, (canonicalEmbedding.latticeBasis_apply K i).symm‚ü©\n  ext1 œÜ\n  rw [Pi.zero_apply]\n  by_cases hœÜ : ComplexEmbedding.IsReal œÜ\n  ¬∑ apply Complex.ext\n    ¬∑ rw [‚Üê embedding_mk_eq_of_isReal hœÜ, ‚Üê commMap_apply_of_isReal K x ‚ü®œÜ, hœÜ, rfl‚ü©]\n      exact congrFun (congrArg (fun x => x.1) h_zero) ‚ü®InfinitePlace.mk œÜ, _‚ü©\n    ¬∑ rw [Complex.zero_im, ‚Üê Complex.conj_eq_iff_im, canonicalEmbedding.conj_apply _ h_mem,\n        ComplexEmbedding.isReal_iff.mp hœÜ]\n  ¬∑ have := congrFun (congrArg (fun x => x.2) h_zero) ‚ü®InfinitePlace.mk œÜ, ‚ü®œÜ, hœÜ, rfl‚ü©‚ü©\n    cases embedding_mk_eq œÜ with\n    | inl h => rwa [‚Üê h, ‚Üê commMap_apply_of_isComplex K x ‚ü®œÜ, hœÜ, rfl‚ü©]\n    | inr h =>\n        apply RingHom.injective (starRingEnd ‚ÑÇ)\n        rwa [canonicalEmbedding.conj_apply _ h_mem, ‚Üê h, map_zero,\n          ‚Üê commMap_apply_of_isComplex K x ‚ü®œÜ, hœÜ, rfl‚ü©]\n\n"}
{"name":"NumberField.mixedEmbedding.normAtPlace_nonneg","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.Basic","initialProofState":"K : Type u_1\ninst‚úù : Field K\nw : NumberField.InfinitePlace K\nx : NumberField.mixedEmbedding.mixedSpace K\n‚ä¢ LE.le 0 ((NumberField.mixedEmbedding.normAtPlace w) x)","decl":"theorem normAtPlace_nonneg (w : InfinitePlace K) (x : mixedSpace K) :\n    0 ‚â§ normAtPlace w x := by\n  rw [normAtPlace, MonoidWithZeroHom.coe_mk, ZeroHom.coe_mk]\n  split_ifs <;> exact norm_nonneg _\n\n"}
{"name":"NumberField.mixedEmbedding.normAtPlace_neg","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.Basic","initialProofState":"K : Type u_1\ninst‚úù : Field K\nw : NumberField.InfinitePlace K\nx : NumberField.mixedEmbedding.mixedSpace K\n‚ä¢ Eq ((NumberField.mixedEmbedding.normAtPlace w) (Neg.neg x)) ((NumberField.mixedEmbedding.normAtPlace w) x)","decl":"theorem normAtPlace_neg (w : InfinitePlace K) (x : mixedSpace K)  :\n    normAtPlace w (- x) = normAtPlace w x := by\n  rw [normAtPlace, MonoidWithZeroHom.coe_mk, ZeroHom.coe_mk]\n  split_ifs <;> simp\n\n"}
{"name":"NumberField.mixedEmbedding.normAtPlace_add_le","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.Basic","initialProofState":"K : Type u_1\ninst‚úù : Field K\nw : NumberField.InfinitePlace K\nx y : NumberField.mixedEmbedding.mixedSpace K\n‚ä¢ LE.le ((NumberField.mixedEmbedding.normAtPlace w) (HAdd.hAdd x y)) (HAdd.hAdd ((NumberField.mixedEmbedding.normAtPlace w) x) ((NumberField.mixedEmbedding.normAtPlace w) y))","decl":"theorem normAtPlace_add_le (w : InfinitePlace K) (x y : mixedSpace K) :\n    normAtPlace w (x + y) ‚â§ normAtPlace w x + normAtPlace w y := by\n  rw [normAtPlace, MonoidWithZeroHom.coe_mk, ZeroHom.coe_mk]\n  split_ifs <;> exact norm_add_le _ _\n\n"}
{"name":"NumberField.mixedEmbedding.normAtPlace_smul","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.Basic","initialProofState":"K : Type u_1\ninst‚úù : Field K\nw : NumberField.InfinitePlace K\nx : NumberField.mixedEmbedding.mixedSpace K\nc : Real\n‚ä¢ Eq ((NumberField.mixedEmbedding.normAtPlace w) (HSMul.hSMul c x)) (HMul.hMul (abs c) ((NumberField.mixedEmbedding.normAtPlace w) x))","decl":"theorem normAtPlace_smul (w : InfinitePlace K) (x : mixedSpace K) (c : ‚Ñù) :\n    normAtPlace w (c ‚Ä¢ x) = |c| * normAtPlace w x := by\n  rw [normAtPlace, MonoidWithZeroHom.coe_mk, ZeroHom.coe_mk]\n  split_ifs\n  ¬∑ rw [Prod.smul_fst, Pi.smul_apply, norm_smul, Real.norm_eq_abs]\n  ¬∑ rw [Prod.smul_snd, Pi.smul_apply, norm_smul, Real.norm_eq_abs, Complex.norm_eq_abs]\n\n"}
{"name":"NumberField.mixedEmbedding.normAtPlace_real","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.Basic","initialProofState":"K : Type u_1\ninst‚úù : Field K\nw : NumberField.InfinitePlace K\nc : Real\n‚ä¢ Eq ((NumberField.mixedEmbedding.normAtPlace w) { fst := fun x => c, snd := fun x => ‚Üëc }) (abs c)","decl":"theorem normAtPlace_real (w : InfinitePlace K) (c : ‚Ñù) :\n    normAtPlace w ((fun _ ‚Ü¶ c, fun _ ‚Ü¶ c) : (mixedSpace K)) = |c| := by\n  rw [show ((fun _ ‚Ü¶ c, fun _ ‚Ü¶ c) : (mixedSpace K)) = c ‚Ä¢ 1 by ext <;> simp, normAtPlace_smul,\n    map_one, mul_one]\n\n"}
{"name":"NumberField.mixedEmbedding.normAtPlace_apply_isReal","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.Basic","initialProofState":"K : Type u_1\ninst‚úù : Field K\nw : NumberField.InfinitePlace K\nhw : w.IsReal\nx : NumberField.mixedEmbedding.mixedSpace K\n‚ä¢ Eq ((NumberField.mixedEmbedding.normAtPlace w) x) (Norm.norm (x.1 ‚ü®w, hw‚ü©))","decl":"theorem normAtPlace_apply_isReal {w : InfinitePlace K} (hw : IsReal w) (x : mixedSpace K) :\n    normAtPlace w x = ‚Äñx.1 ‚ü®w, hw‚ü©‚Äñ := by\n  rw [normAtPlace, MonoidWithZeroHom.coe_mk, ZeroHom.coe_mk, dif_pos]\n\n"}
{"name":"NumberField.mixedEmbedding.normAtPlace_apply_isComplex","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.Basic","initialProofState":"K : Type u_1\ninst‚úù : Field K\nw : NumberField.InfinitePlace K\nhw : w.IsComplex\nx : NumberField.mixedEmbedding.mixedSpace K\n‚ä¢ Eq ((NumberField.mixedEmbedding.normAtPlace w) x) (Norm.norm (x.2 ‚ü®w, hw‚ü©))","decl":"theorem normAtPlace_apply_isComplex {w : InfinitePlace K} (hw : IsComplex w) (x : mixedSpace K) :\n    normAtPlace w x = ‚Äñx.2 ‚ü®w, hw‚ü©‚Äñ := by\n  rw [normAtPlace, MonoidWithZeroHom.coe_mk, ZeroHom.coe_mk,\n    dif_neg (not_isReal_iff_isComplex.mpr hw)]\n\n"}
{"name":"NumberField.mixedEmbedding.normAtPlace_apply","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.Basic","initialProofState":"K : Type u_1\ninst‚úù : Field K\nw : NumberField.InfinitePlace K\nx : K\n‚ä¢ Eq ((NumberField.mixedEmbedding.normAtPlace w) ((NumberField.mixedEmbedding K) x)) (w x)","decl":"@[simp]\ntheorem normAtPlace_apply (w : InfinitePlace K) (x : K) :\n    normAtPlace w (mixedEmbedding K x) = w x := by\n  simp_rw [normAtPlace, MonoidWithZeroHom.coe_mk, ZeroHom.coe_mk, mixedEmbedding,\n    RingHom.prod_apply, Pi.ringHom_apply, norm_embedding_of_isReal, norm_embedding_eq, dite_eq_ite,\n    ite_id]\n\n"}
{"name":"NumberField.mixedEmbedding.forall_normAtPlace_eq_zero_iff","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.Basic","initialProofState":"K : Type u_1\ninst‚úù : Field K\nx : NumberField.mixedEmbedding.mixedSpace K\n‚ä¢ Iff (‚àÄ (w : NumberField.InfinitePlace K), Eq ((NumberField.mixedEmbedding.normAtPlace w) x) 0) (Eq x 0)","decl":"theorem forall_normAtPlace_eq_zero_iff {x : mixedSpace K} :\n    (‚àÄ w, normAtPlace w x = 0) ‚Üî x = 0 := by\n  refine ‚ü®fun h ‚Ü¶ ?_, fun h ‚Ü¶ ?_‚ü©\n  ¬∑ ext w\n    ¬∑ exact norm_eq_zero.mp (normAtPlace_apply_isReal w.prop _ ‚ñ∏ h w.1)\n    ¬∑ exact norm_eq_zero.mp (normAtPlace_apply_isComplex w.prop _ ‚ñ∏ h w.1)\n  ¬∑ simp_rw [h, map_zero, implies_true]\n\n"}
{"name":"NumberField.mixedEmbedding.normAtPlace_eq_zero","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.Basic","initialProofState":"K : Type u_1\ninst‚úù : Field K\nx : NumberField.mixedEmbedding.mixedSpace K\n‚ä¢ Iff (‚àÄ (w : NumberField.InfinitePlace K), Eq ((NumberField.mixedEmbedding.normAtPlace w) x) 0) (Eq x 0)","decl":"@[deprecated (since := \"2024-09-13\")] alias normAtPlace_eq_zero := forall_normAtPlace_eq_zero_iff\n\n"}
{"name":"NumberField.mixedEmbedding.exists_normAtPlace_ne_zero_iff","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.Basic","initialProofState":"K : Type u_1\ninst‚úù : Field K\nx : NumberField.mixedEmbedding.mixedSpace K\n‚ä¢ Iff (Exists fun w => Ne ((NumberField.mixedEmbedding.normAtPlace w) x) 0) (Ne x 0)","decl":"@[simp]\ntheorem exists_normAtPlace_ne_zero_iff {x : mixedSpace K} :\n    (‚àÉ w, normAtPlace w x ‚â† 0) ‚Üî x ‚â† 0 := by\n  rw [ne_eq, ‚Üê forall_normAtPlace_eq_zero_iff, not_forall]\n\n"}
{"name":"NumberField.mixedEmbedding.nnnorm_eq_sup_normAtPlace","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.Basic","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\nx : NumberField.mixedEmbedding.mixedSpace K\n‚ä¢ Eq (NNNorm.nnnorm x) (Finset.univ.sup fun w => ‚ü®(NumberField.mixedEmbedding.normAtPlace w) x, ‚ãØ‚ü©)","decl":"open scoped Classical in\ntheorem nnnorm_eq_sup_normAtPlace (x : mixedSpace K) :\n    ‚Äñx‚Äñ‚Çä = univ.sup fun w ‚Ü¶ ‚ü®normAtPlace w x, normAtPlace_nonneg w x‚ü© := by\n  have :\n      (univ : Finset (InfinitePlace K)) =\n      (univ.image (fun w : {w : InfinitePlace K // IsReal w} ‚Ü¶ w.1)) ‚à™\n      (univ.image (fun w : {w : InfinitePlace K // IsComplex w} ‚Ü¶ w.1)) := by\n    ext; simp [isReal_or_isComplex]\n  rw [this, sup_union, univ.sup_image, univ.sup_image,\n    Prod.nnnorm_def, Pi.nnnorm_def, Pi.nnnorm_def]\n  congr\n  ¬∑ ext w\n    simp [normAtPlace_apply_isReal w.prop]\n  ¬∑ ext w\n    simp [normAtPlace_apply_isComplex w.prop]\n\n"}
{"name":"NumberField.mixedEmbedding.norm_eq_sup'_normAtPlace","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.Basic","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\nx : NumberField.mixedEmbedding.mixedSpace K\n‚ä¢ Eq (Norm.norm x) (Finset.univ.sup' ‚ãØ fun w => (NumberField.mixedEmbedding.normAtPlace w) x)","decl":"open scoped Classical in\ntheorem norm_eq_sup'_normAtPlace (x : mixedSpace K) :\n    ‚Äñx‚Äñ = univ.sup' univ_nonempty fun w ‚Ü¶ normAtPlace w x := by\n  rw [‚Üê coe_nnnorm, nnnorm_eq_sup_normAtPlace, ‚Üê sup'_eq_sup univ_nonempty, ‚Üê NNReal.val_eq_coe,\n    ‚Üê OrderHom.Subtype.val_coe, map_finset_sup', OrderHom.Subtype.val_coe]\n  simp only [Function.comp_apply]\n\n"}
{"name":"NumberField.mixedEmbedding.norm_apply","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.Basic","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\nx : NumberField.mixedEmbedding.mixedSpace K\n‚ä¢ Eq (NumberField.mixedEmbedding.norm x) (Finset.univ.prod fun w => HPow.hPow ((NumberField.mixedEmbedding.normAtPlace w) x) w.mult)","decl":"protected theorem norm_apply (x : mixedSpace K) :\n    mixedEmbedding.norm x = ‚àè w, (normAtPlace w x) ^ (mult w) := rfl\n\n"}
{"name":"NumberField.mixedEmbedding.norm_nonneg","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.Basic","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\nx : NumberField.mixedEmbedding.mixedSpace K\n‚ä¢ LE.le 0 (NumberField.mixedEmbedding.norm x)","decl":"protected theorem norm_nonneg (x : mixedSpace K) :\n    0 ‚â§ mixedEmbedding.norm x := univ.prod_nonneg fun _ _ ‚Ü¶ pow_nonneg (normAtPlace_nonneg _ _) _\n\n"}
{"name":"NumberField.mixedEmbedding.norm_eq_zero_iff","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.Basic","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\nx : NumberField.mixedEmbedding.mixedSpace K\n‚ä¢ Iff (Eq (NumberField.mixedEmbedding.norm x) 0) (Exists fun w => Eq ((NumberField.mixedEmbedding.normAtPlace w) x) 0)","decl":"protected theorem norm_eq_zero_iff {x : mixedSpace K} :\n    mixedEmbedding.norm x = 0 ‚Üî ‚àÉ w, normAtPlace w x = 0 := by\n  simp_rw [mixedEmbedding.norm, MonoidWithZeroHom.coe_mk, ZeroHom.coe_mk, prod_eq_zero_iff,\n    mem_univ, true_and, pow_eq_zero_iff mult_ne_zero]\n\n"}
{"name":"NumberField.mixedEmbedding.norm_ne_zero_iff","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.Basic","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\nx : NumberField.mixedEmbedding.mixedSpace K\n‚ä¢ Iff (Ne (NumberField.mixedEmbedding.norm x) 0) (‚àÄ (w : NumberField.InfinitePlace K), Ne ((NumberField.mixedEmbedding.normAtPlace w) x) 0)","decl":"protected theorem norm_ne_zero_iff {x : mixedSpace K} :\n    mixedEmbedding.norm x ‚â† 0 ‚Üî ‚àÄ w, normAtPlace w x ‚â† 0 := by\n  rw [‚Üê not_iff_not]\n  simp_rw [ne_eq, mixedEmbedding.norm_eq_zero_iff, not_not, not_forall, not_not]\n\n"}
{"name":"NumberField.mixedEmbedding.norm_eq_of_normAtPlace_eq","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.Basic","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\nx y : NumberField.mixedEmbedding.mixedSpace K\nh : ‚àÄ (w : NumberField.InfinitePlace K), Eq ((NumberField.mixedEmbedding.normAtPlace w) x) ((NumberField.mixedEmbedding.normAtPlace w) y)\n‚ä¢ Eq (NumberField.mixedEmbedding.norm x) (NumberField.mixedEmbedding.norm y)","decl":"theorem norm_eq_of_normAtPlace_eq {x y : mixedSpace K}\n    (h : ‚àÄ w, normAtPlace w x = normAtPlace w y) :\n    mixedEmbedding.norm x = mixedEmbedding.norm y := by\n  simp_rw [mixedEmbedding.norm_apply, h]\n\n"}
{"name":"NumberField.mixedEmbedding.norm_smul","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.Basic","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\nc : Real\nx : NumberField.mixedEmbedding.mixedSpace K\n‚ä¢ Eq (NumberField.mixedEmbedding.norm (HSMul.hSMul c x)) (HMul.hMul (HPow.hPow (abs c) (Module.finrank Rat K)) (NumberField.mixedEmbedding.norm x))","decl":"theorem norm_smul (c : ‚Ñù) (x : mixedSpace K) :\n    mixedEmbedding.norm (c ‚Ä¢ x) = |c| ^ finrank ‚Ñö K * (mixedEmbedding.norm x) := by\n  simp_rw [mixedEmbedding.norm_apply, normAtPlace_smul, mul_pow, prod_mul_distrib,\n    prod_pow_eq_pow_sum, sum_mult_eq]\n\n"}
{"name":"NumberField.mixedEmbedding.norm_real","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.Basic","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\nc : Real\n‚ä¢ Eq (NumberField.mixedEmbedding.norm { fst := fun x => c, snd := fun x => ‚Üëc }) (HPow.hPow (abs c) (Module.finrank Rat K))","decl":"theorem norm_real (c : ‚Ñù) :\n    mixedEmbedding.norm ((fun _ ‚Ü¶ c, fun _ ‚Ü¶ c) : (mixedSpace K)) = |c| ^ finrank ‚Ñö K := by\n  rw [show ((fun _ ‚Ü¶ c, fun _ ‚Ü¶ c) : (mixedSpace K)) = c ‚Ä¢ 1 by ext <;> simp, norm_smul, map_one,\n    mul_one]\n\n"}
{"name":"NumberField.mixedEmbedding.norm_eq_norm","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.Basic","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\nx : K\n‚ä¢ Eq (NumberField.mixedEmbedding.norm ((NumberField.mixedEmbedding K) x)) ‚Üë(abs ((Algebra.norm Rat) x))","decl":"@[simp]\ntheorem norm_eq_norm (x : K) :\n    mixedEmbedding.norm (mixedEmbedding K x) = |Algebra.norm ‚Ñö x| := by\n  simp_rw [mixedEmbedding.norm_apply, normAtPlace_apply, prod_eq_abs_norm]\n\n"}
{"name":"NumberField.mixedEmbedding.norm_unit","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.Basic","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\nu : Units (NumberField.RingOfIntegers K)\n‚ä¢ Eq (NumberField.mixedEmbedding.norm ((NumberField.mixedEmbedding K) ((algebraMap (NumberField.RingOfIntegers K) K) ‚Üëu))) 1","decl":"theorem norm_unit (u : (ùìû K)À£) :\n    mixedEmbedding.norm (mixedEmbedding K u) = 1 := by\n  rw [norm_eq_norm, Units.norm, Rat.cast_one]\n\n"}
{"name":"NumberField.mixedEmbedding.norm_eq_zero_iff'","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.Basic","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\nx : NumberField.mixedEmbedding.mixedSpace K\nhx : Membership.mem (Set.range ‚áë(NumberField.mixedEmbedding K)) x\n‚ä¢ Iff (Eq (NumberField.mixedEmbedding.norm x) 0) (Eq x 0)","decl":"theorem norm_eq_zero_iff' {x : mixedSpace K} (hx : x ‚àà Set.range (mixedEmbedding K)) :\n    mixedEmbedding.norm x = 0 ‚Üî x = 0 := by\n  obtain ‚ü®a, rfl‚ü© := hx\n  rw [norm_eq_norm, Rat.cast_abs, abs_eq_zero, Rat.cast_eq_zero, Algebra.norm_eq_zero_iff,\n    map_eq_zero]\n\n"}
{"name":"NumberField.mixedEmbedding.stdBasis_apply_ofIsReal","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.Basic","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\nx : NumberField.mixedEmbedding.mixedSpace K\nw : Subtype fun w => w.IsReal\n‚ä¢ Eq (((NumberField.mixedEmbedding.stdBasis K).repr x) (Sum.inl w)) (x.1 w)","decl":"@[simp]\ntheorem stdBasis_apply_ofIsReal (x : mixedSpace K) (w : {w : InfinitePlace K // IsReal w}) :\n    (stdBasis K).repr x (Sum.inl w) = x.1 w := rfl\n\n"}
{"name":"NumberField.mixedEmbedding.stdBasis_apply_ofIsComplex_fst","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.Basic","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\nx : NumberField.mixedEmbedding.mixedSpace K\nw : Subtype fun w => w.IsComplex\n‚ä¢ Eq (((NumberField.mixedEmbedding.stdBasis K).repr x) (Sum.inr { fst := w, snd := 0 })) (x.2 w).re","decl":"@[simp]\ntheorem stdBasis_apply_ofIsComplex_fst (x : mixedSpace K)\n    (w : {w : InfinitePlace K // IsComplex w}) :\n    (stdBasis K).repr x (Sum.inr ‚ü®w, 0‚ü©) = (x.2 w).re := rfl\n\n"}
{"name":"NumberField.mixedEmbedding.stdBasis_apply_ofIsComplex_snd","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.Basic","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\nx : NumberField.mixedEmbedding.mixedSpace K\nw : Subtype fun w => w.IsComplex\n‚ä¢ Eq (((NumberField.mixedEmbedding.stdBasis K).repr x) (Sum.inr { fst := w, snd := 1 })) (x.2 w).im","decl":"@[simp]\ntheorem stdBasis_apply_ofIsComplex_snd (x : mixedSpace K)\n    (w : {w : InfinitePlace K // IsComplex w}) :\n    (stdBasis K).repr x (Sum.inr ‚ü®w, 1‚ü©) = (x.2 w).im := rfl\n\n"}
{"name":"NumberField.mixedEmbedding.fundamentalDomain_stdBasis","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.Basic","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\n‚ä¢ Eq (ZSpan.fundamentalDomain (NumberField.mixedEmbedding.stdBasis K)) (SProd.sprod (Set.univ.pi fun x => Set.Ico 0 1) (Set.univ.pi fun x => Set.preimage (‚áëComplex.measurableEquivPi) (Set.univ.pi fun x => Set.Ico 0 1)))","decl":"open scoped Classical in\ntheorem fundamentalDomain_stdBasis :\n    fundamentalDomain (stdBasis K) =\n        (Set.univ.pi fun _ => Set.Ico 0 1) √óÀ¢\n        (Set.univ.pi fun _ => Complex.measurableEquivPi‚Åª¬π' (Set.univ.pi fun _ => Set.Ico 0 1)) := by\n  ext\n  simp [stdBasis, mem_fundamentalDomain, Complex.measurableEquivPi]\n\n"}
{"name":"NumberField.mixedEmbedding.volume_fundamentalDomain_stdBasis","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.Basic","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\n‚ä¢ Eq (MeasureTheory.MeasureSpace.volume (ZSpan.fundamentalDomain (NumberField.mixedEmbedding.stdBasis K))) 1","decl":"open scoped Classical in\ntheorem volume_fundamentalDomain_stdBasis :\n    volume (fundamentalDomain (stdBasis K)) = 1 := by\n  rw [fundamentalDomain_stdBasis, volume_eq_prod, prod_prod, volume_pi, volume_pi, pi_pi, pi_pi,\n    Complex.volume_preserving_equiv_pi.measure_preimage ?_, volume_pi, pi_pi, Real.volume_Ico,\n    sub_zero, ENNReal.ofReal_one, prod_const_one, prod_const_one, prod_const_one, one_mul]\n  exact (MeasurableSet.pi Set.countable_univ (fun _ _ => measurableSet_Ico)).nullMeasurableSet\n\n"}
{"name":"NumberField.mixedEmbedding.indexEquiv_apply_ofIsReal","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.Basic","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\nw : Subtype fun w => w.IsReal\n‚ä¢ Eq ((NumberField.mixedEmbedding.indexEquiv K) (Sum.inl w)) (‚Üëw).embedding","decl":"@[simp]\ntheorem indexEquiv_apply_ofIsReal (w : {w : InfinitePlace K // IsReal w}) :\n    (indexEquiv K) (Sum.inl w) = w.val.embedding := rfl\n\n"}
{"name":"NumberField.mixedEmbedding.indexEquiv_apply_ofIsComplex_fst","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.Basic","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\nw : Subtype fun w => w.IsComplex\n‚ä¢ Eq ((NumberField.mixedEmbedding.indexEquiv K) (Sum.inr { fst := w, snd := 0 })) (‚Üëw).embedding","decl":"@[simp]\ntheorem indexEquiv_apply_ofIsComplex_fst (w : {w : InfinitePlace K // IsComplex w}) :\n    (indexEquiv K) (Sum.inr ‚ü®w, 0‚ü©) = w.val.embedding := rfl\n\n"}
{"name":"NumberField.mixedEmbedding.indexEquiv_apply_ofIsComplex_snd","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.Basic","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\nw : Subtype fun w => w.IsComplex\n‚ä¢ Eq ((NumberField.mixedEmbedding.indexEquiv K) (Sum.inr { fst := w, snd := 1 })) (NumberField.ComplexEmbedding.conjugate (‚Üëw).embedding)","decl":"@[simp]\ntheorem indexEquiv_apply_ofIsComplex_snd (w : {w : InfinitePlace K // IsComplex w}) :\n    (indexEquiv K) (Sum.inr ‚ü®w, 1‚ü©) = ComplexEmbedding.conjugate w.val.embedding := rfl\n\n"}
{"name":"NumberField.mixedEmbedding.det_matrixToStdBasis","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.Basic","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\n‚ä¢ Eq (NumberField.mixedEmbedding.matrixToStdBasis K).det (HPow.hPow (HMul.hMul (Inv.inv 2) Complex.I) (NumberField.InfinitePlace.nrComplexPlaces K))","decl":"open scoped Classical in\ntheorem det_matrixToStdBasis :\n    (matrixToStdBasis K).det = (2‚Åª¬π * I) ^ nrComplexPlaces K :=\n  calc\n  _ = ‚àè _k : { w : InfinitePlace K // IsComplex w }, det ((2 : ‚ÑÇ)‚Åª¬π ‚Ä¢ !![1, 1; -I, I]) := by\n      rw [matrixToStdBasis, det_fromBlocks_zero‚ÇÇ‚ÇÅ, det_diagonal, prod_const_one, one_mul,\n          det_reindex_self, det_blockDiagonal]\n  _ = ‚àè _k : { w : InfinitePlace K // IsComplex w }, (2‚Åª¬π * Complex.I) := by\n      refine prod_congr (Eq.refl _) (fun _ _ => ?_)\n      field_simp; ring\n  _ = (2‚Åª¬π * Complex.I) ^ Fintype.card {w : InfinitePlace K // IsComplex w} := by\n      rw [prod_const, Fintype.card]\n\n"}
{"name":"NumberField.mixedEmbedding.stdBasis_repr_eq_matrixToStdBasis_mul","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.Basic","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\nx : RingHom K Complex ‚Üí Complex\nhx : ‚àÄ (œÜ : RingHom K Complex), Eq ((starRingEnd Complex) (x œÜ)) (x (NumberField.ComplexEmbedding.conjugate œÜ))\nc : NumberField.mixedEmbedding.index K\n‚ä¢ Eq (‚Üë(((NumberField.mixedEmbedding.stdBasis K).repr ((NumberField.mixedEmbedding.commMap K) x)) c)) ((NumberField.mixedEmbedding.matrixToStdBasis K).mulVec (Function.comp x ‚áë(NumberField.mixedEmbedding.indexEquiv K)) c)","decl":"open scoped Classical in\n/-- Let `x : (K ‚Üí+* ‚ÑÇ) ‚Üí ‚ÑÇ` such that `x_œÜ = conj x_(conj œÜ)` for all `œÜ : K ‚Üí+* ‚ÑÇ`, then the\nrepresentation of `commMap K x` on `stdBasis` is given (up to reindexing) by the product of\n`matrixToStdBasis` by `x`. -/\ntheorem stdBasis_repr_eq_matrixToStdBasis_mul (x : (K ‚Üí+* ‚ÑÇ) ‚Üí ‚ÑÇ)\n    (hx : ‚àÄ œÜ, conj (x œÜ) = x (ComplexEmbedding.conjugate œÜ)) (c : index K) :\n    ((stdBasis K).repr (commMap K x) c : ‚ÑÇ) =\n      (matrixToStdBasis K *·µ• (x ‚àò (indexEquiv K))) c := by\n  simp_rw [commMap, matrixToStdBasis, LinearMap.coe_mk, AddHom.coe_mk,\n    mulVec, dotProduct, Function.comp_apply, index, Fintype.sum_sum_type,\n    diagonal_one, reindex_apply, ‚Üê univ_product_univ, sum_product,\n    indexEquiv_apply_ofIsReal, Fin.sum_univ_two, indexEquiv_apply_ofIsComplex_fst,\n    indexEquiv_apply_ofIsComplex_snd, smul_of, smul_cons, smul_eq_mul,\n    mul_one, Matrix.smul_empty, Equiv.prodComm_symm, Equiv.coe_prodComm]\n  cases c with\n  | inl w =>\n      simp_rw [stdBasis_apply_ofIsReal, fromBlocks_apply‚ÇÅ‚ÇÅ, fromBlocks_apply‚ÇÅ‚ÇÇ,\n        one_apply, Matrix.zero_apply, ite_mul, one_mul, zero_mul, sum_ite_eq, mem_univ, ite_true,\n        add_zero, sum_const_zero, add_zero, ‚Üê conj_eq_iff_re, hx (embedding w.val),\n        conjugate_embedding_eq_of_isReal w.prop]\n  | inr c =>\n    rcases c with ‚ü®w, j‚ü©\n    fin_cases j\n    ¬∑ simp only [Fin.zero_eta, Fin.isValue, id_eq, stdBasis_apply_ofIsComplex_fst, re_eq_add_conj,\n        mul_neg, fromBlocks_apply‚ÇÇ‚ÇÅ, zero_apply, zero_mul, sum_const_zero, fromBlocks_apply‚ÇÇ‚ÇÇ,\n        submatrix_apply, Prod.swap_prod_mk, blockDiagonal_apply, of_apply, cons_val', cons_val_zero,\n        empty_val', cons_val_fin_one, ite_mul, cons_val_one, head_cons, sum_add_distrib, sum_ite_eq,\n        mem_univ, ‚ÜìreduceIte, ‚Üê hx (embedding w), zero_add]\n      field_simp\n    ¬∑ simp only [Fin.mk_one, Fin.isValue, id_eq, stdBasis_apply_ofIsComplex_snd, im_eq_sub_conj,\n        mul_neg, fromBlocks_apply‚ÇÇ‚ÇÅ, zero_apply, zero_mul, sum_const_zero, fromBlocks_apply‚ÇÇ‚ÇÇ,\n        submatrix_apply, Prod.swap_prod_mk, blockDiagonal_apply, of_apply, cons_val', cons_val_zero,\n        empty_val', cons_val_fin_one, cons_val_one, head_fin_const, ite_mul, neg_mul, head_cons,\n        sum_add_distrib, sum_ite_eq, mem_univ, ‚ÜìreduceIte, ‚Üê hx (embedding w), zero_add]\n      ring_nf; field_simp\n\n"}
{"name":"NumberField.mixedEmbedding.latticeBasis_apply","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.Basic","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\ni : Module.Free.ChooseBasisIndex Int (NumberField.RingOfIntegers K)\n‚ä¢ Eq ((NumberField.mixedEmbedding.latticeBasis K) i) ((NumberField.mixedEmbedding K) ((NumberField.integralBasis K) i))","decl":"@[simp]\ntheorem latticeBasis_apply (i : ChooseBasisIndex ‚Ñ§ (ùìû K)) :\n    latticeBasis K i = (mixedEmbedding K) (integralBasis K i) := by\n  simp only [latticeBasis, coe_basisOfLinearIndependentOfCardEqFinrank, Function.comp_apply,\n    canonicalEmbedding.latticeBasis_apply, integralBasis_apply, commMap_canonical_eq_mixed]\n\n"}
{"name":"NumberField.mixedEmbedding.mem_span_latticeBasis","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.Basic","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\nx : NumberField.mixedEmbedding.mixedSpace K\n‚ä¢ Iff (Membership.mem (Submodule.span Int (Set.range ‚áë(NumberField.mixedEmbedding.latticeBasis K))) x) (Membership.mem (NumberField.mixedEmbedding.integerLattice K) x)","decl":"theorem mem_span_latticeBasis {x : (mixedSpace K)} :\n    x ‚àà Submodule.span ‚Ñ§ (Set.range (latticeBasis K)) ‚Üî\n      x ‚àà mixedEmbedding.integerLattice K := by\n  rw [show Set.range (latticeBasis K) =\n      (mixedEmbedding K).toIntAlgHom.toLinearMap '' (Set.range (integralBasis K)) by\n    rw [‚Üê Set.range_comp]; exact congrArg Set.range (funext (fun i => latticeBasis_apply K i))]\n  rw [‚Üê Submodule.map_span, ‚Üê SetLike.mem_coe, Submodule.map_coe]\n  simp only [Set.mem_image, SetLike.mem_coe, mem_span_integralBasis K,\n    RingHom.mem_range, exists_exists_eq_and]\n  rfl\n\n"}
{"name":"NumberField.mixedEmbedding.span_latticeBasis","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.Basic","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\n‚ä¢ Eq (Submodule.span Int (Set.range ‚áë(NumberField.mixedEmbedding.latticeBasis K))) (NumberField.mixedEmbedding.integerLattice K)","decl":"theorem span_latticeBasis :\n    Submodule.span ‚Ñ§ (Set.range (latticeBasis K)) = mixedEmbedding.integerLattice K :=\n  Submodule.ext_iff.mpr fun _ ‚Ü¶ mem_span_latticeBasis K\n\n"}
{"name":"NumberField.mixedEmbedding.instDiscreteTopologySubtypeMixedSpaceMemSubmoduleIntIntegerLattice","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.Basic","initialProofState":"K : Type u_1\ninst‚úù : Field K\n‚ä¢ DiscreteTopology (Subtype fun x => Membership.mem (NumberField.mixedEmbedding.integerLattice K) x)","decl":"instance : DiscreteTopology (mixedEmbedding.integerLattice K) := by\n  classical\n  rw [‚Üê span_latticeBasis]\n  infer_instance\n\n"}
{"name":"NumberField.mixedEmbedding.instIsZLatticeRealMixedSpaceIntegerLattice","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.Basic","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\n‚ä¢ IsZLattice Real (NumberField.mixedEmbedding.integerLattice K)","decl":"open Classical in\ninstance : IsZLattice ‚Ñù (mixedEmbedding.integerLattice K) := by\n  simp_rw [‚Üê span_latticeBasis]\n  exact ZSpan.isZLattice (latticeBasis K)\n\n"}
{"name":"NumberField.mixedEmbedding.fundamentalDomain_integerLattice","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.Basic","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\n‚ä¢ MeasureTheory.IsAddFundamentalDomain (Subtype fun x => Membership.mem (NumberField.mixedEmbedding.integerLattice K) x) (ZSpan.fundamentalDomain (NumberField.mixedEmbedding.latticeBasis K)) MeasureTheory.MeasureSpace.volume","decl":"open Classical in\ntheorem fundamentalDomain_integerLattice :\n    MeasureTheory.IsAddFundamentalDomain (mixedEmbedding.integerLattice K)\n      (ZSpan.fundamentalDomain (latticeBasis K)) := by\n  rw [‚Üê span_latticeBasis]\n  exact ZSpan.isAddFundamentalDomain (latticeBasis K) _\n\n"}
{"name":"NumberField.mixedEmbedding.mem_rat_span_latticeBasis","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.Basic","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\nx : K\n‚ä¢ Membership.mem (Submodule.span Rat (Set.range ‚áë(NumberField.mixedEmbedding.latticeBasis K))) ((NumberField.mixedEmbedding K) x)","decl":"theorem mem_rat_span_latticeBasis (x : K) :\n    mixedEmbedding K x ‚àà Submodule.span ‚Ñö (Set.range (latticeBasis K)) := by\n  rw [‚Üê Basis.sum_repr (integralBasis K) x, map_sum]\n  simp_rw [map_rat_smul]\n  refine Submodule.sum_smul_mem _ _ (fun i _ ‚Ü¶ Submodule.subset_span ?_)\n  rw [‚Üê latticeBasis_apply]\n  exact Set.mem_range_self i\n\n"}
{"name":"NumberField.mixedEmbedding.latticeBasis_repr_apply","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.Basic","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\nx : K\ni : Module.Free.ChooseBasisIndex Int (NumberField.RingOfIntegers K)\n‚ä¢ Eq (((NumberField.mixedEmbedding.latticeBasis K).repr ((NumberField.mixedEmbedding K) x)) i) ‚Üë(((NumberField.integralBasis K).repr x) i)","decl":"theorem latticeBasis_repr_apply (x : K) (i : ChooseBasisIndex ‚Ñ§ (ùìû K)) :\n    (latticeBasis K).repr (mixedEmbedding K x) i = (integralBasis K).repr x i := by\n  rw [‚Üê Basis.restrictScalars_repr_apply ‚Ñö _ ‚ü®_, mem_rat_span_latticeBasis K x‚ü©, eq_ratCast,\n    Rat.cast_inj]\n  let f := (mixedEmbedding K).toRatAlgHom.toLinearMap.codRestrict _\n    (fun x ‚Ü¶ mem_rat_span_latticeBasis K x)\n  suffices ((latticeBasis K).restrictScalars ‚Ñö).repr.toLinearMap ‚àò‚Çó f =\n    (integralBasis K).repr.toLinearMap from DFunLike.congr_fun (LinearMap.congr_fun this x) i\n  refine Basis.ext (integralBasis K) (fun i ‚Ü¶ ?_)\n  have : f (integralBasis K i) = ((latticeBasis K).restrictScalars ‚Ñö) i := by\n    apply Subtype.val_injective\n    rw [LinearMap.codRestrict_apply, AlgHom.toLinearMap_apply, Basis.restrictScalars_apply,\n      latticeBasis_apply]\n    rfl\n  simp_rw [LinearMap.coe_comp, LinearEquiv.coe_coe, Function.comp_apply, this, Basis.repr_self]\n\n"}
{"name":"NumberField.mixedEmbedding.mem_idealLattice","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.Basic","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\nI : Units (FractionalIdeal (nonZeroDivisors (NumberField.RingOfIntegers K)) K)\nx : NumberField.mixedEmbedding.mixedSpace K\n‚ä¢ Iff (Membership.mem (NumberField.mixedEmbedding.idealLattice K I) x) (Exists fun y => And (Membership.mem (‚Üë‚ÜëI) y) (Eq ((NumberField.mixedEmbedding K) y) x))","decl":"theorem mem_idealLattice {x : mixedSpace K} :\n    x ‚àà idealLattice K I ‚Üî ‚àÉ y, y ‚àà (I : Set K) ‚àß mixedEmbedding K y = x := by\n  simp [idealLattice]\n\n"}
{"name":"NumberField.mixedEmbedding.det_basisOfFractionalIdeal_eq_norm","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.Basic","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\nI : Units (FractionalIdeal (nonZeroDivisors (NumberField.RingOfIntegers K)) K)\ne : Equiv (Module.Free.ChooseBasisIndex Int (NumberField.RingOfIntegers K)) (Module.Free.ChooseBasisIndex Int (Subtype fun x => Membership.mem (‚Üë‚ÜëI) x))\n‚ä¢ Eq (abs ((NumberField.mixedEmbedding.latticeBasis K).det (Function.comp (‚áë(NumberField.mixedEmbedding K)) (Function.comp ‚áë(NumberField.basisOfFractionalIdeal K I) ‚áëe)))) ‚Üë(FractionalIdeal.absNorm ‚ÜëI)","decl":"/-- The generalized index of the lattice generated by `I` in the lattice generated by\n`ùìû K` is equal to the norm of the ideal `I`. The result is stated in terms of base change\ndeterminant and is the translation of `NumberField.det_basisOfFractionalIdeal_eq_absNorm` in\nthe mixed space. This is useful, in particular, to prove that the family obtained from\nthe `‚Ñ§`-basis of `I` is actually an `‚Ñù`-basis of the mixed space, see\n`fractionalIdealLatticeBasis`. -/\ntheorem det_basisOfFractionalIdeal_eq_norm\n    (e : (ChooseBasisIndex ‚Ñ§ (ùìû K)) ‚âÉ (ChooseBasisIndex ‚Ñ§ I)) :\n    |Basis.det (latticeBasis K) ((mixedEmbedding K ‚àò (basisOfFractionalIdeal K I) ‚àò e))| =\n      FractionalIdeal.absNorm I.1 := by\n  suffices Basis.det (latticeBasis K) ((mixedEmbedding K ‚àò (basisOfFractionalIdeal K I) ‚àò e)) =\n      (algebraMap ‚Ñö ‚Ñù) ((Basis.det (integralBasis K)) ((basisOfFractionalIdeal K I) ‚àò e)) by\n    rw [this, eq_ratCast, ‚Üê Rat.cast_abs, ‚Üê Equiv.symm_symm e, ‚Üê Basis.coe_reindex,\n      det_basisOfFractionalIdeal_eq_absNorm K I e]\n  rw [Basis.det_apply, Basis.det_apply, RingHom.map_det]\n  congr\n  ext i j\n  simp_rw [RingHom.mapMatrix_apply, Matrix.map_apply, Basis.toMatrix_apply, Function.comp_apply]\n  exact latticeBasis_repr_apply K _ i\n\n"}
{"name":"NumberField.mixedEmbedding.fractionalIdealLatticeBasis_apply","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.Basic","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\nI : Units (FractionalIdeal (nonZeroDivisors (NumberField.RingOfIntegers K)) K)\ni : Module.Free.ChooseBasisIndex Int (Subtype fun x => Membership.mem (‚Üë‚ÜëI) x)\n‚ä¢ Eq ((NumberField.mixedEmbedding.fractionalIdealLatticeBasis K I) i) ((NumberField.mixedEmbedding K) ((NumberField.basisOfFractionalIdeal K I) i))","decl":"@[simp]\ntheorem fractionalIdealLatticeBasis_apply (i : ChooseBasisIndex ‚Ñ§ I) :\n    fractionalIdealLatticeBasis K I i = (mixedEmbedding K) (basisOfFractionalIdeal K I i) := by\n  simp only [fractionalIdealLatticeBasis, Basis.coe_reindex, Basis.coe_mk, Function.comp_apply,\n    Equiv.apply_symm_apply]\n\n"}
{"name":"NumberField.mixedEmbedding.mem_span_fractionalIdealLatticeBasis","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.Basic","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\nI : Units (FractionalIdeal (nonZeroDivisors (NumberField.RingOfIntegers K)) K)\nx : NumberField.mixedEmbedding.mixedSpace K\n‚ä¢ Iff (Membership.mem (Submodule.span Int (Set.range ‚áë(NumberField.mixedEmbedding.fractionalIdealLatticeBasis K I))) x) (Membership.mem (Set.image ‚áë(NumberField.mixedEmbedding K) ‚Üë‚ÜëI) x)","decl":"theorem mem_span_fractionalIdealLatticeBasis {x : (mixedSpace K)} :\n    x ‚àà Submodule.span ‚Ñ§ (Set.range (fractionalIdealLatticeBasis K I)) ‚Üî\n      x ‚àà mixedEmbedding K '' I := by\n  rw [show Set.range (fractionalIdealLatticeBasis K I) =\n        (mixedEmbedding K).toIntAlgHom.toLinearMap '' (Set.range (basisOfFractionalIdeal K I)) by\n      rw [‚Üê Set.range_comp]\n      exact congr_arg Set.range (funext (fun i ‚Ü¶ fractionalIdealLatticeBasis_apply K I i))]\n  rw [‚Üê Submodule.map_span, ‚Üê SetLike.mem_coe, Submodule.map_coe]\n  rw [show Submodule.span ‚Ñ§ (Set.range (basisOfFractionalIdeal K I)) = (I : Set K) by\n        ext; erw [mem_span_basisOfFractionalIdeal]]\n  rfl\n\n"}
{"name":"NumberField.mixedEmbedding.span_idealLatticeBasis","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.Basic","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\nI : Units (FractionalIdeal (nonZeroDivisors (NumberField.RingOfIntegers K)) K)\n‚ä¢ Eq (Submodule.span Int (Set.range ‚áë(NumberField.mixedEmbedding.fractionalIdealLatticeBasis K I))) (NumberField.mixedEmbedding.idealLattice K I)","decl":"theorem span_idealLatticeBasis :\n    (Submodule.span ‚Ñ§ (Set.range (fractionalIdealLatticeBasis K I))) =\n      (mixedEmbedding.idealLattice K I) := by\n  ext x\n  simp [mem_span_fractionalIdealLatticeBasis]\n\n"}
{"name":"NumberField.mixedEmbedding.instDiscreteTopologySubtypeMixedSpaceMemSubmoduleIntIdealLattice","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.Basic","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\nI : Units (FractionalIdeal (nonZeroDivisors (NumberField.RingOfIntegers K)) K)\n‚ä¢ DiscreteTopology (Subtype fun x => Membership.mem (NumberField.mixedEmbedding.idealLattice K I) x)","decl":"instance : DiscreteTopology (mixedEmbedding.idealLattice K I) := by\n  classical\n  rw [‚Üê span_idealLatticeBasis]\n  infer_instance\n\n"}
{"name":"NumberField.mixedEmbedding.instIsZLatticeRealMixedSpaceIdealLattice","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.Basic","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\nI : Units (FractionalIdeal (nonZeroDivisors (NumberField.RingOfIntegers K)) K)\n‚ä¢ IsZLattice Real (NumberField.mixedEmbedding.idealLattice K I)","decl":"open Classical in\ninstance : IsZLattice ‚Ñù (mixedEmbedding.idealLattice K I) := by\n  simp_rw [‚Üê span_idealLatticeBasis]\n  exact ZSpan.isZLattice (fractionalIdealLatticeBasis K I)\n\n"}
{"name":"NumberField.mixedEmbedding.fundamentalDomain_idealLattice","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.Basic","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\nI : Units (FractionalIdeal (nonZeroDivisors (NumberField.RingOfIntegers K)) K)\n‚ä¢ MeasureTheory.IsAddFundamentalDomain (Subtype fun x => Membership.mem (NumberField.mixedEmbedding.idealLattice K I) x) (ZSpan.fundamentalDomain (NumberField.mixedEmbedding.fractionalIdealLatticeBasis K I)) MeasureTheory.MeasureSpace.volume","decl":"open Classical in\ntheorem fundamentalDomain_idealLattice :\n    MeasureTheory.IsAddFundamentalDomain (mixedEmbedding.idealLattice K I)\n      (ZSpan.fundamentalDomain (fractionalIdealLatticeBasis K I)) := by\n  rw [‚Üê span_idealLatticeBasis]\n  exact ZSpan.isAddFundamentalDomain (fractionalIdealLatticeBasis K I) _\n\n"}
{"name":"NumberField.mixedEmbedding.euclidean.instBorelSpaceMixedSpace","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.Basic","initialProofState":"K : Type u_1\ninst‚úù : Field K\n‚ä¢ BorelSpace (NumberField.mixedEmbedding.euclidean.mixedSpace K)","decl":"instance : BorelSpace (euclidean.mixedSpace K) := ‚ü®rfl‚ü©\n\n"}
{"name":"NumberField.mixedEmbedding.euclidean.instNontrivialMixedSpace","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.Basic","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\n‚ä¢ Nontrivial (NumberField.mixedEmbedding.euclidean.mixedSpace K)","decl":"instance : Nontrivial (euclidean.mixedSpace K) := (toMixed K).toEquiv.nontrivial\n\n"}
{"name":"NumberField.mixedEmbedding.euclidean.finrank","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.Basic","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\n‚ä¢ Eq (Module.finrank Real (NumberField.mixedEmbedding.euclidean.mixedSpace K)) (Module.finrank Rat K)","decl":"protected theorem finrank :\n    finrank ‚Ñù (euclidean.mixedSpace K) = finrank ‚Ñö K := by\n  rw [LinearEquiv.finrank_eq (toMixed K).toLinearEquiv, mixedEmbedding.finrank]\n\n"}
{"name":"NumberField.mixedEmbedding.euclidean.stdOrthonormalBasis_map_eq","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.Basic","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\n‚ä¢ Eq ((NumberField.mixedEmbedding.euclidean.stdOrthonormalBasis K).toBasis.map (NumberField.mixedEmbedding.euclidean.toMixed K).toLinearEquiv) (NumberField.mixedEmbedding.stdBasis K)","decl":"open Classical in\ntheorem stdOrthonormalBasis_map_eq :\n    (euclidean.stdOrthonormalBasis K).toBasis.map (toMixed K).toLinearEquiv =\n      mixedEmbedding.stdBasis K := by\n  ext <;> rfl\n\n"}
{"name":"NumberField.mixedEmbedding.euclidean.volumePreserving_toMixed","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.Basic","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\n‚ä¢ MeasureTheory.MeasurePreserving (‚áë(NumberField.mixedEmbedding.euclidean.toMixed K)) MeasureTheory.MeasureSpace.volume MeasureTheory.MeasureSpace.volume","decl":"open Classical in\ntheorem volumePreserving_toMixed :\n    MeasurePreserving (toMixed K) where\n  measurable := (toMixed K).continuous.measurable\n  map_eq := by\n    rw [‚Üê (OrthonormalBasis.addHaar_eq_volume (euclidean.stdOrthonormalBasis K)), Basis.map_addHaar,\n      stdOrthonormalBasis_map_eq, Basis.addHaar_eq_iff, Basis.coe_parallelepiped,\n      ‚Üê measure_congr (ZSpan.fundamentalDomain_ae_parallelepiped (stdBasis K) volume),\n      volume_fundamentalDomain_stdBasis K]\n\n"}
{"name":"NumberField.mixedEmbedding.euclidean.volumePreserving_toMixed_symm","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.Basic","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\n‚ä¢ MeasureTheory.MeasurePreserving (‚áë(NumberField.mixedEmbedding.euclidean.toMixed K).symm) MeasureTheory.MeasureSpace.volume MeasureTheory.MeasureSpace.volume","decl":"open Classical in\ntheorem volumePreserving_toMixed_symm :\n    MeasurePreserving (toMixed K).symm := by\n  have : MeasurePreserving (toMixed K).toHomeomorph.toMeasurableEquiv := volumePreserving_toMixed K\n  exact this.symm\n\n"}
{"name":"NumberField.mixedEmbedding.euclidean.instDiscreteTopologySubtypeMixedSpaceMemSubmoduleIntIntegerLattice","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.Basic","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\n‚ä¢ DiscreteTopology (Subtype fun x => Membership.mem (NumberField.mixedEmbedding.euclidean.integerLattice K) x)","decl":"instance : DiscreteTopology (euclidean.integerLattice K) := by\n  classical\n  rw [euclidean.integerLattice]\n  infer_instance\n\n"}
{"name":"NumberField.mixedEmbedding.euclidean.instIsZLatticeRealMixedSpaceIntegerLattice","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.Basic","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ninst‚úù : NumberField K\n‚ä¢ IsZLattice Real (NumberField.mixedEmbedding.euclidean.integerLattice K)","decl":"open Classical in\ninstance : IsZLattice ‚Ñù (euclidean.integerLattice K) := by\n  simp_rw [euclidean.integerLattice]\n  infer_instance\n\n"}
{"name":"NumberField.mixedEmbedding.negAt_apply_of_isReal_and_mem","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.Basic","initialProofState":"K : Type u_1\ninst‚úù : Field K\ns : Set (Subtype fun w => w.IsReal)\nx : NumberField.mixedEmbedding.mixedSpace K\nw : Subtype fun w => w.IsReal\nhw : Membership.mem s w\n‚ä¢ Eq (((NumberField.mixedEmbedding.negAt s) x).1 w) (Neg.neg (x.1 w))","decl":"@[simp]\ntheorem negAt_apply_of_isReal_and_mem (x : mixedSpace K) {w : {w // IsReal w}} (hw : w ‚àà s) :\n    (negAt s x).1 w = - x.1 w := by\n  simp_rw [negAt, ContinuousLinearEquiv.prod_apply, piCongrRight_apply, if_pos hw,\n    ContinuousLinearEquiv.neg_apply]\n\n"}
{"name":"NumberField.mixedEmbedding.negAt_apply_of_isReal_and_not_mem","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.Basic","initialProofState":"K : Type u_1\ninst‚úù : Field K\ns : Set (Subtype fun w => w.IsReal)\nx : NumberField.mixedEmbedding.mixedSpace K\nw : Subtype fun w => w.IsReal\nhw : Not (Membership.mem s w)\n‚ä¢ Eq (((NumberField.mixedEmbedding.negAt s) x).1 w) (x.1 w)","decl":"@[simp]\ntheorem negAt_apply_of_isReal_and_not_mem (x : mixedSpace K) {w : {w // IsReal w}} (hw : w ‚àâ s) :\n    (negAt s x).1 w = x.1 w := by\n  simp_rw [negAt, ContinuousLinearEquiv.prod_apply, piCongrRight_apply, if_neg hw,\n    ContinuousLinearEquiv.refl_apply]\n\n"}
{"name":"NumberField.mixedEmbedding.negAt_apply_of_isComplex","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.Basic","initialProofState":"K : Type u_1\ninst‚úù : Field K\ns : Set (Subtype fun w => w.IsReal)\nx : NumberField.mixedEmbedding.mixedSpace K\nw : Subtype fun w => w.IsComplex\n‚ä¢ Eq (((NumberField.mixedEmbedding.negAt s) x).2 w) (x.2 w)","decl":"@[simp]\ntheorem negAt_apply_of_isComplex (x : mixedSpace K) (w : {w // IsComplex w}) :\n    (negAt s x).2 w = x.2 w := rfl\n\n"}
{"name":"NumberField.mixedEmbedding.negAt_apply_snd","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.Basic","initialProofState":"K : Type u_1\ninst‚úù : Field K\ns : Set (Subtype fun w => w.IsReal)\nx : NumberField.mixedEmbedding.mixedSpace K\n‚ä¢ Eq ((NumberField.mixedEmbedding.negAt s) x).2 x.2","decl":"@[simp]\ntheorem negAt_apply_snd (x : mixedSpace K) :\n    (negAt s x).2 = x.2 := rfl\n\n"}
{"name":"NumberField.mixedEmbedding.negAt_apply_abs_of_isReal","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.Basic","initialProofState":"K : Type u_1\ninst‚úù : Field K\ns : Set (Subtype fun w => w.IsReal)\nx : NumberField.mixedEmbedding.mixedSpace K\nw : Subtype fun w => w.IsReal\n‚ä¢ Eq (abs (((NumberField.mixedEmbedding.negAt s) x).1 w)) (abs (x.1 w))","decl":"@[simp]\ntheorem negAt_apply_abs_of_isReal (x : mixedSpace K) (w : {w // IsReal w}) :\n    |(negAt s x).1 w| = |x.1 w| := by\n  by_cases hw : w ‚àà s <;> simp [hw]\n\n"}
{"name":"NumberField.mixedEmbedding.volume_preserving_negAt","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.Basic","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ns : Set (Subtype fun w => w.IsReal)\ninst‚úù : NumberField K\n‚ä¢ MeasureTheory.MeasurePreserving (‚áë(NumberField.mixedEmbedding.negAt s)) MeasureTheory.MeasureSpace.volume MeasureTheory.MeasureSpace.volume","decl":"open MeasureTheory Classical in\n/-- `negAt` preserves the volume . -/\ntheorem volume_preserving_negAt [NumberField K] :\n    MeasurePreserving (negAt s) := by\n  refine MeasurePreserving.prod (volume_preserving_pi fun w ‚Ü¶ ?_) (MeasurePreserving.id _)\n  by_cases hw : w ‚àà s\n  ¬∑ simp_rw [if_pos hw]\n    exact Measure.measurePreserving_neg _\n  ¬∑ simp_rw [if_neg hw]\n    exact MeasurePreserving.id _\n\n"}
{"name":"NumberField.mixedEmbedding.normAtPlace_negAt","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.Basic","initialProofState":"K : Type u_1\ninst‚úù : Field K\ns : Set (Subtype fun w => w.IsReal)\nx : NumberField.mixedEmbedding.mixedSpace K\nw : NumberField.InfinitePlace K\n‚ä¢ Eq ((NumberField.mixedEmbedding.normAtPlace w) ((NumberField.mixedEmbedding.negAt s) x)) ((NumberField.mixedEmbedding.normAtPlace w) x)","decl":"variable (s) in\n/-- `negAt` preserves `normAtPlace`. -/\n@[simp]\ntheorem normAtPlace_negAt (x : mixedSpace K) (w : InfinitePlace K) :\n    normAtPlace w (negAt s x) = normAtPlace w x := by\n  obtain hw | hw := isReal_or_isComplex w\n  ¬∑ simp_rw [normAtPlace_apply_isReal hw, Real.norm_eq_abs, negAt_apply_abs_of_isReal]\n  ¬∑ simp_rw [normAtPlace_apply_isComplex hw, negAt_apply_of_isComplex]\n\n"}
{"name":"NumberField.mixedEmbedding.norm_negAt","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.Basic","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ns : Set (Subtype fun w => w.IsReal)\ninst‚úù : NumberField K\nx : NumberField.mixedEmbedding.mixedSpace K\n‚ä¢ Eq (NumberField.mixedEmbedding.norm ((NumberField.mixedEmbedding.negAt s) x)) (NumberField.mixedEmbedding.norm x)","decl":"/-- `negAt` preserves the `norm`. -/\n@[simp]\ntheorem norm_negAt [NumberField K] (x : mixedSpace K) :\n    mixedEmbedding.norm (negAt s x) = mixedEmbedding.norm x :=\n  norm_eq_of_normAtPlace_eq (fun w ‚Ü¶ normAtPlace_negAt _ _ w)\n\n"}
{"name":"NumberField.mixedEmbedding.negAt_symm","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.Basic","initialProofState":"K : Type u_1\ninst‚úù : Field K\ns : Set (Subtype fun w => w.IsReal)\n‚ä¢ Eq (NumberField.mixedEmbedding.negAt s).symm (NumberField.mixedEmbedding.negAt s)","decl":"/-- `negAt` is its own inverse. -/\n@[simp]\ntheorem negAt_symm :\n    (negAt s).symm = negAt s := by\n  ext x w\n  ¬∑ by_cases hw : w ‚àà s\n    ¬∑ simp_rw [negAt_apply_of_isReal_and_mem _ hw, negAt, prod_symm,\n        ContinuousLinearEquiv.prod_apply, piCongrRight_symm_apply, if_pos hw, symm_neg, neg_apply]\n    ¬∑ simp_rw [negAt_apply_of_isReal_and_not_mem _ hw, negAt, prod_symm,\n        ContinuousLinearEquiv.prod_apply, piCongrRight_symm_apply, if_neg hw, refl_symm, refl_apply]\n  ¬∑ rfl\n\n"}
{"name":"NumberField.mixedEmbedding.negAt_signSet_apply_of_isReal","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.Basic","initialProofState":"K : Type u_1\ninst‚úù : Field K\nx : NumberField.mixedEmbedding.mixedSpace K\nw : Subtype fun w => w.IsReal\n‚ä¢ Eq (((NumberField.mixedEmbedding.negAt (NumberField.mixedEmbedding.signSet x)) x).1 w) (abs (x.1 w))","decl":"@[simp]\ntheorem negAt_signSet_apply_of_isReal (x : mixedSpace K) (w : {w // IsReal w}) :\n    (negAt (signSet x) x).1 w = |x.1 w| := by\n  by_cases hw : x.1 w ‚â§ 0\n  ¬∑ rw [negAt_apply_of_isReal_and_mem _ hw, abs_of_nonpos hw]\n  ¬∑ rw [negAt_apply_of_isReal_and_not_mem _ hw, abs_of_pos (lt_of_not_ge hw)]\n\n"}
{"name":"NumberField.mixedEmbedding.negAt_signSet_apply_of_isComplex","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.Basic","initialProofState":"K : Type u_1\ninst‚úù : Field K\nx : NumberField.mixedEmbedding.mixedSpace K\nw : Subtype fun w => w.IsComplex\n‚ä¢ Eq (((NumberField.mixedEmbedding.negAt (NumberField.mixedEmbedding.signSet x)) x).2 w) (x.2 w)","decl":"@[simp]\ntheorem negAt_signSet_apply_of_isComplex (x : mixedSpace K) (w : {w // IsComplex w}) :\n    (negAt (signSet x) x).2 w = x.2 w := rfl\n\n"}
{"name":"NumberField.mixedEmbedding.negAt_preimage","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.Basic","initialProofState":"K : Type u_1\ninst‚úù : Field K\ns : Set (Subtype fun w => w.IsReal)\nA : Set (NumberField.mixedEmbedding.mixedSpace K)\n‚ä¢ Eq (Set.preimage (‚áë(NumberField.mixedEmbedding.negAt s)) A) (Set.image (‚áë(NumberField.mixedEmbedding.negAt s)) A)","decl":"variable (s) in\n /-- `negAt s A` is also equal to the preimage of `A` by `negAt s`. This fact is used to simplify\n some proofs. -/\n theorem negAt_preimage :\n    negAt s ‚Åª¬π' A = negAt s '' A := by\n  rw [ContinuousLinearEquiv.image_eq_preimage, negAt_symm]\n\n"}
{"name":"NumberField.mixedEmbedding.neg_of_mem_negA_plusPart","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.Basic","initialProofState":"K : Type u_1\ninst‚úù : Field K\ns : Set (Subtype fun w => w.IsReal)\nA : Set (NumberField.mixedEmbedding.mixedSpace K)\nx : NumberField.mixedEmbedding.mixedSpace K\nhx : Membership.mem (Set.image (‚áë(NumberField.mixedEmbedding.negAt s)) (NumberField.mixedEmbedding.plusPart A)) x\nw : Subtype fun w => w.IsReal\nhw : Membership.mem s w\n‚ä¢ LT.lt (x.1 w) 0","decl":"theorem neg_of_mem_negA_plusPart (hx : x ‚àà negAt s '' (plusPart A)) {w : {w // IsReal w}}\n    (hw : w ‚àà s) : x.1 w < 0 := by\n  obtain ‚ü®y, hy, rfl‚ü© := hx\n  rw [negAt_apply_of_isReal_and_mem _ hw, neg_lt_zero]\n  exact hy.2 w\n\n "}
{"name":"NumberField.mixedEmbedding.pos_of_not_mem_negAt_plusPart","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.Basic","initialProofState":"K : Type u_1\ninst‚úù : Field K\ns : Set (Subtype fun w => w.IsReal)\nA : Set (NumberField.mixedEmbedding.mixedSpace K)\nx : NumberField.mixedEmbedding.mixedSpace K\nhx : Membership.mem (Set.image (‚áë(NumberField.mixedEmbedding.negAt s)) (NumberField.mixedEmbedding.plusPart A)) x\nw : Subtype fun w => w.IsReal\nhw : Not (Membership.mem s w)\n‚ä¢ LT.lt 0 (x.1 w)","decl":"theorem pos_of_not_mem_negAt_plusPart (hx : x ‚àà negAt s '' (plusPart A)) {w : {w // IsReal w}}\n    (hw : w ‚àâ s) : 0 < x.1 w := by\n  obtain ‚ü®y, hy, rfl‚ü© := hx\n  rw [negAt_apply_of_isReal_and_not_mem _ hw]\n  exact hy.2 w\n\n"}
{"name":"NumberField.mixedEmbedding.disjoint_negAt_plusPart","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.Basic","initialProofState":"K : Type u_1\ninst‚úù : Field K\nA : Set (NumberField.mixedEmbedding.mixedSpace K)\n‚ä¢ Pairwise (Function.onFun Disjoint fun s => Set.image (‚áë(NumberField.mixedEmbedding.negAt s)) (NumberField.mixedEmbedding.plusPart A))","decl":"open scoped Function in -- required for scoped `on` notation\n /-- The images of `plusPart` by `negAt` are pairwise disjoint. -/\n theorem disjoint_negAt_plusPart : Pairwise (Disjoint on (fun s ‚Ü¶ negAt s '' (plusPart A))) := by\n  intro s t hst\n  refine Set.disjoint_left.mpr fun _ hx hx' ‚Ü¶ ?_\n  obtain ‚ü®w, hw | hw‚ü© : ‚àÉ w, (w ‚àà s ‚àß w ‚àâ t) ‚à® (w ‚àà t ‚àß w ‚àâ s) := by\n    exact Set.symmDiff_nonempty.mpr hst\n  ¬∑ exact lt_irrefl _ <|\n      (neg_of_mem_negA_plusPart A hx hw.1).trans (pos_of_not_mem_negAt_plusPart A hx' hw.2)\n  ¬∑ exact lt_irrefl _ <|\n      (neg_of_mem_negA_plusPart A hx' hw.1).trans (pos_of_not_mem_negAt_plusPart A hx hw.2)\n\n-- We will assume from now that `A` is symmetric at real places\n"}
{"name":"NumberField.mixedEmbedding.mem_negAt_plusPart_of_mem","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.Basic","initialProofState":"K : Type u_1\ninst‚úù : Field K\ns : Set (Subtype fun w => w.IsReal)\nA : Set (NumberField.mixedEmbedding.mixedSpace K)\nx : NumberField.mixedEmbedding.mixedSpace K\nhA : ‚àÄ (x : NumberField.mixedEmbedding.mixedSpace K), Iff (Membership.mem A x) (Membership.mem A { fst := fun w => abs (x.1 w), snd := x.2 })\nhx‚ÇÅ : Membership.mem A x\nhx‚ÇÇ : ‚àÄ (w : Subtype fun w => w.IsReal), Ne (x.1 w) 0\n‚ä¢ Iff (Membership.mem (Set.image (‚áë(NumberField.mixedEmbedding.negAt s)) (NumberField.mixedEmbedding.plusPart A)) x) (And (‚àÄ (w : Subtype fun w => w.IsReal), Membership.mem s w ‚Üí LT.lt (x.1 w) 0) (‚àÄ (w : Subtype fun w => w.IsReal), Not (Membership.mem s w) ‚Üí GT.gt (x.1 w) 0))","decl":"include hA in\ntheorem mem_negAt_plusPart_of_mem (hx‚ÇÅ : x ‚àà A) (hx‚ÇÇ : ‚àÄ w, x.1 w ‚â† 0) :\n    x ‚àà negAt s '' (plusPart A) ‚Üî (‚àÄ w, w ‚àà s ‚Üí x.1 w < 0) ‚àß (‚àÄ w, w ‚àâ s ‚Üí x.1 w > 0) := by\n  refine ‚ü®fun hx ‚Ü¶ ‚ü®fun _ hw ‚Ü¶ neg_of_mem_negA_plusPart A hx hw,\n      fun _ hw ‚Ü¶ pos_of_not_mem_negAt_plusPart A hx hw‚ü©,\n      fun ‚ü®h‚ÇÅ, h‚ÇÇ‚ü© ‚Ü¶ ‚ü®(fun w ‚Ü¶ |x.1 w|, x.2), ‚ü®(hA x).mp hx‚ÇÅ, fun w ‚Ü¶ abs_pos.mpr (hx‚ÇÇ w)‚ü©, ?_‚ü©‚ü©\n  ext w\n  ¬∑ by_cases hw : w ‚àà s\n    ¬∑ simp only [negAt_apply_of_isReal_and_mem _ hw, abs_of_neg (h‚ÇÅ w hw), neg_neg]\n    ¬∑ simp only [negAt_apply_of_isReal_and_not_mem _ hw, abs_of_pos (h‚ÇÇ w hw)]\n  ¬∑ rfl\n\n"}
{"name":"NumberField.mixedEmbedding.iUnion_negAt_plusPart_union","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.Basic","initialProofState":"K : Type u_1\ninst‚úù : Field K\nA : Set (NumberField.mixedEmbedding.mixedSpace K)\nhA : ‚àÄ (x : NumberField.mixedEmbedding.mixedSpace K), Iff (Membership.mem A x) (Membership.mem A { fst := fun w => abs (x.1 w), snd := x.2 })\n‚ä¢ Eq (Union.union (Set.iUnion fun s => Set.image (‚áë(NumberField.mixedEmbedding.negAt s)) (NumberField.mixedEmbedding.plusPart A)) (Inter.inter A (Set.iUnion fun w => setOf fun x => Eq (x.1 w) 0))) A","decl":"include hA in\n/-- Assume that `A`  is symmetric at real places then, the union of the images of `plusPart`\nby `negAt` and of the set of elements of `A` that are zero at at least one real place\nis equal to `A`. -/\ntheorem iUnion_negAt_plusPart_union :\n    (‚ãÉ s, negAt s '' (plusPart A)) ‚à™ (A ‚à© (‚ãÉ w, {x | x.1 w = 0})) = A := by\n  ext x\n  rw [Set.mem_union, Set.mem_inter_iff, Set.mem_iUnion, Set.mem_iUnion]\n  refine ‚ü®?_, fun h ‚Ü¶ ?_‚ü©\n  ¬∑ rintro (‚ü®s, ‚ü®x, ‚ü®hx, _‚ü©, rfl‚ü©‚ü© | h)\n    ¬∑ simp_rw (config := {singlePass := true}) [hA, negAt_apply_abs_of_isReal, negAt_apply_snd]\n      rwa [‚Üê hA]\n    ¬∑ exact h.left\n  ¬∑ obtain hx | hx := exists_or_forall_not (fun w ‚Ü¶ x.1 w = 0)\n    ¬∑ exact Or.inr ‚ü®h, hx‚ü©\n    ¬∑ refine Or.inl ‚ü®signSet x,\n        (mem_negAt_plusPart_of_mem A hA h hx).mpr ‚ü®fun w hw ‚Ü¶ ?_, fun w hw ‚Ü¶ ?_‚ü©‚ü©\n      ¬∑ exact lt_of_le_of_ne hw (hx w)\n      ¬∑ exact lt_of_le_of_ne (lt_of_not_ge hw).le (Ne.symm (hx w))\n\n"}
{"name":"NumberField.mixedEmbedding.iUnion_negAt_plusPart_ae","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.Basic","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\nA : Set (NumberField.mixedEmbedding.mixedSpace K)\nhA : ‚àÄ (x : NumberField.mixedEmbedding.mixedSpace K), Iff (Membership.mem A x) (Membership.mem A { fst := fun w => abs (x.1 w), snd := x.2 })\ninst‚úù : NumberField K\n‚ä¢ (MeasureTheory.ae MeasureTheory.MeasureSpace.volume).EventuallyEq (Set.iUnion fun s => Set.image (‚áë(NumberField.mixedEmbedding.negAt s)) (NumberField.mixedEmbedding.plusPart A)) A","decl":"include hA in\nopen Classical in\ntheorem iUnion_negAt_plusPart_ae :\n    ‚ãÉ s, negAt s '' (plusPart A) =·µê[volume] A := by\n  nth_rewrite 2 [‚Üê iUnion_negAt_plusPart_union A hA]\n  refine (MeasureTheory.union_ae_eq_left_of_ae_eq_empty (ae_eq_empty.mpr ?_)).symm\n  exact measure_mono_null Set.inter_subset_right\n    (measure_iUnion_null_iff.mpr fun _ ‚Ü¶ volume_eq_zero _)\n\n"}
{"name":"NumberField.mixedEmbedding.measurableSet_plusPart","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.Basic","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\nA : Set (NumberField.mixedEmbedding.mixedSpace K)\ninst‚úù : NumberField K\nhm : MeasurableSet A\n‚ä¢ MeasurableSet (NumberField.mixedEmbedding.plusPart A)","decl":"variable {A} in\ntheorem measurableSet_plusPart (hm : MeasurableSet A) :\n    MeasurableSet (plusPart A) := by\n  convert_to MeasurableSet (A ‚à© (‚ãÇ w, {x | 0 < x.1 w}))\n  ¬∑ ext; simp\n  ¬∑ refine hm.inter (MeasurableSet.iInter fun _ ‚Ü¶ ?_)\n    exact measurableSet_lt measurable_const ((measurable_pi_apply _).comp' measurable_fst)\n\n"}
{"name":"NumberField.mixedEmbedding.measurableSet_negAt_plusPart","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.Basic","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ns : Set (Subtype fun w => w.IsReal)\nA : Set (NumberField.mixedEmbedding.mixedSpace K)\ninst‚úù : NumberField K\nhm : MeasurableSet A\n‚ä¢ MeasurableSet (Set.image (‚áë(NumberField.mixedEmbedding.negAt s)) (NumberField.mixedEmbedding.plusPart A))","decl":"variable (s) in\ntheorem measurableSet_negAt_plusPart (hm : MeasurableSet A) :\n    MeasurableSet (negAt s '' (plusPart A)) :=\n  negAt_preimage s _ ‚ñ∏ (measurableSet_plusPart hm).preimage (negAt s).continuous.measurable\n\n"}
{"name":"NumberField.mixedEmbedding.volume_negAt_plusPart","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.Basic","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\ns : Set (Subtype fun w => w.IsReal)\nA : Set (NumberField.mixedEmbedding.mixedSpace K)\ninst‚úù : NumberField K\nhm : MeasurableSet A\n‚ä¢ Eq (MeasureTheory.MeasureSpace.volume (Set.image (‚áë(NumberField.mixedEmbedding.negAt s)) (NumberField.mixedEmbedding.plusPart A))) (MeasureTheory.MeasureSpace.volume (NumberField.mixedEmbedding.plusPart A))","decl":"open Classical in\n/-- The image of the `plusPart` of `A` by `negAt` have all the same volume as `plusPart A`. -/\ntheorem volume_negAt_plusPart (hm : MeasurableSet A) :\n    volume (negAt s '' (plusPart A)) = volume (plusPart A) := by\n  rw [‚Üê negAt_symm, ContinuousLinearEquiv.image_symm_eq_preimage,\n    volume_preserving_negAt.measure_preimage (measurableSet_plusPart hm).nullMeasurableSet]\n\n"}
{"name":"NumberField.mixedEmbedding.volume_eq_two_pow_mul_volume_plusPart","module":"Mathlib.NumberTheory.NumberField.CanonicalEmbedding.Basic","initialProofState":"K : Type u_1\ninst‚úù¬π : Field K\nA : Set (NumberField.mixedEmbedding.mixedSpace K)\nhA : ‚àÄ (x : NumberField.mixedEmbedding.mixedSpace K), Iff (Membership.mem A x) (Membership.mem A { fst := fun w => abs (x.1 w), snd := x.2 })\ninst‚úù : NumberField K\nhm : MeasurableSet A\n‚ä¢ Eq (MeasureTheory.MeasureSpace.volume A) (HMul.hMul (HPow.hPow 2 (NumberField.InfinitePlace.nrRealPlaces K)) (MeasureTheory.MeasureSpace.volume (NumberField.mixedEmbedding.plusPart A)))","decl":"include hA in\nopen Classical in\n/-- If a subset `A` of the `mixedSpace` is symmetric at real places, then its volume is\n`2^ nrRealPlaces K` times the volume of its `plusPart`. -/\ntheorem volume_eq_two_pow_mul_volume_plusPart (hm : MeasurableSet A) :\n    volume A = 2 ^ nrRealPlaces K * volume (plusPart A) := by\n  simp only [‚Üê measure_congr (iUnion_negAt_plusPart_ae A hA),\n    measure_iUnion (disjoint_negAt_plusPart A) (fun _ ‚Ü¶ measurableSet_negAt_plusPart _ A hm),\n    volume_negAt_plusPart _ hm, tsum_fintype, sum_const, card_univ, Fintype.card_set, nsmul_eq_mul,\n    Nat.cast_pow, Nat.cast_ofNat, nrRealPlaces]\n\n"}
