{"name":"Set.toFinset_prod","module":"Mathlib.Data.Fintype.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\ninst✝² : Fintype ↑s\ninst✝¹ : Fintype ↑t\ninst✝ : Fintype ↑(SProd.sprod s t)\n⊢ Eq (SProd.sprod s t).toFinset (SProd.sprod s.toFinset t.toFinset)","decl":"theorem toFinset_prod (s : Set α) (t : Set β) [Fintype s] [Fintype t] [Fintype (s ×ˢ t)] :\n    (s ×ˢ t).toFinset = s.toFinset ×ˢ t.toFinset := by\n  ext\n  simp\n\n"}
{"name":"Set.toFinset_off_diag","module":"Mathlib.Data.Fintype.Prod","initialProofState":"α : Type u_1\ns : Set α\ninst✝² : DecidableEq α\ninst✝¹ : Fintype ↑s\ninst✝ : Fintype ↑s.offDiag\n⊢ Eq s.offDiag.toFinset s.toFinset.offDiag","decl":"theorem toFinset_off_diag {s : Set α} [DecidableEq α] [Fintype s] [Fintype s.offDiag] :\n    s.offDiag.toFinset = s.toFinset.offDiag :=\n  Finset.ext <| by simp\n\n"}
{"name":"Finset.univ_product_univ","module":"Mathlib.Data.Fintype.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Fintype α\ninst✝ : Fintype β\n⊢ Eq (SProd.sprod Finset.univ Finset.univ) Finset.univ","decl":"@[simp] lemma univ_product_univ : univ ×ˢ univ = (univ : Finset (α × β)) := rfl\n\n"}
{"name":"Finset.product_eq_univ","module":"Mathlib.Data.Fintype.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : Fintype α\ninst✝² : Fintype β\ns : Finset α\nt : Finset β\ninst✝¹ : Nonempty α\ninst✝ : Nonempty β\n⊢ Iff (Eq (SProd.sprod s t) Finset.univ) (And (Eq s Finset.univ) (Eq t Finset.univ))","decl":"@[simp] lemma product_eq_univ [Nonempty α] [Nonempty β] : s ×ˢ t = univ ↔ s = univ ∧ t = univ := by\n  simp [eq_univ_iff_forall, forall_and]\n\n"}
{"name":"Fintype.card_prod","module":"Mathlib.Data.Fintype.Prod","initialProofState":"α : Type u_4\nβ : Type u_5\ninst✝¹ : Fintype α\ninst✝ : Fintype β\n⊢ Eq (Fintype.card (Prod α β)) (HMul.hMul (Fintype.card α) (Fintype.card β))","decl":"@[simp]\ntheorem Fintype.card_prod (α β : Type*) [Fintype α] [Fintype β] :\n    Fintype.card (α × β) = Fintype.card α * Fintype.card β :=\n  card_product _ _\n\n"}
{"name":"infinite_prod","module":"Mathlib.Data.Fintype.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\n⊢ Iff (Infinite (Prod α β)) (Or (And (Infinite α) (Nonempty β)) (And (Nonempty α) (Infinite β)))","decl":"@[simp]\ntheorem infinite_prod : Infinite (α × β) ↔ Infinite α ∧ Nonempty β ∨ Nonempty α ∧ Infinite β := by\n  refine\n    ⟨fun H => ?_, fun H =>\n      H.elim (and_imp.2 <| @Prod.infinite_of_left α β) (and_imp.2 <| @Prod.infinite_of_right α β)⟩\n  rw [and_comm]; contrapose! H; intro H'\n  rcases Infinite.nonempty (α × β) with ⟨a, b⟩\n  haveI := fintypeOfNotInfinite (H.1 ⟨b⟩); haveI := fintypeOfNotInfinite (H.2 ⟨a⟩)\n  exact H'.false\n\n"}
{"name":"Pi.infinite_of_left","module":"Mathlib.Data.Fintype.Prod","initialProofState":"ι : Sort u_4\nπ : ι → Type u_5\ninst✝¹ : ∀ (i : ι), Nontrivial (π i)\ninst✝ : Infinite ι\n⊢ Infinite ((i : ι) → π i)","decl":"instance Pi.infinite_of_left {ι : Sort*} {π : ι → Type*} [∀ i, Nontrivial <| π i] [Infinite ι] :\n    Infinite (∀ i : ι, π i) := by\n  classical\n  choose m n hm using fun i => exists_pair_ne (π i)\n  refine Infinite.of_injective (fun i => update m i (n i)) fun x y h => of_not_not fun hne => ?_\n  simp_rw [update_eq_iff, update_of_ne hne] at h\n  exact (hm x h.1.symm).elim\n\n"}
{"name":"Pi.infinite_of_exists_right","module":"Mathlib.Data.Fintype.Prod","initialProofState":"ι : Sort u_4\nπ : ι → Sort u_5\ni : ι\ninst✝¹ : Infinite (π i)\ninst✝ : ∀ (i : ι), Nonempty (π i)\n⊢ Infinite ((i : ι) → π i)","decl":"/-- If at least one `π i` is infinite and the rest nonempty, the pi type of all `π` is infinite. -/\ntheorem Pi.infinite_of_exists_right {ι : Sort*} {π : ι → Sort*} (i : ι) [Infinite <| π i]\n    [∀ i, Nonempty <| π i] : Infinite (∀ i : ι, π i) := by\n  classical\n  let ⟨m⟩ := @Pi.instNonempty ι π _\n  exact Infinite.of_injective _ (update_injective m i)\n\n"}
{"name":"Pi.infinite_of_right","module":"Mathlib.Data.Fintype.Prod","initialProofState":"ι : Sort u_4\nπ : ι → Type u_5\ninst✝¹ : ∀ (i : ι), Infinite (π i)\ninst✝ : Nonempty ι\n⊢ Infinite ((i : ι) → π i)","decl":"/-- See `Pi.infinite_of_exists_right` for the case that only one `π i` is infinite. -/\ninstance Pi.infinite_of_right {ι : Sort*} {π : ι → Type*} [∀ i, Infinite <| π i] [Nonempty ι] :\n    Infinite (∀ i : ι, π i) :=\n  Pi.infinite_of_exists_right (Classical.arbitrary ι)\n\n"}
{"name":"Function.infinite_of_left","module":"Mathlib.Data.Fintype.Prod","initialProofState":"ι : Sort u_4\nπ : Type u_5\ninst✝¹ : Nontrivial π\ninst✝ : Infinite ι\n⊢ Infinite (ι → π)","decl":"/-- Non-dependent version of `Pi.infinite_of_left`. -/\ninstance Function.infinite_of_left {ι : Sort*} {π : Type*} [Nontrivial π] [Infinite ι] :\n    Infinite (ι → π) :=\n  Pi.infinite_of_left\n\n"}
{"name":"Function.infinite_of_right","module":"Mathlib.Data.Fintype.Prod","initialProofState":"ι : Sort u_4\nπ : Type u_5\ninst✝¹ : Infinite π\ninst✝ : Nonempty ι\n⊢ Infinite (ι → π)","decl":"/-- Non-dependent version of `Pi.infinite_of_exists_right` and `Pi.infinite_of_right`. -/\ninstance Function.infinite_of_right {ι : Sort*} {π : Type*} [Infinite π] [Nonempty ι] :\n    Infinite (ι → π) :=\n  Pi.infinite_of_right\n\n"}
