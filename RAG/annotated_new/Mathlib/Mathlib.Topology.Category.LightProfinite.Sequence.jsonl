{"name":"LightProfinite.isClosedEmbedding_natUnionInftyEmbedding","module":"Mathlib.Topology.Category.LightProfinite.Sequence","initialProofState":"âŠ¢ Topology.IsClosedEmbedding â‡‘LightProfinite.natUnionInftyEmbedding","decl":"/--\nThe continuous map from `â„•âˆª{âˆ}` to `â„` sending `n` to `1/(n+1)` and `âˆ` to `0` is a closed\nembedding.\n-/\nlemma isClosedEmbedding_natUnionInftyEmbedding : IsClosedEmbedding natUnionInftyEmbedding := by\n  refine .of_continuous_injective_isClosedMap\n    natUnionInftyEmbedding.continuous ?_ ?_\n  Â· rintro (_|n) (_|m) h\n    Â· rfl\n    Â· simp only [natUnionInftyEmbedding, one_div, ContinuousMap.coe_mk, zero_eq_inv] at h\n      rw [â† Nat.cast_one, â† Nat.cast_add, eq_comm, Nat.cast_eq_zero] at h\n      simp at h\n    Â· simp only [natUnionInftyEmbedding, one_div, ContinuousMap.coe_mk, inv_eq_zero] at h\n      rw [â† Nat.cast_one, â† Nat.cast_add, Nat.cast_eq_zero] at h\n      simp at h\n    Â· simp only [natUnionInftyEmbedding, one_div, ContinuousMap.coe_mk, inv_inj, add_left_inj,\n        Nat.cast_inj] at h\n      rw [h]\n  Â· exact fun _ hC => (hC.isCompact.image natUnionInftyEmbedding.continuous).isClosed\n\n"}
{"name":"LightProfinite.closedEmbedding_natUnionInftyEmbedding","module":"Mathlib.Topology.Category.LightProfinite.Sequence","initialProofState":"âŠ¢ Topology.IsClosedEmbedding â‡‘LightProfinite.natUnionInftyEmbedding","decl":"@[deprecated (since := \"2024-10-20\")]\nalias closedEmbedding_natUnionInftyEmbedding := isClosedEmbedding_natUnionInftyEmbedding\n\n"}
{"name":"LightProfinite.instMetrizableSpaceOnePointNat","module":"Mathlib.Topology.Category.LightProfinite.Sequence","initialProofState":"âŠ¢ TopologicalSpace.MetrizableSpace (OnePoint Nat)","decl":"instance : MetrizableSpace (OnePoint â„•) := isClosedEmbedding_natUnionInftyEmbedding.metrizableSpace\n\n"}
{"name":"LightProfinite.continuous_iff_convergent","module":"Mathlib.Topology.Category.LightProfinite.Sequence","initialProofState":"Y : Type u_1\ninstâœ : TopologicalSpace Y\nf : â†‘LightProfinite.NatUnionInfty.toTop â†’ Y\nâŠ¢ Iff (Continuous f) (Filter.Tendsto (fun x => f (Option.some x)) Filter.atTop (nhds (f OnePoint.infty)))","decl":"lemma continuous_iff_convergent {Y : Type*} [TopologicalSpace Y] (f : â„•âˆª{âˆ} â†’ Y) :\n    Continuous f â†” Tendsto (fun x : â„• â†¦ f x) atTop (ğ“ (f âˆ)) :=\n  continuous_iff_from_nat f\n\n"}
