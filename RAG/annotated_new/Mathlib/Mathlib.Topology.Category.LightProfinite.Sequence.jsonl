{"name":"LightProfinite.isClosedEmbedding_natUnionInftyEmbedding","module":"Mathlib.Topology.Category.LightProfinite.Sequence","initialProofState":"⊢ Topology.IsClosedEmbedding ⇑LightProfinite.natUnionInftyEmbedding","decl":"/--\nThe continuous map from `ℕ∪{∞}` to `ℝ` sending `n` to `1/(n+1)` and `∞` to `0` is a closed\nembedding.\n-/\nlemma isClosedEmbedding_natUnionInftyEmbedding : IsClosedEmbedding natUnionInftyEmbedding := by\n  refine .of_continuous_injective_isClosedMap\n    natUnionInftyEmbedding.continuous ?_ ?_\n  · rintro (_|n) (_|m) h\n    · rfl\n    · simp only [natUnionInftyEmbedding, one_div, ContinuousMap.coe_mk, zero_eq_inv] at h\n      rw [← Nat.cast_one, ← Nat.cast_add, eq_comm, Nat.cast_eq_zero] at h\n      simp at h\n    · simp only [natUnionInftyEmbedding, one_div, ContinuousMap.coe_mk, inv_eq_zero] at h\n      rw [← Nat.cast_one, ← Nat.cast_add, Nat.cast_eq_zero] at h\n      simp at h\n    · simp only [natUnionInftyEmbedding, one_div, ContinuousMap.coe_mk, inv_inj, add_left_inj,\n        Nat.cast_inj] at h\n      rw [h]\n  · exact fun _ hC => (hC.isCompact.image natUnionInftyEmbedding.continuous).isClosed\n\n"}
{"name":"LightProfinite.closedEmbedding_natUnionInftyEmbedding","module":"Mathlib.Topology.Category.LightProfinite.Sequence","initialProofState":"⊢ Topology.IsClosedEmbedding ⇑LightProfinite.natUnionInftyEmbedding","decl":"@[deprecated (since := \"2024-10-20\")]\nalias closedEmbedding_natUnionInftyEmbedding := isClosedEmbedding_natUnionInftyEmbedding\n\n"}
{"name":"LightProfinite.instMetrizableSpaceOnePointNat","module":"Mathlib.Topology.Category.LightProfinite.Sequence","initialProofState":"⊢ TopologicalSpace.MetrizableSpace (OnePoint Nat)","decl":"instance : MetrizableSpace (OnePoint ℕ) := isClosedEmbedding_natUnionInftyEmbedding.metrizableSpace\n\n"}
{"name":"LightProfinite.continuous_iff_convergent","module":"Mathlib.Topology.Category.LightProfinite.Sequence","initialProofState":"Y : Type u_1\ninst✝ : TopologicalSpace Y\nf : ↑LightProfinite.NatUnionInfty.toTop → Y\n⊢ Iff (Continuous f) (Filter.Tendsto (fun x => f (Option.some x)) Filter.atTop (nhds (f OnePoint.infty)))","decl":"lemma continuous_iff_convergent {Y : Type*} [TopologicalSpace Y] (f : ℕ∪{∞} → Y) :\n    Continuous f ↔ Tendsto (fun x : ℕ ↦ f x) atTop (𝓝 (f ∞)) :=\n  continuous_iff_from_nat f\n\n"}
