{"name":"NonemptyFiniteLinearOrder.Nonempty","module":"Mathlib.Order.Category.NonemptyFinLinOrd","initialProofState":"α : Type u_1\nself : NonemptyFiniteLinearOrder α\n⊢ Nonempty α","decl":"/-- A typeclass for nonempty finite linear orders. -/\nclass NonemptyFiniteLinearOrder (α : Type*) extends Fintype α, LinearOrder α where\n  Nonempty : Nonempty α := by infer_instance\n\n"}
{"name":"NonemptyFinLinOrd.instParentProjectionLinearOrderNonemptyFiniteLinearOrderToLinearOrder","module":"Mathlib.Order.Category.NonemptyFinLinOrd","initialProofState":"⊢ CategoryTheory.BundledHom.ParentProjection @NonemptyFiniteLinearOrder.toLinearOrder","decl":"instance : BundledHom.ParentProjection @NonemptyFiniteLinearOrder.toLinearOrder :=\n  ⟨⟩\n\n"}
{"name":"NonemptyFinLinOrd.coe_of","module":"Mathlib.Order.Category.NonemptyFinLinOrd","initialProofState":"α : Type u_1\ninst✝ : NonemptyFiniteLinearOrder α\n⊢ Eq (↑(NonemptyFinLinOrd.of α)) α","decl":"@[simp]\ntheorem coe_of (α : Type*) [NonemptyFiniteLinearOrder α] : ↥(of α) = α :=\n  rfl\n\n"}
{"name":"NonemptyFinLinOrd.Iso.mk_inv","module":"Mathlib.Order.Category.NonemptyFinLinOrd","initialProofState":"α β : NonemptyFinLinOrd\ne : OrderIso ↑α ↑β\n⊢ Eq (NonemptyFinLinOrd.Iso.mk e).inv ↑e.symm","decl":"/-- Constructs an equivalence between nonempty finite linear orders from an order isomorphism\nbetween them. -/\n@[simps]\ndef Iso.mk {α β : NonemptyFinLinOrd.{u}} (e : α ≃o β) : α ≅ β where\n  hom := (e : OrderHom _ _)\n  inv := (e.symm : OrderHom _ _)\n  hom_inv_id := by\n    ext x\n    exact e.symm_apply_apply x\n  inv_hom_id := by\n    ext x\n    exact e.apply_symm_apply x\n\n"}
{"name":"NonemptyFinLinOrd.Iso.mk_hom","module":"Mathlib.Order.Category.NonemptyFinLinOrd","initialProofState":"α β : NonemptyFinLinOrd\ne : OrderIso ↑α ↑β\n⊢ Eq (NonemptyFinLinOrd.Iso.mk e).hom ↑e","decl":"/-- Constructs an equivalence between nonempty finite linear orders from an order isomorphism\nbetween them. -/\n@[simps]\ndef Iso.mk {α β : NonemptyFinLinOrd.{u}} (e : α ≃o β) : α ≅ β where\n  hom := (e : OrderHom _ _)\n  inv := (e.symm : OrderHom _ _)\n  hom_inv_id := by\n    ext x\n    exact e.symm_apply_apply x\n  inv_hom_id := by\n    ext x\n    exact e.apply_symm_apply x\n\n"}
{"name":"NonemptyFinLinOrd.dual_obj","module":"Mathlib.Order.Category.NonemptyFinLinOrd","initialProofState":"X : NonemptyFinLinOrd\n⊢ Eq (NonemptyFinLinOrd.dual.obj X) (NonemptyFinLinOrd.of (OrderDual ↑X))","decl":"/-- `OrderDual` as a functor. -/\n@[simps]\ndef dual : NonemptyFinLinOrd ⥤ NonemptyFinLinOrd where\n  obj X := of Xᵒᵈ\n  map := OrderHom.dual\n\n"}
{"name":"NonemptyFinLinOrd.dual_map","module":"Mathlib.Order.Category.NonemptyFinLinOrd","initialProofState":"X✝ Y✝ : NonemptyFinLinOrd\na : OrderHom ↑X✝ ↑Y✝\n⊢ Eq (NonemptyFinLinOrd.dual.map a) (OrderHom.dual a)","decl":"/-- `OrderDual` as a functor. -/\n@[simps]\ndef dual : NonemptyFinLinOrd ⥤ NonemptyFinLinOrd where\n  obj X := of Xᵒᵈ\n  map := OrderHom.dual\n\n"}
{"name":"NonemptyFinLinOrd.dualEquiv_functor","module":"Mathlib.Order.Category.NonemptyFinLinOrd","initialProofState":"⊢ Eq NonemptyFinLinOrd.dualEquiv.functor NonemptyFinLinOrd.dual","decl":"/-- The equivalence between `NonemptyFinLinOrd` and itself induced by `OrderDual` both ways. -/\n@[simps functor inverse]\ndef dualEquiv : NonemptyFinLinOrd ≌ NonemptyFinLinOrd where\n  functor := dual\n  inverse := dual\n  unitIso := NatIso.ofComponents fun X => Iso.mk <| OrderIso.dualDual X\n  counitIso := NatIso.ofComponents fun X => Iso.mk <| OrderIso.dualDual X\n\n"}
{"name":"NonemptyFinLinOrd.dualEquiv_inverse","module":"Mathlib.Order.Category.NonemptyFinLinOrd","initialProofState":"⊢ Eq NonemptyFinLinOrd.dualEquiv.inverse NonemptyFinLinOrd.dual","decl":"/-- The equivalence between `NonemptyFinLinOrd` and itself induced by `OrderDual` both ways. -/\n@[simps functor inverse]\ndef dualEquiv : NonemptyFinLinOrd ≌ NonemptyFinLinOrd where\n  functor := dual\n  inverse := dual\n  unitIso := NatIso.ofComponents fun X => Iso.mk <| OrderIso.dualDual X\n  counitIso := NatIso.ofComponents fun X => Iso.mk <| OrderIso.dualDual X\n\n"}
{"name":"NonemptyFinLinOrd.instOrderHomClassHomαNonemptyFiniteLinearOrder","module":"Mathlib.Order.Category.NonemptyFinLinOrd","initialProofState":"A B : NonemptyFinLinOrd\n⊢ OrderHomClass (Quiver.Hom A B) ↑A ↑B","decl":"instance {A B : NonemptyFinLinOrd.{u}} : OrderHomClass (A ⟶ B) A B where\n  map_rel f _ _ h := f.monotone h\n\n"}
{"name":"NonemptyFinLinOrd.mono_iff_injective","module":"Mathlib.Order.Category.NonemptyFinLinOrd","initialProofState":"A B : NonemptyFinLinOrd\nf : Quiver.Hom A B\n⊢ Iff (CategoryTheory.Mono f) (Function.Injective ⇑f)","decl":"theorem mono_iff_injective {A B : NonemptyFinLinOrd.{u}} (f : A ⟶ B) :\n    Mono f ↔ Function.Injective f := by\n  refine ⟨?_, ConcreteCategory.mono_of_injective f⟩\n  intro\n  intro a₁ a₂ h\n  let X := NonemptyFinLinOrd.of (ULift (Fin 1))\n  let g₁ : X ⟶ A := ⟨fun _ => a₁, fun _ _ _ => by rfl⟩\n  let g₂ : X ⟶ A := ⟨fun _ => a₂, fun _ _ _ => by rfl⟩\n  change g₁ (ULift.up (0 : Fin 1)) = g₂ (ULift.up (0 : Fin 1))\n  have eq : g₁ ≫ f = g₂ ≫ f := by\n    ext\n    exact h\n  rw [cancel_mono] at eq\n  rw [eq]\n\n-- Porting note: added to ease the following proof\n"}
{"name":"NonemptyFinLinOrd.forget_map_apply","module":"Mathlib.Order.Category.NonemptyFinLinOrd","initialProofState":"A B : NonemptyFinLinOrd\nf : Quiver.Hom A B\na : ↑A\n⊢ Eq ((CategoryTheory.forget NonemptyFinLinOrd).map f a) (f.toFun a)","decl":"lemma forget_map_apply {A B : NonemptyFinLinOrd.{u}} (f : A ⟶ B) (a : A) :\n    (forget NonemptyFinLinOrd).map f a = (f : OrderHom A B).toFun a := rfl\n\n"}
{"name":"NonemptyFinLinOrd.epi_iff_surjective","module":"Mathlib.Order.Category.NonemptyFinLinOrd","initialProofState":"A B : NonemptyFinLinOrd\nf : Quiver.Hom A B\n⊢ Iff (CategoryTheory.Epi f) (Function.Surjective ⇑f)","decl":"theorem epi_iff_surjective {A B : NonemptyFinLinOrd.{u}} (f : A ⟶ B) :\n    Epi f ↔ Function.Surjective f := by\n  constructor\n  · intro\n    dsimp only [Function.Surjective]\n    by_contra! hf'\n    rcases hf' with ⟨m, hm⟩\n    let Y := NonemptyFinLinOrd.of (ULift (Fin 2))\n    let p₁ : B ⟶ Y :=\n      ⟨fun b => if b < m then ULift.up 0 else ULift.up 1, fun x₁ x₂ h => by\n        simp only\n        split_ifs with h₁ h₂ h₂\n        any_goals apply Fin.zero_le\n        · exfalso\n          exact h₁ (lt_of_le_of_lt h h₂)\n        · rfl⟩\n    let p₂ : B ⟶ Y :=\n      ⟨fun b => if b ≤ m then ULift.up 0 else ULift.up 1, fun x₁ x₂ h => by\n        simp only\n        split_ifs with h₁ h₂ h₂\n        any_goals apply Fin.zero_le\n        · exfalso\n          exact h₁ (h.trans h₂)\n        · rfl⟩\n    have h : p₁ m = p₂ m := by\n      congr\n      rw [← cancel_epi f]\n      ext a\n      simp only [CategoryTheory.comp_apply]\n      change ite _ _ _ = ite _ _ _\n      split_ifs with h₁ h₂ h₂\n      any_goals rfl\n      · exfalso\n        exact h₂ (le_of_lt h₁)\n      · exfalso\n        exact hm a (eq_of_le_of_not_lt h₂ h₁)\n    simp [Y, p₁, p₂, DFunLike.coe] at h\n  · intro h\n    exact ConcreteCategory.epi_of_surjective f h\n\n"}
{"name":"NonemptyFinLinOrd.instSplitEpiCategory","module":"Mathlib.Order.Category.NonemptyFinLinOrd","initialProofState":"⊢ CategoryTheory.SplitEpiCategory NonemptyFinLinOrd","decl":"instance : SplitEpiCategory NonemptyFinLinOrd.{u} :=\n  ⟨fun {X Y} f hf => by\n    have H : ∀ y : Y, Nonempty (f ⁻¹' {y}) := by\n      rw [epi_iff_surjective] at hf\n      intro y\n      exact Nonempty.intro ⟨(hf y).choose, (hf y).choose_spec⟩\n    let φ : Y → X := fun y => (H y).some.1\n    have hφ : ∀ y : Y, f (φ y) = y := fun y => (H y).some.2\n    refine IsSplitEpi.mk' ⟨⟨φ, ?_⟩, ?_⟩\n    swap\n    · ext b\n      apply hφ\n    · intro a b\n      contrapose\n      intro h\n      simp only [not_le] at h ⊢\n      suffices b ≤ a by\n        apply lt_of_le_of_ne this\n        rintro rfl\n        exfalso\n        simp at h\n      have H : f (φ b) ≤ f (φ a) := f.monotone (le_of_lt h)\n      simpa only [hφ] using H⟩\n\n"}
{"name":"NonemptyFinLinOrd.instHasStrongEpiMonoFactorisations","module":"Mathlib.Order.Category.NonemptyFinLinOrd","initialProofState":"⊢ CategoryTheory.Limits.HasStrongEpiMonoFactorisations NonemptyFinLinOrd","decl":"instance : HasStrongEpiMonoFactorisations NonemptyFinLinOrd.{u} :=\n  ⟨fun {X Y} f => by\n    letI : NonemptyFiniteLinearOrder (Set.image f ⊤) := ⟨by infer_instance⟩\n    let I := NonemptyFinLinOrd.of (Set.image f ⊤)\n    let e : X ⟶ I := ⟨fun x => ⟨f x, ⟨x, by tauto⟩⟩, fun x₁ x₂ h => f.monotone h⟩\n    let m : I ⟶ Y := ⟨fun y => y.1, by tauto⟩\n    haveI : Epi e := by\n      rw [epi_iff_surjective]\n      rintro ⟨_, y, h, rfl⟩\n      exact ⟨y, rfl⟩\n    haveI : StrongEpi e := strongEpi_of_epi e\n    haveI : Mono m := ConcreteCategory.mono_of_injective _ (fun x y h => Subtype.ext h)\n    exact ⟨⟨I, m, e, rfl⟩⟩⟩\n\n"}
{"name":"nonemptyFinLinOrd_dual_comp_forget_to_linOrd","module":"Mathlib.Order.Category.NonemptyFinLinOrd","initialProofState":"⊢ Eq (NonemptyFinLinOrd.dual.comp (CategoryTheory.forget₂ NonemptyFinLinOrd LinOrd)) ((CategoryTheory.forget₂ NonemptyFinLinOrd LinOrd).comp LinOrd.dual)","decl":"theorem nonemptyFinLinOrd_dual_comp_forget_to_linOrd :\n    NonemptyFinLinOrd.dual ⋙ forget₂ NonemptyFinLinOrd LinOrd =\n      forget₂ NonemptyFinLinOrd LinOrd ⋙ LinOrd.dual :=\n  rfl\n\n"}
