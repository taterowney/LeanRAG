{"name":"Function.directed_ptsOfPeriod_pNat","module":"Mathlib.Dynamics.PeriodicPts.Lemmas","initialProofState":"α : Type u_1\nf : α → α\n⊢ Directed (fun x1 x2 => HasSubset.Subset x1 x2) fun n => Function.ptsOfPeriod f ↑n","decl":"theorem directed_ptsOfPeriod_pNat (f : α → α) : Directed (· ⊆ ·) fun n : ℕ+ => ptsOfPeriod f n :=\n  fun m n => ⟨m * n, fun _ hx => hx.mul_const n, fun _ hx => hx.const_mul m⟩\n\n"}
{"name":"Function.bijOn_periodicPts","module":"Mathlib.Dynamics.PeriodicPts.Lemmas","initialProofState":"α : Type u_1\nf : α → α\n⊢ Set.BijOn f (Function.periodicPts f) (Function.periodicPts f)","decl":"variable (f) in\ntheorem bijOn_periodicPts : BijOn f (periodicPts f) (periodicPts f) :=\n  iUnion_pNat_ptsOfPeriod f ▸\n    bijOn_iUnion_of_directed (directed_ptsOfPeriod_pNat f) fun i => bijOn_ptsOfPeriod f i.pos\n\n"}
{"name":"Function.minimalPeriod_eq_prime","module":"Mathlib.Dynamics.PeriodicPts.Lemmas","initialProofState":"α : Type u_1\nf : α → α\nx : α\np : Nat\nhp : Fact (Nat.Prime p)\nhper : Function.IsPeriodicPt f p x\nhfix : Not (Function.IsFixedPt f x)\n⊢ Eq (Function.minimalPeriod f x) p","decl":"theorem minimalPeriod_eq_prime {p : ℕ} [hp : Fact p.Prime] (hper : IsPeriodicPt f p x)\n    (hfix : ¬IsFixedPt f x) : minimalPeriod f x = p :=\n  (hp.out.eq_one_or_self_of_dvd _ hper.minimalPeriod_dvd).resolve_left\n    (mt minimalPeriod_eq_one_iff_isFixedPt.1 hfix)\n\n"}
{"name":"Function.minimalPeriod_eq_prime_pow","module":"Mathlib.Dynamics.PeriodicPts.Lemmas","initialProofState":"α : Type u_1\nf : α → α\nx : α\np k : Nat\nhp : Fact (Nat.Prime p)\nhk : Not (Function.IsPeriodicPt f (HPow.hPow p k) x)\nhk1 : Function.IsPeriodicPt f (HPow.hPow p (HAdd.hAdd k 1)) x\n⊢ Eq (Function.minimalPeriod f x) (HPow.hPow p (HAdd.hAdd k 1))","decl":"theorem minimalPeriod_eq_prime_pow {p k : ℕ} [hp : Fact p.Prime] (hk : ¬IsPeriodicPt f (p ^ k) x)\n    (hk1 : IsPeriodicPt f (p ^ (k + 1)) x) : minimalPeriod f x = p ^ (k + 1) := by\n  apply Nat.eq_prime_pow_of_dvd_least_prime_pow hp.out <;>\n    rwa [← isPeriodicPt_iff_minimalPeriod_dvd]\n\n"}
{"name":"Function.Commute.minimalPeriod_of_comp_dvd_mul","module":"Mathlib.Dynamics.PeriodicPts.Lemmas","initialProofState":"α : Type u_1\nf : α → α\nx : α\ng : α → α\nh : Function.Commute f g\n⊢ Dvd.dvd (Function.minimalPeriod (Function.comp f g) x) (HMul.hMul (Function.minimalPeriod f x) (Function.minimalPeriod g x))","decl":"theorem Commute.minimalPeriod_of_comp_dvd_mul {g : α → α} (h : Commute f g) :\n    minimalPeriod (f ∘ g) x ∣ minimalPeriod f x * minimalPeriod g x :=\n  dvd_trans h.minimalPeriod_of_comp_dvd_lcm (lcm_dvd_mul _ _)\n\n"}
{"name":"Function.Commute.minimalPeriod_of_comp_eq_mul_of_coprime","module":"Mathlib.Dynamics.PeriodicPts.Lemmas","initialProofState":"α : Type u_1\nf : α → α\nx : α\ng : α → α\nh : Function.Commute f g\nhco : (Function.minimalPeriod f x).Coprime (Function.minimalPeriod g x)\n⊢ Eq (Function.minimalPeriod (Function.comp f g) x) (HMul.hMul (Function.minimalPeriod f x) (Function.minimalPeriod g x))","decl":"theorem Commute.minimalPeriod_of_comp_eq_mul_of_coprime {g : α → α} (h : Commute f g)\n    (hco : Coprime (minimalPeriod f x) (minimalPeriod g x)) :\n    minimalPeriod (f ∘ g) x = minimalPeriod f x * minimalPeriod g x := by\n  apply h.minimalPeriod_of_comp_dvd_mul.antisymm\n  suffices\n    ∀ {f g : α → α},\n      Commute f g →\n        Coprime (minimalPeriod f x) (minimalPeriod g x) →\n          minimalPeriod f x ∣ minimalPeriod (f ∘ g) x from\n    hco.mul_dvd_of_dvd_of_dvd (this h hco) (h.comp_eq.symm ▸ this h.symm hco.symm)\n  intro f g h hco\n  refine hco.dvd_of_dvd_mul_left (IsPeriodicPt.left_of_comp h ?_ ?_).minimalPeriod_dvd\n  · exact (isPeriodicPt_minimalPeriod _ _).const_mul _\n  · exact (isPeriodicPt_minimalPeriod _ _).mul_const _\n\n"}
{"name":"Function.minimalPeriod_prod_map","module":"Mathlib.Dynamics.PeriodicPts.Lemmas","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → α\ng : β → β\nx : Prod α β\n⊢ Eq (Function.minimalPeriod (Prod.map f g) x) ((Function.minimalPeriod f x.1).lcm (Function.minimalPeriod g x.2))","decl":"theorem minimalPeriod_prod_map (f : α → α) (g : β → β) (x : α × β) :\n    minimalPeriod (Prod.map f g) x = (minimalPeriod f x.1).lcm (minimalPeriod g x.2) :=\n  eq_of_forall_dvd <| by cases x; simp [← isPeriodicPt_iff_minimalPeriod_dvd, Nat.lcm_dvd_iff]\n\n"}
{"name":"Function.minimalPeriod_fst_dvd","module":"Mathlib.Dynamics.PeriodicPts.Lemmas","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → α\ng : β → β\nx : Prod α β\n⊢ Dvd.dvd (Function.minimalPeriod f x.1) (Function.minimalPeriod (Prod.map f g) x)","decl":"theorem minimalPeriod_fst_dvd : minimalPeriod f x.1 ∣ minimalPeriod (Prod.map f g) x := by\n  rw [minimalPeriod_prod_map]; exact Nat.dvd_lcm_left _ _\n\n"}
{"name":"Function.minimalPeriod_snd_dvd","module":"Mathlib.Dynamics.PeriodicPts.Lemmas","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → α\ng : β → β\nx : Prod α β\n⊢ Dvd.dvd (Function.minimalPeriod g x.2) (Function.minimalPeriod (Prod.map f g) x)","decl":"theorem minimalPeriod_snd_dvd : minimalPeriod g x.2 ∣ minimalPeriod (Prod.map f g) x := by\n  rw [minimalPeriod_prod_map]; exact Nat.dvd_lcm_right _ _\n\n"}
