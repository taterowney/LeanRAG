{"name":"ConvexOn.map_centerMass_le","module":"Mathlib.Analysis.Convex.Jensen","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nβ : Type u_4\nι : Type u_5\ninst✝⁵ : LinearOrderedField 𝕜\ninst✝⁴ : AddCommGroup E\ninst✝³ : OrderedAddCommGroup β\ninst✝² : Module 𝕜 E\ninst✝¹ : Module 𝕜 β\ninst✝ : OrderedSMul 𝕜 β\ns : Set E\nf : E → β\nt : Finset ι\nw : ι → 𝕜\np : ι → E\nhf : ConvexOn 𝕜 s f\nh₀ : ∀ (i : ι), Membership.mem t i → LE.le 0 (w i)\nh₁ : LT.lt 0 (t.sum fun i => w i)\nhmem : ∀ (i : ι), Membership.mem t i → Membership.mem s (p i)\n⊢ LE.le (f (t.centerMass w p)) (t.centerMass w (Function.comp f p))","decl":"/-- Convex **Jensen's inequality**, `Finset.centerMass` version. -/\ntheorem ConvexOn.map_centerMass_le (hf : ConvexOn 𝕜 s f) (h₀ : ∀ i ∈ t, 0 ≤ w i)\n    (h₁ : 0 < ∑ i ∈ t, w i) (hmem : ∀ i ∈ t, p i ∈ s) :\n    f (t.centerMass w p) ≤ t.centerMass w (f ∘ p) := by\n  have hmem' : ∀ i ∈ t, (p i, (f ∘ p) i) ∈ { p : E × β | p.1 ∈ s ∧ f p.1 ≤ p.2 } := fun i hi =>\n    ⟨hmem i hi, le_rfl⟩\n  convert (hf.convex_epigraph.centerMass_mem h₀ h₁ hmem').2 <;>\n    simp only [centerMass, Function.comp, Prod.smul_fst, Prod.fst_sum, Prod.smul_snd, Prod.snd_sum]\n\n"}
{"name":"ConcaveOn.le_map_centerMass","module":"Mathlib.Analysis.Convex.Jensen","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nβ : Type u_4\nι : Type u_5\ninst✝⁵ : LinearOrderedField 𝕜\ninst✝⁴ : AddCommGroup E\ninst✝³ : OrderedAddCommGroup β\ninst✝² : Module 𝕜 E\ninst✝¹ : Module 𝕜 β\ninst✝ : OrderedSMul 𝕜 β\ns : Set E\nf : E → β\nt : Finset ι\nw : ι → 𝕜\np : ι → E\nhf : ConcaveOn 𝕜 s f\nh₀ : ∀ (i : ι), Membership.mem t i → LE.le 0 (w i)\nh₁ : LT.lt 0 (t.sum fun i => w i)\nhmem : ∀ (i : ι), Membership.mem t i → Membership.mem s (p i)\n⊢ LE.le (t.centerMass w (Function.comp f p)) (f (t.centerMass w p))","decl":"/-- Concave **Jensen's inequality**, `Finset.centerMass` version. -/\ntheorem ConcaveOn.le_map_centerMass (hf : ConcaveOn 𝕜 s f) (h₀ : ∀ i ∈ t, 0 ≤ w i)\n    (h₁ : 0 < ∑ i ∈ t, w i) (hmem : ∀ i ∈ t, p i ∈ s) :\n    t.centerMass w (f ∘ p) ≤ f (t.centerMass w p) :=\n  ConvexOn.map_centerMass_le (β := βᵒᵈ) hf h₀ h₁ hmem\n\n"}
{"name":"ConvexOn.map_sum_le","module":"Mathlib.Analysis.Convex.Jensen","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nβ : Type u_4\nι : Type u_5\ninst✝⁵ : LinearOrderedField 𝕜\ninst✝⁴ : AddCommGroup E\ninst✝³ : OrderedAddCommGroup β\ninst✝² : Module 𝕜 E\ninst✝¹ : Module 𝕜 β\ninst✝ : OrderedSMul 𝕜 β\ns : Set E\nf : E → β\nt : Finset ι\nw : ι → 𝕜\np : ι → E\nhf : ConvexOn 𝕜 s f\nh₀ : ∀ (i : ι), Membership.mem t i → LE.le 0 (w i)\nh₁ : Eq (t.sum fun i => w i) 1\nhmem : ∀ (i : ι), Membership.mem t i → Membership.mem s (p i)\n⊢ LE.le (f (t.sum fun i => HSMul.hSMul (w i) (p i))) (t.sum fun i => HSMul.hSMul (w i) (f (p i)))","decl":"/-- Convex **Jensen's inequality**, `Finset.sum` version. -/\ntheorem ConvexOn.map_sum_le (hf : ConvexOn 𝕜 s f) (h₀ : ∀ i ∈ t, 0 ≤ w i) (h₁ : ∑ i ∈ t, w i = 1)\n    (hmem : ∀ i ∈ t, p i ∈ s) : f (∑ i ∈ t, w i • p i) ≤ ∑ i ∈ t, w i • f (p i) := by\n  simpa only [centerMass, h₁, inv_one, one_smul] using\n    hf.map_centerMass_le h₀ (h₁.symm ▸ zero_lt_one) hmem\n\n"}
{"name":"ConcaveOn.le_map_sum","module":"Mathlib.Analysis.Convex.Jensen","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nβ : Type u_4\nι : Type u_5\ninst✝⁵ : LinearOrderedField 𝕜\ninst✝⁴ : AddCommGroup E\ninst✝³ : OrderedAddCommGroup β\ninst✝² : Module 𝕜 E\ninst✝¹ : Module 𝕜 β\ninst✝ : OrderedSMul 𝕜 β\ns : Set E\nf : E → β\nt : Finset ι\nw : ι → 𝕜\np : ι → E\nhf : ConcaveOn 𝕜 s f\nh₀ : ∀ (i : ι), Membership.mem t i → LE.le 0 (w i)\nh₁ : Eq (t.sum fun i => w i) 1\nhmem : ∀ (i : ι), Membership.mem t i → Membership.mem s (p i)\n⊢ LE.le (t.sum fun i => HSMul.hSMul (w i) (f (p i))) (f (t.sum fun i => HSMul.hSMul (w i) (p i)))","decl":"/-- Concave **Jensen's inequality**, `Finset.sum` version. -/\ntheorem ConcaveOn.le_map_sum (hf : ConcaveOn 𝕜 s f) (h₀ : ∀ i ∈ t, 0 ≤ w i)\n    (h₁ : ∑ i ∈ t, w i = 1) (hmem : ∀ i ∈ t, p i ∈ s) :\n    (∑ i ∈ t, w i • f (p i)) ≤ f (∑ i ∈ t, w i • p i) :=\n  ConvexOn.map_sum_le (β := βᵒᵈ) hf h₀ h₁ hmem\n\n"}
{"name":"ConvexOn.map_add_sum_le","module":"Mathlib.Analysis.Convex.Jensen","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nβ : Type u_4\nι : Type u_5\ninst✝⁵ : LinearOrderedField 𝕜\ninst✝⁴ : AddCommGroup E\ninst✝³ : OrderedAddCommGroup β\ninst✝² : Module 𝕜 E\ninst✝¹ : Module 𝕜 β\ninst✝ : OrderedSMul 𝕜 β\ns : Set E\nf : E → β\nt : Finset ι\nw : ι → 𝕜\np : ι → E\nv : 𝕜\nq : E\nhf : ConvexOn 𝕜 s f\nh₀ : ∀ (i : ι), Membership.mem t i → LE.le 0 (w i)\nh₁ : Eq (HAdd.hAdd v (t.sum fun i => w i)) 1\nhmem : ∀ (i : ι), Membership.mem t i → Membership.mem s (p i)\nhv : LE.le 0 v\nhq : Membership.mem s q\n⊢ LE.le (f (HAdd.hAdd (HSMul.hSMul v q) (t.sum fun i => HSMul.hSMul (w i) (p i)))) (HAdd.hAdd (HSMul.hSMul v (f q)) (t.sum fun i => HSMul.hSMul (w i) (f (p i))))","decl":"/-- Convex **Jensen's inequality** where an element plays a distinguished role. -/\nlemma ConvexOn.map_add_sum_le (hf : ConvexOn 𝕜 s f) (h₀ : ∀ i ∈ t, 0 ≤ w i)\n    (h₁ : v + ∑ i ∈ t, w i = 1) (hmem : ∀ i ∈ t, p i ∈ s) (hv : 0 ≤ v) (hq : q ∈ s) :\n    f (v • q + ∑ i ∈ t, w i • p i) ≤ v • f q + ∑ i ∈ t, w i • f (p i) := by\n  let W j := Option.elim j v w\n  let P j := Option.elim j q p\n  have : f (∑ j ∈ insertNone t, W j • P j) ≤ ∑ j ∈ insertNone t, W j • f (P j) :=\n    hf.map_sum_le (forall_mem_insertNone.2 ⟨hv, h₀⟩) (by simpa using h₁)\n      (forall_mem_insertNone.2 ⟨hq, hmem⟩)\n  simpa using this\n\n"}
{"name":"ConcaveOn.map_add_sum_le","module":"Mathlib.Analysis.Convex.Jensen","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nβ : Type u_4\nι : Type u_5\ninst✝⁵ : LinearOrderedField 𝕜\ninst✝⁴ : AddCommGroup E\ninst✝³ : OrderedAddCommGroup β\ninst✝² : Module 𝕜 E\ninst✝¹ : Module 𝕜 β\ninst✝ : OrderedSMul 𝕜 β\ns : Set E\nf : E → β\nt : Finset ι\nw : ι → 𝕜\np : ι → E\nv : 𝕜\nq : E\nhf : ConcaveOn 𝕜 s f\nh₀ : ∀ (i : ι), Membership.mem t i → LE.le 0 (w i)\nh₁ : Eq (HAdd.hAdd v (t.sum fun i => w i)) 1\nhmem : ∀ (i : ι), Membership.mem t i → Membership.mem s (p i)\nhv : LE.le 0 v\nhq : Membership.mem s q\n⊢ LE.le (HAdd.hAdd (HSMul.hSMul v (f q)) (t.sum fun i => HSMul.hSMul (w i) (f (p i)))) (f (HAdd.hAdd (HSMul.hSMul v q) (t.sum fun i => HSMul.hSMul (w i) (p i))))","decl":"/-- Concave **Jensen's inequality** where an element plays a distinguished role. -/\nlemma ConcaveOn.map_add_sum_le (hf : ConcaveOn 𝕜 s f) (h₀ : ∀ i ∈ t, 0 ≤ w i)\n    (h₁ : v + ∑ i ∈ t, w i = 1) (hmem : ∀ i ∈ t, p i ∈ s) (hv : 0 ≤ v) (hq : q ∈ s) :\n    v • f q + ∑ i ∈ t, w i • f (p i) ≤ f (v • q + ∑ i ∈ t, w i • p i) :=\n  hf.dual.map_add_sum_le h₀ h₁ hmem hv hq\n\n"}
{"name":"StrictConvexOn.map_sum_lt","module":"Mathlib.Analysis.Convex.Jensen","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nβ : Type u_4\nι : Type u_5\ninst✝⁵ : LinearOrderedField 𝕜\ninst✝⁴ : AddCommGroup E\ninst✝³ : OrderedAddCommGroup β\ninst✝² : Module 𝕜 E\ninst✝¹ : Module 𝕜 β\ninst✝ : OrderedSMul 𝕜 β\ns : Set E\nf : E → β\nt : Finset ι\nw : ι → 𝕜\np : ι → E\nhf : StrictConvexOn 𝕜 s f\nh₀ : ∀ (i : ι), Membership.mem t i → LT.lt 0 (w i)\nh₁ : Eq (t.sum fun i => w i) 1\nhmem : ∀ (i : ι), Membership.mem t i → Membership.mem s (p i)\nhp : Exists fun j => And (Membership.mem t j) (Exists fun k => And (Membership.mem t k) (Ne (p j) (p k)))\n⊢ LT.lt (f (t.sum fun i => HSMul.hSMul (w i) (p i))) (t.sum fun i => HSMul.hSMul (w i) (f (p i)))","decl":"/-- Convex **strict Jensen inequality**.\n\nIf the function is strictly convex, the weights are strictly positive and the indexed family of\npoints is non-constant, then Jensen's inequality is strict.\n\nSee also `StrictConvexOn.map_sum_eq_iff`. -/\nlemma StrictConvexOn.map_sum_lt (hf : StrictConvexOn 𝕜 s f) (h₀ : ∀ i ∈ t, 0 < w i)\n    (h₁ : ∑ i ∈ t, w i = 1) (hmem : ∀ i ∈ t, p i ∈ s) (hp : ∃ j ∈ t, ∃ k ∈ t, p j ≠ p k) :\n    f (∑ i ∈ t, w i • p i) < ∑ i ∈ t, w i • f (p i) := by\n  classical\n  obtain ⟨j, hj, k, hk, hjk⟩ := hp\n  -- We replace `t` by `t \\ {j, k}`\n  have : k ∈ t.erase j := mem_erase.2 ⟨ne_of_apply_ne _ hjk.symm, hk⟩\n  let u := (t.erase j).erase k\n  have hj : j ∉ u := by simp [u]\n  have hk : k ∉ u := by simp [u]\n  have ht :\n      t = (u.cons k hk).cons j (mem_cons.not.2 <| not_or_intro (ne_of_apply_ne _ hjk) hj) := by\n    simp [u, insert_erase this, insert_erase ‹j ∈ t›, *]\n  clear_value u\n  subst ht\n  simp only [sum_cons]\n  have := h₀ j <| by simp\n  have := h₀ k <| by simp\n  let c := w j + w k\n  have hc : w j / c + w k / c = 1 := by field_simp [c]\n  calc f (w j • p j + (w k • p k + ∑ x ∈ u, w x • p x))\n    _ = f (c • ((w j / c) • p j + (w k / c) • p k) + ∑ x ∈ u, w x • p x) := by\n      congrm f ?_\n      match_scalars <;> field_simp\n    _ ≤ c • f ((w j / c) • p j + (w k / c) • p k) + ∑ x ∈ u, w x • f (p x) :=\n      -- apply the usual Jensen's inequality wrt the weighted average of the two distinguished\n      -- points and all the other points\n        hf.convexOn.map_add_sum_le (fun i hi ↦ (h₀ _ <| by simp [hi]).le)\n          (by simpa [-cons_eq_insert, ← add_assoc] using h₁)\n          (forall_of_forall_cons <| forall_of_forall_cons hmem) (by positivity) <| by\n           refine hf.1 (hmem _ <| by simp) (hmem _ <| by simp) ?_ ?_ hc <;> positivity\n    _ < c • ((w j / c) • f (p j) + (w k / c) • f (p k)) + ∑ x ∈ u, w x • f (p x) := by\n      -- then apply the definition of strict convexity for the two distinguished points\n      gcongr; refine hf.2 (hmem _ <| by simp) (hmem _ <| by simp) hjk ?_ ?_ hc <;> positivity\n    _ = (w j • f (p j) + w k • f (p k)) + ∑ x ∈ u, w x • f (p x) := by\n      match_scalars <;> field_simp\n    _ = w j • f (p j) + (w k • f (p k) + ∑ x ∈ u, w x • f (p x)) := by abel_nf\n\n"}
{"name":"StrictConcaveOn.lt_map_sum","module":"Mathlib.Analysis.Convex.Jensen","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nβ : Type u_4\nι : Type u_5\ninst✝⁵ : LinearOrderedField 𝕜\ninst✝⁴ : AddCommGroup E\ninst✝³ : OrderedAddCommGroup β\ninst✝² : Module 𝕜 E\ninst✝¹ : Module 𝕜 β\ninst✝ : OrderedSMul 𝕜 β\ns : Set E\nf : E → β\nt : Finset ι\nw : ι → 𝕜\np : ι → E\nhf : StrictConcaveOn 𝕜 s f\nh₀ : ∀ (i : ι), Membership.mem t i → LT.lt 0 (w i)\nh₁ : Eq (t.sum fun i => w i) 1\nhmem : ∀ (i : ι), Membership.mem t i → Membership.mem s (p i)\nhp : Exists fun j => And (Membership.mem t j) (Exists fun k => And (Membership.mem t k) (Ne (p j) (p k)))\n⊢ LT.lt (t.sum fun i => HSMul.hSMul (w i) (f (p i))) (f (t.sum fun i => HSMul.hSMul (w i) (p i)))","decl":"/-- Concave **strict Jensen inequality**.\n\nIf the function is strictly concave, the weights are strictly positive and the indexed family of\npoints is non-constant, then Jensen's inequality is strict.\n\nSee also `StrictConcaveOn.map_sum_eq_iff`. -/\nlemma StrictConcaveOn.lt_map_sum (hf : StrictConcaveOn 𝕜 s f) (h₀ : ∀ i ∈ t, 0 < w i)\n    (h₁ : ∑ i ∈ t, w i = 1) (hmem : ∀ i ∈ t, p i ∈ s) (hp : ∃ j ∈ t, ∃ k ∈ t, p j ≠ p k) :\n    ∑ i ∈ t, w i • f (p i) < f (∑ i ∈ t, w i • p i) := hf.dual.map_sum_lt h₀ h₁ hmem hp\n\n"}
{"name":"StrictConvexOn.eq_of_le_map_sum","module":"Mathlib.Analysis.Convex.Jensen","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nβ : Type u_4\nι : Type u_5\ninst✝⁵ : LinearOrderedField 𝕜\ninst✝⁴ : AddCommGroup E\ninst✝³ : OrderedAddCommGroup β\ninst✝² : Module 𝕜 E\ninst✝¹ : Module 𝕜 β\ninst✝ : OrderedSMul 𝕜 β\ns : Set E\nf : E → β\nt : Finset ι\nw : ι → 𝕜\np : ι → E\nhf : StrictConvexOn 𝕜 s f\nh₀ : ∀ (i : ι), Membership.mem t i → LT.lt 0 (w i)\nh₁ : Eq (t.sum fun i => w i) 1\nhmem : ∀ (i : ι), Membership.mem t i → Membership.mem s (p i)\nh_eq : LE.le (t.sum fun i => HSMul.hSMul (w i) (f (p i))) (f (t.sum fun i => HSMul.hSMul (w i) (p i)))\nj : ι\na✝¹ : Membership.mem t j\nk : ι\na✝ : Membership.mem t k\n⊢ Eq (p j) (p k)","decl":"/-- A form of the **equality case of Jensen's equality**.\n\nFor a strictly convex function `f` and positive weights `w`, if\n`f (∑ i ∈ t, w i • p i) = ∑ i ∈ t, w i • f (p i)`, then the points `p` are all equal.\n\nSee also `StrictConvexOn.map_sum_eq_iff`. -/\nlemma StrictConvexOn.eq_of_le_map_sum (hf : StrictConvexOn 𝕜 s f) (h₀ : ∀ i ∈ t, 0 < w i)\n    (h₁ : ∑ i ∈ t, w i = 1) (hmem : ∀ i ∈ t, p i ∈ s)\n    (h_eq : ∑ i ∈ t, w i • f (p i) ≤ f (∑ i ∈ t, w i • p i)) :\n    ∀ ⦃j⦄, j ∈ t → ∀ ⦃k⦄, k ∈ t → p j = p k := by\n  by_contra!; exact h_eq.not_lt <| hf.map_sum_lt h₀ h₁ hmem this\n\n"}
{"name":"StrictConcaveOn.eq_of_map_sum_eq","module":"Mathlib.Analysis.Convex.Jensen","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nβ : Type u_4\nι : Type u_5\ninst✝⁵ : LinearOrderedField 𝕜\ninst✝⁴ : AddCommGroup E\ninst✝³ : OrderedAddCommGroup β\ninst✝² : Module 𝕜 E\ninst✝¹ : Module 𝕜 β\ninst✝ : OrderedSMul 𝕜 β\ns : Set E\nf : E → β\nt : Finset ι\nw : ι → 𝕜\np : ι → E\nhf : StrictConcaveOn 𝕜 s f\nh₀ : ∀ (i : ι), Membership.mem t i → LT.lt 0 (w i)\nh₁ : Eq (t.sum fun i => w i) 1\nhmem : ∀ (i : ι), Membership.mem t i → Membership.mem s (p i)\nh_eq : LE.le (f (t.sum fun i => HSMul.hSMul (w i) (p i))) (t.sum fun i => HSMul.hSMul (w i) (f (p i)))\nj : ι\na✝¹ : Membership.mem t j\nk : ι\na✝ : Membership.mem t k\n⊢ Eq (p j) (p k)","decl":"/-- A form of the **equality case of Jensen's equality**.\n\nFor a strictly concave function `f` and positive weights `w`, if\n`f (∑ i ∈ t, w i • p i) = ∑ i ∈ t, w i • f (p i)`, then the points `p` are all equal.\n\nSee also `StrictConcaveOn.map_sum_eq_iff`. -/\nlemma StrictConcaveOn.eq_of_map_sum_eq (hf : StrictConcaveOn 𝕜 s f) (h₀ : ∀ i ∈ t, 0 < w i)\n    (h₁ : ∑ i ∈ t, w i = 1) (hmem : ∀ i ∈ t, p i ∈ s)\n    (h_eq : f (∑ i ∈ t, w i • p i) ≤ ∑ i ∈ t, w i • f (p i)) :\n    ∀ ⦃j⦄, j ∈ t → ∀ ⦃k⦄, k ∈ t → p j = p k := by\n  by_contra!; exact h_eq.not_lt <| hf.lt_map_sum h₀ h₁ hmem this\n\n"}
{"name":"StrictConvexOn.map_sum_eq_iff","module":"Mathlib.Analysis.Convex.Jensen","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nβ : Type u_4\nι : Type u_5\ninst✝⁵ : LinearOrderedField 𝕜\ninst✝⁴ : AddCommGroup E\ninst✝³ : OrderedAddCommGroup β\ninst✝² : Module 𝕜 E\ninst✝¹ : Module 𝕜 β\ninst✝ : OrderedSMul 𝕜 β\ns : Set E\nf : E → β\nt : Finset ι\nw : ι → 𝕜\np : ι → E\nhf : StrictConvexOn 𝕜 s f\nh₀ : ∀ (i : ι), Membership.mem t i → LT.lt 0 (w i)\nh₁ : Eq (t.sum fun i => w i) 1\nhmem : ∀ (i : ι), Membership.mem t i → Membership.mem s (p i)\n⊢ Iff (Eq (f (t.sum fun i => HSMul.hSMul (w i) (p i))) (t.sum fun i => HSMul.hSMul (w i) (f (p i)))) (∀ (j : ι), Membership.mem t j → Eq (p j) (t.sum fun i => HSMul.hSMul (w i) (p i)))","decl":"/-- Canonical form of the **equality case of Jensen's equality**.\n\nFor a strictly convex function `f` and positive weights `w`, we have\n`f (∑ i ∈ t, w i • p i) = ∑ i ∈ t, w i • f (p i)` if and only if the points `p` are all equal\n(and in fact all equal to their center of mass wrt `w`). -/\nlemma StrictConvexOn.map_sum_eq_iff {w : ι → 𝕜} {p : ι → E} (hf : StrictConvexOn 𝕜 s f)\n    (h₀ : ∀ i ∈ t, 0 < w i) (h₁ : ∑ i ∈ t, w i = 1) (hmem : ∀ i ∈ t, p i ∈ s) :\n    f (∑ i ∈ t, w i • p i) = ∑ i ∈ t, w i • f (p i) ↔ ∀ j ∈ t, p j = ∑ i ∈ t, w i • p i := by\n  constructor\n  · obtain rfl | ⟨i₀, hi₀⟩ := t.eq_empty_or_nonempty\n    · simp\n    intro h_eq i hi\n    have H : ∀ j ∈ t, p j = p i₀ := by\n      intro j hj\n      apply hf.eq_of_le_map_sum h₀ h₁ hmem h_eq.ge hj hi₀\n    calc p i = p i₀ := by rw [H _ hi]\n      _ = (1 : 𝕜) • p i₀ := by simp\n      _ = (∑ j ∈ t, w j) • p i₀ := by rw [h₁]\n      _ = ∑ j ∈ t, (w j • p i₀) := by rw [sum_smul]\n      _ = ∑ j ∈ t, (w j • p j) := by congr! 2 with j hj; rw [← H _ hj]\n  · intro h\n    have H : ∀ j ∈ t, w j • f (p j) = w j • f (∑ i ∈ t, w i • p i) := by\n      intro j hj\n      simp [h j hj]\n    rw [sum_congr rfl H, ← sum_smul, h₁, one_smul]\n\n"}
{"name":"StrictConcaveOn.map_sum_eq_iff","module":"Mathlib.Analysis.Convex.Jensen","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nβ : Type u_4\nι : Type u_5\ninst✝⁵ : LinearOrderedField 𝕜\ninst✝⁴ : AddCommGroup E\ninst✝³ : OrderedAddCommGroup β\ninst✝² : Module 𝕜 E\ninst✝¹ : Module 𝕜 β\ninst✝ : OrderedSMul 𝕜 β\ns : Set E\nf : E → β\nt : Finset ι\nw : ι → 𝕜\np : ι → E\nhf : StrictConcaveOn 𝕜 s f\nh₀ : ∀ (i : ι), Membership.mem t i → LT.lt 0 (w i)\nh₁ : Eq (t.sum fun i => w i) 1\nhmem : ∀ (i : ι), Membership.mem t i → Membership.mem s (p i)\n⊢ Iff (Eq (f (t.sum fun i => HSMul.hSMul (w i) (p i))) (t.sum fun i => HSMul.hSMul (w i) (f (p i)))) (∀ (j : ι), Membership.mem t j → Eq (p j) (t.sum fun i => HSMul.hSMul (w i) (p i)))","decl":"/-- Canonical form of the **equality case of Jensen's equality**.\n\nFor a strictly concave function `f` and positive weights `w`, we have\n`f (∑ i ∈ t, w i • p i) = ∑ i ∈ t, w i • f (p i)` if and only if the points `p` are all equal\n(and in fact all equal to their center of mass wrt `w`). -/\nlemma StrictConcaveOn.map_sum_eq_iff (hf : StrictConcaveOn 𝕜 s f) (h₀ : ∀ i ∈ t, 0 < w i)\n    (h₁ : ∑ i ∈ t, w i = 1) (hmem : ∀ i ∈ t, p i ∈ s) :\n    f (∑ i ∈ t, w i • p i) = ∑ i ∈ t, w i • f (p i) ↔ ∀ j ∈ t, p j = ∑ i ∈ t, w i • p i := by\n  simpa using hf.neg.map_sum_eq_iff h₀ h₁ hmem\n\n"}
{"name":"StrictConvexOn.map_sum_eq_iff'","module":"Mathlib.Analysis.Convex.Jensen","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nβ : Type u_4\nι : Type u_5\ninst✝⁵ : LinearOrderedField 𝕜\ninst✝⁴ : AddCommGroup E\ninst✝³ : OrderedAddCommGroup β\ninst✝² : Module 𝕜 E\ninst✝¹ : Module 𝕜 β\ninst✝ : OrderedSMul 𝕜 β\ns : Set E\nf : E → β\nt : Finset ι\nw : ι → 𝕜\np : ι → E\nhf : StrictConvexOn 𝕜 s f\nh₀ : ∀ (i : ι), Membership.mem t i → LE.le 0 (w i)\nh₁ : Eq (t.sum fun i => w i) 1\nhmem : ∀ (i : ι), Membership.mem t i → Membership.mem s (p i)\n⊢ Iff (Eq (f (t.sum fun i => HSMul.hSMul (w i) (p i))) (t.sum fun i => HSMul.hSMul (w i) (f (p i)))) (∀ (j : ι), Membership.mem t j → Ne (w j) 0 → Eq (p j) (t.sum fun i => HSMul.hSMul (w i) (p i)))","decl":"/-- Canonical form of the **equality case of Jensen's equality**.\n\nFor a strictly convex function `f` and nonnegative weights `w`, we have\n`f (∑ i ∈ t, w i • p i) = ∑ i ∈ t, w i • f (p i)` if and only if the points `p` with nonzero\nweight are all equal (and in fact all equal to their center of mass wrt `w`). -/\nlemma StrictConvexOn.map_sum_eq_iff' (hf : StrictConvexOn 𝕜 s f) (h₀ : ∀ i ∈ t, 0 ≤ w i)\n    (h₁ : ∑ i ∈ t, w i = 1) (hmem : ∀ i ∈ t, p i ∈ s) :\n    f (∑ i ∈ t, w i • p i) = ∑ i ∈ t, w i • f (p i) ↔\n      ∀ j ∈ t, w j ≠ 0 → p j = ∑ i ∈ t, w i • p i := by\n  have hw (i) (_ : i ∈ t) : w i • p i ≠ 0 → w i ≠ 0 := by aesop\n  have hw' (i) (_ : i ∈ t) : w i • f (p i) ≠ 0 → w i ≠ 0 := by aesop\n  rw [← sum_filter_of_ne hw, ← sum_filter_of_ne hw', hf.map_sum_eq_iff]\n  · simp\n  · simp +contextual [(h₀ _ _).gt_iff_ne]\n  · rwa [sum_filter_ne_zero]\n  · simp +contextual [hmem _ _]\n\n"}
{"name":"StrictConcaveOn.map_sum_eq_iff'","module":"Mathlib.Analysis.Convex.Jensen","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nβ : Type u_4\nι : Type u_5\ninst✝⁵ : LinearOrderedField 𝕜\ninst✝⁴ : AddCommGroup E\ninst✝³ : OrderedAddCommGroup β\ninst✝² : Module 𝕜 E\ninst✝¹ : Module 𝕜 β\ninst✝ : OrderedSMul 𝕜 β\ns : Set E\nf : E → β\nt : Finset ι\nw : ι → 𝕜\np : ι → E\nhf : StrictConcaveOn 𝕜 s f\nh₀ : ∀ (i : ι), Membership.mem t i → LE.le 0 (w i)\nh₁ : Eq (t.sum fun i => w i) 1\nhmem : ∀ (i : ι), Membership.mem t i → Membership.mem s (p i)\n⊢ Iff (Eq (f (t.sum fun i => HSMul.hSMul (w i) (p i))) (t.sum fun i => HSMul.hSMul (w i) (f (p i)))) (∀ (j : ι), Membership.mem t j → Ne (w j) 0 → Eq (p j) (t.sum fun i => HSMul.hSMul (w i) (p i)))","decl":"/-- Canonical form of the **equality case of Jensen's equality**.\n\nFor a strictly concave function `f` and nonnegative weights `w`, we have\n`f (∑ i ∈ t, w i • p i) = ∑ i ∈ t, w i • f (p i)` if and only if the points `p` with nonzero\nweight are all equal (and in fact all equal to their center of mass wrt `w`). -/\nlemma StrictConcaveOn.map_sum_eq_iff' (hf : StrictConcaveOn 𝕜 s f) (h₀ : ∀ i ∈ t, 0 ≤ w i)\n    (h₁ : ∑ i ∈ t, w i = 1) (hmem : ∀ i ∈ t, p i ∈ s) :\n    f (∑ i ∈ t, w i • p i) = ∑ i ∈ t, w i • f (p i) ↔\n      ∀ j ∈ t, w j ≠ 0 → p j = ∑ i ∈ t, w i • p i := hf.dual.map_sum_eq_iff' h₀ h₁ hmem\n\n"}
{"name":"ConvexOn.le_sup_of_mem_convexHull","module":"Mathlib.Analysis.Convex.Jensen","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nβ : Type u_4\ninst✝⁵ : LinearOrderedField 𝕜\ninst✝⁴ : AddCommGroup E\ninst✝³ : LinearOrderedAddCommGroup β\ninst✝² : Module 𝕜 E\ninst✝¹ : Module 𝕜 β\ninst✝ : OrderedSMul 𝕜 β\ns : Set E\nf : E → β\nx : E\nt : Finset E\nhf : ConvexOn 𝕜 s f\nhts : HasSubset.Subset (↑t) s\nhx : Membership.mem ((convexHull 𝕜) ↑t) x\n⊢ LE.le (f x) (t.sup' ⋯ f)","decl":"theorem ConvexOn.le_sup_of_mem_convexHull {t : Finset E} (hf : ConvexOn 𝕜 s f) (hts : ↑t ⊆ s)\n    (hx : x ∈ convexHull 𝕜 (t : Set E)) :\n    f x ≤ t.sup' (coe_nonempty.1 <| convexHull_nonempty_iff.1 ⟨x, hx⟩) f := by\n  obtain ⟨w, hw₀, hw₁, rfl⟩ := mem_convexHull.1 hx\n  exact (hf.map_centerMass_le hw₀ (by positivity) hts).trans\n    (centerMass_le_sup hw₀ <| by positivity)\n\n"}
{"name":"ConvexOn.inf_le_of_mem_convexHull","module":"Mathlib.Analysis.Convex.Jensen","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nβ : Type u_4\ninst✝⁵ : LinearOrderedField 𝕜\ninst✝⁴ : AddCommGroup E\ninst✝³ : LinearOrderedAddCommGroup β\ninst✝² : Module 𝕜 E\ninst✝¹ : Module 𝕜 β\ninst✝ : OrderedSMul 𝕜 β\ns : Set E\nf : E → β\nx : E\nt : Finset E\nhf : ConcaveOn 𝕜 s f\nhts : HasSubset.Subset (↑t) s\nhx : Membership.mem ((convexHull 𝕜) ↑t) x\n⊢ LE.le (t.inf' ⋯ f) (f x)","decl":"theorem ConvexOn.inf_le_of_mem_convexHull {t : Finset E} (hf : ConcaveOn 𝕜 s f) (hts : ↑t ⊆ s)\n    (hx : x ∈ convexHull 𝕜 (t : Set E)) :\n    t.inf' (coe_nonempty.1 <| convexHull_nonempty_iff.1 ⟨x, hx⟩) f ≤ f x :=\n  hf.dual.le_sup_of_mem_convexHull hts hx\n\n"}
{"name":"le_sup_of_mem_convexHull","module":"Mathlib.Analysis.Convex.Jensen","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nβ : Type u_4\ninst✝⁵ : LinearOrderedField 𝕜\ninst✝⁴ : AddCommGroup E\ninst✝³ : LinearOrderedAddCommGroup β\ninst✝² : Module 𝕜 E\ninst✝¹ : Module 𝕜 β\ninst✝ : OrderedSMul 𝕜 β\ns : Set E\nf : E → β\nx : E\nt : Finset E\nhf : ConvexOn 𝕜 s f\nhts : HasSubset.Subset (↑t) s\nhx : Membership.mem ((convexHull 𝕜) ↑t) x\n⊢ LE.le (f x) (t.sup' ⋯ f)","decl":"@[deprecated (since := \"2024-08-25\")]\nalias le_sup_of_mem_convexHull := ConvexOn.le_sup_of_mem_convexHull\n\n"}
{"name":"inf_le_of_mem_convexHull","module":"Mathlib.Analysis.Convex.Jensen","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nβ : Type u_4\ninst✝⁵ : LinearOrderedField 𝕜\ninst✝⁴ : AddCommGroup E\ninst✝³ : LinearOrderedAddCommGroup β\ninst✝² : Module 𝕜 E\ninst✝¹ : Module 𝕜 β\ninst✝ : OrderedSMul 𝕜 β\ns : Set E\nf : E → β\nx : E\nt : Finset E\nhf : ConcaveOn 𝕜 s f\nhts : HasSubset.Subset (↑t) s\nhx : Membership.mem ((convexHull 𝕜) ↑t) x\n⊢ LE.le (t.inf' ⋯ f) (f x)","decl":"@[deprecated (since := \"2024-08-25\")]\nalias inf_le_of_mem_convexHull := ConvexOn.inf_le_of_mem_convexHull\n\n"}
{"name":"ConvexOn.exists_ge_of_centerMass","module":"Mathlib.Analysis.Convex.Jensen","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nβ : Type u_4\nι : Type u_5\ninst✝⁵ : LinearOrderedField 𝕜\ninst✝⁴ : AddCommGroup E\ninst✝³ : LinearOrderedAddCommGroup β\ninst✝² : Module 𝕜 E\ninst✝¹ : Module 𝕜 β\ninst✝ : OrderedSMul 𝕜 β\ns : Set E\nf : E → β\nw : ι → 𝕜\np : ι → E\nt : Finset ι\nh : ConvexOn 𝕜 s f\nhw₀ : ∀ (i : ι), Membership.mem t i → LE.le 0 (w i)\nhw₁ : LT.lt 0 (t.sum fun i => w i)\nhp : ∀ (i : ι), Membership.mem t i → Membership.mem s (p i)\n⊢ Exists fun i => And (Membership.mem t i) (LE.le (f (t.centerMass w p)) (f (p i)))","decl":"/-- If a function `f` is convex on `s`, then the value it takes at some center of mass of points of\n`s` is less than the value it takes on one of those points. -/\nlemma ConvexOn.exists_ge_of_centerMass {t : Finset ι} (h : ConvexOn 𝕜 s f)\n    (hw₀ : ∀ i ∈ t, 0 ≤ w i) (hw₁ : 0 < ∑ i ∈ t, w i) (hp : ∀ i ∈ t, p i ∈ s) :\n    ∃ i ∈ t, f (t.centerMass w p) ≤ f (p i) := by\n  set y := t.centerMass w p\n  -- TODO: can `rsuffices` be used to write the `exact` first, then the proof of this obtain?\n  obtain ⟨i, hi, hfi⟩ : ∃ i ∈ {i ∈ t | w i ≠ 0}, w i • f y ≤ w i • (f ∘ p) i := by\n    have hw' : (0 : 𝕜) < ∑ i ∈ t with w i ≠ 0, w i := by rwa [sum_filter_ne_zero]\n    refine exists_le_of_sum_le (nonempty_of_sum_ne_zero hw'.ne') ?_\n    rw [← sum_smul, ← smul_le_smul_iff_of_pos_left (inv_pos.2 hw'), inv_smul_smul₀ hw'.ne', ←\n      centerMass, centerMass_filter_ne_zero]\n    exact h.map_centerMass_le hw₀ hw₁ hp\n  rw [mem_filter] at hi\n  exact ⟨i, hi.1, (smul_le_smul_iff_of_pos_left <| (hw₀ i hi.1).lt_of_ne hi.2.symm).1 hfi⟩\n\n"}
{"name":"ConcaveOn.exists_le_of_centerMass","module":"Mathlib.Analysis.Convex.Jensen","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nβ : Type u_4\nι : Type u_5\ninst✝⁵ : LinearOrderedField 𝕜\ninst✝⁴ : AddCommGroup E\ninst✝³ : LinearOrderedAddCommGroup β\ninst✝² : Module 𝕜 E\ninst✝¹ : Module 𝕜 β\ninst✝ : OrderedSMul 𝕜 β\ns : Set E\nf : E → β\nw : ι → 𝕜\np : ι → E\nt : Finset ι\nh : ConcaveOn 𝕜 s f\nhw₀ : ∀ (i : ι), Membership.mem t i → LE.le 0 (w i)\nhw₁ : LT.lt 0 (t.sum fun i => w i)\nhp : ∀ (i : ι), Membership.mem t i → Membership.mem s (p i)\n⊢ Exists fun i => And (Membership.mem t i) (LE.le (f (p i)) (f (t.centerMass w p)))","decl":"/-- If a function `f` is concave on `s`, then the value it takes at some center of mass of points of\n`s` is greater than the value it takes on one of those points. -/\nlemma ConcaveOn.exists_le_of_centerMass {t : Finset ι} (h : ConcaveOn 𝕜 s f)\n    (hw₀ : ∀ i ∈ t, 0 ≤ w i) (hw₁ : 0 < ∑ i ∈ t, w i) (hp : ∀ i ∈ t, p i ∈ s) :\n    ∃ i ∈ t, f (p i) ≤ f (t.centerMass w p) := h.dual.exists_ge_of_centerMass hw₀ hw₁ hp\n\n"}
{"name":"ConvexOn.exists_ge_of_mem_convexHull","module":"Mathlib.Analysis.Convex.Jensen","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nβ : Type u_4\ninst✝⁵ : LinearOrderedField 𝕜\ninst✝⁴ : AddCommGroup E\ninst✝³ : LinearOrderedAddCommGroup β\ninst✝² : Module 𝕜 E\ninst✝¹ : Module 𝕜 β\ninst✝ : OrderedSMul 𝕜 β\ns : Set E\nf : E → β\nx : E\nt : Set E\nhf : ConvexOn 𝕜 s f\nhts : HasSubset.Subset t s\nhx : Membership.mem ((convexHull 𝕜) t) x\n⊢ Exists fun y => And (Membership.mem t y) (LE.le (f x) (f y))","decl":"/-- **Maximum principle** for convex functions. If a function `f` is convex on the convex hull of\n`s`, then the eventual maximum of `f` on `convexHull 𝕜 s` lies in `s`. -/\nlemma ConvexOn.exists_ge_of_mem_convexHull {t : Set E} (hf : ConvexOn 𝕜 s f) (hts : t ⊆ s)\n    (hx : x ∈ convexHull 𝕜 t) : ∃ y ∈ t, f x ≤ f y := by\n  rw [_root_.convexHull_eq] at hx\n  obtain ⟨α, t, w, p, hw₀, hw₁, hp, rfl⟩ := hx\n  obtain ⟨i, hit, Hi⟩ := hf.exists_ge_of_centerMass hw₀ (hw₁.symm ▸ zero_lt_one)\n    fun i hi ↦ hts (hp i hi)\n  exact ⟨p i, hp i hit, Hi⟩\n\n"}
{"name":"ConcaveOn.exists_le_of_mem_convexHull","module":"Mathlib.Analysis.Convex.Jensen","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nβ : Type u_4\ninst✝⁵ : LinearOrderedField 𝕜\ninst✝⁴ : AddCommGroup E\ninst✝³ : LinearOrderedAddCommGroup β\ninst✝² : Module 𝕜 E\ninst✝¹ : Module 𝕜 β\ninst✝ : OrderedSMul 𝕜 β\ns : Set E\nf : E → β\nx : E\nt : Set E\nhf : ConcaveOn 𝕜 s f\nhts : HasSubset.Subset t s\nhx : Membership.mem ((convexHull 𝕜) t) x\n⊢ Exists fun y => And (Membership.mem t y) (LE.le (f y) (f x))","decl":"/-- **Minimum principle** for concave functions. If a function `f` is concave on the convex hull of\n`s`, then the eventual minimum of `f` on `convexHull 𝕜 s` lies in `s`. -/\nlemma ConcaveOn.exists_le_of_mem_convexHull {t : Set E} (hf : ConcaveOn 𝕜 s f) (hts : t ⊆ s)\n    (hx : x ∈ convexHull 𝕜 t) : ∃ y ∈ t, f y ≤ f x := hf.dual.exists_ge_of_mem_convexHull hts hx\n\n"}
{"name":"ConvexOn.le_max_of_mem_segment","module":"Mathlib.Analysis.Convex.Jensen","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nβ : Type u_4\ninst✝⁵ : LinearOrderedField 𝕜\ninst✝⁴ : AddCommGroup E\ninst✝³ : LinearOrderedAddCommGroup β\ninst✝² : Module 𝕜 E\ninst✝¹ : Module 𝕜 β\ninst✝ : OrderedSMul 𝕜 β\ns : Set E\nf : E → β\nx y z : E\nhf : ConvexOn 𝕜 s f\nhx : Membership.mem s x\nhy : Membership.mem s y\nhz : Membership.mem (segment 𝕜 x y) z\n⊢ LE.le (f z) (Max.max (f x) (f y))","decl":"/-- **Maximum principle** for convex functions on a segment. If a function `f` is convex on the\nsegment `[x, y]`, then the eventual maximum of `f` on `[x, y]` is at `x` or `y`. -/\nlemma ConvexOn.le_max_of_mem_segment (hf : ConvexOn 𝕜 s f) (hx : x ∈ s) (hy : y ∈ s)\n    (hz : z ∈ [x -[𝕜] y]) : f z ≤ max (f x) (f y) := by\n  rw [← convexHull_pair] at hz; simpa using hf.exists_ge_of_mem_convexHull (pair_subset hx hy) hz\n\n"}
{"name":"ConcaveOn.min_le_of_mem_segment","module":"Mathlib.Analysis.Convex.Jensen","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nβ : Type u_4\ninst✝⁵ : LinearOrderedField 𝕜\ninst✝⁴ : AddCommGroup E\ninst✝³ : LinearOrderedAddCommGroup β\ninst✝² : Module 𝕜 E\ninst✝¹ : Module 𝕜 β\ninst✝ : OrderedSMul 𝕜 β\ns : Set E\nf : E → β\nx y z : E\nhf : ConcaveOn 𝕜 s f\nhx : Membership.mem s x\nhy : Membership.mem s y\nhz : Membership.mem (segment 𝕜 x y) z\n⊢ LE.le (Min.min (f x) (f y)) (f z)","decl":"/-- **Minimum principle** for concave functions on a segment. If a function `f` is concave on the\nsegment `[x, y]`, then the eventual minimum of `f` on `[x, y]` is at `x` or `y`. -/\nlemma ConcaveOn.min_le_of_mem_segment (hf : ConcaveOn 𝕜 s f) (hx : x ∈ s) (hy : y ∈ s)\n    (hz : z ∈ [x -[𝕜] y]) : min (f x) (f y) ≤ f z := hf.dual.le_max_of_mem_segment hx hy hz\n\n"}
{"name":"ConvexOn.le_max_of_mem_Icc","module":"Mathlib.Analysis.Convex.Jensen","initialProofState":"𝕜 : Type u_1\nβ : Type u_4\ninst✝³ : LinearOrderedField 𝕜\ninst✝² : LinearOrderedAddCommGroup β\ninst✝¹ : Module 𝕜 β\ninst✝ : OrderedSMul 𝕜 β\ns : Set 𝕜\nf : 𝕜 → β\nx y z : 𝕜\nhf : ConvexOn 𝕜 s f\nhx : Membership.mem s x\nhy : Membership.mem s y\nhz : Membership.mem (Set.Icc x y) z\n⊢ LE.le (f z) (Max.max (f x) (f y))","decl":"/-- **Maximum principle** for convex functions on an interval. If a function `f` is convex on the\ninterval `[x, y]`, then the eventual maximum of `f` on `[x, y]` is at `x` or `y`. -/\nlemma ConvexOn.le_max_of_mem_Icc {s : Set 𝕜} {f : 𝕜 → β} {x y z : 𝕜} (hf : ConvexOn 𝕜 s f)\n    (hx : x ∈ s) (hy : y ∈ s) (hz : z ∈ Icc x y) : f z ≤ max (f x) (f y) := by\n  rw [← segment_eq_Icc (hz.1.trans hz.2)] at hz; exact hf.le_max_of_mem_segment hx hy hz\n\n"}
{"name":"ConcaveOn.min_le_of_mem_Icc","module":"Mathlib.Analysis.Convex.Jensen","initialProofState":"𝕜 : Type u_1\nβ : Type u_4\ninst✝³ : LinearOrderedField 𝕜\ninst✝² : LinearOrderedAddCommGroup β\ninst✝¹ : Module 𝕜 β\ninst✝ : OrderedSMul 𝕜 β\ns : Set 𝕜\nf : 𝕜 → β\nx y z : 𝕜\nhf : ConcaveOn 𝕜 s f\nhx : Membership.mem s x\nhy : Membership.mem s y\nhz : Membership.mem (Set.Icc x y) z\n⊢ LE.le (Min.min (f x) (f y)) (f z)","decl":"/-- **Minimum principle** for concave functions on an interval. If a function `f` is concave on the\ninterval `[x, y]`, then the eventual minimum of `f` on `[x, y]` is at `x` or `y`. -/\nlemma ConcaveOn.min_le_of_mem_Icc {s : Set 𝕜} {f : 𝕜 → β} {x y z : 𝕜} (hf : ConcaveOn 𝕜 s f)\n    (hx : x ∈ s) (hy : y ∈ s) (hz : z ∈ Icc x y) : min (f x) (f y) ≤ f z :=\n  hf.dual.le_max_of_mem_Icc hx hy hz\n\n"}
{"name":"ConvexOn.bddAbove_convexHull","module":"Mathlib.Analysis.Convex.Jensen","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nβ : Type u_4\ninst✝⁵ : LinearOrderedField 𝕜\ninst✝⁴ : AddCommGroup E\ninst✝³ : LinearOrderedAddCommGroup β\ninst✝² : Module 𝕜 E\ninst✝¹ : Module 𝕜 β\ninst✝ : OrderedSMul 𝕜 β\nf : E → β\ns t : Set E\nhst : HasSubset.Subset s t\nhf : ConvexOn 𝕜 t f\na✝ : BddAbove (Set.image f s)\n⊢ BddAbove (Set.image f ((convexHull 𝕜) s))","decl":"lemma ConvexOn.bddAbove_convexHull {s t : Set E} (hst : s ⊆ t) (hf : ConvexOn 𝕜 t f) :\n    BddAbove (f '' s) → BddAbove (f '' convexHull 𝕜 s) := by\n  rintro ⟨b, hb⟩\n  refine ⟨b, ?_⟩\n  rintro _ ⟨x, hx, rfl⟩\n  obtain ⟨y, hy, hxy⟩ := hf.exists_ge_of_mem_convexHull hst hx\n  exact hxy.trans <| hb <| mem_image_of_mem _ hy\n\n"}
{"name":"ConcaveOn.bddBelow_convexHull","module":"Mathlib.Analysis.Convex.Jensen","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nβ : Type u_4\ninst✝⁵ : LinearOrderedField 𝕜\ninst✝⁴ : AddCommGroup E\ninst✝³ : LinearOrderedAddCommGroup β\ninst✝² : Module 𝕜 E\ninst✝¹ : Module 𝕜 β\ninst✝ : OrderedSMul 𝕜 β\nf : E → β\ns t : Set E\nhst : HasSubset.Subset s t\nhf : ConcaveOn 𝕜 t f\na✝ : BddBelow (Set.image f s)\n⊢ BddBelow (Set.image f ((convexHull 𝕜) s))","decl":"lemma ConcaveOn.bddBelow_convexHull {s t : Set E} (hst : s ⊆ t) (hf : ConcaveOn 𝕜 t f) :\n    BddBelow (f '' s) → BddBelow (f '' convexHull 𝕜 s) := hf.dual.bddAbove_convexHull hst\n\n"}
