{"name":"ConvexOn.map_centerMass_le","module":"Mathlib.Analysis.Convex.Jensen","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nÎ² : Type u_4\nÎ¹ : Type u_5\ninstâœâµ : LinearOrderedField ğ•œ\ninstâœâ´ : AddCommGroup E\ninstâœÂ³ : OrderedAddCommGroup Î²\ninstâœÂ² : Module ğ•œ E\ninstâœÂ¹ : Module ğ•œ Î²\ninstâœ : OrderedSMul ğ•œ Î²\ns : Set E\nf : E â†’ Î²\nt : Finset Î¹\nw : Î¹ â†’ ğ•œ\np : Î¹ â†’ E\nhf : ConvexOn ğ•œ s f\nhâ‚€ : âˆ€ (i : Î¹), Membership.mem t i â†’ LE.le 0 (w i)\nhâ‚ : LT.lt 0 (t.sum fun i => w i)\nhmem : âˆ€ (i : Î¹), Membership.mem t i â†’ Membership.mem s (p i)\nâŠ¢ LE.le (f (t.centerMass w p)) (t.centerMass w (Function.comp f p))","decl":"/-- Convex **Jensen's inequality**, `Finset.centerMass` version. -/\ntheorem ConvexOn.map_centerMass_le (hf : ConvexOn ğ•œ s f) (hâ‚€ : âˆ€ i âˆˆ t, 0 â‰¤ w i)\n    (hâ‚ : 0 < âˆ‘ i âˆˆ t, w i) (hmem : âˆ€ i âˆˆ t, p i âˆˆ s) :\n    f (t.centerMass w p) â‰¤ t.centerMass w (f âˆ˜ p) := by\n  have hmem' : âˆ€ i âˆˆ t, (p i, (f âˆ˜ p) i) âˆˆ { p : E Ã— Î² | p.1 âˆˆ s âˆ§ f p.1 â‰¤ p.2 } := fun i hi =>\n    âŸ¨hmem i hi, le_rflâŸ©\n  convert (hf.convex_epigraph.centerMass_mem hâ‚€ hâ‚ hmem').2 <;>\n    simp only [centerMass, Function.comp, Prod.smul_fst, Prod.fst_sum, Prod.smul_snd, Prod.snd_sum]\n\n"}
{"name":"ConcaveOn.le_map_centerMass","module":"Mathlib.Analysis.Convex.Jensen","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nÎ² : Type u_4\nÎ¹ : Type u_5\ninstâœâµ : LinearOrderedField ğ•œ\ninstâœâ´ : AddCommGroup E\ninstâœÂ³ : OrderedAddCommGroup Î²\ninstâœÂ² : Module ğ•œ E\ninstâœÂ¹ : Module ğ•œ Î²\ninstâœ : OrderedSMul ğ•œ Î²\ns : Set E\nf : E â†’ Î²\nt : Finset Î¹\nw : Î¹ â†’ ğ•œ\np : Î¹ â†’ E\nhf : ConcaveOn ğ•œ s f\nhâ‚€ : âˆ€ (i : Î¹), Membership.mem t i â†’ LE.le 0 (w i)\nhâ‚ : LT.lt 0 (t.sum fun i => w i)\nhmem : âˆ€ (i : Î¹), Membership.mem t i â†’ Membership.mem s (p i)\nâŠ¢ LE.le (t.centerMass w (Function.comp f p)) (f (t.centerMass w p))","decl":"/-- Concave **Jensen's inequality**, `Finset.centerMass` version. -/\ntheorem ConcaveOn.le_map_centerMass (hf : ConcaveOn ğ•œ s f) (hâ‚€ : âˆ€ i âˆˆ t, 0 â‰¤ w i)\n    (hâ‚ : 0 < âˆ‘ i âˆˆ t, w i) (hmem : âˆ€ i âˆˆ t, p i âˆˆ s) :\n    t.centerMass w (f âˆ˜ p) â‰¤ f (t.centerMass w p) :=\n  ConvexOn.map_centerMass_le (Î² := Î²áµ’áµˆ) hf hâ‚€ hâ‚ hmem\n\n"}
{"name":"ConvexOn.map_sum_le","module":"Mathlib.Analysis.Convex.Jensen","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nÎ² : Type u_4\nÎ¹ : Type u_5\ninstâœâµ : LinearOrderedField ğ•œ\ninstâœâ´ : AddCommGroup E\ninstâœÂ³ : OrderedAddCommGroup Î²\ninstâœÂ² : Module ğ•œ E\ninstâœÂ¹ : Module ğ•œ Î²\ninstâœ : OrderedSMul ğ•œ Î²\ns : Set E\nf : E â†’ Î²\nt : Finset Î¹\nw : Î¹ â†’ ğ•œ\np : Î¹ â†’ E\nhf : ConvexOn ğ•œ s f\nhâ‚€ : âˆ€ (i : Î¹), Membership.mem t i â†’ LE.le 0 (w i)\nhâ‚ : Eq (t.sum fun i => w i) 1\nhmem : âˆ€ (i : Î¹), Membership.mem t i â†’ Membership.mem s (p i)\nâŠ¢ LE.le (f (t.sum fun i => HSMul.hSMul (w i) (p i))) (t.sum fun i => HSMul.hSMul (w i) (f (p i)))","decl":"/-- Convex **Jensen's inequality**, `Finset.sum` version. -/\ntheorem ConvexOn.map_sum_le (hf : ConvexOn ğ•œ s f) (hâ‚€ : âˆ€ i âˆˆ t, 0 â‰¤ w i) (hâ‚ : âˆ‘ i âˆˆ t, w i = 1)\n    (hmem : âˆ€ i âˆˆ t, p i âˆˆ s) : f (âˆ‘ i âˆˆ t, w i â€¢ p i) â‰¤ âˆ‘ i âˆˆ t, w i â€¢ f (p i) := by\n  simpa only [centerMass, hâ‚, inv_one, one_smul] using\n    hf.map_centerMass_le hâ‚€ (hâ‚.symm â–¸ zero_lt_one) hmem\n\n"}
{"name":"ConcaveOn.le_map_sum","module":"Mathlib.Analysis.Convex.Jensen","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nÎ² : Type u_4\nÎ¹ : Type u_5\ninstâœâµ : LinearOrderedField ğ•œ\ninstâœâ´ : AddCommGroup E\ninstâœÂ³ : OrderedAddCommGroup Î²\ninstâœÂ² : Module ğ•œ E\ninstâœÂ¹ : Module ğ•œ Î²\ninstâœ : OrderedSMul ğ•œ Î²\ns : Set E\nf : E â†’ Î²\nt : Finset Î¹\nw : Î¹ â†’ ğ•œ\np : Î¹ â†’ E\nhf : ConcaveOn ğ•œ s f\nhâ‚€ : âˆ€ (i : Î¹), Membership.mem t i â†’ LE.le 0 (w i)\nhâ‚ : Eq (t.sum fun i => w i) 1\nhmem : âˆ€ (i : Î¹), Membership.mem t i â†’ Membership.mem s (p i)\nâŠ¢ LE.le (t.sum fun i => HSMul.hSMul (w i) (f (p i))) (f (t.sum fun i => HSMul.hSMul (w i) (p i)))","decl":"/-- Concave **Jensen's inequality**, `Finset.sum` version. -/\ntheorem ConcaveOn.le_map_sum (hf : ConcaveOn ğ•œ s f) (hâ‚€ : âˆ€ i âˆˆ t, 0 â‰¤ w i)\n    (hâ‚ : âˆ‘ i âˆˆ t, w i = 1) (hmem : âˆ€ i âˆˆ t, p i âˆˆ s) :\n    (âˆ‘ i âˆˆ t, w i â€¢ f (p i)) â‰¤ f (âˆ‘ i âˆˆ t, w i â€¢ p i) :=\n  ConvexOn.map_sum_le (Î² := Î²áµ’áµˆ) hf hâ‚€ hâ‚ hmem\n\n"}
{"name":"ConvexOn.map_add_sum_le","module":"Mathlib.Analysis.Convex.Jensen","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nÎ² : Type u_4\nÎ¹ : Type u_5\ninstâœâµ : LinearOrderedField ğ•œ\ninstâœâ´ : AddCommGroup E\ninstâœÂ³ : OrderedAddCommGroup Î²\ninstâœÂ² : Module ğ•œ E\ninstâœÂ¹ : Module ğ•œ Î²\ninstâœ : OrderedSMul ğ•œ Î²\ns : Set E\nf : E â†’ Î²\nt : Finset Î¹\nw : Î¹ â†’ ğ•œ\np : Î¹ â†’ E\nv : ğ•œ\nq : E\nhf : ConvexOn ğ•œ s f\nhâ‚€ : âˆ€ (i : Î¹), Membership.mem t i â†’ LE.le 0 (w i)\nhâ‚ : Eq (HAdd.hAdd v (t.sum fun i => w i)) 1\nhmem : âˆ€ (i : Î¹), Membership.mem t i â†’ Membership.mem s (p i)\nhv : LE.le 0 v\nhq : Membership.mem s q\nâŠ¢ LE.le (f (HAdd.hAdd (HSMul.hSMul v q) (t.sum fun i => HSMul.hSMul (w i) (p i)))) (HAdd.hAdd (HSMul.hSMul v (f q)) (t.sum fun i => HSMul.hSMul (w i) (f (p i))))","decl":"/-- Convex **Jensen's inequality** where an element plays a distinguished role. -/\nlemma ConvexOn.map_add_sum_le (hf : ConvexOn ğ•œ s f) (hâ‚€ : âˆ€ i âˆˆ t, 0 â‰¤ w i)\n    (hâ‚ : v + âˆ‘ i âˆˆ t, w i = 1) (hmem : âˆ€ i âˆˆ t, p i âˆˆ s) (hv : 0 â‰¤ v) (hq : q âˆˆ s) :\n    f (v â€¢ q + âˆ‘ i âˆˆ t, w i â€¢ p i) â‰¤ v â€¢ f q + âˆ‘ i âˆˆ t, w i â€¢ f (p i) := by\n  let W j := Option.elim j v w\n  let P j := Option.elim j q p\n  have : f (âˆ‘ j âˆˆ insertNone t, W j â€¢ P j) â‰¤ âˆ‘ j âˆˆ insertNone t, W j â€¢ f (P j) :=\n    hf.map_sum_le (forall_mem_insertNone.2 âŸ¨hv, hâ‚€âŸ©) (by simpa using hâ‚)\n      (forall_mem_insertNone.2 âŸ¨hq, hmemâŸ©)\n  simpa using this\n\n"}
{"name":"ConcaveOn.map_add_sum_le","module":"Mathlib.Analysis.Convex.Jensen","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nÎ² : Type u_4\nÎ¹ : Type u_5\ninstâœâµ : LinearOrderedField ğ•œ\ninstâœâ´ : AddCommGroup E\ninstâœÂ³ : OrderedAddCommGroup Î²\ninstâœÂ² : Module ğ•œ E\ninstâœÂ¹ : Module ğ•œ Î²\ninstâœ : OrderedSMul ğ•œ Î²\ns : Set E\nf : E â†’ Î²\nt : Finset Î¹\nw : Î¹ â†’ ğ•œ\np : Î¹ â†’ E\nv : ğ•œ\nq : E\nhf : ConcaveOn ğ•œ s f\nhâ‚€ : âˆ€ (i : Î¹), Membership.mem t i â†’ LE.le 0 (w i)\nhâ‚ : Eq (HAdd.hAdd v (t.sum fun i => w i)) 1\nhmem : âˆ€ (i : Î¹), Membership.mem t i â†’ Membership.mem s (p i)\nhv : LE.le 0 v\nhq : Membership.mem s q\nâŠ¢ LE.le (HAdd.hAdd (HSMul.hSMul v (f q)) (t.sum fun i => HSMul.hSMul (w i) (f (p i)))) (f (HAdd.hAdd (HSMul.hSMul v q) (t.sum fun i => HSMul.hSMul (w i) (p i))))","decl":"/-- Concave **Jensen's inequality** where an element plays a distinguished role. -/\nlemma ConcaveOn.map_add_sum_le (hf : ConcaveOn ğ•œ s f) (hâ‚€ : âˆ€ i âˆˆ t, 0 â‰¤ w i)\n    (hâ‚ : v + âˆ‘ i âˆˆ t, w i = 1) (hmem : âˆ€ i âˆˆ t, p i âˆˆ s) (hv : 0 â‰¤ v) (hq : q âˆˆ s) :\n    v â€¢ f q + âˆ‘ i âˆˆ t, w i â€¢ f (p i) â‰¤ f (v â€¢ q + âˆ‘ i âˆˆ t, w i â€¢ p i) :=\n  hf.dual.map_add_sum_le hâ‚€ hâ‚ hmem hv hq\n\n"}
{"name":"StrictConvexOn.map_sum_lt","module":"Mathlib.Analysis.Convex.Jensen","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nÎ² : Type u_4\nÎ¹ : Type u_5\ninstâœâµ : LinearOrderedField ğ•œ\ninstâœâ´ : AddCommGroup E\ninstâœÂ³ : OrderedAddCommGroup Î²\ninstâœÂ² : Module ğ•œ E\ninstâœÂ¹ : Module ğ•œ Î²\ninstâœ : OrderedSMul ğ•œ Î²\ns : Set E\nf : E â†’ Î²\nt : Finset Î¹\nw : Î¹ â†’ ğ•œ\np : Î¹ â†’ E\nhf : StrictConvexOn ğ•œ s f\nhâ‚€ : âˆ€ (i : Î¹), Membership.mem t i â†’ LT.lt 0 (w i)\nhâ‚ : Eq (t.sum fun i => w i) 1\nhmem : âˆ€ (i : Î¹), Membership.mem t i â†’ Membership.mem s (p i)\nhp : Exists fun j => And (Membership.mem t j) (Exists fun k => And (Membership.mem t k) (Ne (p j) (p k)))\nâŠ¢ LT.lt (f (t.sum fun i => HSMul.hSMul (w i) (p i))) (t.sum fun i => HSMul.hSMul (w i) (f (p i)))","decl":"/-- Convex **strict Jensen inequality**.\n\nIf the function is strictly convex, the weights are strictly positive and the indexed family of\npoints is non-constant, then Jensen's inequality is strict.\n\nSee also `StrictConvexOn.map_sum_eq_iff`. -/\nlemma StrictConvexOn.map_sum_lt (hf : StrictConvexOn ğ•œ s f) (hâ‚€ : âˆ€ i âˆˆ t, 0 < w i)\n    (hâ‚ : âˆ‘ i âˆˆ t, w i = 1) (hmem : âˆ€ i âˆˆ t, p i âˆˆ s) (hp : âˆƒ j âˆˆ t, âˆƒ k âˆˆ t, p j â‰  p k) :\n    f (âˆ‘ i âˆˆ t, w i â€¢ p i) < âˆ‘ i âˆˆ t, w i â€¢ f (p i) := by\n  classical\n  obtain âŸ¨j, hj, k, hk, hjkâŸ© := hp\n  -- We replace `t` by `t \\ {j, k}`\n  have : k âˆˆ t.erase j := mem_erase.2 âŸ¨ne_of_apply_ne _ hjk.symm, hkâŸ©\n  let u := (t.erase j).erase k\n  have hj : j âˆ‰ u := by simp [u]\n  have hk : k âˆ‰ u := by simp [u]\n  have ht :\n      t = (u.cons k hk).cons j (mem_cons.not.2 <| not_or_intro (ne_of_apply_ne _ hjk) hj) := by\n    simp [u, insert_erase this, insert_erase â€¹j âˆˆ tâ€º, *]\n  clear_value u\n  subst ht\n  simp only [sum_cons]\n  have := hâ‚€ j <| by simp\n  have := hâ‚€ k <| by simp\n  let c := w j + w k\n  have hc : w j / c + w k / c = 1 := by field_simp [c]\n  calc f (w j â€¢ p j + (w k â€¢ p k + âˆ‘ x âˆˆ u, w x â€¢ p x))\n    _ = f (c â€¢ ((w j / c) â€¢ p j + (w k / c) â€¢ p k) + âˆ‘ x âˆˆ u, w x â€¢ p x) := by\n      congrm f ?_\n      match_scalars <;> field_simp\n    _ â‰¤ c â€¢ f ((w j / c) â€¢ p j + (w k / c) â€¢ p k) + âˆ‘ x âˆˆ u, w x â€¢ f (p x) :=\n      -- apply the usual Jensen's inequality wrt the weighted average of the two distinguished\n      -- points and all the other points\n        hf.convexOn.map_add_sum_le (fun i hi â†¦ (hâ‚€ _ <| by simp [hi]).le)\n          (by simpa [-cons_eq_insert, â† add_assoc] using hâ‚)\n          (forall_of_forall_cons <| forall_of_forall_cons hmem) (by positivity) <| by\n           refine hf.1 (hmem _ <| by simp) (hmem _ <| by simp) ?_ ?_ hc <;> positivity\n    _ < c â€¢ ((w j / c) â€¢ f (p j) + (w k / c) â€¢ f (p k)) + âˆ‘ x âˆˆ u, w x â€¢ f (p x) := by\n      -- then apply the definition of strict convexity for the two distinguished points\n      gcongr; refine hf.2 (hmem _ <| by simp) (hmem _ <| by simp) hjk ?_ ?_ hc <;> positivity\n    _ = (w j â€¢ f (p j) + w k â€¢ f (p k)) + âˆ‘ x âˆˆ u, w x â€¢ f (p x) := by\n      match_scalars <;> field_simp\n    _ = w j â€¢ f (p j) + (w k â€¢ f (p k) + âˆ‘ x âˆˆ u, w x â€¢ f (p x)) := by abel_nf\n\n"}
{"name":"StrictConcaveOn.lt_map_sum","module":"Mathlib.Analysis.Convex.Jensen","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nÎ² : Type u_4\nÎ¹ : Type u_5\ninstâœâµ : LinearOrderedField ğ•œ\ninstâœâ´ : AddCommGroup E\ninstâœÂ³ : OrderedAddCommGroup Î²\ninstâœÂ² : Module ğ•œ E\ninstâœÂ¹ : Module ğ•œ Î²\ninstâœ : OrderedSMul ğ•œ Î²\ns : Set E\nf : E â†’ Î²\nt : Finset Î¹\nw : Î¹ â†’ ğ•œ\np : Î¹ â†’ E\nhf : StrictConcaveOn ğ•œ s f\nhâ‚€ : âˆ€ (i : Î¹), Membership.mem t i â†’ LT.lt 0 (w i)\nhâ‚ : Eq (t.sum fun i => w i) 1\nhmem : âˆ€ (i : Î¹), Membership.mem t i â†’ Membership.mem s (p i)\nhp : Exists fun j => And (Membership.mem t j) (Exists fun k => And (Membership.mem t k) (Ne (p j) (p k)))\nâŠ¢ LT.lt (t.sum fun i => HSMul.hSMul (w i) (f (p i))) (f (t.sum fun i => HSMul.hSMul (w i) (p i)))","decl":"/-- Concave **strict Jensen inequality**.\n\nIf the function is strictly concave, the weights are strictly positive and the indexed family of\npoints is non-constant, then Jensen's inequality is strict.\n\nSee also `StrictConcaveOn.map_sum_eq_iff`. -/\nlemma StrictConcaveOn.lt_map_sum (hf : StrictConcaveOn ğ•œ s f) (hâ‚€ : âˆ€ i âˆˆ t, 0 < w i)\n    (hâ‚ : âˆ‘ i âˆˆ t, w i = 1) (hmem : âˆ€ i âˆˆ t, p i âˆˆ s) (hp : âˆƒ j âˆˆ t, âˆƒ k âˆˆ t, p j â‰  p k) :\n    âˆ‘ i âˆˆ t, w i â€¢ f (p i) < f (âˆ‘ i âˆˆ t, w i â€¢ p i) := hf.dual.map_sum_lt hâ‚€ hâ‚ hmem hp\n\n"}
{"name":"StrictConvexOn.eq_of_le_map_sum","module":"Mathlib.Analysis.Convex.Jensen","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nÎ² : Type u_4\nÎ¹ : Type u_5\ninstâœâµ : LinearOrderedField ğ•œ\ninstâœâ´ : AddCommGroup E\ninstâœÂ³ : OrderedAddCommGroup Î²\ninstâœÂ² : Module ğ•œ E\ninstâœÂ¹ : Module ğ•œ Î²\ninstâœ : OrderedSMul ğ•œ Î²\ns : Set E\nf : E â†’ Î²\nt : Finset Î¹\nw : Î¹ â†’ ğ•œ\np : Î¹ â†’ E\nhf : StrictConvexOn ğ•œ s f\nhâ‚€ : âˆ€ (i : Î¹), Membership.mem t i â†’ LT.lt 0 (w i)\nhâ‚ : Eq (t.sum fun i => w i) 1\nhmem : âˆ€ (i : Î¹), Membership.mem t i â†’ Membership.mem s (p i)\nh_eq : LE.le (t.sum fun i => HSMul.hSMul (w i) (f (p i))) (f (t.sum fun i => HSMul.hSMul (w i) (p i)))\nj : Î¹\naâœÂ¹ : Membership.mem t j\nk : Î¹\naâœ : Membership.mem t k\nâŠ¢ Eq (p j) (p k)","decl":"/-- A form of the **equality case of Jensen's equality**.\n\nFor a strictly convex function `f` and positive weights `w`, if\n`f (âˆ‘ i âˆˆ t, w i â€¢ p i) = âˆ‘ i âˆˆ t, w i â€¢ f (p i)`, then the points `p` are all equal.\n\nSee also `StrictConvexOn.map_sum_eq_iff`. -/\nlemma StrictConvexOn.eq_of_le_map_sum (hf : StrictConvexOn ğ•œ s f) (hâ‚€ : âˆ€ i âˆˆ t, 0 < w i)\n    (hâ‚ : âˆ‘ i âˆˆ t, w i = 1) (hmem : âˆ€ i âˆˆ t, p i âˆˆ s)\n    (h_eq : âˆ‘ i âˆˆ t, w i â€¢ f (p i) â‰¤ f (âˆ‘ i âˆˆ t, w i â€¢ p i)) :\n    âˆ€ â¦ƒjâ¦„, j âˆˆ t â†’ âˆ€ â¦ƒkâ¦„, k âˆˆ t â†’ p j = p k := by\n  by_contra!; exact h_eq.not_lt <| hf.map_sum_lt hâ‚€ hâ‚ hmem this\n\n"}
{"name":"StrictConcaveOn.eq_of_map_sum_eq","module":"Mathlib.Analysis.Convex.Jensen","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nÎ² : Type u_4\nÎ¹ : Type u_5\ninstâœâµ : LinearOrderedField ğ•œ\ninstâœâ´ : AddCommGroup E\ninstâœÂ³ : OrderedAddCommGroup Î²\ninstâœÂ² : Module ğ•œ E\ninstâœÂ¹ : Module ğ•œ Î²\ninstâœ : OrderedSMul ğ•œ Î²\ns : Set E\nf : E â†’ Î²\nt : Finset Î¹\nw : Î¹ â†’ ğ•œ\np : Î¹ â†’ E\nhf : StrictConcaveOn ğ•œ s f\nhâ‚€ : âˆ€ (i : Î¹), Membership.mem t i â†’ LT.lt 0 (w i)\nhâ‚ : Eq (t.sum fun i => w i) 1\nhmem : âˆ€ (i : Î¹), Membership.mem t i â†’ Membership.mem s (p i)\nh_eq : LE.le (f (t.sum fun i => HSMul.hSMul (w i) (p i))) (t.sum fun i => HSMul.hSMul (w i) (f (p i)))\nj : Î¹\naâœÂ¹ : Membership.mem t j\nk : Î¹\naâœ : Membership.mem t k\nâŠ¢ Eq (p j) (p k)","decl":"/-- A form of the **equality case of Jensen's equality**.\n\nFor a strictly concave function `f` and positive weights `w`, if\n`f (âˆ‘ i âˆˆ t, w i â€¢ p i) = âˆ‘ i âˆˆ t, w i â€¢ f (p i)`, then the points `p` are all equal.\n\nSee also `StrictConcaveOn.map_sum_eq_iff`. -/\nlemma StrictConcaveOn.eq_of_map_sum_eq (hf : StrictConcaveOn ğ•œ s f) (hâ‚€ : âˆ€ i âˆˆ t, 0 < w i)\n    (hâ‚ : âˆ‘ i âˆˆ t, w i = 1) (hmem : âˆ€ i âˆˆ t, p i âˆˆ s)\n    (h_eq : f (âˆ‘ i âˆˆ t, w i â€¢ p i) â‰¤ âˆ‘ i âˆˆ t, w i â€¢ f (p i)) :\n    âˆ€ â¦ƒjâ¦„, j âˆˆ t â†’ âˆ€ â¦ƒkâ¦„, k âˆˆ t â†’ p j = p k := by\n  by_contra!; exact h_eq.not_lt <| hf.lt_map_sum hâ‚€ hâ‚ hmem this\n\n"}
{"name":"StrictConvexOn.map_sum_eq_iff","module":"Mathlib.Analysis.Convex.Jensen","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nÎ² : Type u_4\nÎ¹ : Type u_5\ninstâœâµ : LinearOrderedField ğ•œ\ninstâœâ´ : AddCommGroup E\ninstâœÂ³ : OrderedAddCommGroup Î²\ninstâœÂ² : Module ğ•œ E\ninstâœÂ¹ : Module ğ•œ Î²\ninstâœ : OrderedSMul ğ•œ Î²\ns : Set E\nf : E â†’ Î²\nt : Finset Î¹\nw : Î¹ â†’ ğ•œ\np : Î¹ â†’ E\nhf : StrictConvexOn ğ•œ s f\nhâ‚€ : âˆ€ (i : Î¹), Membership.mem t i â†’ LT.lt 0 (w i)\nhâ‚ : Eq (t.sum fun i => w i) 1\nhmem : âˆ€ (i : Î¹), Membership.mem t i â†’ Membership.mem s (p i)\nâŠ¢ Iff (Eq (f (t.sum fun i => HSMul.hSMul (w i) (p i))) (t.sum fun i => HSMul.hSMul (w i) (f (p i)))) (âˆ€ (j : Î¹), Membership.mem t j â†’ Eq (p j) (t.sum fun i => HSMul.hSMul (w i) (p i)))","decl":"/-- Canonical form of the **equality case of Jensen's equality**.\n\nFor a strictly convex function `f` and positive weights `w`, we have\n`f (âˆ‘ i âˆˆ t, w i â€¢ p i) = âˆ‘ i âˆˆ t, w i â€¢ f (p i)` if and only if the points `p` are all equal\n(and in fact all equal to their center of mass wrt `w`). -/\nlemma StrictConvexOn.map_sum_eq_iff {w : Î¹ â†’ ğ•œ} {p : Î¹ â†’ E} (hf : StrictConvexOn ğ•œ s f)\n    (hâ‚€ : âˆ€ i âˆˆ t, 0 < w i) (hâ‚ : âˆ‘ i âˆˆ t, w i = 1) (hmem : âˆ€ i âˆˆ t, p i âˆˆ s) :\n    f (âˆ‘ i âˆˆ t, w i â€¢ p i) = âˆ‘ i âˆˆ t, w i â€¢ f (p i) â†” âˆ€ j âˆˆ t, p j = âˆ‘ i âˆˆ t, w i â€¢ p i := by\n  constructor\n  Â· obtain rfl | âŸ¨iâ‚€, hiâ‚€âŸ© := t.eq_empty_or_nonempty\n    Â· simp\n    intro h_eq i hi\n    have H : âˆ€ j âˆˆ t, p j = p iâ‚€ := by\n      intro j hj\n      apply hf.eq_of_le_map_sum hâ‚€ hâ‚ hmem h_eq.ge hj hiâ‚€\n    calc p i = p iâ‚€ := by rw [H _ hi]\n      _ = (1 : ğ•œ) â€¢ p iâ‚€ := by simp\n      _ = (âˆ‘ j âˆˆ t, w j) â€¢ p iâ‚€ := by rw [hâ‚]\n      _ = âˆ‘ j âˆˆ t, (w j â€¢ p iâ‚€) := by rw [sum_smul]\n      _ = âˆ‘ j âˆˆ t, (w j â€¢ p j) := by congr! 2 with j hj; rw [â† H _ hj]\n  Â· intro h\n    have H : âˆ€ j âˆˆ t, w j â€¢ f (p j) = w j â€¢ f (âˆ‘ i âˆˆ t, w i â€¢ p i) := by\n      intro j hj\n      simp [h j hj]\n    rw [sum_congr rfl H, â† sum_smul, hâ‚, one_smul]\n\n"}
{"name":"StrictConcaveOn.map_sum_eq_iff","module":"Mathlib.Analysis.Convex.Jensen","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nÎ² : Type u_4\nÎ¹ : Type u_5\ninstâœâµ : LinearOrderedField ğ•œ\ninstâœâ´ : AddCommGroup E\ninstâœÂ³ : OrderedAddCommGroup Î²\ninstâœÂ² : Module ğ•œ E\ninstâœÂ¹ : Module ğ•œ Î²\ninstâœ : OrderedSMul ğ•œ Î²\ns : Set E\nf : E â†’ Î²\nt : Finset Î¹\nw : Î¹ â†’ ğ•œ\np : Î¹ â†’ E\nhf : StrictConcaveOn ğ•œ s f\nhâ‚€ : âˆ€ (i : Î¹), Membership.mem t i â†’ LT.lt 0 (w i)\nhâ‚ : Eq (t.sum fun i => w i) 1\nhmem : âˆ€ (i : Î¹), Membership.mem t i â†’ Membership.mem s (p i)\nâŠ¢ Iff (Eq (f (t.sum fun i => HSMul.hSMul (w i) (p i))) (t.sum fun i => HSMul.hSMul (w i) (f (p i)))) (âˆ€ (j : Î¹), Membership.mem t j â†’ Eq (p j) (t.sum fun i => HSMul.hSMul (w i) (p i)))","decl":"/-- Canonical form of the **equality case of Jensen's equality**.\n\nFor a strictly concave function `f` and positive weights `w`, we have\n`f (âˆ‘ i âˆˆ t, w i â€¢ p i) = âˆ‘ i âˆˆ t, w i â€¢ f (p i)` if and only if the points `p` are all equal\n(and in fact all equal to their center of mass wrt `w`). -/\nlemma StrictConcaveOn.map_sum_eq_iff (hf : StrictConcaveOn ğ•œ s f) (hâ‚€ : âˆ€ i âˆˆ t, 0 < w i)\n    (hâ‚ : âˆ‘ i âˆˆ t, w i = 1) (hmem : âˆ€ i âˆˆ t, p i âˆˆ s) :\n    f (âˆ‘ i âˆˆ t, w i â€¢ p i) = âˆ‘ i âˆˆ t, w i â€¢ f (p i) â†” âˆ€ j âˆˆ t, p j = âˆ‘ i âˆˆ t, w i â€¢ p i := by\n  simpa using hf.neg.map_sum_eq_iff hâ‚€ hâ‚ hmem\n\n"}
{"name":"StrictConvexOn.map_sum_eq_iff'","module":"Mathlib.Analysis.Convex.Jensen","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nÎ² : Type u_4\nÎ¹ : Type u_5\ninstâœâµ : LinearOrderedField ğ•œ\ninstâœâ´ : AddCommGroup E\ninstâœÂ³ : OrderedAddCommGroup Î²\ninstâœÂ² : Module ğ•œ E\ninstâœÂ¹ : Module ğ•œ Î²\ninstâœ : OrderedSMul ğ•œ Î²\ns : Set E\nf : E â†’ Î²\nt : Finset Î¹\nw : Î¹ â†’ ğ•œ\np : Î¹ â†’ E\nhf : StrictConvexOn ğ•œ s f\nhâ‚€ : âˆ€ (i : Î¹), Membership.mem t i â†’ LE.le 0 (w i)\nhâ‚ : Eq (t.sum fun i => w i) 1\nhmem : âˆ€ (i : Î¹), Membership.mem t i â†’ Membership.mem s (p i)\nâŠ¢ Iff (Eq (f (t.sum fun i => HSMul.hSMul (w i) (p i))) (t.sum fun i => HSMul.hSMul (w i) (f (p i)))) (âˆ€ (j : Î¹), Membership.mem t j â†’ Ne (w j) 0 â†’ Eq (p j) (t.sum fun i => HSMul.hSMul (w i) (p i)))","decl":"/-- Canonical form of the **equality case of Jensen's equality**.\n\nFor a strictly convex function `f` and nonnegative weights `w`, we have\n`f (âˆ‘ i âˆˆ t, w i â€¢ p i) = âˆ‘ i âˆˆ t, w i â€¢ f (p i)` if and only if the points `p` with nonzero\nweight are all equal (and in fact all equal to their center of mass wrt `w`). -/\nlemma StrictConvexOn.map_sum_eq_iff' (hf : StrictConvexOn ğ•œ s f) (hâ‚€ : âˆ€ i âˆˆ t, 0 â‰¤ w i)\n    (hâ‚ : âˆ‘ i âˆˆ t, w i = 1) (hmem : âˆ€ i âˆˆ t, p i âˆˆ s) :\n    f (âˆ‘ i âˆˆ t, w i â€¢ p i) = âˆ‘ i âˆˆ t, w i â€¢ f (p i) â†”\n      âˆ€ j âˆˆ t, w j â‰  0 â†’ p j = âˆ‘ i âˆˆ t, w i â€¢ p i := by\n  have hw (i) (_ : i âˆˆ t) : w i â€¢ p i â‰  0 â†’ w i â‰  0 := by aesop\n  have hw' (i) (_ : i âˆˆ t) : w i â€¢ f (p i) â‰  0 â†’ w i â‰  0 := by aesop\n  rw [â† sum_filter_of_ne hw, â† sum_filter_of_ne hw', hf.map_sum_eq_iff]\n  Â· simp\n  Â· simp +contextual [(hâ‚€ _ _).gt_iff_ne]\n  Â· rwa [sum_filter_ne_zero]\n  Â· simp +contextual [hmem _ _]\n\n"}
{"name":"StrictConcaveOn.map_sum_eq_iff'","module":"Mathlib.Analysis.Convex.Jensen","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nÎ² : Type u_4\nÎ¹ : Type u_5\ninstâœâµ : LinearOrderedField ğ•œ\ninstâœâ´ : AddCommGroup E\ninstâœÂ³ : OrderedAddCommGroup Î²\ninstâœÂ² : Module ğ•œ E\ninstâœÂ¹ : Module ğ•œ Î²\ninstâœ : OrderedSMul ğ•œ Î²\ns : Set E\nf : E â†’ Î²\nt : Finset Î¹\nw : Î¹ â†’ ğ•œ\np : Î¹ â†’ E\nhf : StrictConcaveOn ğ•œ s f\nhâ‚€ : âˆ€ (i : Î¹), Membership.mem t i â†’ LE.le 0 (w i)\nhâ‚ : Eq (t.sum fun i => w i) 1\nhmem : âˆ€ (i : Î¹), Membership.mem t i â†’ Membership.mem s (p i)\nâŠ¢ Iff (Eq (f (t.sum fun i => HSMul.hSMul (w i) (p i))) (t.sum fun i => HSMul.hSMul (w i) (f (p i)))) (âˆ€ (j : Î¹), Membership.mem t j â†’ Ne (w j) 0 â†’ Eq (p j) (t.sum fun i => HSMul.hSMul (w i) (p i)))","decl":"/-- Canonical form of the **equality case of Jensen's equality**.\n\nFor a strictly concave function `f` and nonnegative weights `w`, we have\n`f (âˆ‘ i âˆˆ t, w i â€¢ p i) = âˆ‘ i âˆˆ t, w i â€¢ f (p i)` if and only if the points `p` with nonzero\nweight are all equal (and in fact all equal to their center of mass wrt `w`). -/\nlemma StrictConcaveOn.map_sum_eq_iff' (hf : StrictConcaveOn ğ•œ s f) (hâ‚€ : âˆ€ i âˆˆ t, 0 â‰¤ w i)\n    (hâ‚ : âˆ‘ i âˆˆ t, w i = 1) (hmem : âˆ€ i âˆˆ t, p i âˆˆ s) :\n    f (âˆ‘ i âˆˆ t, w i â€¢ p i) = âˆ‘ i âˆˆ t, w i â€¢ f (p i) â†”\n      âˆ€ j âˆˆ t, w j â‰  0 â†’ p j = âˆ‘ i âˆˆ t, w i â€¢ p i := hf.dual.map_sum_eq_iff' hâ‚€ hâ‚ hmem\n\n"}
{"name":"ConvexOn.le_sup_of_mem_convexHull","module":"Mathlib.Analysis.Convex.Jensen","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nÎ² : Type u_4\ninstâœâµ : LinearOrderedField ğ•œ\ninstâœâ´ : AddCommGroup E\ninstâœÂ³ : LinearOrderedAddCommGroup Î²\ninstâœÂ² : Module ğ•œ E\ninstâœÂ¹ : Module ğ•œ Î²\ninstâœ : OrderedSMul ğ•œ Î²\ns : Set E\nf : E â†’ Î²\nx : E\nt : Finset E\nhf : ConvexOn ğ•œ s f\nhts : HasSubset.Subset (â†‘t) s\nhx : Membership.mem ((convexHull ğ•œ) â†‘t) x\nâŠ¢ LE.le (f x) (t.sup' â‹¯ f)","decl":"theorem ConvexOn.le_sup_of_mem_convexHull {t : Finset E} (hf : ConvexOn ğ•œ s f) (hts : â†‘t âŠ† s)\n    (hx : x âˆˆ convexHull ğ•œ (t : Set E)) :\n    f x â‰¤ t.sup' (coe_nonempty.1 <| convexHull_nonempty_iff.1 âŸ¨x, hxâŸ©) f := by\n  obtain âŸ¨w, hwâ‚€, hwâ‚, rflâŸ© := mem_convexHull.1 hx\n  exact (hf.map_centerMass_le hwâ‚€ (by positivity) hts).trans\n    (centerMass_le_sup hwâ‚€ <| by positivity)\n\n"}
{"name":"ConvexOn.inf_le_of_mem_convexHull","module":"Mathlib.Analysis.Convex.Jensen","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nÎ² : Type u_4\ninstâœâµ : LinearOrderedField ğ•œ\ninstâœâ´ : AddCommGroup E\ninstâœÂ³ : LinearOrderedAddCommGroup Î²\ninstâœÂ² : Module ğ•œ E\ninstâœÂ¹ : Module ğ•œ Î²\ninstâœ : OrderedSMul ğ•œ Î²\ns : Set E\nf : E â†’ Î²\nx : E\nt : Finset E\nhf : ConcaveOn ğ•œ s f\nhts : HasSubset.Subset (â†‘t) s\nhx : Membership.mem ((convexHull ğ•œ) â†‘t) x\nâŠ¢ LE.le (t.inf' â‹¯ f) (f x)","decl":"theorem ConvexOn.inf_le_of_mem_convexHull {t : Finset E} (hf : ConcaveOn ğ•œ s f) (hts : â†‘t âŠ† s)\n    (hx : x âˆˆ convexHull ğ•œ (t : Set E)) :\n    t.inf' (coe_nonempty.1 <| convexHull_nonempty_iff.1 âŸ¨x, hxâŸ©) f â‰¤ f x :=\n  hf.dual.le_sup_of_mem_convexHull hts hx\n\n"}
{"name":"le_sup_of_mem_convexHull","module":"Mathlib.Analysis.Convex.Jensen","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nÎ² : Type u_4\ninstâœâµ : LinearOrderedField ğ•œ\ninstâœâ´ : AddCommGroup E\ninstâœÂ³ : LinearOrderedAddCommGroup Î²\ninstâœÂ² : Module ğ•œ E\ninstâœÂ¹ : Module ğ•œ Î²\ninstâœ : OrderedSMul ğ•œ Î²\ns : Set E\nf : E â†’ Î²\nx : E\nt : Finset E\nhf : ConvexOn ğ•œ s f\nhts : HasSubset.Subset (â†‘t) s\nhx : Membership.mem ((convexHull ğ•œ) â†‘t) x\nâŠ¢ LE.le (f x) (t.sup' â‹¯ f)","decl":"@[deprecated (since := \"2024-08-25\")]\nalias le_sup_of_mem_convexHull := ConvexOn.le_sup_of_mem_convexHull\n\n"}
{"name":"inf_le_of_mem_convexHull","module":"Mathlib.Analysis.Convex.Jensen","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nÎ² : Type u_4\ninstâœâµ : LinearOrderedField ğ•œ\ninstâœâ´ : AddCommGroup E\ninstâœÂ³ : LinearOrderedAddCommGroup Î²\ninstâœÂ² : Module ğ•œ E\ninstâœÂ¹ : Module ğ•œ Î²\ninstâœ : OrderedSMul ğ•œ Î²\ns : Set E\nf : E â†’ Î²\nx : E\nt : Finset E\nhf : ConcaveOn ğ•œ s f\nhts : HasSubset.Subset (â†‘t) s\nhx : Membership.mem ((convexHull ğ•œ) â†‘t) x\nâŠ¢ LE.le (t.inf' â‹¯ f) (f x)","decl":"@[deprecated (since := \"2024-08-25\")]\nalias inf_le_of_mem_convexHull := ConvexOn.inf_le_of_mem_convexHull\n\n"}
{"name":"ConvexOn.exists_ge_of_centerMass","module":"Mathlib.Analysis.Convex.Jensen","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nÎ² : Type u_4\nÎ¹ : Type u_5\ninstâœâµ : LinearOrderedField ğ•œ\ninstâœâ´ : AddCommGroup E\ninstâœÂ³ : LinearOrderedAddCommGroup Î²\ninstâœÂ² : Module ğ•œ E\ninstâœÂ¹ : Module ğ•œ Î²\ninstâœ : OrderedSMul ğ•œ Î²\ns : Set E\nf : E â†’ Î²\nw : Î¹ â†’ ğ•œ\np : Î¹ â†’ E\nt : Finset Î¹\nh : ConvexOn ğ•œ s f\nhwâ‚€ : âˆ€ (i : Î¹), Membership.mem t i â†’ LE.le 0 (w i)\nhwâ‚ : LT.lt 0 (t.sum fun i => w i)\nhp : âˆ€ (i : Î¹), Membership.mem t i â†’ Membership.mem s (p i)\nâŠ¢ Exists fun i => And (Membership.mem t i) (LE.le (f (t.centerMass w p)) (f (p i)))","decl":"/-- If a function `f` is convex on `s`, then the value it takes at some center of mass of points of\n`s` is less than the value it takes on one of those points. -/\nlemma ConvexOn.exists_ge_of_centerMass {t : Finset Î¹} (h : ConvexOn ğ•œ s f)\n    (hwâ‚€ : âˆ€ i âˆˆ t, 0 â‰¤ w i) (hwâ‚ : 0 < âˆ‘ i âˆˆ t, w i) (hp : âˆ€ i âˆˆ t, p i âˆˆ s) :\n    âˆƒ i âˆˆ t, f (t.centerMass w p) â‰¤ f (p i) := by\n  set y := t.centerMass w p\n  -- TODO: can `rsuffices` be used to write the `exact` first, then the proof of this obtain?\n  obtain âŸ¨i, hi, hfiâŸ© : âˆƒ i âˆˆ {i âˆˆ t | w i â‰  0}, w i â€¢ f y â‰¤ w i â€¢ (f âˆ˜ p) i := by\n    have hw' : (0 : ğ•œ) < âˆ‘ i âˆˆ t with w i â‰  0, w i := by rwa [sum_filter_ne_zero]\n    refine exists_le_of_sum_le (nonempty_of_sum_ne_zero hw'.ne') ?_\n    rw [â† sum_smul, â† smul_le_smul_iff_of_pos_left (inv_pos.2 hw'), inv_smul_smulâ‚€ hw'.ne', â†\n      centerMass, centerMass_filter_ne_zero]\n    exact h.map_centerMass_le hwâ‚€ hwâ‚ hp\n  rw [mem_filter] at hi\n  exact âŸ¨i, hi.1, (smul_le_smul_iff_of_pos_left <| (hwâ‚€ i hi.1).lt_of_ne hi.2.symm).1 hfiâŸ©\n\n"}
{"name":"ConcaveOn.exists_le_of_centerMass","module":"Mathlib.Analysis.Convex.Jensen","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nÎ² : Type u_4\nÎ¹ : Type u_5\ninstâœâµ : LinearOrderedField ğ•œ\ninstâœâ´ : AddCommGroup E\ninstâœÂ³ : LinearOrderedAddCommGroup Î²\ninstâœÂ² : Module ğ•œ E\ninstâœÂ¹ : Module ğ•œ Î²\ninstâœ : OrderedSMul ğ•œ Î²\ns : Set E\nf : E â†’ Î²\nw : Î¹ â†’ ğ•œ\np : Î¹ â†’ E\nt : Finset Î¹\nh : ConcaveOn ğ•œ s f\nhwâ‚€ : âˆ€ (i : Î¹), Membership.mem t i â†’ LE.le 0 (w i)\nhwâ‚ : LT.lt 0 (t.sum fun i => w i)\nhp : âˆ€ (i : Î¹), Membership.mem t i â†’ Membership.mem s (p i)\nâŠ¢ Exists fun i => And (Membership.mem t i) (LE.le (f (p i)) (f (t.centerMass w p)))","decl":"/-- If a function `f` is concave on `s`, then the value it takes at some center of mass of points of\n`s` is greater than the value it takes on one of those points. -/\nlemma ConcaveOn.exists_le_of_centerMass {t : Finset Î¹} (h : ConcaveOn ğ•œ s f)\n    (hwâ‚€ : âˆ€ i âˆˆ t, 0 â‰¤ w i) (hwâ‚ : 0 < âˆ‘ i âˆˆ t, w i) (hp : âˆ€ i âˆˆ t, p i âˆˆ s) :\n    âˆƒ i âˆˆ t, f (p i) â‰¤ f (t.centerMass w p) := h.dual.exists_ge_of_centerMass hwâ‚€ hwâ‚ hp\n\n"}
{"name":"ConvexOn.exists_ge_of_mem_convexHull","module":"Mathlib.Analysis.Convex.Jensen","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nÎ² : Type u_4\ninstâœâµ : LinearOrderedField ğ•œ\ninstâœâ´ : AddCommGroup E\ninstâœÂ³ : LinearOrderedAddCommGroup Î²\ninstâœÂ² : Module ğ•œ E\ninstâœÂ¹ : Module ğ•œ Î²\ninstâœ : OrderedSMul ğ•œ Î²\ns : Set E\nf : E â†’ Î²\nx : E\nt : Set E\nhf : ConvexOn ğ•œ s f\nhts : HasSubset.Subset t s\nhx : Membership.mem ((convexHull ğ•œ) t) x\nâŠ¢ Exists fun y => And (Membership.mem t y) (LE.le (f x) (f y))","decl":"/-- **Maximum principle** for convex functions. If a function `f` is convex on the convex hull of\n`s`, then the eventual maximum of `f` on `convexHull ğ•œ s` lies in `s`. -/\nlemma ConvexOn.exists_ge_of_mem_convexHull {t : Set E} (hf : ConvexOn ğ•œ s f) (hts : t âŠ† s)\n    (hx : x âˆˆ convexHull ğ•œ t) : âˆƒ y âˆˆ t, f x â‰¤ f y := by\n  rw [_root_.convexHull_eq] at hx\n  obtain âŸ¨Î±, t, w, p, hwâ‚€, hwâ‚, hp, rflâŸ© := hx\n  obtain âŸ¨i, hit, HiâŸ© := hf.exists_ge_of_centerMass hwâ‚€ (hwâ‚.symm â–¸ zero_lt_one)\n    fun i hi â†¦ hts (hp i hi)\n  exact âŸ¨p i, hp i hit, HiâŸ©\n\n"}
{"name":"ConcaveOn.exists_le_of_mem_convexHull","module":"Mathlib.Analysis.Convex.Jensen","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nÎ² : Type u_4\ninstâœâµ : LinearOrderedField ğ•œ\ninstâœâ´ : AddCommGroup E\ninstâœÂ³ : LinearOrderedAddCommGroup Î²\ninstâœÂ² : Module ğ•œ E\ninstâœÂ¹ : Module ğ•œ Î²\ninstâœ : OrderedSMul ğ•œ Î²\ns : Set E\nf : E â†’ Î²\nx : E\nt : Set E\nhf : ConcaveOn ğ•œ s f\nhts : HasSubset.Subset t s\nhx : Membership.mem ((convexHull ğ•œ) t) x\nâŠ¢ Exists fun y => And (Membership.mem t y) (LE.le (f y) (f x))","decl":"/-- **Minimum principle** for concave functions. If a function `f` is concave on the convex hull of\n`s`, then the eventual minimum of `f` on `convexHull ğ•œ s` lies in `s`. -/\nlemma ConcaveOn.exists_le_of_mem_convexHull {t : Set E} (hf : ConcaveOn ğ•œ s f) (hts : t âŠ† s)\n    (hx : x âˆˆ convexHull ğ•œ t) : âˆƒ y âˆˆ t, f y â‰¤ f x := hf.dual.exists_ge_of_mem_convexHull hts hx\n\n"}
{"name":"ConvexOn.le_max_of_mem_segment","module":"Mathlib.Analysis.Convex.Jensen","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nÎ² : Type u_4\ninstâœâµ : LinearOrderedField ğ•œ\ninstâœâ´ : AddCommGroup E\ninstâœÂ³ : LinearOrderedAddCommGroup Î²\ninstâœÂ² : Module ğ•œ E\ninstâœÂ¹ : Module ğ•œ Î²\ninstâœ : OrderedSMul ğ•œ Î²\ns : Set E\nf : E â†’ Î²\nx y z : E\nhf : ConvexOn ğ•œ s f\nhx : Membership.mem s x\nhy : Membership.mem s y\nhz : Membership.mem (segment ğ•œ x y) z\nâŠ¢ LE.le (f z) (Max.max (f x) (f y))","decl":"/-- **Maximum principle** for convex functions on a segment. If a function `f` is convex on the\nsegment `[x, y]`, then the eventual maximum of `f` on `[x, y]` is at `x` or `y`. -/\nlemma ConvexOn.le_max_of_mem_segment (hf : ConvexOn ğ•œ s f) (hx : x âˆˆ s) (hy : y âˆˆ s)\n    (hz : z âˆˆ [x -[ğ•œ] y]) : f z â‰¤ max (f x) (f y) := by\n  rw [â† convexHull_pair] at hz; simpa using hf.exists_ge_of_mem_convexHull (pair_subset hx hy) hz\n\n"}
{"name":"ConcaveOn.min_le_of_mem_segment","module":"Mathlib.Analysis.Convex.Jensen","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nÎ² : Type u_4\ninstâœâµ : LinearOrderedField ğ•œ\ninstâœâ´ : AddCommGroup E\ninstâœÂ³ : LinearOrderedAddCommGroup Î²\ninstâœÂ² : Module ğ•œ E\ninstâœÂ¹ : Module ğ•œ Î²\ninstâœ : OrderedSMul ğ•œ Î²\ns : Set E\nf : E â†’ Î²\nx y z : E\nhf : ConcaveOn ğ•œ s f\nhx : Membership.mem s x\nhy : Membership.mem s y\nhz : Membership.mem (segment ğ•œ x y) z\nâŠ¢ LE.le (Min.min (f x) (f y)) (f z)","decl":"/-- **Minimum principle** for concave functions on a segment. If a function `f` is concave on the\nsegment `[x, y]`, then the eventual minimum of `f` on `[x, y]` is at `x` or `y`. -/\nlemma ConcaveOn.min_le_of_mem_segment (hf : ConcaveOn ğ•œ s f) (hx : x âˆˆ s) (hy : y âˆˆ s)\n    (hz : z âˆˆ [x -[ğ•œ] y]) : min (f x) (f y) â‰¤ f z := hf.dual.le_max_of_mem_segment hx hy hz\n\n"}
{"name":"ConvexOn.le_max_of_mem_Icc","module":"Mathlib.Analysis.Convex.Jensen","initialProofState":"ğ•œ : Type u_1\nÎ² : Type u_4\ninstâœÂ³ : LinearOrderedField ğ•œ\ninstâœÂ² : LinearOrderedAddCommGroup Î²\ninstâœÂ¹ : Module ğ•œ Î²\ninstâœ : OrderedSMul ğ•œ Î²\ns : Set ğ•œ\nf : ğ•œ â†’ Î²\nx y z : ğ•œ\nhf : ConvexOn ğ•œ s f\nhx : Membership.mem s x\nhy : Membership.mem s y\nhz : Membership.mem (Set.Icc x y) z\nâŠ¢ LE.le (f z) (Max.max (f x) (f y))","decl":"/-- **Maximum principle** for convex functions on an interval. If a function `f` is convex on the\ninterval `[x, y]`, then the eventual maximum of `f` on `[x, y]` is at `x` or `y`. -/\nlemma ConvexOn.le_max_of_mem_Icc {s : Set ğ•œ} {f : ğ•œ â†’ Î²} {x y z : ğ•œ} (hf : ConvexOn ğ•œ s f)\n    (hx : x âˆˆ s) (hy : y âˆˆ s) (hz : z âˆˆ Icc x y) : f z â‰¤ max (f x) (f y) := by\n  rw [â† segment_eq_Icc (hz.1.trans hz.2)] at hz; exact hf.le_max_of_mem_segment hx hy hz\n\n"}
{"name":"ConcaveOn.min_le_of_mem_Icc","module":"Mathlib.Analysis.Convex.Jensen","initialProofState":"ğ•œ : Type u_1\nÎ² : Type u_4\ninstâœÂ³ : LinearOrderedField ğ•œ\ninstâœÂ² : LinearOrderedAddCommGroup Î²\ninstâœÂ¹ : Module ğ•œ Î²\ninstâœ : OrderedSMul ğ•œ Î²\ns : Set ğ•œ\nf : ğ•œ â†’ Î²\nx y z : ğ•œ\nhf : ConcaveOn ğ•œ s f\nhx : Membership.mem s x\nhy : Membership.mem s y\nhz : Membership.mem (Set.Icc x y) z\nâŠ¢ LE.le (Min.min (f x) (f y)) (f z)","decl":"/-- **Minimum principle** for concave functions on an interval. If a function `f` is concave on the\ninterval `[x, y]`, then the eventual minimum of `f` on `[x, y]` is at `x` or `y`. -/\nlemma ConcaveOn.min_le_of_mem_Icc {s : Set ğ•œ} {f : ğ•œ â†’ Î²} {x y z : ğ•œ} (hf : ConcaveOn ğ•œ s f)\n    (hx : x âˆˆ s) (hy : y âˆˆ s) (hz : z âˆˆ Icc x y) : min (f x) (f y) â‰¤ f z :=\n  hf.dual.le_max_of_mem_Icc hx hy hz\n\n"}
{"name":"ConvexOn.bddAbove_convexHull","module":"Mathlib.Analysis.Convex.Jensen","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nÎ² : Type u_4\ninstâœâµ : LinearOrderedField ğ•œ\ninstâœâ´ : AddCommGroup E\ninstâœÂ³ : LinearOrderedAddCommGroup Î²\ninstâœÂ² : Module ğ•œ E\ninstâœÂ¹ : Module ğ•œ Î²\ninstâœ : OrderedSMul ğ•œ Î²\nf : E â†’ Î²\ns t : Set E\nhst : HasSubset.Subset s t\nhf : ConvexOn ğ•œ t f\naâœ : BddAbove (Set.image f s)\nâŠ¢ BddAbove (Set.image f ((convexHull ğ•œ) s))","decl":"lemma ConvexOn.bddAbove_convexHull {s t : Set E} (hst : s âŠ† t) (hf : ConvexOn ğ•œ t f) :\n    BddAbove (f '' s) â†’ BddAbove (f '' convexHull ğ•œ s) := by\n  rintro âŸ¨b, hbâŸ©\n  refine âŸ¨b, ?_âŸ©\n  rintro _ âŸ¨x, hx, rflâŸ©\n  obtain âŸ¨y, hy, hxyâŸ© := hf.exists_ge_of_mem_convexHull hst hx\n  exact hxy.trans <| hb <| mem_image_of_mem _ hy\n\n"}
{"name":"ConcaveOn.bddBelow_convexHull","module":"Mathlib.Analysis.Convex.Jensen","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nÎ² : Type u_4\ninstâœâµ : LinearOrderedField ğ•œ\ninstâœâ´ : AddCommGroup E\ninstâœÂ³ : LinearOrderedAddCommGroup Î²\ninstâœÂ² : Module ğ•œ E\ninstâœÂ¹ : Module ğ•œ Î²\ninstâœ : OrderedSMul ğ•œ Î²\nf : E â†’ Î²\ns t : Set E\nhst : HasSubset.Subset s t\nhf : ConcaveOn ğ•œ t f\naâœ : BddBelow (Set.image f s)\nâŠ¢ BddBelow (Set.image f ((convexHull ğ•œ) s))","decl":"lemma ConcaveOn.bddBelow_convexHull {s t : Set E} (hst : s âŠ† t) (hf : ConcaveOn ğ•œ t f) :\n    BddBelow (f '' s) â†’ BddBelow (f '' convexHull ğ•œ s) := hf.dual.bddAbove_convexHull hst\n\n"}
