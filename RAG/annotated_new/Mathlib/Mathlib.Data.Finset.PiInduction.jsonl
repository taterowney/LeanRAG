{"name":"Finset.induction_on_pi_of_choice","module":"Mathlib.Data.Finset.PiInduction","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝² : Finite ι\ninst✝¹ : DecidableEq ι\ninst✝ : (i : ι) → DecidableEq (α i)\nr : (i : ι) → α i → Finset (α i) → Prop\nH_ex : ∀ (i : ι) (s : Finset (α i)), s.Nonempty → Exists fun x => And (Membership.mem s x) (r i x (s.erase x))\np : ((i : ι) → Finset (α i)) → Prop\nf : (i : ι) → Finset (α i)\nh0 : p fun x => EmptyCollection.emptyCollection\nstep : ∀ (g : (i : ι) → Finset (α i)) (i : ι) (x : α i), r i x (g i) → p g → p (Function.update g i (Insert.insert x (g i)))\n⊢ p f","decl":"/-- General theorem for `Finset.induction_on_pi`-style induction principles. -/\ntheorem induction_on_pi_of_choice (r : ∀ i, α i → Finset (α i) → Prop)\n    (H_ex : ∀ (i) (s : Finset (α i)), s.Nonempty → ∃ x ∈ s, r i x (s.erase x))\n    {p : (∀ i, Finset (α i)) → Prop} (f : ∀ i, Finset (α i)) (h0 : p fun _ ↦ ∅)\n    (step :\n      ∀ (g : ∀ i, Finset (α i)) (i : ι) (x : α i),\n        r i x (g i) → p g → p (update g i (insert x (g i)))) :\n    p f := by\n  cases nonempty_fintype ι\n  induction' hs : univ.sigma f using Finset.strongInductionOn with s ihs generalizing f; subst s\n  rcases eq_empty_or_nonempty (univ.sigma f) with he | hne\n  · convert h0 using 1\n    simpa [funext_iff] using he\n  · rcases sigma_nonempty.1 hne with ⟨i, -, hi⟩\n    rcases H_ex i (f i) hi with ⟨x, x_mem, hr⟩\n    set g := update f i ((f i).erase x) with hg\n    clear_value g\n    have hx' : x ∉ g i := by\n      rw [hg, update_self]\n      apply not_mem_erase\n    rw [show f = update g i (insert x (g i)) by\n      rw [hg, update_idem, update_self, insert_erase x_mem, update_eq_self]] at hr ihs ⊢\n    clear hg\n    rw [update_self, erase_insert hx'] at hr\n    refine step _ _ _ hr (ihs (univ.sigma g) ?_ _ rfl)\n    rw [ssubset_iff_of_subset (sigma_mono (Subset.refl _) _)]\n    exacts [⟨⟨i, x⟩, mem_sigma.2 ⟨mem_univ _, by simp⟩, by simp [hx']⟩,\n      (@le_update_iff _ _ _ _ g g i _).2 ⟨subset_insert _ _, fun _ _ ↦ le_rfl⟩]\n\n"}
{"name":"Finset.induction_on_pi","module":"Mathlib.Data.Finset.PiInduction","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝² : Finite ι\ninst✝¹ : DecidableEq ι\ninst✝ : (i : ι) → DecidableEq (α i)\np : ((i : ι) → Finset (α i)) → Prop\nf : (i : ι) → Finset (α i)\nh0 : p fun x => EmptyCollection.emptyCollection\nstep : ∀ (g : (i : ι) → Finset (α i)) (i : ι) (x : α i), Not (Membership.mem (g i) x) → p g → p (Function.update g i (Insert.insert x (g i)))\n⊢ p f","decl":"/-- Given a predicate on functions `∀ i, Finset (α i)` defined on a finite type, it is true on all\nmaps provided that it is true on `fun _ ↦ ∅` and for any function `g : ∀ i, Finset (α i)`, an index\n`i : ι`, and `x ∉ g i`, `p g` implies `p (update g i (insert x (g i)))`.\n\nSee also `Finset.induction_on_pi_max` and `Finset.induction_on_pi_min` for specialized versions\nthat require `∀ i, LinearOrder (α i)`. -/\ntheorem induction_on_pi {p : (∀ i, Finset (α i)) → Prop} (f : ∀ i, Finset (α i)) (h0 : p fun _ ↦ ∅)\n    (step : ∀ (g : ∀ i, Finset (α i)) (i : ι), ∀ x ∉ g i, p g → p (update g i (insert x (g i)))) :\n    p f :=\n  induction_on_pi_of_choice (fun _ x s ↦ x ∉ s) (fun _ s ⟨x, hx⟩ ↦ ⟨x, hx, not_mem_erase x s⟩) f\n    h0 step\n\n-- Porting note: this docstring is the exact translation of the one from mathlib3 but\n-- the last sentence (here and in the next lemma) does make much sense to me...\n"}
{"name":"Finset.induction_on_pi_max","module":"Mathlib.Data.Finset.PiInduction","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝³ : Finite ι\ninst✝² : DecidableEq ι\ninst✝¹ : (i : ι) → DecidableEq (α i)\ninst✝ : (i : ι) → LinearOrder (α i)\np : ((i : ι) → Finset (α i)) → Prop\nf : (i : ι) → Finset (α i)\nh0 : p fun x => EmptyCollection.emptyCollection\nstep : ∀ (g : (i : ι) → Finset (α i)) (i : ι) (x : α i), (∀ (y : α i), Membership.mem (g i) y → LT.lt y x) → p g → p (Function.update g i (Insert.insert x (g i)))\n⊢ p f","decl":"/-- Given a predicate on functions `∀ i, Finset (α i)` defined on a finite type, it is true on all\nmaps provided that it is true on `fun _ ↦ ∅` and for any function `g : ∀ i, Finset (α i)`, an index\n`i : ι`, and an element`x : α i` that is strictly greater than all elements of `g i`, `p g` implies\n`p (update g i (insert x (g i)))`.\n\nThis lemma requires `LinearOrder` instances on all `α i`. See also `Finset.induction_on_pi` for a\nversion that `x ∉ g i` instead of ` does not need `∀ i, LinearOrder (α i)`. -/\ntheorem induction_on_pi_max [∀ i, LinearOrder (α i)] {p : (∀ i, Finset (α i)) → Prop}\n    (f : ∀ i, Finset (α i)) (h0 : p fun _ ↦ ∅)\n    (step :\n      ∀ (g : ∀ i, Finset (α i)) (i : ι) (x : α i),\n        (∀ y ∈ g i, y < x) → p g → p (update g i (insert x (g i)))) :\n    p f :=\n  induction_on_pi_of_choice (fun _ x s ↦ ∀ y ∈ s, y < x)\n    (fun _ s hs ↦ ⟨s.max' hs, s.max'_mem hs, fun _ ↦ s.lt_max'_of_mem_erase_max' _⟩) f h0 step\n\n"}
{"name":"Finset.induction_on_pi_min","module":"Mathlib.Data.Finset.PiInduction","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝³ : Finite ι\ninst✝² : DecidableEq ι\ninst✝¹ : (i : ι) → DecidableEq (α i)\ninst✝ : (i : ι) → LinearOrder (α i)\np : ((i : ι) → Finset (α i)) → Prop\nf : (i : ι) → Finset (α i)\nh0 : p fun x => EmptyCollection.emptyCollection\nstep : ∀ (g : (i : ι) → Finset (α i)) (i : ι) (x : α i), (∀ (y : α i), Membership.mem (g i) y → LT.lt x y) → p g → p (Function.update g i (Insert.insert x (g i)))\n⊢ p f","decl":"/-- Given a predicate on functions `∀ i, Finset (α i)` defined on a finite type, it is true on all\nmaps provided that it is true on `fun _ ↦ ∅` and for any function `g : ∀ i, Finset (α i)`, an index\n`i : ι`, and an element`x : α i` that is strictly less than all elements of `g i`, `p g` implies\n`p (update g i (insert x (g i)))`.\n\nThis lemma requires `LinearOrder` instances on all `α i`. See also `Finset.induction_on_pi` for a\nversion that `x ∉ g i` instead of ` does not need `∀ i, LinearOrder (α i)`. -/\ntheorem induction_on_pi_min [∀ i, LinearOrder (α i)] {p : (∀ i, Finset (α i)) → Prop}\n    (f : ∀ i, Finset (α i)) (h0 : p fun _ ↦ ∅)\n    (step :\n      ∀ (g : ∀ i, Finset (α i)) (i : ι) (x : α i),\n        (∀ y ∈ g i, x < y) → p g → p (update g i (insert x (g i)))) :\n    p f :=\n  induction_on_pi_max (α := fun i ↦ (α i)ᵒᵈ) _ h0 step\n\n"}
