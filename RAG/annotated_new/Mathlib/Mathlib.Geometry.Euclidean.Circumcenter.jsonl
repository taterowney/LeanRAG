{"name":"EuclideanGeometry.dist_eq_iff_dist_orthogonalProjection_eq","module":"Mathlib.Geometry.Euclidean.Circumcenter","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁵ : NormedAddCommGroup V\ninst✝⁴ : InnerProductSpace Real V\ninst✝³ : MetricSpace P\ninst✝² : NormedAddTorsor V P\ns : AffineSubspace Real P\ninst✝¹ : Nonempty (Subtype fun x => Membership.mem s x)\ninst✝ : HasOrthogonalProjection s.direction\np1 p2 p3 : P\nhp1 : Membership.mem s p1\nhp2 : Membership.mem s p2\n⊢ Iff (Eq (Dist.dist p1 p3) (Dist.dist p2 p3)) (Eq (Dist.dist p1 ↑((EuclideanGeometry.orthogonalProjection s) p3)) (Dist.dist p2 ↑((EuclideanGeometry.orthogonalProjection s) p3)))","decl":"/-- `p` is equidistant from two points in `s` if and only if its\n`orthogonalProjection` is. -/\ntheorem dist_eq_iff_dist_orthogonalProjection_eq {s : AffineSubspace ℝ P} [Nonempty s]\n    [HasOrthogonalProjection s.direction] {p1 p2 : P} (p3 : P) (hp1 : p1 ∈ s) (hp2 : p2 ∈ s) :\n    dist p1 p3 = dist p2 p3 ↔\n      dist p1 (orthogonalProjection s p3) = dist p2 (orthogonalProjection s p3) := by\n  rw [← mul_self_inj_of_nonneg dist_nonneg dist_nonneg, ←\n    mul_self_inj_of_nonneg dist_nonneg dist_nonneg,\n    dist_sq_eq_dist_orthogonalProjection_sq_add_dist_orthogonalProjection_sq p3 hp1,\n    dist_sq_eq_dist_orthogonalProjection_sq_add_dist_orthogonalProjection_sq p3 hp2]\n  simp\n\n"}
{"name":"EuclideanGeometry.dist_set_eq_iff_dist_orthogonalProjection_eq","module":"Mathlib.Geometry.Euclidean.Circumcenter","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁵ : NormedAddCommGroup V\ninst✝⁴ : InnerProductSpace Real V\ninst✝³ : MetricSpace P\ninst✝² : NormedAddTorsor V P\ns : AffineSubspace Real P\ninst✝¹ : Nonempty (Subtype fun x => Membership.mem s x)\ninst✝ : HasOrthogonalProjection s.direction\nps : Set P\nhps : HasSubset.Subset ps ↑s\np : P\n⊢ Iff (ps.Pairwise fun p1 p2 => Eq (Dist.dist p1 p) (Dist.dist p2 p)) (ps.Pairwise fun p1 p2 => Eq (Dist.dist p1 ↑((EuclideanGeometry.orthogonalProjection s) p)) (Dist.dist p2 ↑((EuclideanGeometry.orthogonalProjection s) p)))","decl":"/-- `p` is equidistant from a set of points in `s` if and only if its\n`orthogonalProjection` is. -/\ntheorem dist_set_eq_iff_dist_orthogonalProjection_eq {s : AffineSubspace ℝ P} [Nonempty s]\n    [HasOrthogonalProjection s.direction] {ps : Set P} (hps : ps ⊆ s) (p : P) :\n    (Set.Pairwise ps fun p1 p2 => dist p1 p = dist p2 p) ↔\n      Set.Pairwise ps fun p1 p2 =>\n        dist p1 (orthogonalProjection s p) = dist p2 (orthogonalProjection s p) :=\n  ⟨fun h _ hp1 _ hp2 hne =>\n    (dist_eq_iff_dist_orthogonalProjection_eq p (hps hp1) (hps hp2)).1 (h hp1 hp2 hne),\n    fun h _ hp1 _ hp2 hne =>\n    (dist_eq_iff_dist_orthogonalProjection_eq p (hps hp1) (hps hp2)).2 (h hp1 hp2 hne)⟩\n\n"}
{"name":"EuclideanGeometry.exists_dist_eq_iff_exists_dist_orthogonalProjection_eq","module":"Mathlib.Geometry.Euclidean.Circumcenter","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁵ : NormedAddCommGroup V\ninst✝⁴ : InnerProductSpace Real V\ninst✝³ : MetricSpace P\ninst✝² : NormedAddTorsor V P\ns : AffineSubspace Real P\ninst✝¹ : Nonempty (Subtype fun x => Membership.mem s x)\ninst✝ : HasOrthogonalProjection s.direction\nps : Set P\nhps : HasSubset.Subset ps ↑s\np : P\n⊢ Iff (Exists fun r => ∀ (p1 : P), Membership.mem ps p1 → Eq (Dist.dist p1 p) r) (Exists fun r => ∀ (p1 : P), Membership.mem ps p1 → Eq (Dist.dist p1 ↑((EuclideanGeometry.orthogonalProjection s) p)) r)","decl":"/-- There exists `r` such that `p` has distance `r` from all the\npoints of a set of points in `s` if and only if there exists (possibly\ndifferent) `r` such that its `orthogonalProjection` has that distance\nfrom all the points in that set. -/\ntheorem exists_dist_eq_iff_exists_dist_orthogonalProjection_eq {s : AffineSubspace ℝ P} [Nonempty s]\n    [HasOrthogonalProjection s.direction] {ps : Set P} (hps : ps ⊆ s) (p : P) :\n    (∃ r, ∀ p1 ∈ ps, dist p1 p = r) ↔ ∃ r, ∀ p1 ∈ ps, dist p1 ↑(orthogonalProjection s p) = r := by\n  have h := dist_set_eq_iff_dist_orthogonalProjection_eq hps p\n  simp_rw [Set.pairwise_eq_iff_exists_eq] at h\n  exact h\n\n"}
{"name":"EuclideanGeometry.existsUnique_dist_eq_of_insert","module":"Mathlib.Geometry.Euclidean.Circumcenter","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor V P\ns : AffineSubspace Real P\ninst✝ : HasOrthogonalProjection s.direction\nps : Set P\nhnps : ps.Nonempty\np : P\nhps : HasSubset.Subset ps ↑s\nhp : Not (Membership.mem s p)\nhu : ExistsUnique fun cs => And (Membership.mem s cs.center) (HasSubset.Subset ps (Metric.sphere cs.center cs.radius))\n⊢ ExistsUnique fun cs₂ => And (Membership.mem (affineSpan Real (Insert.insert p ↑s)) cs₂.center) (HasSubset.Subset (Insert.insert p ps) (Metric.sphere cs₂.center cs₂.radius))","decl":"/-- The induction step for the existence and uniqueness of the\ncircumcenter.  Given a nonempty set of points in a nonempty affine\nsubspace whose direction is complete, such that there is a unique\n(circumcenter, circumradius) pair for those points in that subspace,\nand a point `p` not in that subspace, there is a unique (circumcenter,\ncircumradius) pair for the set with `p` added, in the span of the\nsubspace with `p` added. -/\ntheorem existsUnique_dist_eq_of_insert {s : AffineSubspace ℝ P}\n    [HasOrthogonalProjection s.direction] {ps : Set P} (hnps : ps.Nonempty) {p : P} (hps : ps ⊆ s)\n    (hp : p ∉ s) (hu : ∃! cs : Sphere P, cs.center ∈ s ∧ ps ⊆ (cs : Set P)) :\n    ∃! cs₂ : Sphere P,\n      cs₂.center ∈ affineSpan ℝ (insert p (s : Set P)) ∧ insert p ps ⊆ (cs₂ : Set P) := by\n  haveI : Nonempty s := Set.Nonempty.to_subtype (hnps.mono hps)\n  rcases hu with ⟨⟨cc, cr⟩, ⟨hcc, hcr⟩, hcccru⟩\n  simp only at hcc hcr hcccru\n  let x := dist cc (orthogonalProjection s p)\n  let y := dist p (orthogonalProjection s p)\n  have hy0 : y ≠ 0 := dist_orthogonalProjection_ne_zero_of_not_mem hp\n  let ycc₂ := (x * x + y * y - cr * cr) / (2 * y)\n  let cc₂ := (ycc₂ / y) • (p -ᵥ orthogonalProjection s p : V) +ᵥ cc\n  let cr₂ := √(cr * cr + ycc₂ * ycc₂)\n  use ⟨cc₂, cr₂⟩\n  simp (config := { zeta := false, proj := false }) only\n  have hpo : p = (1 : ℝ) • (p -ᵥ orthogonalProjection s p : V) +ᵥ (orthogonalProjection s p : P) :=\n    by simp\n  constructor\n  · constructor\n    · refine vadd_mem_of_mem_direction ?_ (mem_affineSpan ℝ (Set.mem_insert_of_mem _ hcc))\n      rw [direction_affineSpan]\n      exact\n        Submodule.smul_mem _ _\n          (vsub_mem_vectorSpan ℝ (Set.mem_insert _ _)\n            (Set.mem_insert_of_mem _ (orthogonalProjection_mem _)))\n    · intro p1 hp1\n      rw [Sphere.mem_coe, mem_sphere, ← mul_self_inj_of_nonneg dist_nonneg (Real.sqrt_nonneg _),\n        Real.mul_self_sqrt (add_nonneg (mul_self_nonneg _) (mul_self_nonneg _))]\n      cases' hp1 with hp1 hp1\n      · rw [hp1]\n        rw [hpo,\n          dist_sq_smul_orthogonal_vadd_smul_orthogonal_vadd (orthogonalProjection_mem p) hcc _ _\n            (vsub_orthogonalProjection_mem_direction_orthogonal s p),\n          ← dist_eq_norm_vsub V p, dist_comm _ cc]\n        -- TODO(https://github.com/leanprover-community/mathlib4/issues/15486): used to be `field_simp`, but was really slow\n        -- replaced by `simp only ...` to speed up. Reinstate `field_simp` once it is faster.\n        simp (disch := field_simp_discharge) only [div_div, sub_div', one_mul, mul_div_assoc',\n          div_mul_eq_mul_div, add_div', eq_div_iff, div_eq_iff, ycc₂]\n        ring\n      · rw [dist_sq_eq_dist_orthogonalProjection_sq_add_dist_orthogonalProjection_sq _ (hps hp1),\n          orthogonalProjection_vadd_smul_vsub_orthogonalProjection _ _ hcc, Subtype.coe_mk,\n          dist_of_mem_subset_mk_sphere hp1 hcr, dist_eq_norm_vsub V cc₂ cc, vadd_vsub, norm_smul, ←\n          dist_eq_norm_vsub V, Real.norm_eq_abs, abs_div, abs_of_nonneg dist_nonneg,\n          div_mul_cancel₀ _ hy0, abs_mul_abs_self]\n  · rintro ⟨cc₃, cr₃⟩ ⟨hcc₃, hcr₃⟩\n    simp only at hcc₃ hcr₃\n    obtain ⟨t₃, cc₃', hcc₃', hcc₃''⟩ :\n      ∃ r : ℝ, ∃ p0 ∈ s, cc₃ = r • (p -ᵥ ↑((orthogonalProjection s) p)) +ᵥ p0 := by\n      rwa [mem_affineSpan_insert_iff (orthogonalProjection_mem p)] at hcc₃\n    have hcr₃' : ∃ r, ∀ p1 ∈ ps, dist p1 cc₃ = r :=\n      ⟨cr₃, fun p1 hp1 => dist_of_mem_subset_mk_sphere (Set.mem_insert_of_mem _ hp1) hcr₃⟩\n    rw [exists_dist_eq_iff_exists_dist_orthogonalProjection_eq hps cc₃, hcc₃'',\n      orthogonalProjection_vadd_smul_vsub_orthogonalProjection _ _ hcc₃'] at hcr₃'\n    cases' hcr₃' with cr₃' hcr₃'\n    have hu := hcccru ⟨cc₃', cr₃'⟩\n    simp only at hu\n    replace hu := hu ⟨hcc₃', hcr₃'⟩\n    -- Porting note: was\n    -- cases' hu with hucc hucr\n    -- substs hucc hucr\n    cases' hu\n    have hcr₃val : cr₃ = √(cr * cr + t₃ * y * (t₃ * y)) := by\n      cases' hnps with p0 hp0\n      have h' : ↑(⟨cc, hcc₃'⟩ : s) = cc := rfl\n      rw [← dist_of_mem_subset_mk_sphere (Set.mem_insert_of_mem _ hp0) hcr₃, hcc₃'', ←\n        mul_self_inj_of_nonneg dist_nonneg (Real.sqrt_nonneg _),\n        Real.mul_self_sqrt (add_nonneg (mul_self_nonneg _) (mul_self_nonneg _)),\n        dist_sq_eq_dist_orthogonalProjection_sq_add_dist_orthogonalProjection_sq _ (hps hp0),\n        orthogonalProjection_vadd_smul_vsub_orthogonalProjection _ _ hcc₃', h',\n        dist_of_mem_subset_mk_sphere hp0 hcr, dist_eq_norm_vsub V _ cc, vadd_vsub, norm_smul, ←\n        dist_eq_norm_vsub V p, Real.norm_eq_abs, ← mul_assoc, mul_comm _ |t₃|, ← mul_assoc,\n        abs_mul_abs_self]\n      ring\n    replace hcr₃ := dist_of_mem_subset_mk_sphere (Set.mem_insert _ _) hcr₃\n    rw [hpo, hcc₃'', hcr₃val, ← mul_self_inj_of_nonneg dist_nonneg (Real.sqrt_nonneg _),\n      dist_sq_smul_orthogonal_vadd_smul_orthogonal_vadd (orthogonalProjection_mem p) hcc₃' _ _\n        (vsub_orthogonalProjection_mem_direction_orthogonal s p),\n      dist_comm, ← dist_eq_norm_vsub V p,\n      Real.mul_self_sqrt (add_nonneg (mul_self_nonneg _) (mul_self_nonneg _))] at hcr₃\n    change x * x + _ * (y * y) = _ at hcr₃\n    rw [show\n        x * x + (1 - t₃) * (1 - t₃) * (y * y) = x * x + y * y - 2 * y * (t₃ * y) + t₃ * y * (t₃ * y)\n        by ring,\n      add_left_inj] at hcr₃\n    have ht₃ : t₃ = ycc₂ / y := by field_simp [ycc₂, ← hcr₃, hy0]\n    subst ht₃\n    change cc₃ = cc₂ at hcc₃''\n    congr\n    rw [hcr₃val]\n    congr 2\n    field_simp [hy0]\n\n"}
{"name":"AffineIndependent.existsUnique_dist_eq","module":"Mathlib.Geometry.Euclidean.Circumcenter","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor V P\nι : Type u_3\nhne : Nonempty ι\ninst✝ : Finite ι\np : ι → P\nha : AffineIndependent Real p\n⊢ ExistsUnique fun cs => And (Membership.mem (affineSpan Real (Set.range p)) cs.center) (HasSubset.Subset (Set.range p) (Metric.sphere cs.center cs.radius))","decl":"/-- Given a finite nonempty affinely independent family of points,\nthere is a unique (circumcenter, circumradius) pair for those points\nin the affine subspace they span. -/\ntheorem _root_.AffineIndependent.existsUnique_dist_eq {ι : Type*} [hne : Nonempty ι] [Finite ι]\n    {p : ι → P} (ha : AffineIndependent ℝ p) :\n    ∃! cs : Sphere P, cs.center ∈ affineSpan ℝ (Set.range p) ∧ Set.range p ⊆ (cs : Set P) := by\n  cases nonempty_fintype ι\n  induction' hn : Fintype.card ι with m hm generalizing ι\n  · exfalso\n    have h := Fintype.card_pos_iff.2 hne\n    rw [hn] at h\n    exact lt_irrefl 0 h\n  · cases' m with m\n    · rw [Fintype.card_eq_one_iff] at hn\n      cases' hn with i hi\n      haveI : Unique ι := ⟨⟨i⟩, hi⟩\n      use ⟨p i, 0⟩\n      simp only [Set.range_unique, AffineSubspace.mem_affineSpan_singleton]\n      constructor\n      · simp_rw [hi default, Set.singleton_subset_iff]\n        exact ⟨⟨⟩, by simp only [Metric.sphere_zero, Set.mem_singleton_iff]⟩\n      · rintro ⟨cc, cr⟩\n        simp only\n        rintro ⟨rfl, hdist⟩\n        simp? [Set.singleton_subset_iff] at hdist says\n          simp only [Set.singleton_subset_iff, Metric.mem_sphere, dist_self] at hdist\n        rw [hi default, hdist]\n    · have i := hne.some\n      let ι2 := { x // x ≠ i }\n      classical\n      have hc : Fintype.card ι2 = m + 1 := by\n        rw [Fintype.card_of_subtype (Finset.univ.filter fun x => x ≠ i)]\n        · rw [Finset.filter_not]\n          -- Porting note: removed `simp_rw [eq_comm]` and used `filter_eq'` instead of `filter_eq`\n          rw [Finset.filter_eq' _ i, if_pos (Finset.mem_univ _),\n            Finset.card_sdiff (Finset.subset_univ _), Finset.card_singleton, Finset.card_univ, hn]\n          simp\n        · simp\n      haveI : Nonempty ι2 := Fintype.card_pos_iff.1 (hc.symm ▸ Nat.zero_lt_succ _)\n      have ha2 : AffineIndependent ℝ fun i2 : ι2 => p i2 := ha.subtype _\n      replace hm := hm ha2 _ hc\n      have hr : Set.range p = insert (p i) (Set.range fun i2 : ι2 => p i2) := by\n        change _ = insert _ (Set.range fun i2 : { x | x ≠ i } => p i2)\n        rw [← Set.image_eq_range, ← Set.image_univ, ← Set.image_insert_eq]\n        congr with j\n        simp [Classical.em]\n      rw [hr, ← affineSpan_insert_affineSpan]\n      refine existsUnique_dist_eq_of_insert (Set.range_nonempty _) (subset_spanPoints ℝ _) ?_ hm\n      convert ha.not_mem_affineSpan_diff i Set.univ\n      change (Set.range fun i2 : { x | x ≠ i } => p i2) = _\n      rw [← Set.image_eq_range]\n      congr with j\n      simp\n\n"}
{"name":"Affine.Simplex.circumsphere_unique_dist_eq","module":"Mathlib.Geometry.Euclidean.Circumcenter","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\nn : Nat\ns : Affine.Simplex Real P n\n⊢ And (And (Membership.mem (affineSpan Real (Set.range s.points)) s.circumsphere.center) (HasSubset.Subset (Set.range s.points) (Metric.sphere s.circumsphere.center s.circumsphere.radius))) (∀ (cs : EuclideanGeometry.Sphere P), And (Membership.mem (affineSpan Real (Set.range s.points)) cs.center) (HasSubset.Subset (Set.range s.points) (Metric.sphere cs.center cs.radius)) → Eq cs s.circumsphere)","decl":"/-- The property satisfied by the circumsphere. -/\ntheorem circumsphere_unique_dist_eq {n : ℕ} (s : Simplex ℝ P n) :\n    (s.circumsphere.center ∈ affineSpan ℝ (Set.range s.points) ∧\n        Set.range s.points ⊆ s.circumsphere) ∧\n      ∀ cs : Sphere P,\n        cs.center ∈ affineSpan ℝ (Set.range s.points) ∧ Set.range s.points ⊆ cs →\n          cs = s.circumsphere :=\n  s.independent.existsUnique_dist_eq.choose_spec\n\n"}
{"name":"Affine.Simplex.circumsphere_center","module":"Mathlib.Geometry.Euclidean.Circumcenter","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\nn : Nat\ns : Affine.Simplex Real P n\n⊢ Eq s.circumsphere.center s.circumcenter","decl":"/-- The center of the circumsphere is the circumcenter. -/\n@[simp]\ntheorem circumsphere_center {n : ℕ} (s : Simplex ℝ P n) : s.circumsphere.center = s.circumcenter :=\n  rfl\n\n"}
{"name":"Affine.Simplex.circumsphere_radius","module":"Mathlib.Geometry.Euclidean.Circumcenter","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\nn : Nat\ns : Affine.Simplex Real P n\n⊢ Eq s.circumsphere.radius s.circumradius","decl":"/-- The radius of the circumsphere is the circumradius. -/\n@[simp]\ntheorem circumsphere_radius {n : ℕ} (s : Simplex ℝ P n) : s.circumsphere.radius = s.circumradius :=\n  rfl\n\n"}
{"name":"Affine.Simplex.circumcenter_mem_affineSpan","module":"Mathlib.Geometry.Euclidean.Circumcenter","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\nn : Nat\ns : Affine.Simplex Real P n\n⊢ Membership.mem (affineSpan Real (Set.range s.points)) s.circumcenter","decl":"/-- The circumcenter lies in the affine span. -/\ntheorem circumcenter_mem_affineSpan {n : ℕ} (s : Simplex ℝ P n) :\n    s.circumcenter ∈ affineSpan ℝ (Set.range s.points) :=\n  s.circumsphere_unique_dist_eq.1.1\n\n"}
{"name":"Affine.Simplex.dist_circumcenter_eq_circumradius","module":"Mathlib.Geometry.Euclidean.Circumcenter","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\nn : Nat\ns : Affine.Simplex Real P n\ni : Fin (HAdd.hAdd n 1)\n⊢ Eq (Dist.dist (s.points i) s.circumcenter) s.circumradius","decl":"/-- All points have distance from the circumcenter equal to the\ncircumradius. -/\n@[simp]\ntheorem dist_circumcenter_eq_circumradius {n : ℕ} (s : Simplex ℝ P n) (i : Fin (n + 1)) :\n    dist (s.points i) s.circumcenter = s.circumradius :=\n  dist_of_mem_subset_sphere (Set.mem_range_self _) s.circumsphere_unique_dist_eq.1.2\n\n"}
{"name":"Affine.Simplex.mem_circumsphere","module":"Mathlib.Geometry.Euclidean.Circumcenter","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\nn : Nat\ns : Affine.Simplex Real P n\ni : Fin (HAdd.hAdd n 1)\n⊢ Membership.mem s.circumsphere (s.points i)","decl":"/-- All points lie in the circumsphere. -/\ntheorem mem_circumsphere {n : ℕ} (s : Simplex ℝ P n) (i : Fin (n + 1)) :\n    s.points i ∈ s.circumsphere :=\n  s.dist_circumcenter_eq_circumradius i\n\n"}
{"name":"Affine.Simplex.dist_circumcenter_eq_circumradius'","module":"Mathlib.Geometry.Euclidean.Circumcenter","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\nn : Nat\ns : Affine.Simplex Real P n\ni : Fin (HAdd.hAdd n 1)\n⊢ Eq (Dist.dist s.circumcenter (s.points i)) s.circumradius","decl":"/-- All points have distance to the circumcenter equal to the\ncircumradius. -/\n@[simp]\ntheorem dist_circumcenter_eq_circumradius' {n : ℕ} (s : Simplex ℝ P n) :\n    ∀ i, dist s.circumcenter (s.points i) = s.circumradius := by\n  intro i\n  rw [dist_comm]\n  exact dist_circumcenter_eq_circumradius _ _\n\n"}
{"name":"Affine.Simplex.eq_circumcenter_of_dist_eq","module":"Mathlib.Geometry.Euclidean.Circumcenter","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\nn : Nat\ns : Affine.Simplex Real P n\np : P\nhp : Membership.mem (affineSpan Real (Set.range s.points)) p\nr : Real\nhr : ∀ (i : Fin (HAdd.hAdd n 1)), Eq (Dist.dist (s.points i) p) r\n⊢ Eq p s.circumcenter","decl":"/-- Given a point in the affine span from which all the points are\nequidistant, that point is the circumcenter. -/\ntheorem eq_circumcenter_of_dist_eq {n : ℕ} (s : Simplex ℝ P n) {p : P}\n    (hp : p ∈ affineSpan ℝ (Set.range s.points)) {r : ℝ} (hr : ∀ i, dist (s.points i) p = r) :\n    p = s.circumcenter := by\n  have h := s.circumsphere_unique_dist_eq.2 ⟨p, r⟩\n  simp only [hp, hr, forall_const, eq_self_iff_true, subset_sphere, Sphere.ext_iff,\n    Set.forall_mem_range, mem_sphere, true_and] at h\n  -- Porting note: added the next three lines (`simp` less powerful)\n  rw [subset_sphere (s := ⟨p, r⟩)] at h\n  simp only [hp, hr, forall_const, eq_self_iff_true, subset_sphere, Sphere.ext_iff,\n    Set.forall_mem_range, mem_sphere, true_and] at h\n  exact h.1\n\n"}
{"name":"Affine.Simplex.eq_circumradius_of_dist_eq","module":"Mathlib.Geometry.Euclidean.Circumcenter","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\nn : Nat\ns : Affine.Simplex Real P n\np : P\nhp : Membership.mem (affineSpan Real (Set.range s.points)) p\nr : Real\nhr : ∀ (i : Fin (HAdd.hAdd n 1)), Eq (Dist.dist (s.points i) p) r\n⊢ Eq r s.circumradius","decl":"/-- Given a point in the affine span from which all the points are\nequidistant, that distance is the circumradius. -/\ntheorem eq_circumradius_of_dist_eq {n : ℕ} (s : Simplex ℝ P n) {p : P}\n    (hp : p ∈ affineSpan ℝ (Set.range s.points)) {r : ℝ} (hr : ∀ i, dist (s.points i) p = r) :\n    r = s.circumradius := by\n  have h := s.circumsphere_unique_dist_eq.2 ⟨p, r⟩\n  simp only [hp, hr, forall_const, eq_self_iff_true, subset_sphere, Sphere.ext_iff,\n    Set.forall_mem_range, mem_sphere] at h\n  -- Porting note: added the next three lines (`simp` less powerful)\n  rw [subset_sphere (s := ⟨p, r⟩)] at h\n  simp only [hp, hr, forall_const, eq_self_iff_true, subset_sphere, Sphere.ext_iff,\n    Set.forall_mem_range, mem_sphere, true_and] at h\n  exact h.2\n\n"}
{"name":"Affine.Simplex.circumradius_nonneg","module":"Mathlib.Geometry.Euclidean.Circumcenter","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\nn : Nat\ns : Affine.Simplex Real P n\n⊢ LE.le 0 s.circumradius","decl":"/-- The circumradius is non-negative. -/\ntheorem circumradius_nonneg {n : ℕ} (s : Simplex ℝ P n) : 0 ≤ s.circumradius :=\n  s.dist_circumcenter_eq_circumradius 0 ▸ dist_nonneg\n\n"}
{"name":"Affine.Simplex.circumradius_pos","module":"Mathlib.Geometry.Euclidean.Circumcenter","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\nn : Nat\ns : Affine.Simplex Real P (HAdd.hAdd n 1)\n⊢ LT.lt 0 s.circumradius","decl":"/-- The circumradius of a simplex with at least two points is\npositive. -/\ntheorem circumradius_pos {n : ℕ} (s : Simplex ℝ P (n + 1)) : 0 < s.circumradius := by\n  refine lt_of_le_of_ne s.circumradius_nonneg ?_\n  intro h\n  have hr := s.dist_circumcenter_eq_circumradius\n  simp_rw [← h, dist_eq_zero] at hr\n  have h01 := s.independent.injective.ne (by simp : (0 : Fin (n + 2)) ≠ 1)\n  simp [hr] at h01\n\n"}
{"name":"Affine.Simplex.circumcenter_eq_point","module":"Mathlib.Geometry.Euclidean.Circumcenter","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\ns : Affine.Simplex Real P 0\ni : Fin 1\n⊢ Eq s.circumcenter (s.points i)","decl":"/-- The circumcenter of a 0-simplex equals its unique point. -/\ntheorem circumcenter_eq_point (s : Simplex ℝ P 0) (i : Fin 1) : s.circumcenter = s.points i := by\n  have h := s.circumcenter_mem_affineSpan\n  have : Unique (Fin 1) := ⟨⟨0, by decide⟩, fun a => by simp only [Fin.eq_zero]⟩\n  simp only [Set.range_unique, AffineSubspace.mem_affineSpan_singleton] at h\n  rw [h]\n  congr\n  simp only [eq_iff_true_of_subsingleton]\n\n"}
{"name":"Affine.Simplex.circumcenter_eq_centroid","module":"Mathlib.Geometry.Euclidean.Circumcenter","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\ns : Affine.Simplex Real P 1\n⊢ Eq s.circumcenter (Finset.centroid Real Finset.univ s.points)","decl":"/-- The circumcenter of a 1-simplex equals its centroid. -/\ntheorem circumcenter_eq_centroid (s : Simplex ℝ P 1) :\n    s.circumcenter = Finset.univ.centroid ℝ s.points := by\n  have hr :\n    Set.Pairwise Set.univ fun i j : Fin 2 =>\n      dist (s.points i) (Finset.univ.centroid ℝ s.points) =\n        dist (s.points j) (Finset.univ.centroid ℝ s.points) := by\n    intro i hi j hj hij\n    rw [Finset.centroid_pair_fin, dist_eq_norm_vsub V (s.points i),\n      dist_eq_norm_vsub V (s.points j), vsub_vadd_eq_vsub_sub, vsub_vadd_eq_vsub_sub, ←\n      one_smul ℝ (s.points i -ᵥ s.points 0), ← one_smul ℝ (s.points j -ᵥ s.points 0)]\n    fin_cases i <;> fin_cases j <;> simp [-one_smul, ← sub_smul] <;> norm_num\n  rw [Set.pairwise_eq_iff_exists_eq] at hr\n  cases' hr with r hr\n  exact\n    (s.eq_circumcenter_of_dist_eq\n        (centroid_mem_affineSpan_of_card_eq_add_one ℝ _ (Finset.card_fin 2)) fun i =>\n        hr i (Set.mem_univ _)).symm\n\n"}
{"name":"Affine.Simplex.circumsphere_reindex","module":"Mathlib.Geometry.Euclidean.Circumcenter","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\nm n : Nat\ns : Affine.Simplex Real P m\ne : Equiv (Fin (HAdd.hAdd m 1)) (Fin (HAdd.hAdd n 1))\n⊢ Eq (s.reindex e).circumsphere s.circumsphere","decl":"/-- Reindexing a simplex along an `Equiv` of index types does not change the circumsphere. -/\n@[simp]\ntheorem circumsphere_reindex {m n : ℕ} (s : Simplex ℝ P m) (e : Fin (m + 1) ≃ Fin (n + 1)) :\n    (s.reindex e).circumsphere = s.circumsphere := by\n  refine s.circumsphere_unique_dist_eq.2 _ ⟨?_, ?_⟩ <;> rw [← s.reindex_range_points e]\n  · exact (s.reindex e).circumsphere_unique_dist_eq.1.1\n  · exact (s.reindex e).circumsphere_unique_dist_eq.1.2\n\n"}
{"name":"Affine.Simplex.circumcenter_reindex","module":"Mathlib.Geometry.Euclidean.Circumcenter","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\nm n : Nat\ns : Affine.Simplex Real P m\ne : Equiv (Fin (HAdd.hAdd m 1)) (Fin (HAdd.hAdd n 1))\n⊢ Eq (s.reindex e).circumcenter s.circumcenter","decl":"/-- Reindexing a simplex along an `Equiv` of index types does not change the circumcenter. -/\n@[simp]\ntheorem circumcenter_reindex {m n : ℕ} (s : Simplex ℝ P m) (e : Fin (m + 1) ≃ Fin (n + 1)) :\n    (s.reindex e).circumcenter = s.circumcenter := by simp_rw [circumcenter, circumsphere_reindex]\n\n"}
{"name":"Affine.Simplex.circumradius_reindex","module":"Mathlib.Geometry.Euclidean.Circumcenter","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\nm n : Nat\ns : Affine.Simplex Real P m\ne : Equiv (Fin (HAdd.hAdd m 1)) (Fin (HAdd.hAdd n 1))\n⊢ Eq (s.reindex e).circumradius s.circumradius","decl":"/-- Reindexing a simplex along an `Equiv` of index types does not change the circumradius. -/\n@[simp]\ntheorem circumradius_reindex {m n : ℕ} (s : Simplex ℝ P m) (e : Fin (m + 1) ≃ Fin (n + 1)) :\n    (s.reindex e).circumradius = s.circumradius := by simp_rw [circumradius, circumsphere_reindex]\n\n"}
{"name":"Affine.Simplex.orthogonalProjection_vadd_smul_vsub_orthogonalProjection","module":"Mathlib.Geometry.Euclidean.Circumcenter","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\nn : Nat\ns : Affine.Simplex Real P n\np1 p2 : P\nr : Real\nhp : Membership.mem (affineSpan Real (Set.range s.points)) p1\n⊢ Eq (s.orthogonalProjectionSpan (HVAdd.hVAdd (HSMul.hSMul r (VSub.vsub p2 ↑(s.orthogonalProjectionSpan p2))) p1)) ⟨p1, hp⟩","decl":"/-- Adding a vector to a point in the given subspace, then taking the\northogonal projection, produces the original point if the vector is a\nmultiple of the result of subtracting a point's orthogonal projection\nfrom that point. -/\ntheorem orthogonalProjection_vadd_smul_vsub_orthogonalProjection {n : ℕ} (s : Simplex ℝ P n)\n    {p1 : P} (p2 : P) (r : ℝ) (hp : p1 ∈ affineSpan ℝ (Set.range s.points)) :\n    s.orthogonalProjectionSpan (r • (p2 -ᵥ s.orthogonalProjectionSpan p2 : V) +ᵥ p1) = ⟨p1, hp⟩ :=\n  EuclideanGeometry.orthogonalProjection_vadd_smul_vsub_orthogonalProjection _ _ _\n\n"}
{"name":"Affine.Simplex.coe_orthogonalProjection_vadd_smul_vsub_orthogonalProjection","module":"Mathlib.Geometry.Euclidean.Circumcenter","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\nn : Nat\nr₁ : Real\ns : Affine.Simplex Real P n\np p₁o : P\nhp₁o : Membership.mem (affineSpan Real (Set.range s.points)) p₁o\n⊢ Eq (↑(s.orthogonalProjectionSpan (HVAdd.hVAdd (HSMul.hSMul r₁ (VSub.vsub p ↑(s.orthogonalProjectionSpan p))) p₁o))) p₁o","decl":"theorem coe_orthogonalProjection_vadd_smul_vsub_orthogonalProjection {n : ℕ} {r₁ : ℝ}\n    (s : Simplex ℝ P n) {p p₁o : P} (hp₁o : p₁o ∈ affineSpan ℝ (Set.range s.points)) :\n    ↑(s.orthogonalProjectionSpan (r₁ • (p -ᵥ ↑(s.orthogonalProjectionSpan p)) +ᵥ p₁o)) = p₁o :=\n  congrArg ((↑) : _ → P) (orthogonalProjection_vadd_smul_vsub_orthogonalProjection _ _ _ hp₁o)\n\n"}
{"name":"Affine.Simplex.dist_sq_eq_dist_orthogonalProjection_sq_add_dist_orthogonalProjection_sq","module":"Mathlib.Geometry.Euclidean.Circumcenter","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\nn : Nat\ns : Affine.Simplex Real P n\np1 p2 : P\nhp1 : Membership.mem (affineSpan Real (Set.range s.points)) p1\n⊢ Eq (HMul.hMul (Dist.dist p1 p2) (Dist.dist p1 p2)) (HAdd.hAdd (HMul.hMul (Dist.dist p1 ↑(s.orthogonalProjectionSpan p2)) (Dist.dist p1 ↑(s.orthogonalProjectionSpan p2))) (HMul.hMul (Dist.dist p2 ↑(s.orthogonalProjectionSpan p2)) (Dist.dist p2 ↑(s.orthogonalProjectionSpan p2))))","decl":"theorem dist_sq_eq_dist_orthogonalProjection_sq_add_dist_orthogonalProjection_sq {n : ℕ}\n    (s : Simplex ℝ P n) {p1 : P} (p2 : P) (hp1 : p1 ∈ affineSpan ℝ (Set.range s.points)) :\n    dist p1 p2 * dist p1 p2 =\n      dist p1 (s.orthogonalProjectionSpan p2) * dist p1 (s.orthogonalProjectionSpan p2) +\n        dist p2 (s.orthogonalProjectionSpan p2) * dist p2 (s.orthogonalProjectionSpan p2) := by\n  rw [PseudoMetricSpace.dist_comm p2 _, dist_eq_norm_vsub V p1 _, dist_eq_norm_vsub V p1 _,\n    dist_eq_norm_vsub V _ p2, ← vsub_add_vsub_cancel p1 (s.orthogonalProjectionSpan p2) p2,\n    norm_add_sq_eq_norm_sq_add_norm_sq_iff_real_inner_eq_zero]\n  exact\n    Submodule.inner_right_of_mem_orthogonal (vsub_orthogonalProjection_mem_direction p2 hp1)\n      (orthogonalProjection_vsub_mem_direction_orthogonal _ p2)\n\n"}
{"name":"Affine.Simplex.dist_circumcenter_sq_eq_sq_sub_circumradius","module":"Mathlib.Geometry.Euclidean.Circumcenter","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\nn : Nat\nr : Real\ns : Affine.Simplex Real P n\np₁ : P\nh₁ : ∀ (i : Fin (HAdd.hAdd n 1)), Eq (Dist.dist (s.points i) p₁) r\nh₁' : Eq (↑(s.orthogonalProjectionSpan p₁)) s.circumcenter\nh : Membership.mem (affineSpan Real (Set.range s.points)) (s.points 0)\n⊢ Eq (HMul.hMul (Dist.dist p₁ s.circumcenter) (Dist.dist p₁ s.circumcenter)) (HSub.hSub (HMul.hMul r r) (HMul.hMul s.circumradius s.circumradius))","decl":"theorem dist_circumcenter_sq_eq_sq_sub_circumradius {n : ℕ} {r : ℝ} (s : Simplex ℝ P n) {p₁ : P}\n    (h₁ : ∀ i : Fin (n + 1), dist (s.points i) p₁ = r)\n    (h₁' : ↑(s.orthogonalProjectionSpan p₁) = s.circumcenter)\n    (h : s.points 0 ∈ affineSpan ℝ (Set.range s.points)) :\n    dist p₁ s.circumcenter * dist p₁ s.circumcenter = r * r - s.circumradius * s.circumradius := by\n  rw [dist_comm, ← h₁ 0,\n    s.dist_sq_eq_dist_orthogonalProjection_sq_add_dist_orthogonalProjection_sq p₁ h]\n  simp only [h₁', dist_comm p₁, add_sub_cancel_left, Simplex.dist_circumcenter_eq_circumradius]\n\n"}
{"name":"Affine.Simplex.orthogonalProjection_eq_circumcenter_of_exists_dist_eq","module":"Mathlib.Geometry.Euclidean.Circumcenter","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\nn : Nat\ns : Affine.Simplex Real P n\np : P\nhr : Exists fun r => ∀ (i : Fin (HAdd.hAdd n 1)), Eq (Dist.dist (s.points i) p) r\n⊢ Eq (↑(s.orthogonalProjectionSpan p)) s.circumcenter","decl":"/-- If there exists a distance that a point has from all vertices of a\nsimplex, the orthogonal projection of that point onto the subspace\nspanned by that simplex is its circumcenter. -/\ntheorem orthogonalProjection_eq_circumcenter_of_exists_dist_eq {n : ℕ} (s : Simplex ℝ P n) {p : P}\n    (hr : ∃ r, ∀ i, dist (s.points i) p = r) :\n    ↑(s.orthogonalProjectionSpan p) = s.circumcenter := by\n  change ∃ r : ℝ, ∀ i, (fun x => dist x p = r) (s.points i) at hr\n  have hr : ∃ (r : ℝ), ∀ (a : P),\n      a ∈ Set.range (fun (i : Fin (n + 1)) => s.points i) → dist a p = r := by\n    cases' hr with r hr\n    use r\n    refine Set.forall_mem_range.mpr ?_\n    exact hr\n  rw [exists_dist_eq_iff_exists_dist_orthogonalProjection_eq (subset_affineSpan ℝ _) p] at hr\n  cases' hr with r hr\n  exact\n    s.eq_circumcenter_of_dist_eq (orthogonalProjection_mem p) fun i => hr _ (Set.mem_range_self i)\n\n"}
{"name":"Affine.Simplex.orthogonalProjection_eq_circumcenter_of_dist_eq","module":"Mathlib.Geometry.Euclidean.Circumcenter","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\nn : Nat\ns : Affine.Simplex Real P n\np : P\nr : Real\nhr : ∀ (i : Fin (HAdd.hAdd n 1)), Eq (Dist.dist (s.points i) p) r\n⊢ Eq (↑(s.orthogonalProjectionSpan p)) s.circumcenter","decl":"/-- If a point has the same distance from all vertices of a simplex,\nthe orthogonal projection of that point onto the subspace spanned by\nthat simplex is its circumcenter. -/\ntheorem orthogonalProjection_eq_circumcenter_of_dist_eq {n : ℕ} (s : Simplex ℝ P n) {p : P} {r : ℝ}\n    (hr : ∀ i, dist (s.points i) p = r) : ↑(s.orthogonalProjectionSpan p) = s.circumcenter :=\n  s.orthogonalProjection_eq_circumcenter_of_exists_dist_eq ⟨r, hr⟩\n\n"}
{"name":"Affine.Simplex.orthogonalProjection_circumcenter","module":"Mathlib.Geometry.Euclidean.Circumcenter","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\nn : Nat\ns : Affine.Simplex Real P n\nfs : Finset (Fin (HAdd.hAdd n 1))\nm : Nat\nh : Eq fs.card (HAdd.hAdd m 1)\n⊢ Eq (↑((s.face h).orthogonalProjectionSpan s.circumcenter)) (s.face h).circumcenter","decl":"/-- The orthogonal projection of the circumcenter onto a face is the\ncircumcenter of that face. -/\ntheorem orthogonalProjection_circumcenter {n : ℕ} (s : Simplex ℝ P n) {fs : Finset (Fin (n + 1))}\n    {m : ℕ} (h : #fs = m + 1) :\n    ↑((s.face h).orthogonalProjectionSpan s.circumcenter) = (s.face h).circumcenter :=\n  haveI hr : ∃ r, ∀ i, dist ((s.face h).points i) s.circumcenter = r := by\n    use s.circumradius\n    simp [face_points]\n  orthogonalProjection_eq_circumcenter_of_exists_dist_eq _ hr\n\n"}
{"name":"Affine.Simplex.circumcenter_eq_of_range_eq","module":"Mathlib.Geometry.Euclidean.Circumcenter","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\nn : Nat\ns₁ s₂ : Affine.Simplex Real P n\nh : Eq (Set.range s₁.points) (Set.range s₂.points)\n⊢ Eq s₁.circumcenter s₂.circumcenter","decl":"/-- Two simplices with the same points have the same circumcenter. -/\ntheorem circumcenter_eq_of_range_eq {n : ℕ} {s₁ s₂ : Simplex ℝ P n}\n    (h : Set.range s₁.points = Set.range s₂.points) : s₁.circumcenter = s₂.circumcenter := by\n  have hs : s₁.circumcenter ∈ affineSpan ℝ (Set.range s₂.points) :=\n    h ▸ s₁.circumcenter_mem_affineSpan\n  have hr : ∀ i, dist (s₂.points i) s₁.circumcenter = s₁.circumradius := by\n    intro i\n    have hi : s₂.points i ∈ Set.range s₂.points := Set.mem_range_self _\n    rw [← h, Set.mem_range] at hi\n    rcases hi with ⟨j, hj⟩\n    rw [← hj, s₁.dist_circumcenter_eq_circumradius j]\n  exact s₂.eq_circumcenter_of_dist_eq hs hr\n\n"}
{"name":"Affine.Simplex.PointsWithCircumcenterIndex.pointIndex.inj","module":"Mathlib.Geometry.Euclidean.Circumcenter","initialProofState":"n : Nat\na✝¹ a✝ : Fin (HAdd.hAdd n 1)\nx✝ : Eq (Affine.Simplex.PointsWithCircumcenterIndex.pointIndex a✝¹) (Affine.Simplex.PointsWithCircumcenterIndex.pointIndex a✝)\n⊢ Eq a✝¹ a✝","decl":"/-- An index type for the vertices of a simplex plus its circumcenter.\nThis is for use in calculations where it is convenient to work with\naffine combinations of vertices together with the circumcenter.  (An\nequivalent form sometimes used in the literature is placing the\ncircumcenter at the origin and working with vectors for the vertices.) -/\ninductive PointsWithCircumcenterIndex (n : ℕ)\n  | pointIndex : Fin (n + 1) → PointsWithCircumcenterIndex n\n  | circumcenterIndex : PointsWithCircumcenterIndex n\n  deriving Fintype\n\n"}
{"name":"Affine.Simplex.PointsWithCircumcenterIndex.pointIndex.injEq","module":"Mathlib.Geometry.Euclidean.Circumcenter","initialProofState":"n : Nat\na✝¹ a✝ : Fin (HAdd.hAdd n 1)\n⊢ Eq (Eq (Affine.Simplex.PointsWithCircumcenterIndex.pointIndex a✝¹) (Affine.Simplex.PointsWithCircumcenterIndex.pointIndex a✝)) (Eq a✝¹ a✝)","decl":"/-- An index type for the vertices of a simplex plus its circumcenter.\nThis is for use in calculations where it is convenient to work with\naffine combinations of vertices together with the circumcenter.  (An\nequivalent form sometimes used in the literature is placing the\ncircumcenter at the origin and working with vectors for the vertices.) -/\ninductive PointsWithCircumcenterIndex (n : ℕ)\n  | pointIndex : Fin (n + 1) → PointsWithCircumcenterIndex n\n  | circumcenterIndex : PointsWithCircumcenterIndex n\n  deriving Fintype\n\n"}
{"name":"Affine.Simplex.PointsWithCircumcenterIndex.pointIndex.sizeOf_spec","module":"Mathlib.Geometry.Euclidean.Circumcenter","initialProofState":"n : Nat\na✝ : Fin (HAdd.hAdd n 1)\n⊢ Eq (SizeOf.sizeOf (Affine.Simplex.PointsWithCircumcenterIndex.pointIndex a✝)) (HAdd.hAdd 1 (SizeOf.sizeOf a✝))","decl":"/-- An index type for the vertices of a simplex plus its circumcenter.\nThis is for use in calculations where it is convenient to work with\naffine combinations of vertices together with the circumcenter.  (An\nequivalent form sometimes used in the literature is placing the\ncircumcenter at the origin and working with vectors for the vertices.) -/\ninductive PointsWithCircumcenterIndex (n : ℕ)\n  | pointIndex : Fin (n + 1) → PointsWithCircumcenterIndex n\n  | circumcenterIndex : PointsWithCircumcenterIndex n\n  deriving Fintype\n\n"}
{"name":"Affine.Simplex.PointsWithCircumcenterIndex.circumcenterIndex.sizeOf_spec","module":"Mathlib.Geometry.Euclidean.Circumcenter","initialProofState":"n : Nat\n⊢ Eq (SizeOf.sizeOf Affine.Simplex.PointsWithCircumcenterIndex.circumcenterIndex) 1","decl":"/-- An index type for the vertices of a simplex plus its circumcenter.\nThis is for use in calculations where it is convenient to work with\naffine combinations of vertices together with the circumcenter.  (An\nequivalent form sometimes used in the literature is placing the\ncircumcenter at the origin and working with vectors for the vertices.) -/\ninductive PointsWithCircumcenterIndex (n : ℕ)\n  | pointIndex : Fin (n + 1) → PointsWithCircumcenterIndex n\n  | circumcenterIndex : PointsWithCircumcenterIndex n\n  deriving Fintype\n\n"}
{"name":"Affine.Simplex.sum_pointsWithCircumcenter","module":"Mathlib.Geometry.Euclidean.Circumcenter","initialProofState":"α : Type u_3\ninst✝ : AddCommMonoid α\nn : Nat\nf : Affine.Simplex.PointsWithCircumcenterIndex n → α\n⊢ Eq (Finset.univ.sum fun i => f i) (HAdd.hAdd (Finset.univ.sum fun i => f (Affine.Simplex.PointsWithCircumcenterIndex.pointIndex i)) (f Affine.Simplex.PointsWithCircumcenterIndex.circumcenterIndex))","decl":"/-- The sum of a function over `PointsWithCircumcenterIndex`. -/\ntheorem sum_pointsWithCircumcenter {α : Type*} [AddCommMonoid α] {n : ℕ}\n    (f : PointsWithCircumcenterIndex n → α) :\n    ∑ i, f i = (∑ i : Fin (n + 1), f (pointIndex i)) + f circumcenterIndex := by\n  classical\n  have h : univ = insert circumcenterIndex (univ.map (pointIndexEmbedding n)) := by\n    ext x\n    refine ⟨fun h => ?_, fun _ => mem_univ _⟩\n    cases' x with i\n    · exact mem_insert_of_mem (mem_map_of_mem _ (mem_univ i))\n    · exact mem_insert_self _ _\n  change _ = (∑ i, f (pointIndexEmbedding n i)) + _\n  rw [add_comm, h, ← sum_map, sum_insert]\n  simp_rw [Finset.mem_map, not_exists]\n  rintro x ⟨_, h⟩\n  injection h\n\n"}
{"name":"Affine.Simplex.pointsWithCircumcenter_point","module":"Mathlib.Geometry.Euclidean.Circumcenter","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\nn : Nat\ns : Affine.Simplex Real P n\ni : Fin (HAdd.hAdd n 1)\n⊢ Eq (s.pointsWithCircumcenter (Affine.Simplex.PointsWithCircumcenterIndex.pointIndex i)) (s.points i)","decl":"/-- `pointsWithCircumcenter`, applied to a `pointIndex` value,\nequals `points` applied to that value. -/\n@[simp]\ntheorem pointsWithCircumcenter_point {n : ℕ} (s : Simplex ℝ P n) (i : Fin (n + 1)) :\n    s.pointsWithCircumcenter (pointIndex i) = s.points i :=\n  rfl\n\n"}
{"name":"Affine.Simplex.pointsWithCircumcenter_eq_circumcenter","module":"Mathlib.Geometry.Euclidean.Circumcenter","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\nn : Nat\ns : Affine.Simplex Real P n\n⊢ Eq (s.pointsWithCircumcenter Affine.Simplex.PointsWithCircumcenterIndex.circumcenterIndex) s.circumcenter","decl":"/-- `pointsWithCircumcenter`, applied to `circumcenterIndex`, equals the\ncircumcenter. -/\n@[simp]\ntheorem pointsWithCircumcenter_eq_circumcenter {n : ℕ} (s : Simplex ℝ P n) :\n    s.pointsWithCircumcenter circumcenterIndex = s.circumcenter :=\n  rfl\n\n"}
{"name":"Affine.Simplex.sum_pointWeightsWithCircumcenter","module":"Mathlib.Geometry.Euclidean.Circumcenter","initialProofState":"n : Nat\ni : Fin (HAdd.hAdd n 1)\n⊢ Eq (Finset.univ.sum fun j => Affine.Simplex.pointWeightsWithCircumcenter i j) 1","decl":"/-- `point_weights_with_circumcenter` sums to 1. -/\n@[simp]\ntheorem sum_pointWeightsWithCircumcenter {n : ℕ} (i : Fin (n + 1)) :\n    ∑ j, pointWeightsWithCircumcenter i j = 1 := by\n  classical\n  convert sum_ite_eq' univ (pointIndex i) (Function.const _ (1 : ℝ)) with j\n  · cases j <;> simp [pointWeightsWithCircumcenter]\n  · simp\n\n"}
{"name":"Affine.Simplex.point_eq_affineCombination_of_pointsWithCircumcenter","module":"Mathlib.Geometry.Euclidean.Circumcenter","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\nn : Nat\ns : Affine.Simplex Real P n\ni : Fin (HAdd.hAdd n 1)\n⊢ Eq (s.points i) ((Finset.affineCombination Real Finset.univ s.pointsWithCircumcenter) (Affine.Simplex.pointWeightsWithCircumcenter i))","decl":"/-- A single vertex, in terms of `pointsWithCircumcenter`. -/\ntheorem point_eq_affineCombination_of_pointsWithCircumcenter {n : ℕ} (s : Simplex ℝ P n)\n    (i : Fin (n + 1)) :\n    s.points i =\n      (univ : Finset (PointsWithCircumcenterIndex n)).affineCombination ℝ s.pointsWithCircumcenter\n        (pointWeightsWithCircumcenter i) := by\n  rw [← pointsWithCircumcenter_point]\n  symm\n  refine\n    affineCombination_of_eq_one_of_eq_zero _ _ _ (mem_univ _)\n      (by simp [pointWeightsWithCircumcenter]) ?_\n  intro i hi hn\n  cases i\n  · have h : _ ≠ i := fun h => hn (h ▸ rfl)\n    simp [pointWeightsWithCircumcenter, h]\n  · rfl\n\n"}
{"name":"Affine.Simplex.sum_centroidWeightsWithCircumcenter","module":"Mathlib.Geometry.Euclidean.Circumcenter","initialProofState":"n : Nat\nfs : Finset (Fin (HAdd.hAdd n 1))\nh : fs.Nonempty\n⊢ Eq (Finset.univ.sum fun i => Affine.Simplex.centroidWeightsWithCircumcenter fs i) 1","decl":"/-- `centroidWeightsWithCircumcenter` sums to 1, if the `Finset` is nonempty. -/\n@[simp]\ntheorem sum_centroidWeightsWithCircumcenter {n : ℕ} {fs : Finset (Fin (n + 1))} (h : fs.Nonempty) :\n    ∑ i, centroidWeightsWithCircumcenter fs i = 1 := by\n  simp_rw [sum_pointsWithCircumcenter, centroidWeightsWithCircumcenter, add_zero, ←\n    fs.sum_centroidWeights_eq_one_of_nonempty ℝ h, ← sum_indicator_subset _ fs.subset_univ]\n  rcongr\n\n"}
{"name":"Affine.Simplex.centroid_eq_affineCombination_of_pointsWithCircumcenter","module":"Mathlib.Geometry.Euclidean.Circumcenter","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\nn : Nat\ns : Affine.Simplex Real P n\nfs : Finset (Fin (HAdd.hAdd n 1))\n⊢ Eq (Finset.centroid Real fs s.points) ((Finset.affineCombination Real Finset.univ s.pointsWithCircumcenter) (Affine.Simplex.centroidWeightsWithCircumcenter fs))","decl":"/-- The centroid of some vertices of a simplex, in terms of `pointsWithCircumcenter`. -/\ntheorem centroid_eq_affineCombination_of_pointsWithCircumcenter {n : ℕ} (s : Simplex ℝ P n)\n    (fs : Finset (Fin (n + 1))) :\n    fs.centroid ℝ s.points =\n      (univ : Finset (PointsWithCircumcenterIndex n)).affineCombination ℝ s.pointsWithCircumcenter\n        (centroidWeightsWithCircumcenter fs) := by\n  simp_rw [centroid_def, affineCombination_apply, weightedVSubOfPoint_apply,\n    sum_pointsWithCircumcenter, centroidWeightsWithCircumcenter,\n    pointsWithCircumcenter_point, zero_smul, add_zero, centroidWeights,\n    ← sum_indicator_subset_of_eq_zero (Function.const (Fin (n + 1)) (#fs : ℝ)⁻¹)\n      (fun i wi => wi • (s.points i -ᵥ Classical.choice AddTorsor.nonempty)) fs.subset_univ fun _ =>\n      zero_smul ℝ _,\n    Set.indicator_apply]\n  congr\n\n"}
{"name":"Affine.Simplex.sum_circumcenterWeightsWithCircumcenter","module":"Mathlib.Geometry.Euclidean.Circumcenter","initialProofState":"n : Nat\n⊢ Eq (Finset.univ.sum fun i => Affine.Simplex.circumcenterWeightsWithCircumcenter n i) 1","decl":"/-- `circumcenterWeightsWithCircumcenter` sums to 1. -/\n@[simp]\ntheorem sum_circumcenterWeightsWithCircumcenter (n : ℕ) :\n    ∑ i, circumcenterWeightsWithCircumcenter n i = 1 := by\n  classical\n  convert sum_ite_eq' univ circumcenterIndex (Function.const _ (1 : ℝ)) with j\n  · cases j <;> simp [circumcenterWeightsWithCircumcenter]\n  · simp\n\n"}
{"name":"Affine.Simplex.circumcenter_eq_affineCombination_of_pointsWithCircumcenter","module":"Mathlib.Geometry.Euclidean.Circumcenter","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\nn : Nat\ns : Affine.Simplex Real P n\n⊢ Eq s.circumcenter ((Finset.affineCombination Real Finset.univ s.pointsWithCircumcenter) (Affine.Simplex.circumcenterWeightsWithCircumcenter n))","decl":"/-- The circumcenter of a simplex, in terms of `pointsWithCircumcenter`. -/\ntheorem circumcenter_eq_affineCombination_of_pointsWithCircumcenter {n : ℕ} (s : Simplex ℝ P n) :\n    s.circumcenter =\n      (univ : Finset (PointsWithCircumcenterIndex n)).affineCombination ℝ s.pointsWithCircumcenter\n        (circumcenterWeightsWithCircumcenter n) := by\n  rw [← pointsWithCircumcenter_eq_circumcenter]\n  symm\n  refine affineCombination_of_eq_one_of_eq_zero _ _ _ (mem_univ _) rfl ?_\n  rintro ⟨i⟩ _ hn <;> tauto\n\n"}
{"name":"Affine.Simplex.sum_reflectionCircumcenterWeightsWithCircumcenter","module":"Mathlib.Geometry.Euclidean.Circumcenter","initialProofState":"n : Nat\ni₁ i₂ : Fin (HAdd.hAdd n 1)\nh : Ne i₁ i₂\n⊢ Eq (Finset.univ.sum fun i => Affine.Simplex.reflectionCircumcenterWeightsWithCircumcenter i₁ i₂ i) 1","decl":"/-- `reflectionCircumcenterWeightsWithCircumcenter` sums to 1. -/\n@[simp]\ntheorem sum_reflectionCircumcenterWeightsWithCircumcenter {n : ℕ} {i₁ i₂ : Fin (n + 1)}\n    (h : i₁ ≠ i₂) : ∑ i, reflectionCircumcenterWeightsWithCircumcenter i₁ i₂ i = 1 := by\n  simp_rw [sum_pointsWithCircumcenter, reflectionCircumcenterWeightsWithCircumcenter, sum_ite,\n    sum_const, filter_or, filter_eq']\n  rw [card_union_of_disjoint]\n  · set_option simprocs false in simp\n  · simpa only [if_true, mem_univ, disjoint_singleton] using h\n\n"}
{"name":"Affine.Simplex.reflection_circumcenter_eq_affineCombination_of_pointsWithCircumcenter","module":"Mathlib.Geometry.Euclidean.Circumcenter","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\nn : Nat\ns : Affine.Simplex Real P n\ni₁ i₂ : Fin (HAdd.hAdd n 1)\nh : Ne i₁ i₂\n⊢ Eq ((EuclideanGeometry.reflection (affineSpan Real (Set.image s.points (Insert.insert i₁ (Singleton.singleton i₂))))) s.circumcenter) ((Finset.affineCombination Real Finset.univ s.pointsWithCircumcenter) (Affine.Simplex.reflectionCircumcenterWeightsWithCircumcenter i₁ i₂))","decl":"/-- The reflection of the circumcenter of a simplex in an edge, in\nterms of `pointsWithCircumcenter`. -/\ntheorem reflection_circumcenter_eq_affineCombination_of_pointsWithCircumcenter {n : ℕ}\n    (s : Simplex ℝ P n) {i₁ i₂ : Fin (n + 1)} (h : i₁ ≠ i₂) :\n    reflection (affineSpan ℝ (s.points '' {i₁, i₂})) s.circumcenter =\n      (univ : Finset (PointsWithCircumcenterIndex n)).affineCombination ℝ s.pointsWithCircumcenter\n        (reflectionCircumcenterWeightsWithCircumcenter i₁ i₂) := by\n  have hc : #{i₁, i₂} = 2 := by simp [h]\n  -- Making the next line a separate definition helps the elaborator:\n  set W : AffineSubspace ℝ P := affineSpan ℝ (s.points '' {i₁, i₂})\n  have h_faces :\n    (orthogonalProjection W s.circumcenter : P) =\n      ↑((s.face hc).orthogonalProjectionSpan s.circumcenter) := by\n    apply eq_orthogonalProjection_of_eq_subspace\n    simp [W]\n  rw [EuclideanGeometry.reflection_apply, h_faces, s.orthogonalProjection_circumcenter hc,\n    circumcenter_eq_centroid, s.face_centroid_eq_centroid hc,\n    centroid_eq_affineCombination_of_pointsWithCircumcenter,\n    circumcenter_eq_affineCombination_of_pointsWithCircumcenter, ← @vsub_eq_zero_iff_eq V,\n    affineCombination_vsub, weightedVSub_vadd_affineCombination, affineCombination_vsub,\n    weightedVSub_apply, sum_pointsWithCircumcenter]\n  simp_rw [Pi.sub_apply, Pi.add_apply, Pi.sub_apply, sub_smul, add_smul, sub_smul,\n    centroidWeightsWithCircumcenter, circumcenterWeightsWithCircumcenter,\n    reflectionCircumcenterWeightsWithCircumcenter, ite_smul, zero_smul, sub_zero,\n    apply_ite₂ (· + ·), add_zero, ← add_smul, hc, zero_sub, neg_smul, sub_self, add_zero]\n  -- Porting note: was `convert sum_const_zero`\n  rw [← sum_const_zero]\n  congr\n  norm_num\n\n"}
{"name":"EuclideanGeometry.cospherical_iff_exists_mem_of_complete","module":"Mathlib.Geometry.Euclidean.Circumcenter","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁵ : NormedAddCommGroup V\ninst✝⁴ : InnerProductSpace Real V\ninst✝³ : MetricSpace P\ninst✝² : NormedAddTorsor V P\ns : AffineSubspace Real P\nps : Set P\nh : HasSubset.Subset ps ↑s\ninst✝¹ : Nonempty (Subtype fun x => Membership.mem s x)\ninst✝ : HasOrthogonalProjection s.direction\n⊢ Iff (EuclideanGeometry.Cospherical ps) (Exists fun center => And (Membership.mem s center) (Exists fun radius => ∀ (p : P), Membership.mem ps p → Eq (Dist.dist p center) radius))","decl":"/-- Given a nonempty affine subspace, whose direction is complete,\nthat contains a set of points, those points are cospherical if and\nonly if they are equidistant from some point in that subspace. -/\ntheorem cospherical_iff_exists_mem_of_complete {s : AffineSubspace ℝ P} {ps : Set P} (h : ps ⊆ s)\n    [Nonempty s] [HasOrthogonalProjection s.direction] :\n    Cospherical ps ↔ ∃ center ∈ s, ∃ radius : ℝ, ∀ p ∈ ps, dist p center = radius := by\n  constructor\n  · rintro ⟨c, hcr⟩\n    rw [exists_dist_eq_iff_exists_dist_orthogonalProjection_eq h c] at hcr\n    exact ⟨orthogonalProjection s c, orthogonalProjection_mem _, hcr⟩\n  · exact fun ⟨c, _, hd⟩ => ⟨c, hd⟩\n\n"}
{"name":"EuclideanGeometry.cospherical_iff_exists_mem_of_finiteDimensional","module":"Mathlib.Geometry.Euclidean.Circumcenter","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁵ : NormedAddCommGroup V\ninst✝⁴ : InnerProductSpace Real V\ninst✝³ : MetricSpace P\ninst✝² : NormedAddTorsor V P\ns : AffineSubspace Real P\nps : Set P\nh : HasSubset.Subset ps ↑s\ninst✝¹ : Nonempty (Subtype fun x => Membership.mem s x)\ninst✝ : FiniteDimensional Real (Subtype fun x => Membership.mem s.direction x)\n⊢ Iff (EuclideanGeometry.Cospherical ps) (Exists fun center => And (Membership.mem s center) (Exists fun radius => ∀ (p : P), Membership.mem ps p → Eq (Dist.dist p center) radius))","decl":"/-- Given a nonempty affine subspace, whose direction is\nfinite-dimensional, that contains a set of points, those points are\ncospherical if and only if they are equidistant from some point in\nthat subspace. -/\ntheorem cospherical_iff_exists_mem_of_finiteDimensional {s : AffineSubspace ℝ P} {ps : Set P}\n    (h : ps ⊆ s) [Nonempty s] [FiniteDimensional ℝ s.direction] :\n    Cospherical ps ↔ ∃ center ∈ s, ∃ radius : ℝ, ∀ p ∈ ps, dist p center = radius :=\n  cospherical_iff_exists_mem_of_complete h\n\n"}
{"name":"EuclideanGeometry.exists_circumradius_eq_of_cospherical_subset","module":"Mathlib.Geometry.Euclidean.Circumcenter","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁵ : NormedAddCommGroup V\ninst✝⁴ : InnerProductSpace Real V\ninst✝³ : MetricSpace P\ninst✝² : NormedAddTorsor V P\ns : AffineSubspace Real P\nps : Set P\nh : HasSubset.Subset ps ↑s\ninst✝¹ : Nonempty (Subtype fun x => Membership.mem s x)\nn : Nat\ninst✝ : FiniteDimensional Real (Subtype fun x => Membership.mem s.direction x)\nhd : Eq (Module.finrank Real (Subtype fun x => Membership.mem s.direction x)) n\nhc : EuclideanGeometry.Cospherical ps\n⊢ Exists fun r => ∀ (sx : Affine.Simplex Real P n), HasSubset.Subset (Set.range sx.points) ps → Eq sx.circumradius r","decl":"/-- All n-simplices among cospherical points in an n-dimensional\nsubspace have the same circumradius. -/\ntheorem exists_circumradius_eq_of_cospherical_subset {s : AffineSubspace ℝ P} {ps : Set P}\n    (h : ps ⊆ s) [Nonempty s] {n : ℕ} [FiniteDimensional ℝ s.direction]\n    (hd : finrank ℝ s.direction = n) (hc : Cospherical ps) :\n    ∃ r : ℝ, ∀ sx : Simplex ℝ P n, Set.range sx.points ⊆ ps → sx.circumradius = r := by\n  rw [cospherical_iff_exists_mem_of_finiteDimensional h] at hc\n  rcases hc with ⟨c, hc, r, hcr⟩\n  use r\n  intro sx hsxps\n  have hsx : affineSpan ℝ (Set.range sx.points) = s := by\n    refine\n      sx.independent.affineSpan_eq_of_le_of_card_eq_finrank_add_one\n        (spanPoints_subset_coe_of_subset_coe (hsxps.trans h)) ?_\n    simp [hd]\n  have hc : c ∈ affineSpan ℝ (Set.range sx.points) := hsx.symm ▸ hc\n  exact\n    (sx.eq_circumradius_of_dist_eq hc fun i =>\n        hcr (sx.points i) (hsxps (Set.mem_range_self i))).symm\n\n"}
{"name":"EuclideanGeometry.circumradius_eq_of_cospherical_subset","module":"Mathlib.Geometry.Euclidean.Circumcenter","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁵ : NormedAddCommGroup V\ninst✝⁴ : InnerProductSpace Real V\ninst✝³ : MetricSpace P\ninst✝² : NormedAddTorsor V P\ns : AffineSubspace Real P\nps : Set P\nh : HasSubset.Subset ps ↑s\ninst✝¹ : Nonempty (Subtype fun x => Membership.mem s x)\nn : Nat\ninst✝ : FiniteDimensional Real (Subtype fun x => Membership.mem s.direction x)\nhd : Eq (Module.finrank Real (Subtype fun x => Membership.mem s.direction x)) n\nhc : EuclideanGeometry.Cospherical ps\nsx₁ sx₂ : Affine.Simplex Real P n\nhsx₁ : HasSubset.Subset (Set.range sx₁.points) ps\nhsx₂ : HasSubset.Subset (Set.range sx₂.points) ps\n⊢ Eq sx₁.circumradius sx₂.circumradius","decl":"/-- Two n-simplices among cospherical points in an n-dimensional\nsubspace have the same circumradius. -/\ntheorem circumradius_eq_of_cospherical_subset {s : AffineSubspace ℝ P} {ps : Set P} (h : ps ⊆ s)\n    [Nonempty s] {n : ℕ} [FiniteDimensional ℝ s.direction] (hd : finrank ℝ s.direction = n)\n    (hc : Cospherical ps) {sx₁ sx₂ : Simplex ℝ P n} (hsx₁ : Set.range sx₁.points ⊆ ps)\n    (hsx₂ : Set.range sx₂.points ⊆ ps) : sx₁.circumradius = sx₂.circumradius := by\n  rcases exists_circumradius_eq_of_cospherical_subset h hd hc with ⟨r, hr⟩\n  rw [hr sx₁ hsx₁, hr sx₂ hsx₂]\n\n"}
{"name":"EuclideanGeometry.exists_circumradius_eq_of_cospherical","module":"Mathlib.Geometry.Euclidean.Circumcenter","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor V P\nps : Set P\nn : Nat\ninst✝ : FiniteDimensional Real V\nhd : Eq (Module.finrank Real V) n\nhc : EuclideanGeometry.Cospherical ps\n⊢ Exists fun r => ∀ (sx : Affine.Simplex Real P n), HasSubset.Subset (Set.range sx.points) ps → Eq sx.circumradius r","decl":"/-- All n-simplices among cospherical points in n-space have the same\ncircumradius. -/\ntheorem exists_circumradius_eq_of_cospherical {ps : Set P} {n : ℕ} [FiniteDimensional ℝ V]\n    (hd : finrank ℝ V = n) (hc : Cospherical ps) :\n    ∃ r : ℝ, ∀ sx : Simplex ℝ P n, Set.range sx.points ⊆ ps → sx.circumradius = r := by\n  haveI : Nonempty (⊤ : AffineSubspace ℝ P) := Set.univ.nonempty\n  rw [← finrank_top, ← direction_top ℝ V P] at hd\n  refine exists_circumradius_eq_of_cospherical_subset ?_ hd hc\n  exact Set.subset_univ _\n\n"}
{"name":"EuclideanGeometry.circumradius_eq_of_cospherical","module":"Mathlib.Geometry.Euclidean.Circumcenter","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor V P\nps : Set P\nn : Nat\ninst✝ : FiniteDimensional Real V\nhd : Eq (Module.finrank Real V) n\nhc : EuclideanGeometry.Cospherical ps\nsx₁ sx₂ : Affine.Simplex Real P n\nhsx₁ : HasSubset.Subset (Set.range sx₁.points) ps\nhsx₂ : HasSubset.Subset (Set.range sx₂.points) ps\n⊢ Eq sx₁.circumradius sx₂.circumradius","decl":"/-- Two n-simplices among cospherical points in n-space have the same\ncircumradius. -/\ntheorem circumradius_eq_of_cospherical {ps : Set P} {n : ℕ} [FiniteDimensional ℝ V]\n    (hd : finrank ℝ V = n) (hc : Cospherical ps) {sx₁ sx₂ : Simplex ℝ P n}\n    (hsx₁ : Set.range sx₁.points ⊆ ps) (hsx₂ : Set.range sx₂.points ⊆ ps) :\n    sx₁.circumradius = sx₂.circumradius := by\n  rcases exists_circumradius_eq_of_cospherical hd hc with ⟨r, hr⟩\n  rw [hr sx₁ hsx₁, hr sx₂ hsx₂]\n\n"}
{"name":"EuclideanGeometry.exists_circumcenter_eq_of_cospherical_subset","module":"Mathlib.Geometry.Euclidean.Circumcenter","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁵ : NormedAddCommGroup V\ninst✝⁴ : InnerProductSpace Real V\ninst✝³ : MetricSpace P\ninst✝² : NormedAddTorsor V P\ns : AffineSubspace Real P\nps : Set P\nh : HasSubset.Subset ps ↑s\ninst✝¹ : Nonempty (Subtype fun x => Membership.mem s x)\nn : Nat\ninst✝ : FiniteDimensional Real (Subtype fun x => Membership.mem s.direction x)\nhd : Eq (Module.finrank Real (Subtype fun x => Membership.mem s.direction x)) n\nhc : EuclideanGeometry.Cospherical ps\n⊢ Exists fun c => ∀ (sx : Affine.Simplex Real P n), HasSubset.Subset (Set.range sx.points) ps → Eq sx.circumcenter c","decl":"/-- All n-simplices among cospherical points in an n-dimensional\nsubspace have the same circumcenter. -/\ntheorem exists_circumcenter_eq_of_cospherical_subset {s : AffineSubspace ℝ P} {ps : Set P}\n    (h : ps ⊆ s) [Nonempty s] {n : ℕ} [FiniteDimensional ℝ s.direction]\n    (hd : finrank ℝ s.direction = n) (hc : Cospherical ps) :\n    ∃ c : P, ∀ sx : Simplex ℝ P n, Set.range sx.points ⊆ ps → sx.circumcenter = c := by\n  rw [cospherical_iff_exists_mem_of_finiteDimensional h] at hc\n  rcases hc with ⟨c, hc, r, hcr⟩\n  use c\n  intro sx hsxps\n  have hsx : affineSpan ℝ (Set.range sx.points) = s := by\n    refine\n      sx.independent.affineSpan_eq_of_le_of_card_eq_finrank_add_one\n        (spanPoints_subset_coe_of_subset_coe (hsxps.trans h)) ?_\n    simp [hd]\n  have hc : c ∈ affineSpan ℝ (Set.range sx.points) := hsx.symm ▸ hc\n  exact\n    (sx.eq_circumcenter_of_dist_eq hc fun i =>\n        hcr (sx.points i) (hsxps (Set.mem_range_self i))).symm\n\n"}
{"name":"EuclideanGeometry.circumcenter_eq_of_cospherical_subset","module":"Mathlib.Geometry.Euclidean.Circumcenter","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁵ : NormedAddCommGroup V\ninst✝⁴ : InnerProductSpace Real V\ninst✝³ : MetricSpace P\ninst✝² : NormedAddTorsor V P\ns : AffineSubspace Real P\nps : Set P\nh : HasSubset.Subset ps ↑s\ninst✝¹ : Nonempty (Subtype fun x => Membership.mem s x)\nn : Nat\ninst✝ : FiniteDimensional Real (Subtype fun x => Membership.mem s.direction x)\nhd : Eq (Module.finrank Real (Subtype fun x => Membership.mem s.direction x)) n\nhc : EuclideanGeometry.Cospherical ps\nsx₁ sx₂ : Affine.Simplex Real P n\nhsx₁ : HasSubset.Subset (Set.range sx₁.points) ps\nhsx₂ : HasSubset.Subset (Set.range sx₂.points) ps\n⊢ Eq sx₁.circumcenter sx₂.circumcenter","decl":"/-- Two n-simplices among cospherical points in an n-dimensional\nsubspace have the same circumcenter. -/\ntheorem circumcenter_eq_of_cospherical_subset {s : AffineSubspace ℝ P} {ps : Set P} (h : ps ⊆ s)\n    [Nonempty s] {n : ℕ} [FiniteDimensional ℝ s.direction] (hd : finrank ℝ s.direction = n)\n    (hc : Cospherical ps) {sx₁ sx₂ : Simplex ℝ P n} (hsx₁ : Set.range sx₁.points ⊆ ps)\n    (hsx₂ : Set.range sx₂.points ⊆ ps) : sx₁.circumcenter = sx₂.circumcenter := by\n  rcases exists_circumcenter_eq_of_cospherical_subset h hd hc with ⟨r, hr⟩\n  rw [hr sx₁ hsx₁, hr sx₂ hsx₂]\n\n"}
{"name":"EuclideanGeometry.exists_circumcenter_eq_of_cospherical","module":"Mathlib.Geometry.Euclidean.Circumcenter","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor V P\nps : Set P\nn : Nat\ninst✝ : FiniteDimensional Real V\nhd : Eq (Module.finrank Real V) n\nhc : EuclideanGeometry.Cospherical ps\n⊢ Exists fun c => ∀ (sx : Affine.Simplex Real P n), HasSubset.Subset (Set.range sx.points) ps → Eq sx.circumcenter c","decl":"/-- All n-simplices among cospherical points in n-space have the same\ncircumcenter. -/\ntheorem exists_circumcenter_eq_of_cospherical {ps : Set P} {n : ℕ} [FiniteDimensional ℝ V]\n    (hd : finrank ℝ V = n) (hc : Cospherical ps) :\n    ∃ c : P, ∀ sx : Simplex ℝ P n, Set.range sx.points ⊆ ps → sx.circumcenter = c := by\n  haveI : Nonempty (⊤ : AffineSubspace ℝ P) := Set.univ.nonempty\n  rw [← finrank_top, ← direction_top ℝ V P] at hd\n  refine exists_circumcenter_eq_of_cospherical_subset ?_ hd hc\n  exact Set.subset_univ _\n\n"}
{"name":"EuclideanGeometry.circumcenter_eq_of_cospherical","module":"Mathlib.Geometry.Euclidean.Circumcenter","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor V P\nps : Set P\nn : Nat\ninst✝ : FiniteDimensional Real V\nhd : Eq (Module.finrank Real V) n\nhc : EuclideanGeometry.Cospherical ps\nsx₁ sx₂ : Affine.Simplex Real P n\nhsx₁ : HasSubset.Subset (Set.range sx₁.points) ps\nhsx₂ : HasSubset.Subset (Set.range sx₂.points) ps\n⊢ Eq sx₁.circumcenter sx₂.circumcenter","decl":"/-- Two n-simplices among cospherical points in n-space have the same\ncircumcenter. -/\ntheorem circumcenter_eq_of_cospherical {ps : Set P} {n : ℕ} [FiniteDimensional ℝ V]\n    (hd : finrank ℝ V = n) (hc : Cospherical ps) {sx₁ sx₂ : Simplex ℝ P n}\n    (hsx₁ : Set.range sx₁.points ⊆ ps) (hsx₂ : Set.range sx₂.points ⊆ ps) :\n    sx₁.circumcenter = sx₂.circumcenter := by\n  rcases exists_circumcenter_eq_of_cospherical hd hc with ⟨r, hr⟩\n  rw [hr sx₁ hsx₁, hr sx₂ hsx₂]\n\n"}
{"name":"EuclideanGeometry.exists_circumsphere_eq_of_cospherical_subset","module":"Mathlib.Geometry.Euclidean.Circumcenter","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁵ : NormedAddCommGroup V\ninst✝⁴ : InnerProductSpace Real V\ninst✝³ : MetricSpace P\ninst✝² : NormedAddTorsor V P\ns : AffineSubspace Real P\nps : Set P\nh : HasSubset.Subset ps ↑s\ninst✝¹ : Nonempty (Subtype fun x => Membership.mem s x)\nn : Nat\ninst✝ : FiniteDimensional Real (Subtype fun x => Membership.mem s.direction x)\nhd : Eq (Module.finrank Real (Subtype fun x => Membership.mem s.direction x)) n\nhc : EuclideanGeometry.Cospherical ps\n⊢ Exists fun c => ∀ (sx : Affine.Simplex Real P n), HasSubset.Subset (Set.range sx.points) ps → Eq sx.circumsphere c","decl":"/-- All n-simplices among cospherical points in an n-dimensional\nsubspace have the same circumsphere. -/\ntheorem exists_circumsphere_eq_of_cospherical_subset {s : AffineSubspace ℝ P} {ps : Set P}\n    (h : ps ⊆ s) [Nonempty s] {n : ℕ} [FiniteDimensional ℝ s.direction]\n    (hd : finrank ℝ s.direction = n) (hc : Cospherical ps) :\n    ∃ c : Sphere P, ∀ sx : Simplex ℝ P n, Set.range sx.points ⊆ ps → sx.circumsphere = c := by\n  obtain ⟨r, hr⟩ := exists_circumradius_eq_of_cospherical_subset h hd hc\n  obtain ⟨c, hc⟩ := exists_circumcenter_eq_of_cospherical_subset h hd hc\n  exact ⟨⟨c, r⟩, fun sx hsx => Sphere.ext (hc sx hsx) (hr sx hsx)⟩\n\n"}
{"name":"EuclideanGeometry.circumsphere_eq_of_cospherical_subset","module":"Mathlib.Geometry.Euclidean.Circumcenter","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁵ : NormedAddCommGroup V\ninst✝⁴ : InnerProductSpace Real V\ninst✝³ : MetricSpace P\ninst✝² : NormedAddTorsor V P\ns : AffineSubspace Real P\nps : Set P\nh : HasSubset.Subset ps ↑s\ninst✝¹ : Nonempty (Subtype fun x => Membership.mem s x)\nn : Nat\ninst✝ : FiniteDimensional Real (Subtype fun x => Membership.mem s.direction x)\nhd : Eq (Module.finrank Real (Subtype fun x => Membership.mem s.direction x)) n\nhc : EuclideanGeometry.Cospherical ps\nsx₁ sx₂ : Affine.Simplex Real P n\nhsx₁ : HasSubset.Subset (Set.range sx₁.points) ps\nhsx₂ : HasSubset.Subset (Set.range sx₂.points) ps\n⊢ Eq sx₁.circumsphere sx₂.circumsphere","decl":"/-- Two n-simplices among cospherical points in an n-dimensional\nsubspace have the same circumsphere. -/\ntheorem circumsphere_eq_of_cospherical_subset {s : AffineSubspace ℝ P} {ps : Set P} (h : ps ⊆ s)\n    [Nonempty s] {n : ℕ} [FiniteDimensional ℝ s.direction] (hd : finrank ℝ s.direction = n)\n    (hc : Cospherical ps) {sx₁ sx₂ : Simplex ℝ P n} (hsx₁ : Set.range sx₁.points ⊆ ps)\n    (hsx₂ : Set.range sx₂.points ⊆ ps) : sx₁.circumsphere = sx₂.circumsphere := by\n  rcases exists_circumsphere_eq_of_cospherical_subset h hd hc with ⟨r, hr⟩\n  rw [hr sx₁ hsx₁, hr sx₂ hsx₂]\n\n"}
{"name":"EuclideanGeometry.exists_circumsphere_eq_of_cospherical","module":"Mathlib.Geometry.Euclidean.Circumcenter","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor V P\nps : Set P\nn : Nat\ninst✝ : FiniteDimensional Real V\nhd : Eq (Module.finrank Real V) n\nhc : EuclideanGeometry.Cospherical ps\n⊢ Exists fun c => ∀ (sx : Affine.Simplex Real P n), HasSubset.Subset (Set.range sx.points) ps → Eq sx.circumsphere c","decl":"/-- All n-simplices among cospherical points in n-space have the same\ncircumsphere. -/\ntheorem exists_circumsphere_eq_of_cospherical {ps : Set P} {n : ℕ} [FiniteDimensional ℝ V]\n    (hd : finrank ℝ V = n) (hc : Cospherical ps) :\n    ∃ c : Sphere P, ∀ sx : Simplex ℝ P n, Set.range sx.points ⊆ ps → sx.circumsphere = c := by\n  haveI : Nonempty (⊤ : AffineSubspace ℝ P) := Set.univ.nonempty\n  rw [← finrank_top, ← direction_top ℝ V P] at hd\n  refine exists_circumsphere_eq_of_cospherical_subset ?_ hd hc\n  exact Set.subset_univ _\n\n"}
{"name":"EuclideanGeometry.circumsphere_eq_of_cospherical","module":"Mathlib.Geometry.Euclidean.Circumcenter","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor V P\nps : Set P\nn : Nat\ninst✝ : FiniteDimensional Real V\nhd : Eq (Module.finrank Real V) n\nhc : EuclideanGeometry.Cospherical ps\nsx₁ sx₂ : Affine.Simplex Real P n\nhsx₁ : HasSubset.Subset (Set.range sx₁.points) ps\nhsx₂ : HasSubset.Subset (Set.range sx₂.points) ps\n⊢ Eq sx₁.circumsphere sx₂.circumsphere","decl":"/-- Two n-simplices among cospherical points in n-space have the same\ncircumsphere. -/\ntheorem circumsphere_eq_of_cospherical {ps : Set P} {n : ℕ} [FiniteDimensional ℝ V]\n    (hd : finrank ℝ V = n) (hc : Cospherical ps) {sx₁ sx₂ : Simplex ℝ P n}\n    (hsx₁ : Set.range sx₁.points ⊆ ps) (hsx₂ : Set.range sx₂.points ⊆ ps) :\n    sx₁.circumsphere = sx₂.circumsphere := by\n  rcases exists_circumsphere_eq_of_cospherical hd hc with ⟨r, hr⟩\n  rw [hr sx₁ hsx₁, hr sx₂ hsx₂]\n\n"}
{"name":"EuclideanGeometry.eq_or_eq_reflection_of_dist_eq","module":"Mathlib.Geometry.Euclidean.Circumcenter","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\nn : Nat\ns : Affine.Simplex Real P n\np p₁ p₂ : P\nr : Real\nhp₁ : Membership.mem (affineSpan Real (Insert.insert p (Set.range s.points))) p₁\nhp₂ : Membership.mem (affineSpan Real (Insert.insert p (Set.range s.points))) p₂\nh₁ : ∀ (i : Fin (HAdd.hAdd n 1)), Eq (Dist.dist (s.points i) p₁) r\nh₂ : ∀ (i : Fin (HAdd.hAdd n 1)), Eq (Dist.dist (s.points i) p₂) r\n⊢ Or (Eq p₁ p₂) (Eq p₁ ((EuclideanGeometry.reflection (affineSpan Real (Set.range s.points))) p₂))","decl":"/-- Suppose all distances from `p₁` and `p₂` to the points of a\nsimplex are equal, and that `p₁` and `p₂` lie in the affine span of\n`p` with the vertices of that simplex.  Then `p₁` and `p₂` are equal\nor reflections of each other in the affine span of the vertices of the\nsimplex. -/\ntheorem eq_or_eq_reflection_of_dist_eq {n : ℕ} {s : Simplex ℝ P n} {p p₁ p₂ : P} {r : ℝ}\n    (hp₁ : p₁ ∈ affineSpan ℝ (insert p (Set.range s.points)))\n    (hp₂ : p₂ ∈ affineSpan ℝ (insert p (Set.range s.points))) (h₁ : ∀ i, dist (s.points i) p₁ = r)\n    (h₂ : ∀ i, dist (s.points i) p₂ = r) :\n    p₁ = p₂ ∨ p₁ = reflection (affineSpan ℝ (Set.range s.points)) p₂ := by\n  set span_s := affineSpan ℝ (Set.range s.points)\n  have h₁' := s.orthogonalProjection_eq_circumcenter_of_dist_eq h₁\n  have h₂' := s.orthogonalProjection_eq_circumcenter_of_dist_eq h₂\n  rw [← affineSpan_insert_affineSpan, mem_affineSpan_insert_iff (orthogonalProjection_mem p)]\n    at hp₁ hp₂\n  obtain ⟨r₁, p₁o, hp₁o, hp₁⟩ := hp₁\n  obtain ⟨r₂, p₂o, hp₂o, hp₂⟩ := hp₂\n  obtain rfl : ↑(s.orthogonalProjectionSpan p₁) = p₁o := by\n    subst hp₁\n    exact s.coe_orthogonalProjection_vadd_smul_vsub_orthogonalProjection hp₁o\n  rw [h₁'] at hp₁\n  obtain rfl : ↑(s.orthogonalProjectionSpan p₂) = p₂o := by\n    subst hp₂\n    exact s.coe_orthogonalProjection_vadd_smul_vsub_orthogonalProjection hp₂o\n  rw [h₂'] at hp₂\n  have h : s.points 0 ∈ span_s := mem_affineSpan ℝ (Set.mem_range_self _)\n  have hd₁ :\n    dist p₁ s.circumcenter * dist p₁ s.circumcenter = r * r - s.circumradius * s.circumradius :=\n    s.dist_circumcenter_sq_eq_sq_sub_circumradius h₁ h₁' h\n  have hd₂ :\n    dist p₂ s.circumcenter * dist p₂ s.circumcenter = r * r - s.circumradius * s.circumradius :=\n    s.dist_circumcenter_sq_eq_sq_sub_circumradius h₂ h₂' h\n  rw [← hd₂, hp₁, hp₂, dist_eq_norm_vsub V _ s.circumcenter, dist_eq_norm_vsub V _ s.circumcenter,\n    vadd_vsub, vadd_vsub, ← real_inner_self_eq_norm_mul_norm, ← real_inner_self_eq_norm_mul_norm,\n    real_inner_smul_left, real_inner_smul_left, real_inner_smul_right, real_inner_smul_right, ←\n    mul_assoc, ← mul_assoc] at hd₁\n  by_cases hp : p = s.orthogonalProjectionSpan p\n  · rw [Simplex.orthogonalProjectionSpan] at hp\n    rw [hp₁, hp₂, ← hp]\n    simp only [true_or, eq_self_iff_true, smul_zero, vsub_self]\n  · have hz : ⟪p -ᵥ orthogonalProjection span_s p, p -ᵥ orthogonalProjection span_s p⟫ ≠ 0 := by\n      simpa only [Ne, vsub_eq_zero_iff_eq, inner_self_eq_zero] using hp\n    rw [mul_left_inj' hz, mul_self_eq_mul_self_iff] at hd₁\n    rw [hp₁, hp₂]\n    cases' hd₁ with hd₁ hd₁\n    · left\n      rw [hd₁]\n    · right\n      rw [hd₁, reflection_vadd_smul_vsub_orthogonalProjection p r₂ s.circumcenter_mem_affineSpan,\n        neg_smul]\n\n"}
