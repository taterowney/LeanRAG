{"name":"Module.charP_end","module":"Mathlib.Algebra.CharP.LinearMaps","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\np : Nat\nhchar : CharP R p\nhtorsion : Exists fun x => Eq (Ideal.torsionOf R M x) Bot.bot\n⊢ CharP (LinearMap (RingHom.id R) M M) p","decl":"/-- For a commutative semiring `R` and a `R`-module `M`, if `M` contains an\n  element `x` that is not torsion, then the characteristic of `R` is equal to the\n  characteristic of the `R`-linear endomorphisms of `M`.-/\ntheorem charP_end {p : ℕ} [hchar : CharP R p]\n    (htorsion : ∃ x : M, Ideal.torsionOf R M x = ⊥) : CharP (M →ₗ[R] M) p where\n  cast_eq_zero_iff' n := by\n    have hreduction : ∃ x : M, ∀ r : R, r • x = 0 → r = 0 :=\n      Exists.casesOn htorsion fun x hx ↦\n        Exists.intro x fun r a ↦ (hx ▸ Ideal.mem_torsionOf_iff x r).mpr a\n    have exact : (n : M →ₗ[R] M) = (n : R) • 1 := by\n      simp only [Nat.cast_smul_eq_nsmul, nsmul_eq_mul, mul_one]\n    rw [exact, LinearMap.ext_iff, ← hchar.1]\n    exact ⟨fun h ↦ Exists.casesOn hreduction fun x hx ↦ hx n (h x),\n      fun h ↦ (congrArg (fun t ↦ ∀ x, t • x = 0) h).mpr fun x ↦ zero_smul R x⟩\n\n"}
{"name":"instCharPLinearMapSubtypeMemSubringCenterId","module":"Mathlib.Algebra.CharP.LinearMaps","initialProofState":"D : Type u_1\ninst✝¹ : DivisionRing D\np : Nat\ninst✝ : CharP D p\n⊢ CharP (LinearMap (RingHom.id (Subtype fun x => Membership.mem (Subring.center D) x)) D D) p","decl":"/-- For a division ring `D` with center `k`, the ring of `k`-linear endomorphisms\n  of `D` has the same characteristic as `D`-/\ninstance {D : Type*} [DivisionRing D] {p : ℕ} [CharP D p] :\n    CharP (D →ₗ[(Subring.center D)] D) p :=\n  charP_of_injective_ringHom (Algebra.lmul (Subring.center D) D).toRingHom.injective p\n\n"}
{"name":"instExpCharLinearMapSubtypeMemSubringCenterId","module":"Mathlib.Algebra.CharP.LinearMaps","initialProofState":"D : Type u_1\ninst✝¹ : DivisionRing D\np : Nat\ninst✝ : ExpChar D p\n⊢ ExpChar (LinearMap (RingHom.id (Subtype fun x => Membership.mem (Subring.center D) x)) D D) p","decl":"instance {D : Type*} [DivisionRing D] {p : ℕ} [ExpChar D p] :\n    ExpChar (D →ₗ[Subring.center D] D) p :=\n  expChar_of_injective_ringHom (Algebra.lmul (Subring.center D) D).toRingHom.injective p\n"}
