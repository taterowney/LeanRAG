{"name":"Matrix.mvPolynomialX_apply","module":"Mathlib.LinearAlgebra.Matrix.MvPolynomial","initialProofState":"m : Type u_1\nn : Type u_2\nR : Type u_3\ninst✝ : CommSemiring R\ni : m\nj : n\n⊢ Eq (Matrix.mvPolynomialX m n R i j) (MvPolynomial.X { fst := i, snd := j })","decl":"@[simp]\ntheorem mvPolynomialX_apply [CommSemiring R] (i j) :\n    mvPolynomialX m n R i j = MvPolynomial.X (i, j) :=\n  rfl\n\n"}
{"name":"Matrix.mvPolynomialX_map_eval₂","module":"Mathlib.LinearAlgebra.Matrix.MvPolynomial","initialProofState":"m : Type u_1\nn : Type u_2\nR : Type u_3\nS : Type u_4\ninst✝¹ : CommSemiring R\ninst✝ : CommSemiring S\nf : RingHom R S\nA : Matrix m n S\n⊢ Eq ((Matrix.mvPolynomialX m n R).map (MvPolynomial.eval₂ f fun p => A p.1 p.2)) A","decl":"/-- Any matrix `A` can be expressed as the evaluation of `Matrix.mvPolynomialX`.\n\nThis is of particular use when `MvPolynomial (m × n) R` is an integral domain but `S` is\nnot, as if the `MvPolynomial.eval₂` can be pulled to the outside of a goal, it can be solved in\nunder cancellative assumptions. -/\ntheorem mvPolynomialX_map_eval₂ [CommSemiring R] [CommSemiring S] (f : R →+* S) (A : Matrix m n S) :\n    (mvPolynomialX m n R).map (MvPolynomial.eval₂ f fun p : m × n => A p.1 p.2) = A :=\n  ext fun i j => MvPolynomial.eval₂_X _ (fun p : m × n => A p.1 p.2) (i, j)\n\n"}
{"name":"Matrix.mvPolynomialX_mapMatrix_eval","module":"Mathlib.LinearAlgebra.Matrix.MvPolynomial","initialProofState":"m : Type u_1\nR : Type u_3\ninst✝² : Fintype m\ninst✝¹ : DecidableEq m\ninst✝ : CommSemiring R\nA : Matrix m m R\n⊢ Eq ((MvPolynomial.eval fun p => A p.1 p.2).mapMatrix (Matrix.mvPolynomialX m m R)) A","decl":"/-- A variant of `Matrix.mvPolynomialX_map_eval₂` with a bundled `RingHom` on the LHS. -/\ntheorem mvPolynomialX_mapMatrix_eval [Fintype m] [DecidableEq m] [CommSemiring R]\n    (A : Matrix m m R) :\n    (MvPolynomial.eval fun p : m × m => A p.1 p.2).mapMatrix (mvPolynomialX m m R) = A :=\n  mvPolynomialX_map_eval₂ _ A\n\n"}
{"name":"Matrix.mvPolynomialX_mapMatrix_aeval","module":"Mathlib.LinearAlgebra.Matrix.MvPolynomial","initialProofState":"m : Type u_1\nR : Type u_3\nS : Type u_4\ninst✝⁴ : Fintype m\ninst✝³ : DecidableEq m\ninst✝² : CommSemiring R\ninst✝¹ : CommSemiring S\ninst✝ : Algebra R S\nA : Matrix m m S\n⊢ Eq ((MvPolynomial.aeval fun p => A p.1 p.2).mapMatrix (Matrix.mvPolynomialX m m R)) A","decl":"/-- A variant of `Matrix.mvPolynomialX_map_eval₂` with a bundled `AlgHom` on the LHS. -/\ntheorem mvPolynomialX_mapMatrix_aeval [Fintype m] [DecidableEq m] [CommSemiring R] [CommSemiring S]\n    [Algebra R S] (A : Matrix m m S) :\n    (MvPolynomial.aeval fun p : m × m => A p.1 p.2).mapMatrix (mvPolynomialX m m R) = A :=\n  mvPolynomialX_map_eval₂ _ A\n\n"}
{"name":"Matrix.det_mvPolynomialX_ne_zero","module":"Mathlib.LinearAlgebra.Matrix.MvPolynomial","initialProofState":"m : Type u_1\nR : Type u_3\ninst✝³ : DecidableEq m\ninst✝² : Fintype m\ninst✝¹ : CommRing R\ninst✝ : Nontrivial R\n⊢ Ne (Matrix.mvPolynomialX m m R).det 0","decl":"/-- In a nontrivial ring, `Matrix.mvPolynomialX m m R` has non-zero determinant. -/\ntheorem det_mvPolynomialX_ne_zero [DecidableEq m] [Fintype m] [CommRing R] [Nontrivial R] :\n    det (mvPolynomialX m m R) ≠ 0 := by\n  intro h_det\n  have := congr_arg Matrix.det (mvPolynomialX_mapMatrix_eval (1 : Matrix m m R))\n  rw [det_one, ← RingHom.map_det, h_det, RingHom.map_zero] at this\n  exact zero_ne_one this\n\n"}
