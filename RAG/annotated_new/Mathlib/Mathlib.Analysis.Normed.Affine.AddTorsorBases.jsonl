{"name":"isOpenMap_barycentric_coord","module":"Mathlib.Analysis.Normed.Affine.AddTorsorBases","initialProofState":"Î¹ : Type u_1\nğ•œ : Type u_2\nE : Type u_3\nP : Type u_4\ninstâœâ¶ : NontriviallyNormedField ğ•œ\ninstâœâµ : CompleteSpace ğ•œ\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\ninstâœÂ² : MetricSpace P\ninstâœÂ¹ : NormedAddTorsor E P\ninstâœ : Nontrivial Î¹\nb : AffineBasis Î¹ ğ•œ P\ni : Î¹\nâŠ¢ IsOpenMap â‡‘(b.coord i)","decl":"theorem isOpenMap_barycentric_coord [Nontrivial Î¹] (b : AffineBasis Î¹ ğ•œ P) (i : Î¹) :\n    IsOpenMap (b.coord i) :=\n  AffineMap.isOpenMap_linear_iff.mp <|\n    (b.coord i).linear.isOpenMap_of_finiteDimensional <|\n      (b.coord i).linear_surjective_iff.mpr (b.surjective_coord i)\n\n"}
{"name":"continuous_barycentric_coord","module":"Mathlib.Analysis.Normed.Affine.AddTorsorBases","initialProofState":"Î¹ : Type u_1\nğ•œ : Type u_2\nE : Type u_3\nP : Type u_4\ninstâœâ¶ : NontriviallyNormedField ğ•œ\ninstâœâµ : CompleteSpace ğ•œ\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\ninstâœÂ² : MetricSpace P\ninstâœÂ¹ : NormedAddTorsor E P\ninstâœ : FiniteDimensional ğ•œ E\nb : AffineBasis Î¹ ğ•œ P\ni : Î¹\nâŠ¢ Continuous â‡‘(b.coord i)","decl":"@[continuity]\ntheorem continuous_barycentric_coord (i : Î¹) : Continuous (b.coord i) :=\n  (b.coord i).continuous_of_finiteDimensional\n\n"}
{"name":"AffineBasis.interior_convexHull","module":"Mathlib.Analysis.Normed.Affine.AddTorsorBases","initialProofState":"Î¹ : Type u_1\nE : Type u_2\ninstâœÂ² : Finite Î¹\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\nb : AffineBasis Î¹ Real E\nâŠ¢ Eq (interior ((convexHull Real) (Set.range â‡‘b))) (setOf fun x => âˆ€ (i : Î¹), LT.lt 0 ((b.coord i) x))","decl":"/-- Given a finite-dimensional normed real vector space, the interior of the convex hull of an\naffine basis is the set of points whose barycentric coordinates are strictly positive with respect\nto this basis.\n\nTODO Restate this result for affine spaces (instead of vector spaces) once the definition of\nconvexity is generalised to this setting. -/\ntheorem AffineBasis.interior_convexHull {Î¹ E : Type*} [Finite Î¹] [NormedAddCommGroup E]\n    [NormedSpace â„ E] (b : AffineBasis Î¹ â„ E) :\n    interior (convexHull â„ (range b)) = {x | âˆ€ i, 0 < b.coord i x} := by\n  cases subsingleton_or_nontrivial Î¹\n  Â· -- The zero-dimensional case.\n    have : range b = univ :=\n      AffineSubspace.eq_univ_of_subsingleton_span_eq_top (subsingleton_range _) b.tot\n    simp [this]\n  Â· -- The positive-dimensional case.\n    haveI : FiniteDimensional â„ E := b.finiteDimensional\n    have : convexHull â„ (range b) = â‹‚ i, b.coord i â»Â¹' Ici 0 := by\n      rw [b.convexHull_eq_nonneg_coord, setOf_forall]; rfl\n    ext\n    simp only [this, interior_iInter_of_finite, â†\n      IsOpenMap.preimage_interior_eq_interior_preimage (isOpenMap_barycentric_coord b _)\n        (continuous_barycentric_coord b _),\n      interior_Ici, mem_iInter, mem_setOf_eq, mem_Ioi, mem_preimage]\n\n"}
{"name":"IsOpen.exists_between_affineIndependent_span_eq_top","module":"Mathlib.Analysis.Normed.Affine.AddTorsorBases","initialProofState":"V : Type u_1\nP : Type u_2\ninstâœÂ³ : NormedAddCommGroup V\ninstâœÂ² : NormedSpace Real V\ninstâœÂ¹ : MetricSpace P\ninstâœ : NormedAddTorsor V P\ns u : Set P\nhu : IsOpen u\nhsu : HasSubset.Subset s u\nhne : s.Nonempty\nh : AffineIndependent Real Subtype.val\nâŠ¢ Exists fun t => And (HasSubset.Subset s t) (And (HasSubset.Subset t u) (And (AffineIndependent Real Subtype.val) (Eq (affineSpan Real t) Top.top)))","decl":"/-- Given a set `s` of affine-independent points belonging to an open set `u`, we may extend `s` to\nan affine basis, all of whose elements belong to `u`. -/\ntheorem IsOpen.exists_between_affineIndependent_span_eq_top {s u : Set P} (hu : IsOpen u)\n    (hsu : s âŠ† u) (hne : s.Nonempty) (h : AffineIndependent â„ ((â†‘) : s â†’ P)) :\n    âˆƒ t : Set P, s âŠ† t âˆ§ t âŠ† u âˆ§ AffineIndependent â„ ((â†‘) : t â†’ P) âˆ§ affineSpan â„ t = âŠ¤ := by\n  obtain âŸ¨q, hqâŸ© := hne\n  obtain âŸ¨Îµ, Îµ0, hÎµuâŸ© := Metric.nhds_basis_closedBall.mem_iff.1 (hu.mem_nhds <| hsu hq)\n  obtain âŸ¨t, htâ‚, htâ‚‚, htâ‚ƒâŸ© := exists_subset_affineIndependent_affineSpan_eq_top h\n  let f : P â†’ P := fun y => lineMap q y (Îµ / dist y q)\n  have hf : âˆ€ y, f y âˆˆ u := by\n    refine fun y => hÎµu ?_\n    simp only [f]\n    rw [Metric.mem_closedBall, lineMap_apply, dist_vadd_left, norm_smul, Real.norm_eq_abs,\n      dist_eq_norm_vsub V y q, abs_div, abs_of_pos Îµ0, abs_of_nonneg (norm_nonneg _), div_mul_comm]\n    exact mul_le_of_le_one_left Îµ0.le (div_self_le_one _)\n  have hÎµyq : âˆ€ y âˆ‰ s, Îµ / dist y q â‰  0 := fun y hy =>\n    div_ne_zero Îµ0.ne' (dist_ne_zero.2 (ne_of_mem_of_not_mem hq hy).symm)\n  classical\n  let w : t â†’ â„Ë£ := fun p => if hp : (p : P) âˆˆ s then 1 else Units.mk0 _ (hÎµyq (â†‘p) hp)\n  refine âŸ¨Set.range fun p : t => lineMap q p (w p : â„), ?_, ?_, ?_, ?_âŸ©\n  Â· intro p hp; use âŸ¨p, htâ‚ hpâŸ©; simp [w, hp]\n  Â· rintro y âŸ¨âŸ¨p, hpâŸ©, rflâŸ©\n    by_cases hps : p âˆˆ s <;>\n    simp only [w, hps, lineMap_apply_one, Units.val_mk0, dif_neg, dif_pos, not_false_iff,\n      Units.val_one, Subtype.coe_mk] <;>\n    [exact hsu hps; exact hf p]\n  Â· exact (htâ‚‚.units_lineMap âŸ¨q, htâ‚ hqâŸ© w).range\n  Â· rw [affineSpan_eq_affineSpan_lineMap_units (htâ‚ hq) w, htâ‚ƒ]\n\n"}
{"name":"IsOpen.exists_subset_affineIndependent_span_eq_top","module":"Mathlib.Analysis.Normed.Affine.AddTorsorBases","initialProofState":"V : Type u_1\nP : Type u_2\ninstâœÂ³ : NormedAddCommGroup V\ninstâœÂ² : NormedSpace Real V\ninstâœÂ¹ : MetricSpace P\ninstâœ : NormedAddTorsor V P\nu : Set P\nhu : IsOpen u\nhne : u.Nonempty\nâŠ¢ Exists fun s => And (HasSubset.Subset s u) (And (AffineIndependent Real Subtype.val) (Eq (affineSpan Real s) Top.top))","decl":"theorem IsOpen.exists_subset_affineIndependent_span_eq_top {u : Set P} (hu : IsOpen u)\n    (hne : u.Nonempty) : âˆƒ s âŠ† u, AffineIndependent â„ ((â†‘) : s â†’ P) âˆ§ affineSpan â„ s = âŠ¤ := by\n  rcases hne with âŸ¨x, hxâŸ©\n  rcases hu.exists_between_affineIndependent_span_eq_top (singleton_subset_iff.mpr hx)\n    (singleton_nonempty _) (affineIndependent_of_subsingleton _ _) with âŸ¨s, -, hsu, hsâŸ©\n  exact âŸ¨s, hsu, hsâŸ©\n\n"}
{"name":"IsOpen.affineSpan_eq_top","module":"Mathlib.Analysis.Normed.Affine.AddTorsorBases","initialProofState":"V : Type u_1\nP : Type u_2\ninstâœÂ³ : NormedAddCommGroup V\ninstâœÂ² : NormedSpace Real V\ninstâœÂ¹ : MetricSpace P\ninstâœ : NormedAddTorsor V P\nu : Set P\nhu : IsOpen u\nhne : u.Nonempty\nâŠ¢ Eq (affineSpan Real u) Top.top","decl":"/-- The affine span of a nonempty open set is `âŠ¤`. -/\ntheorem IsOpen.affineSpan_eq_top {u : Set P} (hu : IsOpen u) (hne : u.Nonempty) :\n    affineSpan â„ u = âŠ¤ :=\n  let âŸ¨_, hsu, _, hs'âŸ© := hu.exists_subset_affineIndependent_span_eq_top hne\n  top_unique <| hs' â–¸ affineSpan_mono _ hsu\n\n"}
{"name":"affineSpan_eq_top_of_nonempty_interior","module":"Mathlib.Analysis.Normed.Affine.AddTorsorBases","initialProofState":"V : Type u_1\ninstâœÂ¹ : NormedAddCommGroup V\ninstâœ : NormedSpace Real V\ns : Set V\nhs : (interior ((convexHull Real) s)).Nonempty\nâŠ¢ Eq (affineSpan Real s) Top.top","decl":"theorem affineSpan_eq_top_of_nonempty_interior {s : Set V}\n    (hs : (interior <| convexHull â„ s).Nonempty) : affineSpan â„ s = âŠ¤ :=\n  top_unique <| isOpen_interior.affineSpan_eq_top hs â–¸\n    (affineSpan_mono _ interior_subset).trans_eq (affineSpan_convexHull _)\n\n"}
{"name":"AffineBasis.centroid_mem_interior_convexHull","module":"Mathlib.Analysis.Normed.Affine.AddTorsorBases","initialProofState":"V : Type u_1\ninstâœÂ² : NormedAddCommGroup V\ninstâœÂ¹ : NormedSpace Real V\nÎ¹ : Type u_3\ninstâœ : Fintype Î¹\nb : AffineBasis Î¹ Real V\nâŠ¢ Membership.mem (interior ((convexHull Real) (Set.range â‡‘b))) (Finset.centroid Real Finset.univ â‡‘b)","decl":"theorem AffineBasis.centroid_mem_interior_convexHull {Î¹} [Fintype Î¹] (b : AffineBasis Î¹ â„ V) :\n    Finset.univ.centroid â„ b âˆˆ interior (convexHull â„ (range b)) := by\n  haveI := b.nonempty\n  simp only [b.interior_convexHull, mem_setOf_eq, b.coord_apply_centroid (Finset.mem_univ _),\n    inv_pos, Nat.cast_pos, Finset.card_pos, Finset.univ_nonempty, forall_true_iff]\n\n"}
{"name":"interior_convexHull_nonempty_iff_affineSpan_eq_top","module":"Mathlib.Analysis.Normed.Affine.AddTorsorBases","initialProofState":"V : Type u_1\ninstâœÂ² : NormedAddCommGroup V\ninstâœÂ¹ : NormedSpace Real V\ninstâœ : FiniteDimensional Real V\ns : Set V\nâŠ¢ Iff (interior ((convexHull Real) s)).Nonempty (Eq (affineSpan Real s) Top.top)","decl":"theorem interior_convexHull_nonempty_iff_affineSpan_eq_top [FiniteDimensional â„ V] {s : Set V} :\n    (interior (convexHull â„ s)).Nonempty â†” affineSpan â„ s = âŠ¤ := by\n  refine âŸ¨affineSpan_eq_top_of_nonempty_interior, fun h => ?_âŸ©\n  obtain âŸ¨t, hts, b, hbâŸ© := AffineBasis.exists_affine_subbasis h\n  suffices (interior (convexHull â„ (range b))).Nonempty by\n    rw [hb, Subtype.range_coe_subtype, setOf_mem_eq] at this\n    refine this.mono (by gcongr)\n  lift t to Finset V using b.finite_set\n  exact âŸ¨_, b.centroid_mem_interior_convexHullâŸ©\n\n"}
{"name":"Convex.interior_nonempty_iff_affineSpan_eq_top","module":"Mathlib.Analysis.Normed.Affine.AddTorsorBases","initialProofState":"V : Type u_1\ninstâœÂ² : NormedAddCommGroup V\ninstâœÂ¹ : NormedSpace Real V\ninstâœ : FiniteDimensional Real V\ns : Set V\nhs : Convex Real s\nâŠ¢ Iff (interior s).Nonempty (Eq (affineSpan Real s) Top.top)","decl":"theorem Convex.interior_nonempty_iff_affineSpan_eq_top [FiniteDimensional â„ V] {s : Set V}\n    (hs : Convex â„ s) : (interior s).Nonempty â†” affineSpan â„ s = âŠ¤ := by\n  rw [â† interior_convexHull_nonempty_iff_affineSpan_eq_top, hs.convexHull_eq]\n"}
