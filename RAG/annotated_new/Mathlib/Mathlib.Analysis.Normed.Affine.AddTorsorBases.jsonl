{"name":"isOpenMap_barycentric_coord","module":"Mathlib.Analysis.Normed.Affine.AddTorsorBases","initialProofState":"ι : Type u_1\n𝕜 : Type u_2\nE : Type u_3\nP : Type u_4\ninst✝⁶ : NontriviallyNormedField 𝕜\ninst✝⁵ : CompleteSpace 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor E P\ninst✝ : Nontrivial ι\nb : AffineBasis ι 𝕜 P\ni : ι\n⊢ IsOpenMap ⇑(b.coord i)","decl":"theorem isOpenMap_barycentric_coord [Nontrivial ι] (b : AffineBasis ι 𝕜 P) (i : ι) :\n    IsOpenMap (b.coord i) :=\n  AffineMap.isOpenMap_linear_iff.mp <|\n    (b.coord i).linear.isOpenMap_of_finiteDimensional <|\n      (b.coord i).linear_surjective_iff.mpr (b.surjective_coord i)\n\n"}
{"name":"continuous_barycentric_coord","module":"Mathlib.Analysis.Normed.Affine.AddTorsorBases","initialProofState":"ι : Type u_1\n𝕜 : Type u_2\nE : Type u_3\nP : Type u_4\ninst✝⁶ : NontriviallyNormedField 𝕜\ninst✝⁵ : CompleteSpace 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor E P\ninst✝ : FiniteDimensional 𝕜 E\nb : AffineBasis ι 𝕜 P\ni : ι\n⊢ Continuous ⇑(b.coord i)","decl":"@[continuity]\ntheorem continuous_barycentric_coord (i : ι) : Continuous (b.coord i) :=\n  (b.coord i).continuous_of_finiteDimensional\n\n"}
{"name":"AffineBasis.interior_convexHull","module":"Mathlib.Analysis.Normed.Affine.AddTorsorBases","initialProofState":"ι : Type u_1\nE : Type u_2\ninst✝² : Finite ι\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nb : AffineBasis ι Real E\n⊢ Eq (interior ((convexHull Real) (Set.range ⇑b))) (setOf fun x => ∀ (i : ι), LT.lt 0 ((b.coord i) x))","decl":"/-- Given a finite-dimensional normed real vector space, the interior of the convex hull of an\naffine basis is the set of points whose barycentric coordinates are strictly positive with respect\nto this basis.\n\nTODO Restate this result for affine spaces (instead of vector spaces) once the definition of\nconvexity is generalised to this setting. -/\ntheorem AffineBasis.interior_convexHull {ι E : Type*} [Finite ι] [NormedAddCommGroup E]\n    [NormedSpace ℝ E] (b : AffineBasis ι ℝ E) :\n    interior (convexHull ℝ (range b)) = {x | ∀ i, 0 < b.coord i x} := by\n  cases subsingleton_or_nontrivial ι\n  · -- The zero-dimensional case.\n    have : range b = univ :=\n      AffineSubspace.eq_univ_of_subsingleton_span_eq_top (subsingleton_range _) b.tot\n    simp [this]\n  · -- The positive-dimensional case.\n    haveI : FiniteDimensional ℝ E := b.finiteDimensional\n    have : convexHull ℝ (range b) = ⋂ i, b.coord i ⁻¹' Ici 0 := by\n      rw [b.convexHull_eq_nonneg_coord, setOf_forall]; rfl\n    ext\n    simp only [this, interior_iInter_of_finite, ←\n      IsOpenMap.preimage_interior_eq_interior_preimage (isOpenMap_barycentric_coord b _)\n        (continuous_barycentric_coord b _),\n      interior_Ici, mem_iInter, mem_setOf_eq, mem_Ioi, mem_preimage]\n\n"}
{"name":"IsOpen.exists_between_affineIndependent_span_eq_top","module":"Mathlib.Analysis.Normed.Affine.AddTorsorBases","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : NormedSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\ns u : Set P\nhu : IsOpen u\nhsu : HasSubset.Subset s u\nhne : s.Nonempty\nh : AffineIndependent Real Subtype.val\n⊢ Exists fun t => And (HasSubset.Subset s t) (And (HasSubset.Subset t u) (And (AffineIndependent Real Subtype.val) (Eq (affineSpan Real t) Top.top)))","decl":"/-- Given a set `s` of affine-independent points belonging to an open set `u`, we may extend `s` to\nan affine basis, all of whose elements belong to `u`. -/\ntheorem IsOpen.exists_between_affineIndependent_span_eq_top {s u : Set P} (hu : IsOpen u)\n    (hsu : s ⊆ u) (hne : s.Nonempty) (h : AffineIndependent ℝ ((↑) : s → P)) :\n    ∃ t : Set P, s ⊆ t ∧ t ⊆ u ∧ AffineIndependent ℝ ((↑) : t → P) ∧ affineSpan ℝ t = ⊤ := by\n  obtain ⟨q, hq⟩ := hne\n  obtain ⟨ε, ε0, hεu⟩ := Metric.nhds_basis_closedBall.mem_iff.1 (hu.mem_nhds <| hsu hq)\n  obtain ⟨t, ht₁, ht₂, ht₃⟩ := exists_subset_affineIndependent_affineSpan_eq_top h\n  let f : P → P := fun y => lineMap q y (ε / dist y q)\n  have hf : ∀ y, f y ∈ u := by\n    refine fun y => hεu ?_\n    simp only [f]\n    rw [Metric.mem_closedBall, lineMap_apply, dist_vadd_left, norm_smul, Real.norm_eq_abs,\n      dist_eq_norm_vsub V y q, abs_div, abs_of_pos ε0, abs_of_nonneg (norm_nonneg _), div_mul_comm]\n    exact mul_le_of_le_one_left ε0.le (div_self_le_one _)\n  have hεyq : ∀ y ∉ s, ε / dist y q ≠ 0 := fun y hy =>\n    div_ne_zero ε0.ne' (dist_ne_zero.2 (ne_of_mem_of_not_mem hq hy).symm)\n  classical\n  let w : t → ℝˣ := fun p => if hp : (p : P) ∈ s then 1 else Units.mk0 _ (hεyq (↑p) hp)\n  refine ⟨Set.range fun p : t => lineMap q p (w p : ℝ), ?_, ?_, ?_, ?_⟩\n  · intro p hp; use ⟨p, ht₁ hp⟩; simp [w, hp]\n  · rintro y ⟨⟨p, hp⟩, rfl⟩\n    by_cases hps : p ∈ s <;>\n    simp only [w, hps, lineMap_apply_one, Units.val_mk0, dif_neg, dif_pos, not_false_iff,\n      Units.val_one, Subtype.coe_mk] <;>\n    [exact hsu hps; exact hf p]\n  · exact (ht₂.units_lineMap ⟨q, ht₁ hq⟩ w).range\n  · rw [affineSpan_eq_affineSpan_lineMap_units (ht₁ hq) w, ht₃]\n\n"}
{"name":"IsOpen.exists_subset_affineIndependent_span_eq_top","module":"Mathlib.Analysis.Normed.Affine.AddTorsorBases","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : NormedSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\nu : Set P\nhu : IsOpen u\nhne : u.Nonempty\n⊢ Exists fun s => And (HasSubset.Subset s u) (And (AffineIndependent Real Subtype.val) (Eq (affineSpan Real s) Top.top))","decl":"theorem IsOpen.exists_subset_affineIndependent_span_eq_top {u : Set P} (hu : IsOpen u)\n    (hne : u.Nonempty) : ∃ s ⊆ u, AffineIndependent ℝ ((↑) : s → P) ∧ affineSpan ℝ s = ⊤ := by\n  rcases hne with ⟨x, hx⟩\n  rcases hu.exists_between_affineIndependent_span_eq_top (singleton_subset_iff.mpr hx)\n    (singleton_nonempty _) (affineIndependent_of_subsingleton _ _) with ⟨s, -, hsu, hs⟩\n  exact ⟨s, hsu, hs⟩\n\n"}
{"name":"IsOpen.affineSpan_eq_top","module":"Mathlib.Analysis.Normed.Affine.AddTorsorBases","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : NormedSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\nu : Set P\nhu : IsOpen u\nhne : u.Nonempty\n⊢ Eq (affineSpan Real u) Top.top","decl":"/-- The affine span of a nonempty open set is `⊤`. -/\ntheorem IsOpen.affineSpan_eq_top {u : Set P} (hu : IsOpen u) (hne : u.Nonempty) :\n    affineSpan ℝ u = ⊤ :=\n  let ⟨_, hsu, _, hs'⟩ := hu.exists_subset_affineIndependent_span_eq_top hne\n  top_unique <| hs' ▸ affineSpan_mono _ hsu\n\n"}
{"name":"affineSpan_eq_top_of_nonempty_interior","module":"Mathlib.Analysis.Normed.Affine.AddTorsorBases","initialProofState":"V : Type u_1\ninst✝¹ : NormedAddCommGroup V\ninst✝ : NormedSpace Real V\ns : Set V\nhs : (interior ((convexHull Real) s)).Nonempty\n⊢ Eq (affineSpan Real s) Top.top","decl":"theorem affineSpan_eq_top_of_nonempty_interior {s : Set V}\n    (hs : (interior <| convexHull ℝ s).Nonempty) : affineSpan ℝ s = ⊤ :=\n  top_unique <| isOpen_interior.affineSpan_eq_top hs ▸\n    (affineSpan_mono _ interior_subset).trans_eq (affineSpan_convexHull _)\n\n"}
{"name":"AffineBasis.centroid_mem_interior_convexHull","module":"Mathlib.Analysis.Normed.Affine.AddTorsorBases","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : NormedSpace Real V\nι : Type u_3\ninst✝ : Fintype ι\nb : AffineBasis ι Real V\n⊢ Membership.mem (interior ((convexHull Real) (Set.range ⇑b))) (Finset.centroid Real Finset.univ ⇑b)","decl":"theorem AffineBasis.centroid_mem_interior_convexHull {ι} [Fintype ι] (b : AffineBasis ι ℝ V) :\n    Finset.univ.centroid ℝ b ∈ interior (convexHull ℝ (range b)) := by\n  haveI := b.nonempty\n  simp only [b.interior_convexHull, mem_setOf_eq, b.coord_apply_centroid (Finset.mem_univ _),\n    inv_pos, Nat.cast_pos, Finset.card_pos, Finset.univ_nonempty, forall_true_iff]\n\n"}
{"name":"interior_convexHull_nonempty_iff_affineSpan_eq_top","module":"Mathlib.Analysis.Normed.Affine.AddTorsorBases","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : NormedSpace Real V\ninst✝ : FiniteDimensional Real V\ns : Set V\n⊢ Iff (interior ((convexHull Real) s)).Nonempty (Eq (affineSpan Real s) Top.top)","decl":"theorem interior_convexHull_nonempty_iff_affineSpan_eq_top [FiniteDimensional ℝ V] {s : Set V} :\n    (interior (convexHull ℝ s)).Nonempty ↔ affineSpan ℝ s = ⊤ := by\n  refine ⟨affineSpan_eq_top_of_nonempty_interior, fun h => ?_⟩\n  obtain ⟨t, hts, b, hb⟩ := AffineBasis.exists_affine_subbasis h\n  suffices (interior (convexHull ℝ (range b))).Nonempty by\n    rw [hb, Subtype.range_coe_subtype, setOf_mem_eq] at this\n    refine this.mono (by gcongr)\n  lift t to Finset V using b.finite_set\n  exact ⟨_, b.centroid_mem_interior_convexHull⟩\n\n"}
{"name":"Convex.interior_nonempty_iff_affineSpan_eq_top","module":"Mathlib.Analysis.Normed.Affine.AddTorsorBases","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : NormedSpace Real V\ninst✝ : FiniteDimensional Real V\ns : Set V\nhs : Convex Real s\n⊢ Iff (interior s).Nonempty (Eq (affineSpan Real s) Top.top)","decl":"theorem Convex.interior_nonempty_iff_affineSpan_eq_top [FiniteDimensional ℝ V] {s : Set V}\n    (hs : Convex ℝ s) : (interior s).Nonempty ↔ affineSpan ℝ s = ⊤ := by\n  rw [← interior_convexHull_nonempty_iff_affineSpan_eq_top, hs.convexHull_eq]\n"}
