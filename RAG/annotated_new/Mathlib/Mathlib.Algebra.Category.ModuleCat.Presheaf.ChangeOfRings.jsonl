{"name":"PresheafOfModules.restrictScalarsObj_obj","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf.ChangeOfRings","initialProofState":"C : Type u'\ninst‚úù : CategoryTheory.Category.{v', u'} C\nR R' : CategoryTheory.Functor (Opposite C) RingCat\nM' : PresheafOfModules R'\nŒ± : Quiver.Hom R R'\nX : Opposite C\n‚ä¢ Eq ((M'.restrictScalarsObj Œ±).obj X) ((ModuleCat.restrictScalars (RingCat.Hom.hom (Œ±.app X))).obj (M'.obj X))","decl":"/-- The restriction of scalars of presheaves of modules, on objects. -/\n@[simps]\nnoncomputable def restrictScalarsObj (M' : PresheafOfModules.{v} R') (Œ± : R ‚ü∂ R') :\n    PresheafOfModules R where\n  obj := fun X ‚Ü¶ (ModuleCat.restrictScalars (Œ±.app X).hom).obj (M'.obj X)\n  -- TODO: after https://github.com/leanprover-community/mathlib4/pull/19511 we need to hint `(X := ...)` and `(Y := ...)`.\n  -- This suggests `restrictScalars` needs to be redesigned.\n  map := fun {X Y} f ‚Ü¶ ModuleCat.ofHom\n      (X := (ModuleCat.restrictScalars (Œ±.app X).hom).obj (M'.obj X))\n      (Y := (ModuleCat.restrictScalars (R.map f).hom).obj\n        ((ModuleCat.restrictScalars (Œ±.app Y).hom).obj (M'.obj Y)))\n    { toFun := M'.map f\n      map_add' := map_add _\n      map_smul' := fun r x ‚Ü¶ (M'.map_smul f (Œ±.app _ r) x).trans (by\n        have eq := RingHom.congr_fun (congrArg RingCat.Hom.hom <| Œ±.naturality f) r\n        dsimp at eq\n        rw [‚Üê eq]\n        rfl ) }\n\n"}
{"name":"PresheafOfModules.restrictScalarsObj_map","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf.ChangeOfRings","initialProofState":"C : Type u'\ninst‚úù : CategoryTheory.Category.{v', u'} C\nR R' : CategoryTheory.Functor (Opposite C) RingCat\nM' : PresheafOfModules R'\nŒ± : Quiver.Hom R R'\nX Y : Opposite C\nf : Quiver.Hom X Y\n‚ä¢ Eq ((M'.restrictScalarsObj Œ±).map f) (ModuleCat.ofHom { toFun := ‚áë(CategoryTheory.ConcreteCategory.hom (M'.map f)), map_add' := ‚ãØ, map_smul' := ‚ãØ })","decl":"/-- The restriction of scalars of presheaves of modules, on objects. -/\n@[simps]\nnoncomputable def restrictScalarsObj (M' : PresheafOfModules.{v} R') (Œ± : R ‚ü∂ R') :\n    PresheafOfModules R where\n  obj := fun X ‚Ü¶ (ModuleCat.restrictScalars (Œ±.app X).hom).obj (M'.obj X)\n  -- TODO: after https://github.com/leanprover-community/mathlib4/pull/19511 we need to hint `(X := ...)` and `(Y := ...)`.\n  -- This suggests `restrictScalars` needs to be redesigned.\n  map := fun {X Y} f ‚Ü¶ ModuleCat.ofHom\n      (X := (ModuleCat.restrictScalars (Œ±.app X).hom).obj (M'.obj X))\n      (Y := (ModuleCat.restrictScalars (R.map f).hom).obj\n        ((ModuleCat.restrictScalars (Œ±.app Y).hom).obj (M'.obj Y)))\n    { toFun := M'.map f\n      map_add' := map_add _\n      map_smul' := fun r x ‚Ü¶ (M'.map_smul f (Œ±.app _ r) x).trans (by\n        have eq := RingHom.congr_fun (congrArg RingCat.Hom.hom <| Œ±.naturality f) r\n        dsimp at eq\n        rw [‚Üê eq]\n        rfl ) }\n\n"}
{"name":"PresheafOfModules.restrictScalars_obj","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf.ChangeOfRings","initialProofState":"C : Type u'\ninst‚úù : CategoryTheory.Category.{v', u'} C\nR R' : CategoryTheory.Functor (Opposite C) RingCat\nŒ± : Quiver.Hom R R'\nM' : PresheafOfModules R'\n‚ä¢ Eq ((PresheafOfModules.restrictScalars Œ±).obj M') (M'.restrictScalarsObj Œ±)","decl":"/-- The restriction of scalars functor `PresheafOfModules R' ‚•§ PresheafOfModules R`\ninduced by a morphism of presheaves of rings `R ‚ü∂ R'`. -/\n@[simps]\nnoncomputable def restrictScalars (Œ± : R ‚ü∂ R') :\n    PresheafOfModules.{v} R' ‚•§ PresheafOfModules.{v} R where\n  obj M' := M'.restrictScalarsObj Œ±\n  map œÜ' :=\n    { app := fun X ‚Ü¶ (ModuleCat.restrictScalars (Œ±.app X).hom).map (Hom.app œÜ' X)\n      naturality := fun {X Y} f ‚Ü¶ by\n        ext x\n        exact naturality_apply œÜ' f x }\n\n"}
{"name":"PresheafOfModules.restrictScalars_map_app","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf.ChangeOfRings","initialProofState":"C : Type u'\ninst‚úù : CategoryTheory.Category.{v', u'} C\nR R' : CategoryTheory.Functor (Opposite C) RingCat\nŒ± : Quiver.Hom R R'\nX‚úù Y‚úù : PresheafOfModules R'\nœÜ' : Quiver.Hom X‚úù Y‚úù\nX : Opposite C\n‚ä¢ Eq (((PresheafOfModules.restrictScalars Œ±).map œÜ').app X) ((ModuleCat.restrictScalars (RingCat.Hom.hom (Œ±.app X))).map (œÜ'.app X))","decl":"/-- The restriction of scalars functor `PresheafOfModules R' ‚•§ PresheafOfModules R`\ninduced by a morphism of presheaves of rings `R ‚ü∂ R'`. -/\n@[simps]\nnoncomputable def restrictScalars (Œ± : R ‚ü∂ R') :\n    PresheafOfModules.{v} R' ‚•§ PresheafOfModules.{v} R where\n  obj M' := M'.restrictScalarsObj Œ±\n  map œÜ' :=\n    { app := fun X ‚Ü¶ (ModuleCat.restrictScalars (Œ±.app X).hom).map (Hom.app œÜ' X)\n      naturality := fun {X Y} f ‚Ü¶ by\n        ext x\n        exact naturality_apply œÜ' f x }\n\n"}
{"name":"PresheafOfModules.instAdditiveRestrictScalars","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf.ChangeOfRings","initialProofState":"C : Type u'\ninst‚úù : CategoryTheory.Category.{v', u'} C\nR R' : CategoryTheory.Functor (Opposite C) RingCat\nŒ± : Quiver.Hom R R'\n‚ä¢ (PresheafOfModules.restrictScalars Œ±).Additive","decl":"instance (Œ± : R ‚ü∂ R') : (restrictScalars.{v} Œ±).Additive where\n\n"}
{"name":"PresheafOfModules.instFullRestrictScalarsIdFunctorOppositeRingCat","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf.ChangeOfRings","initialProofState":"C : Type u'\ninst‚úù : CategoryTheory.Category.{v', u'} C\nR : CategoryTheory.Functor (Opposite C) RingCat\n‚ä¢ (PresheafOfModules.restrictScalars (CategoryTheory.CategoryStruct.id R)).Full","decl":"instance : (restrictScalars (ùüô R)).Full := inferInstanceAs (ùü≠ _).Full\n\n"}
{"name":"PresheafOfModules.instFaithfulRestrictScalars","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf.ChangeOfRings","initialProofState":"C : Type u'\ninst‚úù : CategoryTheory.Category.{v', u'} C\nR R' : CategoryTheory.Functor (Opposite C) RingCat\nŒ± : Quiver.Hom R R'\n‚ä¢ (PresheafOfModules.restrictScalars Œ±).Faithful","decl":"instance (Œ± : R ‚ü∂ R') : (restrictScalars Œ±).Faithful where\n  map_injective h := (toPresheaf R').map_injective ((toPresheaf R).congr_map h)\n\n"}
