{"name":"zero_cpow_eq_nhds","module":"Mathlib.Analysis.SpecialFunctions.Pow.Continuity","initialProofState":"b : Complex\nhb : Ne b 0\n‚ä¢ (nhds b).EventuallyEq (fun x => HPow.hPow 0 x) 0","decl":"theorem zero_cpow_eq_nhds {b : ‚ÑÇ} (hb : b ‚â† 0) : (fun x : ‚ÑÇ => (0 : ‚ÑÇ) ^ x) =·∂†[ùìù b] 0 := by\n  suffices ‚àÄ·∂† x : ‚ÑÇ in ùìù b, x ‚â† 0 from\n    this.mono fun x hx ‚Ü¶ by\n      dsimp only\n      rw [zero_cpow hx, Pi.zero_apply]\n  exact IsOpen.eventually_mem isOpen_ne hb\n\n"}
{"name":"cpow_eq_nhds","module":"Mathlib.Analysis.SpecialFunctions.Pow.Continuity","initialProofState":"a b : Complex\nha : Ne a 0\n‚ä¢ (nhds a).EventuallyEq (fun x => HPow.hPow x b) fun x => Complex.exp (HMul.hMul (Complex.log x) b)","decl":"theorem cpow_eq_nhds {a b : ‚ÑÇ} (ha : a ‚â† 0) :\n    (fun x => x ^ b) =·∂†[ùìù a] fun x => exp (log x * b) := by\n  suffices ‚àÄ·∂† x : ‚ÑÇ in ùìù a, x ‚â† 0 from\n    this.mono fun x hx ‚Ü¶ by\n      dsimp only\n      rw [cpow_def_of_ne_zero hx]\n  exact IsOpen.eventually_mem isOpen_ne ha\n\n"}
{"name":"cpow_eq_nhds'","module":"Mathlib.Analysis.SpecialFunctions.Pow.Continuity","initialProofState":"p : Prod Complex Complex\nhp_fst : Ne p.1 0\n‚ä¢ (nhds p).EventuallyEq (fun x => HPow.hPow x.1 x.2) fun x => Complex.exp (HMul.hMul (Complex.log x.1) x.2)","decl":"theorem cpow_eq_nhds' {p : ‚ÑÇ √ó ‚ÑÇ} (hp_fst : p.fst ‚â† 0) :\n    (fun x => x.1 ^ x.2) =·∂†[ùìù p] fun x => exp (log x.1 * x.2) := by\n  suffices ‚àÄ·∂† x : ‚ÑÇ √ó ‚ÑÇ in ùìù p, x.1 ‚â† 0 from\n    this.mono fun x hx ‚Ü¶ by\n      dsimp only\n      rw [cpow_def_of_ne_zero hx]\n  refine IsOpen.eventually_mem ?_ hp_fst\n  change IsOpen { x : ‚ÑÇ √ó ‚ÑÇ | x.1 = 0 }·∂ú\n  rw [isOpen_compl_iff]\n  exact isClosed_eq continuous_fst continuous_const\n\n-- Continuity of `fun x => a ^ x`: union of these two lemmas is optimal.\n"}
{"name":"continuousAt_const_cpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.Continuity","initialProofState":"a b : Complex\nha : Ne a 0\n‚ä¢ ContinuousAt (fun x => HPow.hPow a x) b","decl":"theorem continuousAt_const_cpow {a b : ‚ÑÇ} (ha : a ‚â† 0) : ContinuousAt (fun x : ‚ÑÇ => a ^ x) b := by\n  have cpow_eq : (fun x : ‚ÑÇ => a ^ x) = fun x => exp (log a * x) := by\n    ext1 b\n    rw [cpow_def_of_ne_zero ha]\n  rw [cpow_eq]\n  exact continuous_exp.continuousAt.comp (ContinuousAt.mul continuousAt_const continuousAt_id)\n\n"}
{"name":"continuousAt_const_cpow'","module":"Mathlib.Analysis.SpecialFunctions.Pow.Continuity","initialProofState":"a b : Complex\nh : Ne b 0\n‚ä¢ ContinuousAt (fun x => HPow.hPow a x) b","decl":"theorem continuousAt_const_cpow' {a b : ‚ÑÇ} (h : b ‚â† 0) : ContinuousAt (fun x : ‚ÑÇ => a ^ x) b := by\n  by_cases ha : a = 0\n  ¬∑ rw [ha, continuousAt_congr (zero_cpow_eq_nhds h)]\n    exact continuousAt_const\n  ¬∑ exact continuousAt_const_cpow ha\n\n"}
{"name":"continuousAt_cpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.Continuity","initialProofState":"p : Prod Complex Complex\nhp_fst : Membership.mem Complex.slitPlane p.1\n‚ä¢ ContinuousAt (fun x => HPow.hPow x.1 x.2) p","decl":"/-- The function `z ^ w` is continuous in `(z, w)` provided that `z` does not belong to the interval\n`(-‚àû, 0]` on the real line. See also `Complex.continuousAt_cpow_zero_of_re_pos` for a version that\nworks for `z = 0` but assumes `0 < re w`. -/\ntheorem continuousAt_cpow {p : ‚ÑÇ √ó ‚ÑÇ} (hp_fst : p.fst ‚àà slitPlane) :\n    ContinuousAt (fun x : ‚ÑÇ √ó ‚ÑÇ => x.1 ^ x.2) p := by\n  rw [continuousAt_congr (cpow_eq_nhds' <| slitPlane_ne_zero hp_fst)]\n  refine continuous_exp.continuousAt.comp ?_\n  exact\n    ContinuousAt.mul\n      (ContinuousAt.comp (continuousAt_clog hp_fst) continuous_fst.continuousAt)\n      continuous_snd.continuousAt\n\n"}
{"name":"continuousAt_cpow_const","module":"Mathlib.Analysis.SpecialFunctions.Pow.Continuity","initialProofState":"a b : Complex\nha : Membership.mem Complex.slitPlane a\n‚ä¢ ContinuousAt (fun x => HPow.hPow x b) a","decl":"theorem continuousAt_cpow_const {a b : ‚ÑÇ} (ha : a ‚àà slitPlane) :\n    ContinuousAt (¬∑ ^ b) a :=\n  Tendsto.comp (@continuousAt_cpow (a, b) ha) (continuousAt_id.prod continuousAt_const)\n\n"}
{"name":"Filter.Tendsto.cpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.Continuity","initialProofState":"Œ± : Type u_1\nl : Filter Œ±\nf g : Œ± ‚Üí Complex\na b : Complex\nhf : Filter.Tendsto f l (nhds a)\nhg : Filter.Tendsto g l (nhds b)\nha : Membership.mem Complex.slitPlane a\n‚ä¢ Filter.Tendsto (fun x => HPow.hPow (f x) (g x)) l (nhds (HPow.hPow a b))","decl":"theorem Filter.Tendsto.cpow {l : Filter Œ±} {f g : Œ± ‚Üí ‚ÑÇ} {a b : ‚ÑÇ} (hf : Tendsto f l (ùìù a))\n    (hg : Tendsto g l (ùìù b)) (ha : a ‚àà slitPlane) :\n    Tendsto (fun x => f x ^ g x) l (ùìù (a ^ b)) :=\n  (@continuousAt_cpow (a, b) ha).tendsto.comp (hf.prod_mk_nhds hg)\n\n"}
{"name":"Filter.Tendsto.const_cpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.Continuity","initialProofState":"Œ± : Type u_1\nl : Filter Œ±\nf : Œ± ‚Üí Complex\na b : Complex\nhf : Filter.Tendsto f l (nhds b)\nh : Or (Ne a 0) (Ne b 0)\n‚ä¢ Filter.Tendsto (fun x => HPow.hPow a (f x)) l (nhds (HPow.hPow a b))","decl":"theorem Filter.Tendsto.const_cpow {l : Filter Œ±} {f : Œ± ‚Üí ‚ÑÇ} {a b : ‚ÑÇ} (hf : Tendsto f l (ùìù b))\n    (h : a ‚â† 0 ‚à® b ‚â† 0) : Tendsto (fun x => a ^ f x) l (ùìù (a ^ b)) := by\n  cases h with\n  | inl h => exact (continuousAt_const_cpow h).tendsto.comp hf\n  | inr h => exact (continuousAt_const_cpow' h).tendsto.comp hf\n\n"}
{"name":"ContinuousWithinAt.cpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.Continuity","initialProofState":"Œ± : Type u_1\ninst‚úù : TopologicalSpace Œ±\nf g : Œ± ‚Üí Complex\ns : Set Œ±\na : Œ±\nhf : ContinuousWithinAt f s a\nhg : ContinuousWithinAt g s a\nh0 : Membership.mem Complex.slitPlane (f a)\n‚ä¢ ContinuousWithinAt (fun x => HPow.hPow (f x) (g x)) s a","decl":"nonrec theorem ContinuousWithinAt.cpow (hf : ContinuousWithinAt f s a)\n    (hg : ContinuousWithinAt g s a) (h0 : f a ‚àà slitPlane) :\n    ContinuousWithinAt (fun x => f x ^ g x) s a :=\n  hf.cpow hg h0\n\n"}
{"name":"ContinuousWithinAt.const_cpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.Continuity","initialProofState":"Œ± : Type u_1\ninst‚úù : TopologicalSpace Œ±\nf : Œ± ‚Üí Complex\ns : Set Œ±\na : Œ±\nb : Complex\nhf : ContinuousWithinAt f s a\nh : Or (Ne b 0) (Ne (f a) 0)\n‚ä¢ ContinuousWithinAt (fun x => HPow.hPow b (f x)) s a","decl":"nonrec theorem ContinuousWithinAt.const_cpow {b : ‚ÑÇ} (hf : ContinuousWithinAt f s a)\n    (h : b ‚â† 0 ‚à® f a ‚â† 0) : ContinuousWithinAt (fun x => b ^ f x) s a :=\n  hf.const_cpow h\n\n"}
{"name":"ContinuousAt.cpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.Continuity","initialProofState":"Œ± : Type u_1\ninst‚úù : TopologicalSpace Œ±\nf g : Œ± ‚Üí Complex\na : Œ±\nhf : ContinuousAt f a\nhg : ContinuousAt g a\nh0 : Membership.mem Complex.slitPlane (f a)\n‚ä¢ ContinuousAt (fun x => HPow.hPow (f x) (g x)) a","decl":"nonrec theorem ContinuousAt.cpow (hf : ContinuousAt f a) (hg : ContinuousAt g a)\n    (h0 : f a ‚àà slitPlane) : ContinuousAt (fun x => f x ^ g x) a :=\n  hf.cpow hg h0\n\n"}
{"name":"ContinuousAt.const_cpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.Continuity","initialProofState":"Œ± : Type u_1\ninst‚úù : TopologicalSpace Œ±\nf : Œ± ‚Üí Complex\na : Œ±\nb : Complex\nhf : ContinuousAt f a\nh : Or (Ne b 0) (Ne (f a) 0)\n‚ä¢ ContinuousAt (fun x => HPow.hPow b (f x)) a","decl":"nonrec theorem ContinuousAt.const_cpow {b : ‚ÑÇ} (hf : ContinuousAt f a) (h : b ‚â† 0 ‚à® f a ‚â† 0) :\n    ContinuousAt (fun x => b ^ f x) a :=\n  hf.const_cpow h\n\n"}
{"name":"ContinuousOn.cpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.Continuity","initialProofState":"Œ± : Type u_1\ninst‚úù : TopologicalSpace Œ±\nf g : Œ± ‚Üí Complex\ns : Set Œ±\nhf : ContinuousOn f s\nhg : ContinuousOn g s\nh0 : ‚àÄ (a : Œ±), Membership.mem s a ‚Üí Membership.mem Complex.slitPlane (f a)\n‚ä¢ ContinuousOn (fun x => HPow.hPow (f x) (g x)) s","decl":"theorem ContinuousOn.cpow (hf : ContinuousOn f s) (hg : ContinuousOn g s)\n    (h0 : ‚àÄ a ‚àà s, f a ‚àà slitPlane) : ContinuousOn (fun x => f x ^ g x) s := fun a ha =>\n  (hf a ha).cpow (hg a ha) (h0 a ha)\n\n"}
{"name":"ContinuousOn.const_cpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.Continuity","initialProofState":"Œ± : Type u_1\ninst‚úù : TopologicalSpace Œ±\nf : Œ± ‚Üí Complex\ns : Set Œ±\nb : Complex\nhf : ContinuousOn f s\nh : Or (Ne b 0) (‚àÄ (a : Œ±), Membership.mem s a ‚Üí Ne (f a) 0)\n‚ä¢ ContinuousOn (fun x => HPow.hPow b (f x)) s","decl":"theorem ContinuousOn.const_cpow {b : ‚ÑÇ} (hf : ContinuousOn f s) (h : b ‚â† 0 ‚à® ‚àÄ a ‚àà s, f a ‚â† 0) :\n    ContinuousOn (fun x => b ^ f x) s := fun a ha => (hf a ha).const_cpow (h.imp id fun h => h a ha)\n\n"}
{"name":"Continuous.cpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.Continuity","initialProofState":"Œ± : Type u_1\ninst‚úù : TopologicalSpace Œ±\nf g : Œ± ‚Üí Complex\nhf : Continuous f\nhg : Continuous g\nh0 : ‚àÄ (a : Œ±), Membership.mem Complex.slitPlane (f a)\n‚ä¢ Continuous fun x => HPow.hPow (f x) (g x)","decl":"theorem Continuous.cpow (hf : Continuous f) (hg : Continuous g)\n    (h0 : ‚àÄ a, f a ‚àà slitPlane) : Continuous fun x => f x ^ g x :=\n  continuous_iff_continuousAt.2 fun a => hf.continuousAt.cpow hg.continuousAt (h0 a)\n\n"}
{"name":"Continuous.const_cpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.Continuity","initialProofState":"Œ± : Type u_1\ninst‚úù : TopologicalSpace Œ±\nf : Œ± ‚Üí Complex\nb : Complex\nhf : Continuous f\nh : Or (Ne b 0) (‚àÄ (a : Œ±), Ne (f a) 0)\n‚ä¢ Continuous fun x => HPow.hPow b (f x)","decl":"theorem Continuous.const_cpow {b : ‚ÑÇ} (hf : Continuous f) (h : b ‚â† 0 ‚à® ‚àÄ a, f a ‚â† 0) :\n    Continuous fun x => b ^ f x :=\n  continuous_iff_continuousAt.2 fun a => hf.continuousAt.const_cpow <| h.imp id fun h => h a\n\n"}
{"name":"ContinuousOn.cpow_const","module":"Mathlib.Analysis.SpecialFunctions.Pow.Continuity","initialProofState":"Œ± : Type u_1\ninst‚úù : TopologicalSpace Œ±\nf : Œ± ‚Üí Complex\ns : Set Œ±\nb : Complex\nhf : ContinuousOn f s\nh : ‚àÄ (a : Œ±), Membership.mem s a ‚Üí Membership.mem Complex.slitPlane (f a)\n‚ä¢ ContinuousOn (fun x => HPow.hPow (f x) b) s","decl":"theorem ContinuousOn.cpow_const {b : ‚ÑÇ} (hf : ContinuousOn f s)\n    (h : ‚àÄ a : Œ±, a ‚àà s ‚Üí f a ‚àà slitPlane) : ContinuousOn (fun x => f x ^ b) s :=\n  hf.cpow continuousOn_const h\n\n"}
{"name":"continuous_const_cpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.Continuity","initialProofState":"z : Complex\ninst‚úù : NeZero z\n‚ä¢ Continuous fun s => HPow.hPow z s","decl":"@[fun_prop]\nlemma continuous_const_cpow (z : ‚ÑÇ) [NeZero z] : Continuous fun s : ‚ÑÇ ‚Ü¶ z ^ s :=\n  continuous_id.const_cpow (.inl <| NeZero.ne z)\n\n"}
{"name":"Real.continuousAt_const_rpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.Continuity","initialProofState":"a b : Real\nh : Ne a 0\n‚ä¢ ContinuousAt (fun x => HPow.hPow a x) b","decl":"theorem continuousAt_const_rpow {a b : ‚Ñù} (h : a ‚â† 0) : ContinuousAt (a ^ ¬∑) b := by\n  simp only [rpow_def]\n  refine Complex.continuous_re.continuousAt.comp ?_\n  refine (continuousAt_const_cpow ?_).comp Complex.continuous_ofReal.continuousAt\n  norm_cast\n\n"}
{"name":"Real.continuousAt_const_rpow'","module":"Mathlib.Analysis.SpecialFunctions.Pow.Continuity","initialProofState":"a b : Real\nh : Ne b 0\n‚ä¢ ContinuousAt (fun x => HPow.hPow a x) b","decl":"theorem continuousAt_const_rpow' {a b : ‚Ñù} (h : b ‚â† 0) : ContinuousAt (a ^ ¬∑) b := by\n  simp only [rpow_def]\n  refine Complex.continuous_re.continuousAt.comp ?_\n  refine (continuousAt_const_cpow' ?_).comp Complex.continuous_ofReal.continuousAt\n  norm_cast\n\n"}
{"name":"Real.rpow_eq_nhds_of_neg","module":"Mathlib.Analysis.SpecialFunctions.Pow.Continuity","initialProofState":"p : Prod Real Real\nhp_fst : LT.lt p.1 0\n‚ä¢ (nhds p).EventuallyEq (fun x => HPow.hPow x.1 x.2) fun x => HMul.hMul (Real.exp (HMul.hMul (Real.log x.1) x.2)) (Real.cos (HMul.hMul x.2 Real.pi))","decl":"theorem rpow_eq_nhds_of_neg {p : ‚Ñù √ó ‚Ñù} (hp_fst : p.fst < 0) :\n    (fun x : ‚Ñù √ó ‚Ñù => x.1 ^ x.2) =·∂†[ùìù p] fun x => exp (log x.1 * x.2) * cos (x.2 * œÄ) := by\n  suffices ‚àÄ·∂† x : ‚Ñù √ó ‚Ñù in ùìù p, x.1 < 0 from\n    this.mono fun x hx ‚Ü¶ by\n      dsimp only\n      rw [rpow_def_of_neg hx]\n  exact IsOpen.eventually_mem (isOpen_lt continuous_fst continuous_const) hp_fst\n\n"}
{"name":"Real.rpow_eq_nhds_of_pos","module":"Mathlib.Analysis.SpecialFunctions.Pow.Continuity","initialProofState":"p : Prod Real Real\nhp_fst : LT.lt 0 p.1\n‚ä¢ (nhds p).EventuallyEq (fun x => HPow.hPow x.1 x.2) fun x => Real.exp (HMul.hMul (Real.log x.1) x.2)","decl":"theorem rpow_eq_nhds_of_pos {p : ‚Ñù √ó ‚Ñù} (hp_fst : 0 < p.fst) :\n    (fun x : ‚Ñù √ó ‚Ñù => x.1 ^ x.2) =·∂†[ùìù p] fun x => exp (log x.1 * x.2) := by\n  suffices ‚àÄ·∂† x : ‚Ñù √ó ‚Ñù in ùìù p, 0 < x.1 from\n    this.mono fun x hx ‚Ü¶ by\n      dsimp only\n      rw [rpow_def_of_pos hx]\n  exact IsOpen.eventually_mem (isOpen_lt continuous_const continuous_fst) hp_fst\n\n"}
{"name":"Real.continuousAt_rpow_of_ne","module":"Mathlib.Analysis.SpecialFunctions.Pow.Continuity","initialProofState":"p : Prod Real Real\nhp : Ne p.1 0\n‚ä¢ ContinuousAt (fun p => HPow.hPow p.1 p.2) p","decl":"theorem continuousAt_rpow_of_ne (p : ‚Ñù √ó ‚Ñù) (hp : p.1 ‚â† 0) :\n    ContinuousAt (fun p : ‚Ñù √ó ‚Ñù => p.1 ^ p.2) p := by\n  rw [ne_iff_lt_or_gt] at hp\n  cases hp with\n  | inl hp =>\n    rw [continuousAt_congr (rpow_eq_nhds_of_neg hp)]\n    refine ContinuousAt.mul ?_ (continuous_cos.continuousAt.comp ?_)\n    ¬∑ refine continuous_exp.continuousAt.comp (ContinuousAt.mul ?_ continuous_snd.continuousAt)\n      refine (continuousAt_log ?_).comp continuous_fst.continuousAt\n      exact hp.ne\n    ¬∑ exact continuous_snd.continuousAt.mul continuousAt_const\n  | inr hp =>\n    rw [continuousAt_congr (rpow_eq_nhds_of_pos hp)]\n    refine continuous_exp.continuousAt.comp (ContinuousAt.mul ?_ continuous_snd.continuousAt)\n    refine (continuousAt_log ?_).comp continuous_fst.continuousAt\n    exact hp.lt.ne.symm\n\n"}
{"name":"Real.continuousAt_rpow_of_pos","module":"Mathlib.Analysis.SpecialFunctions.Pow.Continuity","initialProofState":"p : Prod Real Real\nhp : LT.lt 0 p.2\n‚ä¢ ContinuousAt (fun p => HPow.hPow p.1 p.2) p","decl":"theorem continuousAt_rpow_of_pos (p : ‚Ñù √ó ‚Ñù) (hp : 0 < p.2) :\n    ContinuousAt (fun p : ‚Ñù √ó ‚Ñù => p.1 ^ p.2) p := by\n  cases' p with x y\n  dsimp only at hp\n  obtain hx | rfl := ne_or_eq x 0\n  ¬∑ exact continuousAt_rpow_of_ne (x, y) hx\n  have A : Tendsto (fun p : ‚Ñù √ó ‚Ñù => exp (log p.1 * p.2)) (ùìù[‚â†] 0 √óÀ¢ ùìù y) (ùìù 0) :=\n    tendsto_exp_atBot.comp\n      ((tendsto_log_nhdsWithin_zero.comp tendsto_fst).atBot_mul hp tendsto_snd)\n  have B : Tendsto (fun p : ‚Ñù √ó ‚Ñù => p.1 ^ p.2) (ùìù[‚â†] 0 √óÀ¢ ùìù y) (ùìù 0) :=\n    squeeze_zero_norm (fun p => abs_rpow_le_exp_log_mul p.1 p.2) A\n  have C : Tendsto (fun p : ‚Ñù √ó ‚Ñù => p.1 ^ p.2) (ùìù[{0}] 0 √óÀ¢ ùìù y) (pure 0) := by\n    rw [nhdsWithin_singleton, tendsto_pure, pure_prod, eventually_map]\n    exact (lt_mem_nhds hp).mono fun y hy => zero_rpow hy.ne'\n  simpa only [‚Üê sup_prod, ‚Üê nhdsWithin_union, compl_union_self, nhdsWithin_univ, nhds_prod_eq,\n    ContinuousAt, zero_rpow hp.ne'] using B.sup (C.mono_right (pure_le_nhds _))\n\n"}
{"name":"Real.continuousAt_rpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.Continuity","initialProofState":"p : Prod Real Real\nh : Or (Ne p.1 0) (LT.lt 0 p.2)\n‚ä¢ ContinuousAt (fun p => HPow.hPow p.1 p.2) p","decl":"theorem continuousAt_rpow (p : ‚Ñù √ó ‚Ñù) (h : p.1 ‚â† 0 ‚à® 0 < p.2) :\n    ContinuousAt (fun p : ‚Ñù √ó ‚Ñù => p.1 ^ p.2) p :=\n  h.elim (fun h => continuousAt_rpow_of_ne p h) fun h => continuousAt_rpow_of_pos p h\n\n"}
{"name":"Real.continuousAt_rpow_const","module":"Mathlib.Analysis.SpecialFunctions.Pow.Continuity","initialProofState":"x q : Real\nh : Or (Ne x 0) (LE.le 0 q)\n‚ä¢ ContinuousAt (fun x => HPow.hPow x q) x","decl":"@[fun_prop]\ntheorem continuousAt_rpow_const (x : ‚Ñù) (q : ‚Ñù) (h : x ‚â† 0 ‚à® 0 ‚â§ q) :\n    ContinuousAt (fun x : ‚Ñù => x ^ q) x := by\n¬∑ rw [le_iff_lt_or_eq, ‚Üê or_assoc] at h\n  obtain h|rfl := h\n  ¬∑ exact (continuousAt_rpow (x, q) h).comp‚ÇÇ continuousAt_id continuousAt_const\n  ¬∑ simp_rw [rpow_zero]; exact continuousAt_const\n\n"}
{"name":"Real.continuous_rpow_const","module":"Mathlib.Analysis.SpecialFunctions.Pow.Continuity","initialProofState":"q : Real\nh : LE.le 0 q\n‚ä¢ Continuous fun x => HPow.hPow x q","decl":"@[fun_prop]\ntheorem continuous_rpow_const {q : ‚Ñù} (h : 0 ‚â§ q) : Continuous (fun x : ‚Ñù => x ^ q) :=\n  continuous_iff_continuousAt.mpr fun x ‚Ü¶ continuousAt_rpow_const x q (.inr h)\n"}
{"name":"Filter.Tendsto.rpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.Continuity","initialProofState":"Œ± : Type u_1\nl : Filter Œ±\nf g : Œ± ‚Üí Real\nx y : Real\nhf : Filter.Tendsto f l (nhds x)\nhg : Filter.Tendsto g l (nhds y)\nh : Or (Ne x 0) (LT.lt 0 y)\n‚ä¢ Filter.Tendsto (fun t => HPow.hPow (f t) (g t)) l (nhds (HPow.hPow x y))","decl":"theorem Filter.Tendsto.rpow {l : Filter Œ±} {f g : Œ± ‚Üí ‚Ñù} {x y : ‚Ñù} (hf : Tendsto f l (ùìù x))\n    (hg : Tendsto g l (ùìù y)) (h : x ‚â† 0 ‚à® 0 < y) : Tendsto (fun t => f t ^ g t) l (ùìù (x ^ y)) :=\n  (Real.continuousAt_rpow (x, y) h).tendsto.comp (hf.prod_mk_nhds hg)\n\n"}
{"name":"Filter.Tendsto.rpow_const","module":"Mathlib.Analysis.SpecialFunctions.Pow.Continuity","initialProofState":"Œ± : Type u_1\nl : Filter Œ±\nf : Œ± ‚Üí Real\nx p : Real\nhf : Filter.Tendsto f l (nhds x)\nh : Or (Ne x 0) (LE.le 0 p)\n‚ä¢ Filter.Tendsto (fun a => HPow.hPow (f a) p) l (nhds (HPow.hPow x p))","decl":"theorem Filter.Tendsto.rpow_const {l : Filter Œ±} {f : Œ± ‚Üí ‚Ñù} {x p : ‚Ñù} (hf : Tendsto f l (ùìù x))\n    (h : x ‚â† 0 ‚à® 0 ‚â§ p) : Tendsto (fun a => f a ^ p) l (ùìù (x ^ p)) :=\n  if h0 : 0 = p then h0 ‚ñ∏ by simp [tendsto_const_nhds]\n  else hf.rpow tendsto_const_nhds (h.imp id fun h' => h'.lt_of_ne h0)\n\n"}
{"name":"ContinuousAt.rpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.Continuity","initialProofState":"Œ± : Type u_1\ninst‚úù : TopologicalSpace Œ±\nf g : Œ± ‚Üí Real\nx : Œ±\nhf : ContinuousAt f x\nhg : ContinuousAt g x\nh : Or (Ne (f x) 0) (LT.lt 0 (g x))\n‚ä¢ ContinuousAt (fun t => HPow.hPow (f t) (g t)) x","decl":"nonrec theorem ContinuousAt.rpow (hf : ContinuousAt f x) (hg : ContinuousAt g x)\n    (h : f x ‚â† 0 ‚à® 0 < g x) : ContinuousAt (fun t => f t ^ g t) x :=\n  hf.rpow hg h\n\n"}
{"name":"ContinuousWithinAt.rpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.Continuity","initialProofState":"Œ± : Type u_1\ninst‚úù : TopologicalSpace Œ±\nf g : Œ± ‚Üí Real\ns : Set Œ±\nx : Œ±\nhf : ContinuousWithinAt f s x\nhg : ContinuousWithinAt g s x\nh : Or (Ne (f x) 0) (LT.lt 0 (g x))\n‚ä¢ ContinuousWithinAt (fun t => HPow.hPow (f t) (g t)) s x","decl":"nonrec theorem ContinuousWithinAt.rpow (hf : ContinuousWithinAt f s x)\n    (hg : ContinuousWithinAt g s x) (h : f x ‚â† 0 ‚à® 0 < g x) :\n    ContinuousWithinAt (fun t => f t ^ g t) s x :=\n  hf.rpow hg h\n\n"}
{"name":"ContinuousOn.rpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.Continuity","initialProofState":"Œ± : Type u_1\ninst‚úù : TopologicalSpace Œ±\nf g : Œ± ‚Üí Real\ns : Set Œ±\nhf : ContinuousOn f s\nhg : ContinuousOn g s\nh : ‚àÄ (x : Œ±), Membership.mem s x ‚Üí Or (Ne (f x) 0) (LT.lt 0 (g x))\n‚ä¢ ContinuousOn (fun t => HPow.hPow (f t) (g t)) s","decl":"theorem ContinuousOn.rpow (hf : ContinuousOn f s) (hg : ContinuousOn g s)\n    (h : ‚àÄ x ‚àà s, f x ‚â† 0 ‚à® 0 < g x) : ContinuousOn (fun t => f t ^ g t) s := fun t ht =>\n  (hf t ht).rpow (hg t ht) (h t ht)\n\n"}
{"name":"Continuous.rpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.Continuity","initialProofState":"Œ± : Type u_1\ninst‚úù : TopologicalSpace Œ±\nf g : Œ± ‚Üí Real\nhf : Continuous f\nhg : Continuous g\nh : ‚àÄ (x : Œ±), Or (Ne (f x) 0) (LT.lt 0 (g x))\n‚ä¢ Continuous fun x => HPow.hPow (f x) (g x)","decl":"theorem Continuous.rpow (hf : Continuous f) (hg : Continuous g) (h : ‚àÄ x, f x ‚â† 0 ‚à® 0 < g x) :\n    Continuous fun x => f x ^ g x :=\n  continuous_iff_continuousAt.2 fun x => hf.continuousAt.rpow hg.continuousAt (h x)\n\n"}
{"name":"ContinuousWithinAt.rpow_const","module":"Mathlib.Analysis.SpecialFunctions.Pow.Continuity","initialProofState":"Œ± : Type u_1\ninst‚úù : TopologicalSpace Œ±\nf : Œ± ‚Üí Real\ns : Set Œ±\nx : Œ±\np : Real\nhf : ContinuousWithinAt f s x\nh : Or (Ne (f x) 0) (LE.le 0 p)\n‚ä¢ ContinuousWithinAt (fun x => HPow.hPow (f x) p) s x","decl":"nonrec theorem ContinuousWithinAt.rpow_const (hf : ContinuousWithinAt f s x) (h : f x ‚â† 0 ‚à® 0 ‚â§ p) :\n    ContinuousWithinAt (fun x => f x ^ p) s x :=\n  hf.rpow_const h\n\n"}
{"name":"ContinuousAt.rpow_const","module":"Mathlib.Analysis.SpecialFunctions.Pow.Continuity","initialProofState":"Œ± : Type u_1\ninst‚úù : TopologicalSpace Œ±\nf : Œ± ‚Üí Real\nx : Œ±\np : Real\nhf : ContinuousAt f x\nh : Or (Ne (f x) 0) (LE.le 0 p)\n‚ä¢ ContinuousAt (fun x => HPow.hPow (f x) p) x","decl":"nonrec theorem ContinuousAt.rpow_const (hf : ContinuousAt f x) (h : f x ‚â† 0 ‚à® 0 ‚â§ p) :\n    ContinuousAt (fun x => f x ^ p) x :=\n  hf.rpow_const h\n\n"}
{"name":"ContinuousOn.rpow_const","module":"Mathlib.Analysis.SpecialFunctions.Pow.Continuity","initialProofState":"Œ± : Type u_1\ninst‚úù : TopologicalSpace Œ±\nf : Œ± ‚Üí Real\ns : Set Œ±\np : Real\nhf : ContinuousOn f s\nh : ‚àÄ (x : Œ±), Membership.mem s x ‚Üí Or (Ne (f x) 0) (LE.le 0 p)\n‚ä¢ ContinuousOn (fun x => HPow.hPow (f x) p) s","decl":"theorem ContinuousOn.rpow_const (hf : ContinuousOn f s) (h : ‚àÄ x ‚àà s, f x ‚â† 0 ‚à® 0 ‚â§ p) :\n    ContinuousOn (fun x => f x ^ p) s := fun x hx => (hf x hx).rpow_const (h x hx)\n\n"}
{"name":"Continuous.rpow_const","module":"Mathlib.Analysis.SpecialFunctions.Pow.Continuity","initialProofState":"Œ± : Type u_1\ninst‚úù : TopologicalSpace Œ±\nf : Œ± ‚Üí Real\np : Real\nhf : Continuous f\nh : ‚àÄ (x : Œ±), Or (Ne (f x) 0) (LE.le 0 p)\n‚ä¢ Continuous fun x => HPow.hPow (f x) p","decl":"theorem Continuous.rpow_const (hf : Continuous f) (h : ‚àÄ x, f x ‚â† 0 ‚à® 0 ‚â§ p) :\n    Continuous fun x => f x ^ p :=\n  continuous_iff_continuousAt.2 fun x => hf.continuousAt.rpow_const (h x)\n\n"}
{"name":"Complex.continuousAt_cpow_zero_of_re_pos","module":"Mathlib.Analysis.SpecialFunctions.Pow.Continuity","initialProofState":"z : Complex\nhz : LT.lt 0 z.re\n‚ä¢ ContinuousAt (fun x => HPow.hPow x.1 x.2) { fst := 0, snd := z }","decl":"/-- See also `continuousAt_cpow` and `Complex.continuousAt_cpow_of_re_pos`. -/\ntheorem continuousAt_cpow_zero_of_re_pos {z : ‚ÑÇ} (hz : 0 < z.re) :\n    ContinuousAt (fun x : ‚ÑÇ √ó ‚ÑÇ => x.1 ^ x.2) (0, z) := by\n  have hz‚ÇÄ : z ‚â† 0 := ne_of_apply_ne re hz.ne'\n  rw [ContinuousAt, zero_cpow hz‚ÇÄ, tendsto_zero_iff_norm_tendsto_zero]\n  refine squeeze_zero (fun _ => norm_nonneg _) (fun _ => abs_cpow_le _ _) ?_\n  simp only [div_eq_mul_inv, ‚Üê Real.exp_neg]\n  refine Tendsto.zero_mul_isBoundedUnder_le ?_ ?_\n  ¬∑ convert\n        (continuous_fst.norm.tendsto ((0 : ‚ÑÇ), z)).rpow\n          ((continuous_re.comp continuous_snd).tendsto _) _ <;>\n      simp [hz, Real.zero_rpow hz.ne']\n  ¬∑ simp only [Function.comp_def, Real.norm_eq_abs, abs_of_pos (Real.exp_pos _)]\n    rcases exists_gt |im z| with ‚ü®C, hC‚ü©\n    refine ‚ü®Real.exp (œÄ * C), eventually_map.2 ?_‚ü©\n    refine\n      (((continuous_im.comp continuous_snd).abs.tendsto (_, z)).eventually (gt_mem_nhds hC)).mono\n        fun z hz => Real.exp_le_exp.2 <| (neg_le_abs _).trans ?_\n    rw [_root_.abs_mul]\n    exact\n      mul_le_mul (abs_le.2 ‚ü®(neg_pi_lt_arg _).le, arg_le_pi _‚ü©) hz.le (_root_.abs_nonneg _)\n        Real.pi_pos.le\n\n"}
{"name":"Complex.continuousAt_cpow_of_re_pos","module":"Mathlib.Analysis.SpecialFunctions.Pow.Continuity","initialProofState":"p : Prod Complex Complex\nh‚ÇÅ : Or (LE.le 0 p.1.re) (Ne p.1.im 0)\nh‚ÇÇ : LT.lt 0 p.2.re\n‚ä¢ ContinuousAt (fun x => HPow.hPow x.1 x.2) p","decl":"open ComplexOrder in\n/-- See also `continuousAt_cpow` for a version that assumes `p.1 ‚â† 0` but makes no\nassumptions about `p.2`. -/\ntheorem continuousAt_cpow_of_re_pos {p : ‚ÑÇ √ó ‚ÑÇ} (h‚ÇÅ : 0 ‚â§ p.1.re ‚à® p.1.im ‚â† 0) (h‚ÇÇ : 0 < p.2.re) :\n    ContinuousAt (fun x : ‚ÑÇ √ó ‚ÑÇ => x.1 ^ x.2) p := by\n  cases' p with z w\n  rw [‚Üê not_lt_zero_iff, lt_iff_le_and_ne, not_and_or, Ne, Classical.not_not,\n    not_le_zero_iff] at h‚ÇÅ\n  rcases h‚ÇÅ with (h‚ÇÅ | (rfl : z = 0))\n  exacts [continuousAt_cpow h‚ÇÅ, continuousAt_cpow_zero_of_re_pos h‚ÇÇ]\n\n"}
{"name":"Complex.continuousAt_cpow_const_of_re_pos","module":"Mathlib.Analysis.SpecialFunctions.Pow.Continuity","initialProofState":"z w : Complex\nhz : Or (LE.le 0 z.re) (Ne z.im 0)\nhw : LT.lt 0 w.re\n‚ä¢ ContinuousAt (fun x => HPow.hPow x w) z","decl":"/-- See also `continuousAt_cpow_const` for a version that assumes `z ‚â† 0` but makes no\nassumptions about `w`. -/\ntheorem continuousAt_cpow_const_of_re_pos {z w : ‚ÑÇ} (hz : 0 ‚â§ re z ‚à® im z ‚â† 0) (hw : 0 < re w) :\n    ContinuousAt (fun x => x ^ w) z :=\n  Tendsto.comp (@continuousAt_cpow_of_re_pos (z, w) hz hw) (continuousAt_id.prod continuousAt_const)\n\n"}
{"name":"Complex.continuousAt_ofReal_cpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.Continuity","initialProofState":"x : Real\ny : Complex\nh : Or (LT.lt 0 y.re) (Ne x 0)\n‚ä¢ ContinuousAt (fun p => HPow.hPow (‚Üëp.1) p.2) { fst := x, snd := y }","decl":"/-- Continuity of `(x, y) ‚Ü¶ x ^ y` as a function on `‚Ñù √ó ‚ÑÇ`. -/\ntheorem continuousAt_ofReal_cpow (x : ‚Ñù) (y : ‚ÑÇ) (h : 0 < y.re ‚à® x ‚â† 0) :\n    ContinuousAt (fun p => (p.1 : ‚ÑÇ) ^ p.2 : ‚Ñù √ó ‚ÑÇ ‚Üí ‚ÑÇ) (x, y) := by\n  rcases lt_trichotomy (0 : ‚Ñù) x with (hx | rfl | hx)\n  ¬∑ -- x > 0 : easy case\n    have : ContinuousAt (fun p => ‚ü®‚Üëp.1, p.2‚ü© : ‚Ñù √ó ‚ÑÇ ‚Üí ‚ÑÇ √ó ‚ÑÇ) (x, y) := by fun_prop\n    refine (continuousAt_cpow (Or.inl ?_)).comp this\n    rwa [ofReal_re]\n  ¬∑ -- x = 0 : reduce to continuousAt_cpow_zero_of_re_pos\n    have A : ContinuousAt (fun p => p.1 ^ p.2 : ‚ÑÇ √ó ‚ÑÇ ‚Üí ‚ÑÇ) ‚ü®‚Üë(0 : ‚Ñù), y‚ü© := by\n      rw [ofReal_zero]\n      apply continuousAt_cpow_zero_of_re_pos\n      tauto\n    have B : ContinuousAt (fun p => ‚ü®‚Üëp.1, p.2‚ü© : ‚Ñù √ó ‚ÑÇ ‚Üí ‚ÑÇ √ó ‚ÑÇ) ‚ü®0, y‚ü© := by fun_prop\n    exact A.comp_of_eq B rfl\n  ¬∑ -- x < 0 : difficult case\n    suffices ContinuousAt (fun p => (-(p.1 : ‚ÑÇ)) ^ p.2 * exp (œÄ * I * p.2) : ‚Ñù √ó ‚ÑÇ ‚Üí ‚ÑÇ) (x, y) by\n      refine this.congr (eventually_of_mem (prod_mem_nhds (Iio_mem_nhds hx) univ_mem) ?_)\n      exact fun p hp => (ofReal_cpow_of_nonpos (le_of_lt hp.1) p.2).symm\n    have A : ContinuousAt (fun p => ‚ü®-‚Üëp.1, p.2‚ü© : ‚Ñù √ó ‚ÑÇ ‚Üí ‚ÑÇ √ó ‚ÑÇ) (x, y) := by fun_prop\n    apply ContinuousAt.mul\n    ¬∑ refine (continuousAt_cpow (Or.inl ?_)).comp A\n      rwa [neg_re, ofReal_re, neg_pos]\n    ¬∑ exact (continuous_exp.comp (continuous_const.mul continuous_snd)).continuousAt\n\n"}
{"name":"Complex.continuousAt_ofReal_cpow_const","module":"Mathlib.Analysis.SpecialFunctions.Pow.Continuity","initialProofState":"x : Real\ny : Complex\nh : Or (LT.lt 0 y.re) (Ne x 0)\n‚ä¢ ContinuousAt (fun a => HPow.hPow (‚Üëa) y) x","decl":"theorem continuousAt_ofReal_cpow_const (x : ‚Ñù) (y : ‚ÑÇ) (h : 0 < y.re ‚à® x ‚â† 0) :\n    ContinuousAt (fun a => (a : ‚ÑÇ) ^ y : ‚Ñù ‚Üí ‚ÑÇ) x := by\n  exact ContinuousAt.comp (x := x) (continuousAt_ofReal_cpow x y h)\n          ((continuous_id (X := ‚Ñù)).prod_mk (continuous_const (y := y))).continuousAt\n\n"}
{"name":"Complex.continuous_ofReal_cpow_const","module":"Mathlib.Analysis.SpecialFunctions.Pow.Continuity","initialProofState":"y : Complex\nhs : LT.lt 0 y.re\n‚ä¢ Continuous fun x => HPow.hPow (‚Üëx) y","decl":"theorem continuous_ofReal_cpow_const {y : ‚ÑÇ} (hs : 0 < y.re) :\n    Continuous (fun x => (x : ‚ÑÇ) ^ y : ‚Ñù ‚Üí ‚ÑÇ) :=\n  continuous_iff_continuousAt.mpr fun x => continuousAt_ofReal_cpow_const x y (Or.inl hs)\n\n"}
{"name":"NNReal.continuousAt_rpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.Continuity","initialProofState":"x : NNReal\ny : Real\nh : Or (Ne x 0) (LT.lt 0 y)\n‚ä¢ ContinuousAt (fun p => HPow.hPow p.1 p.2) { fst := x, snd := y }","decl":"theorem continuousAt_rpow {x : ‚Ñù‚â•0} {y : ‚Ñù} (h : x ‚â† 0 ‚à® 0 < y) :\n    ContinuousAt (fun p : ‚Ñù‚â•0 √ó ‚Ñù => p.1 ^ p.2) (x, y) := by\n  have :\n    (fun p : ‚Ñù‚â•0 √ó ‚Ñù => p.1 ^ p.2) =\n      Real.toNNReal ‚àò (fun p : ‚Ñù √ó ‚Ñù => p.1 ^ p.2) ‚àò fun p : ‚Ñù‚â•0 √ó ‚Ñù => (p.1.1, p.2) := by\n    ext p\n    erw [coe_rpow, Real.coe_toNNReal _ (Real.rpow_nonneg p.1.2 _)]\n    rfl\n  rw [this]\n  refine continuous_real_toNNReal.continuousAt.comp (ContinuousAt.comp ?_ ?_)\n  ¬∑ apply Real.continuousAt_rpow\n    simpa using h\n  ¬∑ exact ((continuous_subtype_val.comp continuous_fst).prod_mk continuous_snd).continuousAt\n\n"}
{"name":"NNReal.eventually_pow_one_div_le","module":"Mathlib.Analysis.SpecialFunctions.Pow.Continuity","initialProofState":"x y : NNReal\nhy : LT.lt 1 y\n‚ä¢ Filter.Eventually (fun n => LE.le (HPow.hPow x (HDiv.hDiv 1 ‚Üën)) y) Filter.atTop","decl":"theorem eventually_pow_one_div_le (x : ‚Ñù‚â•0) {y : ‚Ñù‚â•0} (hy : 1 < y) :\n    ‚àÄ·∂† n : ‚Ñï in atTop, x ^ (1 / n : ‚Ñù) ‚â§ y := by\n  obtain ‚ü®m, hm‚ü© := add_one_pow_unbounded_of_pos x (tsub_pos_of_lt hy)\n  rw [tsub_add_cancel_of_le hy.le] at hm\n  refine eventually_atTop.2 ‚ü®m + 1, fun n hn => ?_‚ü©\n  simp only [one_div]\n  simpa only [NNReal.rpow_inv_le_iff (Nat.cast_pos.2 <| m.succ_pos.trans_le hn),\n    NNReal.rpow_natCast] using hm.le.trans (pow_right_mono‚ÇÄ hy.le (m.le_succ.trans hn))\n\n"}
{"name":"Filter.Tendsto.nnrpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.Continuity","initialProofState":"Œ± : Type u_1\nf : Filter Œ±\nu : Œ± ‚Üí NNReal\nv : Œ± ‚Üí Real\nx : NNReal\ny : Real\nhx : Filter.Tendsto u f (nhds x)\nhy : Filter.Tendsto v f (nhds y)\nh : Or (Ne x 0) (LT.lt 0 y)\n‚ä¢ Filter.Tendsto (fun a => HPow.hPow (u a) (v a)) f (nhds (HPow.hPow x y))","decl":"theorem Filter.Tendsto.nnrpow {Œ± : Type*} {f : Filter Œ±} {u : Œ± ‚Üí ‚Ñù‚â•0} {v : Œ± ‚Üí ‚Ñù} {x : ‚Ñù‚â•0}\n    {y : ‚Ñù} (hx : Tendsto u f (ùìù x)) (hy : Tendsto v f (ùìù y)) (h : x ‚â† 0 ‚à® 0 < y) :\n    Tendsto (fun a => u a ^ v a) f (ùìù (x ^ y)) :=\n  Tendsto.comp (NNReal.continuousAt_rpow h) (hx.prod_mk_nhds hy)\n\n"}
{"name":"NNReal.continuousAt_rpow_const","module":"Mathlib.Analysis.SpecialFunctions.Pow.Continuity","initialProofState":"x : NNReal\ny : Real\nh : Or (Ne x 0) (LE.le 0 y)\n‚ä¢ ContinuousAt (fun z => HPow.hPow z y) x","decl":"theorem continuousAt_rpow_const {x : ‚Ñù‚â•0} {y : ‚Ñù} (h : x ‚â† 0 ‚à® 0 ‚â§ y) :\n    ContinuousAt (fun z => z ^ y) x :=\n  h.elim (fun h => tendsto_id.nnrpow tendsto_const_nhds (Or.inl h)) fun h =>\n    h.eq_or_lt.elim (fun h => h ‚ñ∏ by simp only [rpow_zero, continuousAt_const]) fun h =>\n      tendsto_id.nnrpow tendsto_const_nhds (Or.inr h)\n\n"}
{"name":"NNReal.continuous_rpow_const","module":"Mathlib.Analysis.SpecialFunctions.Pow.Continuity","initialProofState":"y : Real\nh : LE.le 0 y\n‚ä¢ Continuous fun x => HPow.hPow x y","decl":"@[fun_prop]\ntheorem continuous_rpow_const {y : ‚Ñù} (h : 0 ‚â§ y) : Continuous fun x : ‚Ñù‚â•0 => x ^ y :=\n  continuous_iff_continuousAt.2 fun _ => continuousAt_rpow_const (Or.inr h)\n\n"}
{"name":"NNReal.continuousOn_rpow_const_compl_zero","module":"Mathlib.Analysis.SpecialFunctions.Pow.Continuity","initialProofState":"r : Real\n‚ä¢ ContinuousOn (fun z => HPow.hPow z r) (HasCompl.compl (Singleton.singleton 0))","decl":"@[fun_prop]\ntheorem continuousOn_rpow_const_compl_zero {r : ‚Ñù} :\n    ContinuousOn (fun z : ‚Ñù‚â•0 => z ^ r) {0}·∂ú :=\n  fun _ h => ContinuousAt.continuousWithinAt <| NNReal.continuousAt_rpow_const (.inl h)\n\n-- even though this follows from `ContinuousOn.mono` and the previous lemma, we include it for\n-- automation purposes with `fun_prop`, because the side goal `0 ‚àâ s ‚à® 0 ‚â§ r` is often easy to check\n"}
{"name":"NNReal.continuousOn_rpow_const","module":"Mathlib.Analysis.SpecialFunctions.Pow.Continuity","initialProofState":"r : Real\ns : Set NNReal\nh : Or (Not (Membership.mem s 0)) (LE.le 0 r)\n‚ä¢ ContinuousOn (fun z => HPow.hPow z r) s","decl":"@[fun_prop]\ntheorem continuousOn_rpow_const {r : ‚Ñù} {s : Set ‚Ñù‚â•0}\n    (h : 0 ‚àâ s ‚à® 0 ‚â§ r) : ContinuousOn (fun z : ‚Ñù‚â•0 => z ^ r) s :=\n  h.elim (fun _ ‚Ü¶ ContinuousOn.mono (s := {0}·∂ú) (by fun_prop) (by aesop))\n    (NNReal.continuous_rpow_const ¬∑ |>.continuousOn)\n\n"}
{"name":"ENNReal.eventually_pow_one_div_le","module":"Mathlib.Analysis.SpecialFunctions.Pow.Continuity","initialProofState":"x : ENNReal\nhx : Ne x Top.top\ny : ENNReal\nhy : LT.lt 1 y\n‚ä¢ Filter.Eventually (fun n => LE.le (HPow.hPow x (HDiv.hDiv 1 ‚Üën)) y) Filter.atTop","decl":"theorem eventually_pow_one_div_le {x : ‚Ñù‚â•0‚àû} (hx : x ‚â† ‚àû) {y : ‚Ñù‚â•0‚àû} (hy : 1 < y) :\n    ‚àÄ·∂† n : ‚Ñï in atTop, x ^ (1 / n : ‚Ñù) ‚â§ y := by\n  lift x to ‚Ñù‚â•0 using hx\n  by_cases h : y = ‚àû\n  ¬∑ exact Eventually.of_forall fun n => h.symm ‚ñ∏ le_top\n  ¬∑ lift y to ‚Ñù‚â•0 using h\n    have := NNReal.eventually_pow_one_div_le x (mod_cast hy : 1 < y)\n    refine this.congr (Eventually.of_forall fun n => ?_)\n    rw [‚Üê coe_rpow_of_nonneg x (by positivity : 0 ‚â§ (1 / n : ‚Ñù)), coe_le_coe]\n\n"}
{"name":"ENNReal.continuous_rpow_const","module":"Mathlib.Analysis.SpecialFunctions.Pow.Continuity","initialProofState":"y : Real\n‚ä¢ Continuous fun a => HPow.hPow a y","decl":"@[continuity, fun_prop]\ntheorem continuous_rpow_const {y : ‚Ñù} : Continuous fun a : ‚Ñù‚â•0‚àû => a ^ y := by\n  refine continuous_iff_continuousAt.2 fun x => ?_\n  rcases lt_trichotomy (0 : ‚Ñù) y with (hy | rfl | hy)\n  ¬∑ exact continuousAt_rpow_const_of_pos hy\n  ¬∑ simp only [rpow_zero]\n    exact continuousAt_const\n  ¬∑ obtain ‚ü®z, hz‚ü© : ‚àÉ z, y = -z := ‚ü®-y, (neg_neg _).symm‚ü©\n    have z_pos : 0 < z := by simpa [hz] using hy\n    simp_rw [hz, rpow_neg]\n    exact continuous_inv.continuousAt.comp (continuousAt_rpow_const_of_pos z_pos)\n\n"}
{"name":"ENNReal.tendsto_const_mul_rpow_nhds_zero_of_pos","module":"Mathlib.Analysis.SpecialFunctions.Pow.Continuity","initialProofState":"c : ENNReal\nhc : Ne c Top.top\ny : Real\nhy : LT.lt 0 y\n‚ä¢ Filter.Tendsto (fun x => HMul.hMul c (HPow.hPow x y)) (nhds 0) (nhds 0)","decl":"theorem tendsto_const_mul_rpow_nhds_zero_of_pos {c : ‚Ñù‚â•0‚àû} (hc : c ‚â† ‚àû) {y : ‚Ñù} (hy : 0 < y) :\n    Tendsto (fun x : ‚Ñù‚â•0‚àû => c * x ^ y) (ùìù 0) (ùìù 0) := by\n  convert ENNReal.Tendsto.const_mul (ENNReal.continuous_rpow_const.tendsto 0) _\n  ¬∑ simp [hy]\n  ¬∑ exact Or.inr hc\n\n"}
{"name":"Filter.Tendsto.ennrpow_const","module":"Mathlib.Analysis.SpecialFunctions.Pow.Continuity","initialProofState":"Œ± : Type u_1\nf : Filter Œ±\nm : Œ± ‚Üí ENNReal\na : ENNReal\nr : Real\nhm : Filter.Tendsto m f (nhds a)\n‚ä¢ Filter.Tendsto (fun x => HPow.hPow (m x) r) f (nhds (HPow.hPow a r))","decl":"theorem Filter.Tendsto.ennrpow_const {Œ± : Type*} {f : Filter Œ±} {m : Œ± ‚Üí ‚Ñù‚â•0‚àû} {a : ‚Ñù‚â•0‚àû} (r : ‚Ñù)\n    (hm : Tendsto m f (ùìù a)) : Tendsto (fun x => m x ^ r) f (ùìù (a ^ r)) :=\n  (ENNReal.continuous_rpow_const.tendsto a).comp hm\n"}
