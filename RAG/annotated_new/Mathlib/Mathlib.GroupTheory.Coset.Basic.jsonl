{"name":"mem_leftAddCoset","module":"Mathlib.GroupTheory.Coset.Basic","initialProofState":"α : Type u_1\ninst✝ : Add α\ns : Set α\nx a : α\nhxS : Membership.mem s x\n⊢ Membership.mem (HVAdd.hVAdd a s) (HAdd.hAdd a x)","decl":"@[to_additive mem_leftAddCoset]\ntheorem mem_leftCoset {s : Set α} {x : α} (a : α) (hxS : x ∈ s) : a * x ∈ a • s :=\n  mem_image_of_mem (fun b : α => a * b) hxS\n\n"}
{"name":"mem_leftCoset","module":"Mathlib.GroupTheory.Coset.Basic","initialProofState":"α : Type u_1\ninst✝ : Mul α\ns : Set α\nx a : α\nhxS : Membership.mem s x\n⊢ Membership.mem (HSMul.hSMul a s) (HMul.hMul a x)","decl":"@[to_additive mem_leftAddCoset]\ntheorem mem_leftCoset {s : Set α} {x : α} (a : α) (hxS : x ∈ s) : a * x ∈ a • s :=\n  mem_image_of_mem (fun b : α => a * b) hxS\n\n"}
{"name":"mem_rightAddCoset","module":"Mathlib.GroupTheory.Coset.Basic","initialProofState":"α : Type u_1\ninst✝ : Add α\ns : Set α\nx a : α\nhxS : Membership.mem s x\n⊢ Membership.mem (HVAdd.hVAdd (AddOpposite.op a) s) (HAdd.hAdd x a)","decl":"@[to_additive mem_rightAddCoset]\ntheorem mem_rightCoset {s : Set α} {x : α} (a : α) (hxS : x ∈ s) : x * a ∈ op a • s :=\n  mem_image_of_mem (fun b : α => b * a) hxS\n\n"}
{"name":"mem_rightCoset","module":"Mathlib.GroupTheory.Coset.Basic","initialProofState":"α : Type u_1\ninst✝ : Mul α\ns : Set α\nx a : α\nhxS : Membership.mem s x\n⊢ Membership.mem (HSMul.hSMul (MulOpposite.op a) s) (HMul.hMul x a)","decl":"@[to_additive mem_rightAddCoset]\ntheorem mem_rightCoset {s : Set α} {x : α} (a : α) (hxS : x ∈ s) : x * a ∈ op a • s :=\n  mem_image_of_mem (fun b : α => b * a) hxS\n\n"}
{"name":"leftAddCosetEquivalence_rel","module":"Mathlib.GroupTheory.Coset.Basic","initialProofState":"α : Type u_1\ninst✝ : Add α\ns : Set α\n⊢ Equivalence (LeftAddCosetEquivalence s)","decl":"@[to_additive leftAddCosetEquivalence_rel]\ntheorem leftCosetEquivalence_rel (s : Set α) : Equivalence (LeftCosetEquivalence s) :=\n  @Equivalence.mk _ (LeftCosetEquivalence s) (fun _ => rfl) Eq.symm Eq.trans\n\n"}
{"name":"leftCosetEquivalence_rel","module":"Mathlib.GroupTheory.Coset.Basic","initialProofState":"α : Type u_1\ninst✝ : Mul α\ns : Set α\n⊢ Equivalence (LeftCosetEquivalence s)","decl":"@[to_additive leftAddCosetEquivalence_rel]\ntheorem leftCosetEquivalence_rel (s : Set α) : Equivalence (LeftCosetEquivalence s) :=\n  @Equivalence.mk _ (LeftCosetEquivalence s) (fun _ => rfl) Eq.symm Eq.trans\n\n"}
{"name":"rightAddCosetEquivalence_rel","module":"Mathlib.GroupTheory.Coset.Basic","initialProofState":"α : Type u_1\ninst✝ : Add α\ns : Set α\n⊢ Equivalence (RightAddCosetEquivalence s)","decl":"@[to_additive rightAddCosetEquivalence_rel]\ntheorem rightCosetEquivalence_rel (s : Set α) : Equivalence (RightCosetEquivalence s) :=\n  @Equivalence.mk _ (RightCosetEquivalence s) (fun _a => rfl) Eq.symm Eq.trans\n\n"}
{"name":"rightCosetEquivalence_rel","module":"Mathlib.GroupTheory.Coset.Basic","initialProofState":"α : Type u_1\ninst✝ : Mul α\ns : Set α\n⊢ Equivalence (RightCosetEquivalence s)","decl":"@[to_additive rightAddCosetEquivalence_rel]\ntheorem rightCosetEquivalence_rel (s : Set α) : Equivalence (RightCosetEquivalence s) :=\n  @Equivalence.mk _ (RightCosetEquivalence s) (fun _a => rfl) Eq.symm Eq.trans\n\n"}
{"name":"leftCoset_assoc","module":"Mathlib.GroupTheory.Coset.Basic","initialProofState":"α : Type u_1\ninst✝ : Semigroup α\ns : Set α\na b : α\n⊢ Eq (HSMul.hSMul a (HSMul.hSMul b s)) (HSMul.hSMul (HMul.hMul a b) s)","decl":"@[to_additive leftAddCoset_assoc]\ntheorem leftCoset_assoc (s : Set α) (a b : α) : a • (b • s) = (a * b) • s := by\n  simp [← image_smul, (image_comp _ _ _).symm, Function.comp, mul_assoc]\n\n"}
{"name":"leftAddCoset_assoc","module":"Mathlib.GroupTheory.Coset.Basic","initialProofState":"α : Type u_1\ninst✝ : AddSemigroup α\ns : Set α\na b : α\n⊢ Eq (HVAdd.hVAdd a (HVAdd.hVAdd b s)) (HVAdd.hVAdd (HAdd.hAdd a b) s)","decl":"@[to_additive leftAddCoset_assoc]\ntheorem leftCoset_assoc (s : Set α) (a b : α) : a • (b • s) = (a * b) • s := by\n  simp [← image_smul, (image_comp _ _ _).symm, Function.comp, mul_assoc]\n\n"}
{"name":"rightAddCoset_assoc","module":"Mathlib.GroupTheory.Coset.Basic","initialProofState":"α : Type u_1\ninst✝ : AddSemigroup α\ns : Set α\na b : α\n⊢ Eq (HVAdd.hVAdd (AddOpposite.op b) (HVAdd.hVAdd (AddOpposite.op a) s)) (HVAdd.hVAdd (AddOpposite.op (HAdd.hAdd a b)) s)","decl":"@[to_additive rightAddCoset_assoc]\ntheorem rightCoset_assoc (s : Set α) (a b : α) : op b • op a • s = op (a * b) • s := by\n  simp [← image_smul, (image_comp _ _ _).symm, Function.comp, mul_assoc]\n\n"}
{"name":"rightCoset_assoc","module":"Mathlib.GroupTheory.Coset.Basic","initialProofState":"α : Type u_1\ninst✝ : Semigroup α\ns : Set α\na b : α\n⊢ Eq (HSMul.hSMul (MulOpposite.op b) (HSMul.hSMul (MulOpposite.op a) s)) (HSMul.hSMul (MulOpposite.op (HMul.hMul a b)) s)","decl":"@[to_additive rightAddCoset_assoc]\ntheorem rightCoset_assoc (s : Set α) (a b : α) : op b • op a • s = op (a * b) • s := by\n  simp [← image_smul, (image_comp _ _ _).symm, Function.comp, mul_assoc]\n\n"}
{"name":"leftAddCoset_rightAddCoset","module":"Mathlib.GroupTheory.Coset.Basic","initialProofState":"α : Type u_1\ninst✝ : AddSemigroup α\ns : Set α\na b : α\n⊢ Eq (HVAdd.hVAdd (AddOpposite.op b) (HVAdd.hVAdd a s)) (HVAdd.hVAdd a (HVAdd.hVAdd (AddOpposite.op b) s))","decl":"@[to_additive leftAddCoset_rightAddCoset]\ntheorem leftCoset_rightCoset (s : Set α) (a b : α) : op b • a • s = a • (op b • s) := by\n  simp [← image_smul, (image_comp _ _ _).symm, Function.comp, mul_assoc]\n\n"}
{"name":"leftCoset_rightCoset","module":"Mathlib.GroupTheory.Coset.Basic","initialProofState":"α : Type u_1\ninst✝ : Semigroup α\ns : Set α\na b : α\n⊢ Eq (HSMul.hSMul (MulOpposite.op b) (HSMul.hSMul a s)) (HSMul.hSMul a (HSMul.hSMul (MulOpposite.op b) s))","decl":"@[to_additive leftAddCoset_rightAddCoset]\ntheorem leftCoset_rightCoset (s : Set α) (a b : α) : op b • a • s = a • (op b • s) := by\n  simp [← image_smul, (image_comp _ _ _).symm, Function.comp, mul_assoc]\n\n"}
{"name":"one_leftCoset","module":"Mathlib.GroupTheory.Coset.Basic","initialProofState":"α : Type u_1\ninst✝ : Monoid α\ns : Set α\n⊢ Eq (HSMul.hSMul 1 s) s","decl":"@[to_additive zero_leftAddCoset]\ntheorem one_leftCoset : (1 : α) • s = s :=\n  Set.ext <| by simp [← image_smul]\n\n"}
{"name":"zero_leftAddCoset","module":"Mathlib.GroupTheory.Coset.Basic","initialProofState":"α : Type u_1\ninst✝ : AddMonoid α\ns : Set α\n⊢ Eq (HVAdd.hVAdd 0 s) s","decl":"@[to_additive zero_leftAddCoset]\ntheorem one_leftCoset : (1 : α) • s = s :=\n  Set.ext <| by simp [← image_smul]\n\n"}
{"name":"rightCoset_one","module":"Mathlib.GroupTheory.Coset.Basic","initialProofState":"α : Type u_1\ninst✝ : Monoid α\ns : Set α\n⊢ Eq (HSMul.hSMul (MulOpposite.op 1) s) s","decl":"@[to_additive rightAddCoset_zero]\ntheorem rightCoset_one : op (1 : α) • s = s :=\n  Set.ext <| by simp [← image_smul]\n\n"}
{"name":"rightAddCoset_zero","module":"Mathlib.GroupTheory.Coset.Basic","initialProofState":"α : Type u_1\ninst✝ : AddMonoid α\ns : Set α\n⊢ Eq (HVAdd.hVAdd (AddOpposite.op 0) s) s","decl":"@[to_additive rightAddCoset_zero]\ntheorem rightCoset_one : op (1 : α) • s = s :=\n  Set.ext <| by simp [← image_smul]\n\n"}
{"name":"mem_own_leftCoset","module":"Mathlib.GroupTheory.Coset.Basic","initialProofState":"α : Type u_1\ninst✝ : Monoid α\ns : Submonoid α\na : α\n⊢ Membership.mem (HSMul.hSMul a ↑s) a","decl":"@[to_additive mem_own_leftAddCoset]\ntheorem mem_own_leftCoset (a : α) : a ∈ a • (s : Set α) :=\n  suffices a * 1 ∈ a • (s : Set α) by simpa\n  mem_leftCoset a (one_mem s : 1 ∈ s)\n\n"}
{"name":"mem_own_leftAddCoset","module":"Mathlib.GroupTheory.Coset.Basic","initialProofState":"α : Type u_1\ninst✝ : AddMonoid α\ns : AddSubmonoid α\na : α\n⊢ Membership.mem (HVAdd.hVAdd a ↑s) a","decl":"@[to_additive mem_own_leftAddCoset]\ntheorem mem_own_leftCoset (a : α) : a ∈ a • (s : Set α) :=\n  suffices a * 1 ∈ a • (s : Set α) by simpa\n  mem_leftCoset a (one_mem s : 1 ∈ s)\n\n"}
{"name":"mem_own_rightAddCoset","module":"Mathlib.GroupTheory.Coset.Basic","initialProofState":"α : Type u_1\ninst✝ : AddMonoid α\ns : AddSubmonoid α\na : α\n⊢ Membership.mem (HVAdd.hVAdd (AddOpposite.op a) ↑s) a","decl":"@[to_additive mem_own_rightAddCoset]\ntheorem mem_own_rightCoset (a : α) : a ∈ op a • (s : Set α) :=\n  suffices 1 * a ∈ op a • (s : Set α) by simpa\n  mem_rightCoset a (one_mem s : 1 ∈ s)\n\n"}
{"name":"mem_own_rightCoset","module":"Mathlib.GroupTheory.Coset.Basic","initialProofState":"α : Type u_1\ninst✝ : Monoid α\ns : Submonoid α\na : α\n⊢ Membership.mem (HSMul.hSMul (MulOpposite.op a) ↑s) a","decl":"@[to_additive mem_own_rightAddCoset]\ntheorem mem_own_rightCoset (a : α) : a ∈ op a • (s : Set α) :=\n  suffices 1 * a ∈ op a • (s : Set α) by simpa\n  mem_rightCoset a (one_mem s : 1 ∈ s)\n\n"}
{"name":"mem_leftAddCoset_leftAddCoset","module":"Mathlib.GroupTheory.Coset.Basic","initialProofState":"α : Type u_1\ninst✝ : AddMonoid α\ns : AddSubmonoid α\na : α\nha : Eq (HVAdd.hVAdd a ↑s) ↑s\n⊢ Membership.mem s a","decl":"@[to_additive mem_leftAddCoset_leftAddCoset]\ntheorem mem_leftCoset_leftCoset {a : α} (ha : a • (s : Set α) = s) : a ∈ s := by\n  rw [← SetLike.mem_coe, ← ha]; exact mem_own_leftCoset s a\n\n"}
{"name":"mem_leftCoset_leftCoset","module":"Mathlib.GroupTheory.Coset.Basic","initialProofState":"α : Type u_1\ninst✝ : Monoid α\ns : Submonoid α\na : α\nha : Eq (HSMul.hSMul a ↑s) ↑s\n⊢ Membership.mem s a","decl":"@[to_additive mem_leftAddCoset_leftAddCoset]\ntheorem mem_leftCoset_leftCoset {a : α} (ha : a • (s : Set α) = s) : a ∈ s := by\n  rw [← SetLike.mem_coe, ← ha]; exact mem_own_leftCoset s a\n\n"}
{"name":"mem_rightAddCoset_rightAddCoset","module":"Mathlib.GroupTheory.Coset.Basic","initialProofState":"α : Type u_1\ninst✝ : AddMonoid α\ns : AddSubmonoid α\na : α\nha : Eq (HVAdd.hVAdd (AddOpposite.op a) ↑s) ↑s\n⊢ Membership.mem s a","decl":"@[to_additive mem_rightAddCoset_rightAddCoset]\ntheorem mem_rightCoset_rightCoset {a : α} (ha : op a • (s : Set α) = s) : a ∈ s := by\n  rw [← SetLike.mem_coe, ← ha]; exact mem_own_rightCoset s a\n\n"}
{"name":"mem_rightCoset_rightCoset","module":"Mathlib.GroupTheory.Coset.Basic","initialProofState":"α : Type u_1\ninst✝ : Monoid α\ns : Submonoid α\na : α\nha : Eq (HSMul.hSMul (MulOpposite.op a) ↑s) ↑s\n⊢ Membership.mem s a","decl":"@[to_additive mem_rightAddCoset_rightAddCoset]\ntheorem mem_rightCoset_rightCoset {a : α} (ha : op a • (s : Set α) = s) : a ∈ s := by\n  rw [← SetLike.mem_coe, ← ha]; exact mem_own_rightCoset s a\n\n"}
{"name":"mem_leftCoset_iff","module":"Mathlib.GroupTheory.Coset.Basic","initialProofState":"α : Type u_1\ninst✝ : Group α\ns : Set α\nx a : α\n⊢ Iff (Membership.mem (HSMul.hSMul a s) x) (Membership.mem s (HMul.hMul (Inv.inv a) x))","decl":"@[to_additive mem_leftAddCoset_iff]\ntheorem mem_leftCoset_iff (a : α) : x ∈ a • s ↔ a⁻¹ * x ∈ s :=\n  Iff.intro (fun ⟨b, hb, Eq⟩ => by simp [Eq.symm, hb]) fun h => ⟨a⁻¹ * x, h, by simp⟩\n\n"}
{"name":"mem_leftAddCoset_iff","module":"Mathlib.GroupTheory.Coset.Basic","initialProofState":"α : Type u_1\ninst✝ : AddGroup α\ns : Set α\nx a : α\n⊢ Iff (Membership.mem (HVAdd.hVAdd a s) x) (Membership.mem s (HAdd.hAdd (Neg.neg a) x))","decl":"@[to_additive mem_leftAddCoset_iff]\ntheorem mem_leftCoset_iff (a : α) : x ∈ a • s ↔ a⁻¹ * x ∈ s :=\n  Iff.intro (fun ⟨b, hb, Eq⟩ => by simp [Eq.symm, hb]) fun h => ⟨a⁻¹ * x, h, by simp⟩\n\n"}
{"name":"mem_rightAddCoset_iff","module":"Mathlib.GroupTheory.Coset.Basic","initialProofState":"α : Type u_1\ninst✝ : AddGroup α\ns : Set α\nx a : α\n⊢ Iff (Membership.mem (HVAdd.hVAdd (AddOpposite.op a) s) x) (Membership.mem s (HAdd.hAdd x (Neg.neg a)))","decl":"@[to_additive mem_rightAddCoset_iff]\ntheorem mem_rightCoset_iff (a : α) : x ∈ op a • s ↔ x * a⁻¹ ∈ s :=\n  Iff.intro (fun ⟨b, hb, Eq⟩ => by simp [Eq.symm, hb]) fun h => ⟨x * a⁻¹, h, by simp⟩\n\n"}
{"name":"mem_rightCoset_iff","module":"Mathlib.GroupTheory.Coset.Basic","initialProofState":"α : Type u_1\ninst✝ : Group α\ns : Set α\nx a : α\n⊢ Iff (Membership.mem (HSMul.hSMul (MulOpposite.op a) s) x) (Membership.mem s (HMul.hMul x (Inv.inv a)))","decl":"@[to_additive mem_rightAddCoset_iff]\ntheorem mem_rightCoset_iff (a : α) : x ∈ op a • s ↔ x * a⁻¹ ∈ s :=\n  Iff.intro (fun ⟨b, hb, Eq⟩ => by simp [Eq.symm, hb]) fun h => ⟨x * a⁻¹, h, by simp⟩\n\n"}
{"name":"leftAddCoset_mem_leftAddCoset","module":"Mathlib.GroupTheory.Coset.Basic","initialProofState":"α : Type u_1\ninst✝ : AddGroup α\ns : AddSubgroup α\na : α\nha : Membership.mem s a\n⊢ Eq (HVAdd.hVAdd a ↑s) ↑s","decl":"@[to_additive leftAddCoset_mem_leftAddCoset]\ntheorem leftCoset_mem_leftCoset {a : α} (ha : a ∈ s) : a • (s : Set α) = s :=\n  Set.ext <| by simp [mem_leftCoset_iff, mul_mem_cancel_left (s.inv_mem ha)]\n\n"}
{"name":"leftCoset_mem_leftCoset","module":"Mathlib.GroupTheory.Coset.Basic","initialProofState":"α : Type u_1\ninst✝ : Group α\ns : Subgroup α\na : α\nha : Membership.mem s a\n⊢ Eq (HSMul.hSMul a ↑s) ↑s","decl":"@[to_additive leftAddCoset_mem_leftAddCoset]\ntheorem leftCoset_mem_leftCoset {a : α} (ha : a ∈ s) : a • (s : Set α) = s :=\n  Set.ext <| by simp [mem_leftCoset_iff, mul_mem_cancel_left (s.inv_mem ha)]\n\n"}
{"name":"rightAddCoset_mem_rightAddCoset","module":"Mathlib.GroupTheory.Coset.Basic","initialProofState":"α : Type u_1\ninst✝ : AddGroup α\ns : AddSubgroup α\na : α\nha : Membership.mem s a\n⊢ Eq (HVAdd.hVAdd (AddOpposite.op a) ↑s) ↑s","decl":"@[to_additive rightAddCoset_mem_rightAddCoset]\ntheorem rightCoset_mem_rightCoset {a : α} (ha : a ∈ s) : op a • (s : Set α) = s :=\n  Set.ext fun b => by simp [mem_rightCoset_iff, mul_mem_cancel_right (s.inv_mem ha)]\n\n"}
{"name":"rightCoset_mem_rightCoset","module":"Mathlib.GroupTheory.Coset.Basic","initialProofState":"α : Type u_1\ninst✝ : Group α\ns : Subgroup α\na : α\nha : Membership.mem s a\n⊢ Eq (HSMul.hSMul (MulOpposite.op a) ↑s) ↑s","decl":"@[to_additive rightAddCoset_mem_rightAddCoset]\ntheorem rightCoset_mem_rightCoset {a : α} (ha : a ∈ s) : op a • (s : Set α) = s :=\n  Set.ext fun b => by simp [mem_rightCoset_iff, mul_mem_cancel_right (s.inv_mem ha)]\n\n"}
{"name":"orbit_addSubgroup_eq_rightCoset","module":"Mathlib.GroupTheory.Coset.Basic","initialProofState":"α : Type u_1\ninst✝ : AddGroup α\ns : AddSubgroup α\na : α\n⊢ Eq (AddAction.orbit (Subtype fun x => Membership.mem s x) a) (HVAdd.hVAdd (AddOpposite.op a) ↑s)","decl":"@[to_additive]\ntheorem orbit_subgroup_eq_rightCoset (a : α) : MulAction.orbit s a = op a • s :=\n  Set.ext fun _b => ⟨fun ⟨c, d⟩ => ⟨c, c.2, d⟩, fun ⟨c, d, e⟩ => ⟨⟨c, d⟩, e⟩⟩\n\n"}
{"name":"orbit_subgroup_eq_rightCoset","module":"Mathlib.GroupTheory.Coset.Basic","initialProofState":"α : Type u_1\ninst✝ : Group α\ns : Subgroup α\na : α\n⊢ Eq (MulAction.orbit (Subtype fun x => Membership.mem s x) a) (HSMul.hSMul (MulOpposite.op a) ↑s)","decl":"@[to_additive]\ntheorem orbit_subgroup_eq_rightCoset (a : α) : MulAction.orbit s a = op a • s :=\n  Set.ext fun _b => ⟨fun ⟨c, d⟩ => ⟨c, c.2, d⟩, fun ⟨c, d, e⟩ => ⟨⟨c, d⟩, e⟩⟩\n\n"}
{"name":"orbit_subgroup_eq_self_of_mem","module":"Mathlib.GroupTheory.Coset.Basic","initialProofState":"α : Type u_1\ninst✝ : Group α\ns : Subgroup α\na : α\nha : Membership.mem s a\n⊢ Eq (MulAction.orbit (Subtype fun x => Membership.mem s x) a) ↑s","decl":"@[to_additive]\ntheorem orbit_subgroup_eq_self_of_mem {a : α} (ha : a ∈ s) : MulAction.orbit s a = s :=\n  (orbit_subgroup_eq_rightCoset s a).trans (rightCoset_mem_rightCoset s ha)\n\n"}
{"name":"orbit_addSubgroup_eq_self_of_mem","module":"Mathlib.GroupTheory.Coset.Basic","initialProofState":"α : Type u_1\ninst✝ : AddGroup α\ns : AddSubgroup α\na : α\nha : Membership.mem s a\n⊢ Eq (AddAction.orbit (Subtype fun x => Membership.mem s x) a) ↑s","decl":"@[to_additive]\ntheorem orbit_subgroup_eq_self_of_mem {a : α} (ha : a ∈ s) : MulAction.orbit s a = s :=\n  (orbit_subgroup_eq_rightCoset s a).trans (rightCoset_mem_rightCoset s ha)\n\n"}
{"name":"orbit_subgroup_one_eq_self","module":"Mathlib.GroupTheory.Coset.Basic","initialProofState":"α : Type u_1\ninst✝ : Group α\ns : Subgroup α\n⊢ Eq (MulAction.orbit (Subtype fun x => Membership.mem s x) 1) ↑s","decl":"@[to_additive]\ntheorem orbit_subgroup_one_eq_self : MulAction.orbit s (1 : α) = s :=\n  orbit_subgroup_eq_self_of_mem s s.one_mem\n\n"}
{"name":"orbit_addSubgroup_zero_eq_self","module":"Mathlib.GroupTheory.Coset.Basic","initialProofState":"α : Type u_1\ninst✝ : AddGroup α\ns : AddSubgroup α\n⊢ Eq (AddAction.orbit (Subtype fun x => Membership.mem s x) 0) ↑s","decl":"@[to_additive]\ntheorem orbit_subgroup_one_eq_self : MulAction.orbit s (1 : α) = s :=\n  orbit_subgroup_eq_self_of_mem s s.one_mem\n\n"}
{"name":"eq_cosets_of_normal","module":"Mathlib.GroupTheory.Coset.Basic","initialProofState":"α : Type u_1\ninst✝ : Group α\ns : Subgroup α\nN : s.Normal\ng : α\n⊢ Eq (HSMul.hSMul g ↑s) (HSMul.hSMul (MulOpposite.op g) ↑s)","decl":"@[to_additive eq_addCosets_of_normal]\ntheorem eq_cosets_of_normal (N : s.Normal) (g : α) : g • (s : Set α) = op g • s :=\n  Set.ext fun a => by simp [mem_leftCoset_iff, mem_rightCoset_iff, N.mem_comm_iff]\n\n"}
{"name":"eq_addCosets_of_normal","module":"Mathlib.GroupTheory.Coset.Basic","initialProofState":"α : Type u_1\ninst✝ : AddGroup α\ns : AddSubgroup α\nN : s.Normal\ng : α\n⊢ Eq (HVAdd.hVAdd g ↑s) (HVAdd.hVAdd (AddOpposite.op g) ↑s)","decl":"@[to_additive eq_addCosets_of_normal]\ntheorem eq_cosets_of_normal (N : s.Normal) (g : α) : g • (s : Set α) = op g • s :=\n  Set.ext fun a => by simp [mem_leftCoset_iff, mem_rightCoset_iff, N.mem_comm_iff]\n\n"}
{"name":"normal_of_eq_cosets","module":"Mathlib.GroupTheory.Coset.Basic","initialProofState":"α : Type u_1\ninst✝ : Group α\ns : Subgroup α\nh : ∀ (g : α), Eq (HSMul.hSMul g ↑s) (HSMul.hSMul (MulOpposite.op g) ↑s)\n⊢ s.Normal","decl":"@[to_additive normal_of_eq_addCosets]\ntheorem normal_of_eq_cosets (h : ∀ g : α, g • (s : Set α) = op g • s) : s.Normal :=\n  ⟨fun a ha g =>\n    show g * a * g⁻¹ ∈ (s : Set α) by rw [← mem_rightCoset_iff, ← h]; exact mem_leftCoset g ha⟩\n\n"}
{"name":"normal_of_eq_addCosets","module":"Mathlib.GroupTheory.Coset.Basic","initialProofState":"α : Type u_1\ninst✝ : AddGroup α\ns : AddSubgroup α\nh : ∀ (g : α), Eq (HVAdd.hVAdd g ↑s) (HVAdd.hVAdd (AddOpposite.op g) ↑s)\n⊢ s.Normal","decl":"@[to_additive normal_of_eq_addCosets]\ntheorem normal_of_eq_cosets (h : ∀ g : α, g • (s : Set α) = op g • s) : s.Normal :=\n  ⟨fun a ha g =>\n    show g * a * g⁻¹ ∈ (s : Set α) by rw [← mem_rightCoset_iff, ← h]; exact mem_leftCoset g ha⟩\n\n"}
{"name":"normal_iff_eq_cosets","module":"Mathlib.GroupTheory.Coset.Basic","initialProofState":"α : Type u_1\ninst✝ : Group α\ns : Subgroup α\n⊢ Iff s.Normal (∀ (g : α), Eq (HSMul.hSMul g ↑s) (HSMul.hSMul (MulOpposite.op g) ↑s))","decl":"@[to_additive normal_iff_eq_addCosets]\ntheorem normal_iff_eq_cosets : s.Normal ↔ ∀ g : α, g • (s : Set α) = op g • s :=\n  ⟨@eq_cosets_of_normal _ _ s, normal_of_eq_cosets s⟩\n\n"}
{"name":"normal_iff_eq_addCosets","module":"Mathlib.GroupTheory.Coset.Basic","initialProofState":"α : Type u_1\ninst✝ : AddGroup α\ns : AddSubgroup α\n⊢ Iff s.Normal (∀ (g : α), Eq (HVAdd.hVAdd g ↑s) (HVAdd.hVAdd (AddOpposite.op g) ↑s))","decl":"@[to_additive normal_iff_eq_addCosets]\ntheorem normal_iff_eq_cosets : s.Normal ↔ ∀ g : α, g • (s : Set α) = op g • s :=\n  ⟨@eq_cosets_of_normal _ _ s, normal_of_eq_cosets s⟩\n\n"}
{"name":"leftAddCoset_eq_iff","module":"Mathlib.GroupTheory.Coset.Basic","initialProofState":"α : Type u_1\ninst✝ : AddGroup α\ns : AddSubgroup α\nx y : α\n⊢ Iff (Eq (HVAdd.hVAdd x ↑s) (HVAdd.hVAdd y ↑s)) (Membership.mem s (HAdd.hAdd (Neg.neg x) y))","decl":"@[to_additive leftAddCoset_eq_iff]\ntheorem leftCoset_eq_iff {x y : α} : x • (s : Set α) = y • s ↔ x⁻¹ * y ∈ s := by\n  rw [Set.ext_iff]\n  simp_rw [mem_leftCoset_iff, SetLike.mem_coe]\n  constructor\n  · intro h\n    apply (h y).mpr\n    rw [inv_mul_cancel]\n    exact s.one_mem\n  · intro h z\n    rw [← mul_inv_cancel_right x⁻¹ y]\n    rw [mul_assoc]\n    exact s.mul_mem_cancel_left h\n\n"}
{"name":"leftCoset_eq_iff","module":"Mathlib.GroupTheory.Coset.Basic","initialProofState":"α : Type u_1\ninst✝ : Group α\ns : Subgroup α\nx y : α\n⊢ Iff (Eq (HSMul.hSMul x ↑s) (HSMul.hSMul y ↑s)) (Membership.mem s (HMul.hMul (Inv.inv x) y))","decl":"@[to_additive leftAddCoset_eq_iff]\ntheorem leftCoset_eq_iff {x y : α} : x • (s : Set α) = y • s ↔ x⁻¹ * y ∈ s := by\n  rw [Set.ext_iff]\n  simp_rw [mem_leftCoset_iff, SetLike.mem_coe]\n  constructor\n  · intro h\n    apply (h y).mpr\n    rw [inv_mul_cancel]\n    exact s.one_mem\n  · intro h z\n    rw [← mul_inv_cancel_right x⁻¹ y]\n    rw [mul_assoc]\n    exact s.mul_mem_cancel_left h\n\n"}
{"name":"rightAddCoset_eq_iff","module":"Mathlib.GroupTheory.Coset.Basic","initialProofState":"α : Type u_1\ninst✝ : AddGroup α\ns : AddSubgroup α\nx y : α\n⊢ Iff (Eq (HVAdd.hVAdd (AddOpposite.op x) ↑s) (HVAdd.hVAdd (AddOpposite.op y) ↑s)) (Membership.mem s (HAdd.hAdd y (Neg.neg x)))","decl":"@[to_additive rightAddCoset_eq_iff]\ntheorem rightCoset_eq_iff {x y : α} : op x • (s : Set α) = op y • s ↔ y * x⁻¹ ∈ s := by\n  rw [Set.ext_iff]\n  simp_rw [mem_rightCoset_iff, SetLike.mem_coe]\n  constructor\n  · intro h\n    apply (h y).mpr\n    rw [mul_inv_cancel]\n    exact s.one_mem\n  · intro h z\n    rw [← inv_mul_cancel_left y x⁻¹]\n    rw [← mul_assoc]\n    exact s.mul_mem_cancel_right h\n\n"}
{"name":"rightCoset_eq_iff","module":"Mathlib.GroupTheory.Coset.Basic","initialProofState":"α : Type u_1\ninst✝ : Group α\ns : Subgroup α\nx y : α\n⊢ Iff (Eq (HSMul.hSMul (MulOpposite.op x) ↑s) (HSMul.hSMul (MulOpposite.op y) ↑s)) (Membership.mem s (HMul.hMul y (Inv.inv x)))","decl":"@[to_additive rightAddCoset_eq_iff]\ntheorem rightCoset_eq_iff {x y : α} : op x • (s : Set α) = op y • s ↔ y * x⁻¹ ∈ s := by\n  rw [Set.ext_iff]\n  simp_rw [mem_rightCoset_iff, SetLike.mem_coe]\n  constructor\n  · intro h\n    apply (h y).mpr\n    rw [mul_inv_cancel]\n    exact s.one_mem\n  · intro h z\n    rw [← inv_mul_cancel_left y x⁻¹]\n    rw [← mul_assoc]\n    exact s.mul_mem_cancel_right h\n\n"}
{"name":"QuotientGroup.leftRel_r_eq_leftCosetEquivalence","module":"Mathlib.GroupTheory.Coset.Basic","initialProofState":"α : Type u_1\ninst✝ : Group α\ns : Subgroup α\n⊢ Eq (⇑(QuotientGroup.leftRel s)) (LeftCosetEquivalence ↑s)","decl":"theorem leftRel_r_eq_leftCosetEquivalence :\n    ⇑(QuotientGroup.leftRel s) = LeftCosetEquivalence s := by\n  ext\n  rw [leftRel_eq]\n  exact (leftCoset_eq_iff s).symm\n\n"}
{"name":"QuotientAddGroup.leftRel_sum","module":"Mathlib.GroupTheory.Coset.Basic","initialProofState":"α : Type u_1\ninst✝¹ : AddGroup α\ns : AddSubgroup α\nβ : Type u_2\ninst✝ : AddGroup β\ns' : AddSubgroup β\n⊢ Eq (QuotientAddGroup.leftRel (s.prod s')) ((QuotientAddGroup.leftRel s).prod (QuotientAddGroup.leftRel s'))","decl":"@[to_additive]\nlemma leftRel_prod {β : Type*} [Group β] (s' : Subgroup β) :\n    leftRel (s.prod s') = (leftRel s).prod (leftRel s') := by\n  refine Setoid.ext fun x y ↦ ?_\n  rw [Setoid.prod_apply]\n  simp_rw [leftRel_apply]\n  rfl\n\n"}
{"name":"QuotientGroup.leftRel_prod","module":"Mathlib.GroupTheory.Coset.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Group α\ns : Subgroup α\nβ : Type u_2\ninst✝ : Group β\ns' : Subgroup β\n⊢ Eq (QuotientGroup.leftRel (s.prod s')) ((QuotientGroup.leftRel s).prod (QuotientGroup.leftRel s'))","decl":"@[to_additive]\nlemma leftRel_prod {β : Type*} [Group β] (s' : Subgroup β) :\n    leftRel (s.prod s') = (leftRel s).prod (leftRel s') := by\n  refine Setoid.ext fun x y ↦ ?_\n  rw [Setoid.prod_apply]\n  simp_rw [leftRel_apply]\n  rfl\n\n"}
{"name":"QuotientAddGroup.leftRel_pi","module":"Mathlib.GroupTheory.Coset.Basic","initialProofState":"ι : Type u_2\nβ : ι → Type u_3\ninst✝ : (i : ι) → AddGroup (β i)\ns' : (i : ι) → AddSubgroup (β i)\n⊢ Eq (QuotientAddGroup.leftRel (AddSubgroup.pi Set.univ s')) piSetoid","decl":"@[to_additive]\nlemma leftRel_pi {ι : Type*} {β : ι → Type*} [∀ i, Group (β i)] (s' : ∀ i, Subgroup (β i)) :\n    leftRel (Subgroup.pi Set.univ s') = @piSetoid _ _ fun i ↦ leftRel (s' i) := by\n  refine Setoid.ext fun x y ↦ ?_\n  simp [Setoid.piSetoid_apply, leftRel_apply, Subgroup.mem_pi]\n\n"}
{"name":"QuotientGroup.leftRel_pi","module":"Mathlib.GroupTheory.Coset.Basic","initialProofState":"ι : Type u_2\nβ : ι → Type u_3\ninst✝ : (i : ι) → Group (β i)\ns' : (i : ι) → Subgroup (β i)\n⊢ Eq (QuotientGroup.leftRel (Subgroup.pi Set.univ s')) piSetoid","decl":"@[to_additive]\nlemma leftRel_pi {ι : Type*} {β : ι → Type*} [∀ i, Group (β i)] (s' : ∀ i, Subgroup (β i)) :\n    leftRel (Subgroup.pi Set.univ s') = @piSetoid _ _ fun i ↦ leftRel (s' i) := by\n  refine Setoid.ext fun x y ↦ ?_\n  simp [Setoid.piSetoid_apply, leftRel_apply, Subgroup.mem_pi]\n\n"}
{"name":"QuotientGroup.rightRel_r_eq_rightCosetEquivalence","module":"Mathlib.GroupTheory.Coset.Basic","initialProofState":"α : Type u_1\ninst✝ : Group α\ns : Subgroup α\n⊢ Eq (⇑(QuotientGroup.rightRel s)) (RightCosetEquivalence ↑s)","decl":"theorem rightRel_r_eq_rightCosetEquivalence :\n    ⇑(QuotientGroup.rightRel s) = RightCosetEquivalence s := by\n  ext\n  rw [rightRel_eq]\n  exact (rightCoset_eq_iff s).symm\n\n"}
{"name":"QuotientGroup.rightRel_prod","module":"Mathlib.GroupTheory.Coset.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Group α\ns : Subgroup α\nβ : Type u_2\ninst✝ : Group β\ns' : Subgroup β\n⊢ Eq (QuotientGroup.rightRel (s.prod s')) ((QuotientGroup.rightRel s).prod (QuotientGroup.rightRel s'))","decl":"@[to_additive]\nlemma rightRel_prod {β : Type*} [Group β] (s' : Subgroup β) :\n    rightRel (s.prod s') = (rightRel s).prod (rightRel s') := by\n  refine Setoid.ext fun x y ↦ ?_\n  rw [Setoid.prod_apply]\n  simp_rw [rightRel_apply]\n  rfl\n\n"}
{"name":"QuotientAddGroup.rightRel_sum","module":"Mathlib.GroupTheory.Coset.Basic","initialProofState":"α : Type u_1\ninst✝¹ : AddGroup α\ns : AddSubgroup α\nβ : Type u_2\ninst✝ : AddGroup β\ns' : AddSubgroup β\n⊢ Eq (QuotientAddGroup.rightRel (s.prod s')) ((QuotientAddGroup.rightRel s).prod (QuotientAddGroup.rightRel s'))","decl":"@[to_additive]\nlemma rightRel_prod {β : Type*} [Group β] (s' : Subgroup β) :\n    rightRel (s.prod s') = (rightRel s).prod (rightRel s') := by\n  refine Setoid.ext fun x y ↦ ?_\n  rw [Setoid.prod_apply]\n  simp_rw [rightRel_apply]\n  rfl\n\n"}
{"name":"QuotientAddGroup.rightRel_pi","module":"Mathlib.GroupTheory.Coset.Basic","initialProofState":"ι : Type u_2\nβ : ι → Type u_3\ninst✝ : (i : ι) → AddGroup (β i)\ns' : (i : ι) → AddSubgroup (β i)\n⊢ Eq (QuotientAddGroup.rightRel (AddSubgroup.pi Set.univ s')) piSetoid","decl":"@[to_additive]\nlemma rightRel_pi {ι : Type*} {β : ι → Type*} [∀ i, Group (β i)] (s' : ∀ i, Subgroup (β i)) :\n    rightRel (Subgroup.pi Set.univ s') = @piSetoid _ _ fun i ↦ rightRel (s' i) := by\n  refine Setoid.ext fun x y ↦ ?_\n  simp [Setoid.piSetoid_apply, rightRel_apply, Subgroup.mem_pi]\n\n"}
{"name":"QuotientGroup.rightRel_pi","module":"Mathlib.GroupTheory.Coset.Basic","initialProofState":"ι : Type u_2\nβ : ι → Type u_3\ninst✝ : (i : ι) → Group (β i)\ns' : (i : ι) → Subgroup (β i)\n⊢ Eq (QuotientGroup.rightRel (Subgroup.pi Set.univ s')) piSetoid","decl":"@[to_additive]\nlemma rightRel_pi {ι : Type*} {β : ι → Type*} [∀ i, Group (β i)] (s' : ∀ i, Subgroup (β i)) :\n    rightRel (Subgroup.pi Set.univ s') = @piSetoid _ _ fun i ↦ rightRel (s' i) := by\n  refine Setoid.ext fun x y ↦ ?_\n  simp [Setoid.piSetoid_apply, rightRel_apply, Subgroup.mem_pi]\n\n"}
{"name":"QuotientAddGroup.card_quotient_rightRel","module":"Mathlib.GroupTheory.Coset.Basic","initialProofState":"α : Type u_1\ninst✝¹ : AddGroup α\ns : AddSubgroup α\ninst✝ : Fintype (HasQuotient.Quotient α s)\n⊢ Eq (Fintype.card (Quotient (QuotientAddGroup.rightRel s))) (Fintype.card (HasQuotient.Quotient α s))","decl":"@[to_additive]\ntheorem card_quotient_rightRel [Fintype (α ⧸ s)] :\n    Fintype.card (Quotient (QuotientGroup.rightRel s)) = Fintype.card (α ⧸ s) :=\n  Fintype.ofEquiv_card (QuotientGroup.quotientRightRelEquivQuotientLeftRel s).symm\n\n"}
{"name":"QuotientGroup.card_quotient_rightRel","module":"Mathlib.GroupTheory.Coset.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Group α\ns : Subgroup α\ninst✝ : Fintype (HasQuotient.Quotient α s)\n⊢ Eq (Fintype.card (Quotient (QuotientGroup.rightRel s))) (Fintype.card (HasQuotient.Quotient α s))","decl":"@[to_additive]\ntheorem card_quotient_rightRel [Fintype (α ⧸ s)] :\n    Fintype.card (Quotient (QuotientGroup.rightRel s)) = Fintype.card (α ⧸ s) :=\n  Fintype.ofEquiv_card (QuotientGroup.quotientRightRelEquivQuotientLeftRel s).symm\n\n"}
{"name":"QuotientAddGroup.strictMono_comap_prod_image","module":"Mathlib.GroupTheory.Coset.Basic","initialProofState":"α : Type u_1\ninst✝ : AddGroup α\ns : AddSubgroup α\n⊢ StrictMono fun t => { fst := AddSubgroup.comap s.subtype t, snd := Set.image QuotientAddGroup.mk ↑t }","decl":"/-- Given a subgroup `s`, the function that sends a subgroup `t` to the pair consisting of\nits intersection with `s` and its image in the quotient `α ⧸ s` is strictly monotone, even though\nit is not injective in general. -/\n@[to_additive QuotientAddGroup.strictMono_comap_prod_image \"Given an additive subgroup `s`,\nthe function that sends an additive subgroup `t` to the pair consisting of\nits intersection with `s` and its image in the quotient `α ⧸ s`\nis strictly monotone, even though it is not injective in general.\"]\ntheorem strictMono_comap_prod_image :\n    StrictMono fun t : Subgroup α ↦ (t.comap s.subtype, mk (s := s) '' t) := by\n  refine fun t₁ t₂ h ↦ ⟨⟨Subgroup.comap_mono h.1, Set.image_mono h.1⟩,\n    mt (fun ⟨le1, le2⟩ a ha ↦ ?_) h.2⟩\n  obtain ⟨a', h', eq⟩ := le2 ⟨_, ha, rfl⟩\n  convert ← t₁.mul_mem h' (@le1 ⟨_, QuotientGroup.eq.1 eq⟩ <| t₂.mul_mem (t₂.inv_mem <| h.1 h') ha)\n  apply mul_inv_cancel_left\n\n"}
{"name":"QuotientGroup.strictMono_comap_prod_image","module":"Mathlib.GroupTheory.Coset.Basic","initialProofState":"α : Type u_1\ninst✝ : Group α\ns : Subgroup α\n⊢ StrictMono fun t => { fst := Subgroup.comap s.subtype t, snd := Set.image QuotientGroup.mk ↑t }","decl":"/-- Given a subgroup `s`, the function that sends a subgroup `t` to the pair consisting of\nits intersection with `s` and its image in the quotient `α ⧸ s` is strictly monotone, even though\nit is not injective in general. -/\n@[to_additive QuotientAddGroup.strictMono_comap_prod_image \"Given an additive subgroup `s`,\nthe function that sends an additive subgroup `t` to the pair consisting of\nits intersection with `s` and its image in the quotient `α ⧸ s`\nis strictly monotone, even though it is not injective in general.\"]\ntheorem strictMono_comap_prod_image :\n    StrictMono fun t : Subgroup α ↦ (t.comap s.subtype, mk (s := s) '' t) := by\n  refine fun t₁ t₂ h ↦ ⟨⟨Subgroup.comap_mono h.1, Set.image_mono h.1⟩,\n    mt (fun ⟨le1, le2⟩ a ha ↦ ?_) h.2⟩\n  obtain ⟨a', h', eq⟩ := le2 ⟨_, ha, rfl⟩\n  convert ← t₁.mul_mem h' (@le1 ⟨_, QuotientGroup.eq.1 eq⟩ <| t₂.mul_mem (t₂.inv_mem <| h.1 h') ha)\n  apply mul_inv_cancel_left\n\n"}
{"name":"QuotientAddGroup.eq_class_eq_leftCoset","module":"Mathlib.GroupTheory.Coset.Basic","initialProofState":"α : Type u_1\ninst✝ : AddGroup α\ns : AddSubgroup α\ng : α\n⊢ Eq (setOf fun x => Eq ↑x ↑g) (HVAdd.hVAdd g ↑s)","decl":"@[to_additive]\ntheorem eq_class_eq_leftCoset (s : Subgroup α) (g : α) :\n    { x : α | (x : α ⧸ s) = g } = g • s :=\n  Set.ext fun z => by\n    rw [mem_leftCoset_iff, Set.mem_setOf_eq, eq_comm, QuotientGroup.eq, SetLike.mem_coe]\n\n"}
{"name":"QuotientGroup.eq_class_eq_leftCoset","module":"Mathlib.GroupTheory.Coset.Basic","initialProofState":"α : Type u_1\ninst✝ : Group α\ns : Subgroup α\ng : α\n⊢ Eq (setOf fun x => Eq ↑x ↑g) (HSMul.hSMul g ↑s)","decl":"@[to_additive]\ntheorem eq_class_eq_leftCoset (s : Subgroup α) (g : α) :\n    { x : α | (x : α ⧸ s) = g } = g • s :=\n  Set.ext fun z => by\n    rw [mem_leftCoset_iff, Set.mem_setOf_eq, eq_comm, QuotientGroup.eq, SetLike.mem_coe]\n\n"}
{"name":"QuotientAddGroup.orbit_mk_eq_vadd","module":"Mathlib.GroupTheory.Coset.Basic","initialProofState":"α : Type u_1\ninst✝ : AddGroup α\ns : AddSubgroup α\nx : α\n⊢ Eq (AddAction.orbitRel.Quotient.orbit ↑x) (HVAdd.hVAdd x ↑s)","decl":"open MulAction in\n@[to_additive]\nlemma orbit_mk_eq_smul (x : α) : MulAction.orbitRel.Quotient.orbit (x : α ⧸ s) = x • s := by\n  ext\n  rw [orbitRel.Quotient.mem_orbit]\n  simpa [mem_smul_set_iff_inv_smul_mem, ← leftRel_apply, Quotient.eq''] using Setoid.comm' _\n\n"}
{"name":"QuotientGroup.orbit_mk_eq_smul","module":"Mathlib.GroupTheory.Coset.Basic","initialProofState":"α : Type u_1\ninst✝ : Group α\ns : Subgroup α\nx : α\n⊢ Eq (MulAction.orbitRel.Quotient.orbit ↑x) (HSMul.hSMul x ↑s)","decl":"open MulAction in\n@[to_additive]\nlemma orbit_mk_eq_smul (x : α) : MulAction.orbitRel.Quotient.orbit (x : α ⧸ s) = x • s := by\n  ext\n  rw [orbitRel.Quotient.mem_orbit]\n  simpa [mem_smul_set_iff_inv_smul_mem, ← leftRel_apply, Quotient.eq''] using Setoid.comm' _\n\n"}
{"name":"QuotientGroup.orbit_eq_out_smul","module":"Mathlib.GroupTheory.Coset.Basic","initialProofState":"α : Type u_1\ninst✝ : Group α\ns : Subgroup α\nx : HasQuotient.Quotient α s\n⊢ Eq (MulAction.orbitRel.Quotient.orbit x) (HSMul.hSMul (Quotient.out x) ↑s)","decl":"@[to_additive]\nlemma orbit_eq_out_smul (x : α ⧸ s) : MulAction.orbitRel.Quotient.orbit x = x.out • s := by\n  induction x using QuotientGroup.induction_on\n  simp only [orbit_mk_eq_smul, ← eq_class_eq_leftCoset, Quotient.out_eq']\n\n"}
{"name":"QuotientAddGroup.orbit_eq_out_vadd","module":"Mathlib.GroupTheory.Coset.Basic","initialProofState":"α : Type u_1\ninst✝ : AddGroup α\ns : AddSubgroup α\nx : HasQuotient.Quotient α s\n⊢ Eq (AddAction.orbitRel.Quotient.orbit x) (HVAdd.hVAdd (Quotient.out x) ↑s)","decl":"@[to_additive]\nlemma orbit_eq_out_smul (x : α ⧸ s) : MulAction.orbitRel.Quotient.orbit x = x.out • s := by\n  induction x using QuotientGroup.induction_on\n  simp only [orbit_mk_eq_smul, ← eq_class_eq_leftCoset, Quotient.out_eq']\n\n"}
{"name":"QuotientAddGroup.orbit_eq_out'_vadd","module":"Mathlib.GroupTheory.Coset.Basic","initialProofState":"α : Type u_1\ninst✝ : AddGroup α\ns : AddSubgroup α\nx : HasQuotient.Quotient α s\n⊢ Eq (AddAction.orbitRel.Quotient.orbit x) (HVAdd.hVAdd (Quotient.out x) ↑s)","decl":"@[to_additive]\nalias orbit_eq_out'_smul := orbit_eq_out_smul\n\n-- `alias` doesn't add the deprecation suggestion to the `to_additive` version\n-- see https://github.com/leanprover-community/mathlib4/issues/19424\n"}
{"name":"QuotientGroup.orbit_eq_out'_smul","module":"Mathlib.GroupTheory.Coset.Basic","initialProofState":"α : Type u_1\ninst✝ : Group α\ns : Subgroup α\nx : HasQuotient.Quotient α s\n⊢ Eq (MulAction.orbitRel.Quotient.orbit x) (HSMul.hSMul (Quotient.out x) ↑s)","decl":"@[to_additive]\nalias orbit_eq_out'_smul := orbit_eq_out_smul\n\n-- `alias` doesn't add the deprecation suggestion to the `to_additive` version\n-- see https://github.com/leanprover-community/mathlib4/issues/19424\n"}
{"name":"Subgroup.quotientEquivProdOfLE'_symm_apply","module":"Mathlib.GroupTheory.Coset.Basic","initialProofState":"α : Type u_1\ninst✝ : Group α\ns t : Subgroup α\nh_le : LE.le s t\nf : HasQuotient.Quotient α t → α\nhf : Function.RightInverse f QuotientGroup.mk\na : Prod (HasQuotient.Quotient α t) (HasQuotient.Quotient (Subtype fun x => Membership.mem t x) (s.subgroupOf t))\n⊢ Eq ((Subgroup.quotientEquivProdOfLE' h_le f hf).symm a) (Quotient.map' (fun b => HMul.hMul (f a.1) ↑b) ⋯ a.2)","decl":"/-- If `H ≤ K`, then `G/H ≃ G/K × K/H` constructively, using the provided right inverse\nof the quotient map `G → G/K`. The classical version is `Subgroup.quotientEquivProdOfLE`. -/\n@[to_additive (attr := simps)\n  \"If `H ≤ K`, then `G/H ≃ G/K × K/H` constructively, using the provided right inverse\n  of the quotient map `G → G/K`. The classical version is `AddSubgroup.quotientEquivSumOfLE`.\"]\ndef quotientEquivProdOfLE' (h_le : s ≤ t) (f : α ⧸ t → α)\n    (hf : Function.RightInverse f QuotientGroup.mk) : α ⧸ s ≃ (α ⧸ t) × t ⧸ s.subgroupOf t where\n  toFun a :=\n    ⟨a.map' id fun _ _ h => leftRel_apply.mpr (h_le (leftRel_apply.mp h)),\n      a.map' (fun g : α => ⟨(f (Quotient.mk'' g))⁻¹ * g, leftRel_apply.mp (Quotient.exact' (hf g))⟩)\n        fun b c h => by\n        rw [leftRel_apply]\n        change ((f b)⁻¹ * b)⁻¹ * ((f c)⁻¹ * c) ∈ s\n        have key : f b = f c :=\n          congr_arg f (Quotient.sound' (leftRel_apply.mpr (h_le (leftRel_apply.mp h))))\n        rwa [key, mul_inv_rev, inv_inv, mul_assoc, mul_inv_cancel_left, ← leftRel_apply]⟩\n  invFun a := by\n    refine a.2.map' (fun (b : { x // x ∈ t}) => f a.1 * b) fun b c h => by\n      rw [leftRel_apply] at h ⊢\n      change (f a.1 * b)⁻¹ * (f a.1 * c) ∈ s\n      rwa [mul_inv_rev, mul_assoc, inv_mul_cancel_left]\n  left_inv := by\n    refine Quotient.ind' fun a => ?_\n    simp_rw [Quotient.map'_mk'', id, mul_inv_cancel_left]\n  right_inv := by\n    refine Prod.rec ?_\n    refine Quotient.ind' fun a => ?_\n    refine Quotient.ind' fun b => ?_\n    have key : Quotient.mk'' (f (Quotient.mk'' a) * b) = Quotient.mk'' a :=\n      (QuotientGroup.mk_mul_of_mem (f a) b.2).trans (hf a)\n    simp_rw [Quotient.map'_mk'', id, key, inv_mul_cancel_left]\n\n"}
{"name":"Subgroup.quotientEquivProdOfLE'_apply","module":"Mathlib.GroupTheory.Coset.Basic","initialProofState":"α : Type u_1\ninst✝ : Group α\ns t : Subgroup α\nh_le : LE.le s t\nf : HasQuotient.Quotient α t → α\nhf : Function.RightInverse f QuotientGroup.mk\na : HasQuotient.Quotient α s\n⊢ Eq ((Subgroup.quotientEquivProdOfLE' h_le f hf) a) { fst := Quotient.map' id ⋯ a, snd := Quotient.map' (fun g => ⟨HMul.hMul (Inv.inv (f (Quotient.mk'' g))) g, ⋯⟩) ⋯ a }","decl":"/-- If `H ≤ K`, then `G/H ≃ G/K × K/H` constructively, using the provided right inverse\nof the quotient map `G → G/K`. The classical version is `Subgroup.quotientEquivProdOfLE`. -/\n@[to_additive (attr := simps)\n  \"If `H ≤ K`, then `G/H ≃ G/K × K/H` constructively, using the provided right inverse\n  of the quotient map `G → G/K`. The classical version is `AddSubgroup.quotientEquivSumOfLE`.\"]\ndef quotientEquivProdOfLE' (h_le : s ≤ t) (f : α ⧸ t → α)\n    (hf : Function.RightInverse f QuotientGroup.mk) : α ⧸ s ≃ (α ⧸ t) × t ⧸ s.subgroupOf t where\n  toFun a :=\n    ⟨a.map' id fun _ _ h => leftRel_apply.mpr (h_le (leftRel_apply.mp h)),\n      a.map' (fun g : α => ⟨(f (Quotient.mk'' g))⁻¹ * g, leftRel_apply.mp (Quotient.exact' (hf g))⟩)\n        fun b c h => by\n        rw [leftRel_apply]\n        change ((f b)⁻¹ * b)⁻¹ * ((f c)⁻¹ * c) ∈ s\n        have key : f b = f c :=\n          congr_arg f (Quotient.sound' (leftRel_apply.mpr (h_le (leftRel_apply.mp h))))\n        rwa [key, mul_inv_rev, inv_inv, mul_assoc, mul_inv_cancel_left, ← leftRel_apply]⟩\n  invFun a := by\n    refine a.2.map' (fun (b : { x // x ∈ t}) => f a.1 * b) fun b c h => by\n      rw [leftRel_apply] at h ⊢\n      change (f a.1 * b)⁻¹ * (f a.1 * c) ∈ s\n      rwa [mul_inv_rev, mul_assoc, inv_mul_cancel_left]\n  left_inv := by\n    refine Quotient.ind' fun a => ?_\n    simp_rw [Quotient.map'_mk'', id, mul_inv_cancel_left]\n  right_inv := by\n    refine Prod.rec ?_\n    refine Quotient.ind' fun a => ?_\n    refine Quotient.ind' fun b => ?_\n    have key : Quotient.mk'' (f (Quotient.mk'' a) * b) = Quotient.mk'' a :=\n      (QuotientGroup.mk_mul_of_mem (f a) b.2).trans (hf a)\n    simp_rw [Quotient.map'_mk'', id, key, inv_mul_cancel_left]\n\n"}
{"name":"AddSubgroup.quotientEquivSumOfLE'_symm_apply","module":"Mathlib.GroupTheory.Coset.Basic","initialProofState":"α : Type u_1\ninst✝ : AddGroup α\ns t : AddSubgroup α\nh_le : LE.le s t\nf : HasQuotient.Quotient α t → α\nhf : Function.RightInverse f QuotientAddGroup.mk\na : Prod (HasQuotient.Quotient α t) (HasQuotient.Quotient (Subtype fun x => Membership.mem t x) (s.addSubgroupOf t))\n⊢ Eq ((AddSubgroup.quotientEquivSumOfLE' h_le f hf).symm a) (Quotient.map' (fun b => HAdd.hAdd (f a.1) ↑b) ⋯ a.2)","decl":"/-- If `H ≤ K`, then `G/H ≃ G/K × K/H` constructively, using the provided right inverse\nof the quotient map `G → G/K`. The classical version is `Subgroup.quotientEquivProdOfLE`. -/\n@[to_additive (attr := simps)\n  \"If `H ≤ K`, then `G/H ≃ G/K × K/H` constructively, using the provided right inverse\n  of the quotient map `G → G/K`. The classical version is `AddSubgroup.quotientEquivSumOfLE`.\"]\ndef quotientEquivProdOfLE' (h_le : s ≤ t) (f : α ⧸ t → α)\n    (hf : Function.RightInverse f QuotientGroup.mk) : α ⧸ s ≃ (α ⧸ t) × t ⧸ s.subgroupOf t where\n  toFun a :=\n    ⟨a.map' id fun _ _ h => leftRel_apply.mpr (h_le (leftRel_apply.mp h)),\n      a.map' (fun g : α => ⟨(f (Quotient.mk'' g))⁻¹ * g, leftRel_apply.mp (Quotient.exact' (hf g))⟩)\n        fun b c h => by\n        rw [leftRel_apply]\n        change ((f b)⁻¹ * b)⁻¹ * ((f c)⁻¹ * c) ∈ s\n        have key : f b = f c :=\n          congr_arg f (Quotient.sound' (leftRel_apply.mpr (h_le (leftRel_apply.mp h))))\n        rwa [key, mul_inv_rev, inv_inv, mul_assoc, mul_inv_cancel_left, ← leftRel_apply]⟩\n  invFun a := by\n    refine a.2.map' (fun (b : { x // x ∈ t}) => f a.1 * b) fun b c h => by\n      rw [leftRel_apply] at h ⊢\n      change (f a.1 * b)⁻¹ * (f a.1 * c) ∈ s\n      rwa [mul_inv_rev, mul_assoc, inv_mul_cancel_left]\n  left_inv := by\n    refine Quotient.ind' fun a => ?_\n    simp_rw [Quotient.map'_mk'', id, mul_inv_cancel_left]\n  right_inv := by\n    refine Prod.rec ?_\n    refine Quotient.ind' fun a => ?_\n    refine Quotient.ind' fun b => ?_\n    have key : Quotient.mk'' (f (Quotient.mk'' a) * b) = Quotient.mk'' a :=\n      (QuotientGroup.mk_mul_of_mem (f a) b.2).trans (hf a)\n    simp_rw [Quotient.map'_mk'', id, key, inv_mul_cancel_left]\n\n"}
{"name":"AddSubgroup.quotientEquivSumOfLE'_apply","module":"Mathlib.GroupTheory.Coset.Basic","initialProofState":"α : Type u_1\ninst✝ : AddGroup α\ns t : AddSubgroup α\nh_le : LE.le s t\nf : HasQuotient.Quotient α t → α\nhf : Function.RightInverse f QuotientAddGroup.mk\na : HasQuotient.Quotient α s\n⊢ Eq ((AddSubgroup.quotientEquivSumOfLE' h_le f hf) a) { fst := Quotient.map' id ⋯ a, snd := Quotient.map' (fun g => ⟨HAdd.hAdd (Neg.neg (f (Quotient.mk'' g))) g, ⋯⟩) ⋯ a }","decl":"/-- If `H ≤ K`, then `G/H ≃ G/K × K/H` constructively, using the provided right inverse\nof the quotient map `G → G/K`. The classical version is `Subgroup.quotientEquivProdOfLE`. -/\n@[to_additive (attr := simps)\n  \"If `H ≤ K`, then `G/H ≃ G/K × K/H` constructively, using the provided right inverse\n  of the quotient map `G → G/K`. The classical version is `AddSubgroup.quotientEquivSumOfLE`.\"]\ndef quotientEquivProdOfLE' (h_le : s ≤ t) (f : α ⧸ t → α)\n    (hf : Function.RightInverse f QuotientGroup.mk) : α ⧸ s ≃ (α ⧸ t) × t ⧸ s.subgroupOf t where\n  toFun a :=\n    ⟨a.map' id fun _ _ h => leftRel_apply.mpr (h_le (leftRel_apply.mp h)),\n      a.map' (fun g : α => ⟨(f (Quotient.mk'' g))⁻¹ * g, leftRel_apply.mp (Quotient.exact' (hf g))⟩)\n        fun b c h => by\n        rw [leftRel_apply]\n        change ((f b)⁻¹ * b)⁻¹ * ((f c)⁻¹ * c) ∈ s\n        have key : f b = f c :=\n          congr_arg f (Quotient.sound' (leftRel_apply.mpr (h_le (leftRel_apply.mp h))))\n        rwa [key, mul_inv_rev, inv_inv, mul_assoc, mul_inv_cancel_left, ← leftRel_apply]⟩\n  invFun a := by\n    refine a.2.map' (fun (b : { x // x ∈ t}) => f a.1 * b) fun b c h => by\n      rw [leftRel_apply] at h ⊢\n      change (f a.1 * b)⁻¹ * (f a.1 * c) ∈ s\n      rwa [mul_inv_rev, mul_assoc, inv_mul_cancel_left]\n  left_inv := by\n    refine Quotient.ind' fun a => ?_\n    simp_rw [Quotient.map'_mk'', id, mul_inv_cancel_left]\n  right_inv := by\n    refine Prod.rec ?_\n    refine Quotient.ind' fun a => ?_\n    refine Quotient.ind' fun b => ?_\n    have key : Quotient.mk'' (f (Quotient.mk'' a) * b) = Quotient.mk'' a :=\n      (QuotientGroup.mk_mul_of_mem (f a) b.2).trans (hf a)\n    simp_rw [Quotient.map'_mk'', id, key, inv_mul_cancel_left]\n\n"}
{"name":"AddSubgroup.quotientEquivSumOfLE_apply","module":"Mathlib.GroupTheory.Coset.Basic","initialProofState":"α : Type u_1\ninst✝ : AddGroup α\ns t : AddSubgroup α\nh_le : LE.le s t\na : HasQuotient.Quotient α s\n⊢ Eq ((AddSubgroup.quotientEquivSumOfLE h_le) a) { fst := Quotient.map' id ⋯ a, snd := Quotient.map' (fun g => ⟨HAdd.hAdd (Neg.neg (Quotient.mk'' g).out) g, ⋯⟩) ⋯ a }","decl":"/-- If `H ≤ K`, then `G/H ≃ G/K × K/H` nonconstructively.\nThe constructive version is `quotientEquivProdOfLE'`. -/\n@[to_additive (attr := simps!) \"If `H ≤ K`, then `G/H ≃ G/K × K/H` nonconstructively. The\n constructive version is `quotientEquivProdOfLE'`.\"]\nnoncomputable def quotientEquivProdOfLE (h_le : s ≤ t) : α ⧸ s ≃ (α ⧸ t) × t ⧸ s.subgroupOf t :=\n  quotientEquivProdOfLE' h_le Quotient.out Quotient.out_eq'\n\n"}
{"name":"Subgroup.quotientEquivProdOfLE_symm_apply","module":"Mathlib.GroupTheory.Coset.Basic","initialProofState":"α : Type u_1\ninst✝ : Group α\ns t : Subgroup α\nh_le : LE.le s t\na : Prod (HasQuotient.Quotient α t) (HasQuotient.Quotient (Subtype fun x => Membership.mem t x) (s.subgroupOf t))\n⊢ Eq ((Subgroup.quotientEquivProdOfLE h_le).symm a) (Quotient.map' (fun b => HMul.hMul (Quotient.out a.1) ↑b) ⋯ a.2)","decl":"/-- If `H ≤ K`, then `G/H ≃ G/K × K/H` nonconstructively.\nThe constructive version is `quotientEquivProdOfLE'`. -/\n@[to_additive (attr := simps!) \"If `H ≤ K`, then `G/H ≃ G/K × K/H` nonconstructively. The\n constructive version is `quotientEquivProdOfLE'`.\"]\nnoncomputable def quotientEquivProdOfLE (h_le : s ≤ t) : α ⧸ s ≃ (α ⧸ t) × t ⧸ s.subgroupOf t :=\n  quotientEquivProdOfLE' h_le Quotient.out Quotient.out_eq'\n\n"}
{"name":"Subgroup.quotientEquivProdOfLE_apply","module":"Mathlib.GroupTheory.Coset.Basic","initialProofState":"α : Type u_1\ninst✝ : Group α\ns t : Subgroup α\nh_le : LE.le s t\na : HasQuotient.Quotient α s\n⊢ Eq ((Subgroup.quotientEquivProdOfLE h_le) a) { fst := Quotient.map' id ⋯ a, snd := Quotient.map' (fun g => ⟨HMul.hMul (Inv.inv (Quotient.mk'' g).out) g, ⋯⟩) ⋯ a }","decl":"/-- If `H ≤ K`, then `G/H ≃ G/K × K/H` nonconstructively.\nThe constructive version is `quotientEquivProdOfLE'`. -/\n@[to_additive (attr := simps!) \"If `H ≤ K`, then `G/H ≃ G/K × K/H` nonconstructively. The\n constructive version is `quotientEquivProdOfLE'`.\"]\nnoncomputable def quotientEquivProdOfLE (h_le : s ≤ t) : α ⧸ s ≃ (α ⧸ t) × t ⧸ s.subgroupOf t :=\n  quotientEquivProdOfLE' h_le Quotient.out Quotient.out_eq'\n\n"}
{"name":"AddSubgroup.quotientEquivSumOfLE_symm_apply","module":"Mathlib.GroupTheory.Coset.Basic","initialProofState":"α : Type u_1\ninst✝ : AddGroup α\ns t : AddSubgroup α\nh_le : LE.le s t\na : Prod (HasQuotient.Quotient α t) (HasQuotient.Quotient (Subtype fun x => Membership.mem t x) (s.addSubgroupOf t))\n⊢ Eq ((AddSubgroup.quotientEquivSumOfLE h_le).symm a) (Quotient.map' (fun b => HAdd.hAdd (Quotient.out a.1) ↑b) ⋯ a.2)","decl":"/-- If `H ≤ K`, then `G/H ≃ G/K × K/H` nonconstructively.\nThe constructive version is `quotientEquivProdOfLE'`. -/\n@[to_additive (attr := simps!) \"If `H ≤ K`, then `G/H ≃ G/K × K/H` nonconstructively. The\n constructive version is `quotientEquivProdOfLE'`.\"]\nnoncomputable def quotientEquivProdOfLE (h_le : s ≤ t) : α ⧸ s ≃ (α ⧸ t) × t ⧸ s.subgroupOf t :=\n  quotientEquivProdOfLE' h_le Quotient.out Quotient.out_eq'\n\n"}
{"name":"Subgroup.quotientSubgroupOfEmbeddingOfLE_apply_mk","module":"Mathlib.GroupTheory.Coset.Basic","initialProofState":"α : Type u_1\ninst✝ : Group α\ns t H : Subgroup α\nh : LE.le s t\ng : Subtype fun x => Membership.mem s x\n⊢ Eq ((Subgroup.quotientSubgroupOfEmbeddingOfLE H h) ↑g) ↑((Subgroup.inclusion h) g)","decl":"@[to_additive (attr := simp)]\ntheorem quotientSubgroupOfEmbeddingOfLE_apply_mk (H : Subgroup α) (h : s ≤ t) (g : s) :\n    quotientSubgroupOfEmbeddingOfLE H h (QuotientGroup.mk g) =\n      (QuotientGroup.mk (inclusion h g) : (fun _ => { x // x ∈ t } ⧸ subgroupOf H t) ↑g) :=\n  rfl\n\n"}
{"name":"AddSubgroup.quotientAddSubgroupOfEmbeddingOfLE_apply_mk","module":"Mathlib.GroupTheory.Coset.Basic","initialProofState":"α : Type u_1\ninst✝ : AddGroup α\ns t H : AddSubgroup α\nh : LE.le s t\ng : Subtype fun x => Membership.mem s x\n⊢ Eq ((AddSubgroup.quotientAddSubgroupOfEmbeddingOfLE H h) ↑g) ↑((AddSubgroup.inclusion h) g)","decl":"@[to_additive (attr := simp)]\ntheorem quotientSubgroupOfEmbeddingOfLE_apply_mk (H : Subgroup α) (h : s ≤ t) (g : s) :\n    quotientSubgroupOfEmbeddingOfLE H h (QuotientGroup.mk g) =\n      (QuotientGroup.mk (inclusion h g) : (fun _ => { x // x ∈ t } ⧸ subgroupOf H t) ↑g) :=\n  rfl\n\n"}
{"name":"Subgroup.quotientSubgroupOfMapOfLE_apply_mk","module":"Mathlib.GroupTheory.Coset.Basic","initialProofState":"α : Type u_1\ninst✝ : Group α\ns t H : Subgroup α\nh : LE.le s t\ng : Subtype fun x => Membership.mem H x\n⊢ Eq (Subgroup.quotientSubgroupOfMapOfLE H h ↑g) ↑g","decl":"@[to_additive (attr := simp)]\ntheorem quotientSubgroupOfMapOfLE_apply_mk (H : Subgroup α) (h : s ≤ t) (g : H) :\n    quotientSubgroupOfMapOfLE H h (QuotientGroup.mk g) =\n      (QuotientGroup.mk g : { x // x ∈ H } ⧸ subgroupOf t H) :=\n  rfl\n\n"}
{"name":"AddSubgroup.quotientAddSubgroupOfMapOfLE_apply_mk","module":"Mathlib.GroupTheory.Coset.Basic","initialProofState":"α : Type u_1\ninst✝ : AddGroup α\ns t H : AddSubgroup α\nh : LE.le s t\ng : Subtype fun x => Membership.mem H x\n⊢ Eq (AddSubgroup.quotientAddSubgroupOfMapOfLE H h ↑g) ↑g","decl":"@[to_additive (attr := simp)]\ntheorem quotientSubgroupOfMapOfLE_apply_mk (H : Subgroup α) (h : s ≤ t) (g : H) :\n    quotientSubgroupOfMapOfLE H h (QuotientGroup.mk g) =\n      (QuotientGroup.mk g : { x // x ∈ H } ⧸ subgroupOf t H) :=\n  rfl\n\n"}
{"name":"Subgroup.quotientMapOfLE_apply_mk","module":"Mathlib.GroupTheory.Coset.Basic","initialProofState":"α : Type u_1\ninst✝ : Group α\ns t : Subgroup α\nh : LE.le s t\ng : α\n⊢ Eq (Subgroup.quotientMapOfLE h ↑g) ↑g","decl":"@[to_additive (attr := simp)]\ntheorem quotientMapOfLE_apply_mk (h : s ≤ t) (g : α) :\n    quotientMapOfLE h (QuotientGroup.mk g) = QuotientGroup.mk g :=\n  rfl\n\n"}
{"name":"AddSubgroup.quotientMapOfLE_apply_mk","module":"Mathlib.GroupTheory.Coset.Basic","initialProofState":"α : Type u_1\ninst✝ : AddGroup α\ns t : AddSubgroup α\nh : LE.le s t\ng : α\n⊢ Eq (AddSubgroup.quotientMapOfLE h ↑g) ↑g","decl":"@[to_additive (attr := simp)]\ntheorem quotientMapOfLE_apply_mk (h : s ≤ t) (g : α) :\n    quotientMapOfLE h (QuotientGroup.mk g) = QuotientGroup.mk g :=\n  rfl\n\n"}
{"name":"AddSubgroup.quotientiInfAddSubgroupOfEmbedding_apply","module":"Mathlib.GroupTheory.Coset.Basic","initialProofState":"α : Type u_1\ninst✝ : AddGroup α\nι : Type u_2\nf : ι → AddSubgroup α\nH : AddSubgroup α\nq : HasQuotient.Quotient (Subtype fun x => Membership.mem H x) ((iInf fun i => f i).addSubgroupOf H)\ni : ι\n⊢ Eq ((AddSubgroup.quotientiInfAddSubgroupOfEmbedding f H) q i) (AddSubgroup.quotientAddSubgroupOfMapOfLE H ⋯ q)","decl":"/-- The natural embedding `H ⧸ (⨅ i, f i).subgroupOf H ↪ Π i, H ⧸ (f i).subgroupOf H`. -/\n@[to_additive (attr := simps) \"The natural embedding\n `H ⧸ (⨅ i, f i).addSubgroupOf H) ↪ Π i, H ⧸ (f i).addSubgroupOf H`.\"]\ndef quotientiInfSubgroupOfEmbedding {ι : Type*} (f : ι → Subgroup α) (H : Subgroup α) :\n    H ⧸ (⨅ i, f i).subgroupOf H ↪ ∀ i, H ⧸ (f i).subgroupOf H where\n  toFun q i := quotientSubgroupOfMapOfLE H (iInf_le f i) q\n  inj' :=\n    Quotient.ind₂' <| by\n      simp_rw [funext_iff, quotientSubgroupOfMapOfLE_apply_mk, QuotientGroup.eq, mem_subgroupOf,\n        mem_iInf, imp_self, forall_const]\n\n-- Porting note: I had to add the type ascription to the right-hand side or else Lean times out.\n"}
{"name":"Subgroup.quotientiInfSubgroupOfEmbedding_apply","module":"Mathlib.GroupTheory.Coset.Basic","initialProofState":"α : Type u_1\ninst✝ : Group α\nι : Type u_2\nf : ι → Subgroup α\nH : Subgroup α\nq : HasQuotient.Quotient (Subtype fun x => Membership.mem H x) ((iInf fun i => f i).subgroupOf H)\ni : ι\n⊢ Eq ((Subgroup.quotientiInfSubgroupOfEmbedding f H) q i) (Subgroup.quotientSubgroupOfMapOfLE H ⋯ q)","decl":"/-- The natural embedding `H ⧸ (⨅ i, f i).subgroupOf H ↪ Π i, H ⧸ (f i).subgroupOf H`. -/\n@[to_additive (attr := simps) \"The natural embedding\n `H ⧸ (⨅ i, f i).addSubgroupOf H) ↪ Π i, H ⧸ (f i).addSubgroupOf H`.\"]\ndef quotientiInfSubgroupOfEmbedding {ι : Type*} (f : ι → Subgroup α) (H : Subgroup α) :\n    H ⧸ (⨅ i, f i).subgroupOf H ↪ ∀ i, H ⧸ (f i).subgroupOf H where\n  toFun q i := quotientSubgroupOfMapOfLE H (iInf_le f i) q\n  inj' :=\n    Quotient.ind₂' <| by\n      simp_rw [funext_iff, quotientSubgroupOfMapOfLE_apply_mk, QuotientGroup.eq, mem_subgroupOf,\n        mem_iInf, imp_self, forall_const]\n\n-- Porting note: I had to add the type ascription to the right-hand side or else Lean times out.\n"}
{"name":"Subgroup.quotientiInfSubgroupOfEmbedding_apply_mk","module":"Mathlib.GroupTheory.Coset.Basic","initialProofState":"α : Type u_1\ninst✝ : Group α\nι : Type u_2\nf : ι → Subgroup α\nH : Subgroup α\ng : Subtype fun x => Membership.mem H x\ni : ι\n⊢ Eq ((Subgroup.quotientiInfSubgroupOfEmbedding f H) (↑g) i) ↑g","decl":"@[to_additive (attr := simp)]\ntheorem quotientiInfSubgroupOfEmbedding_apply_mk {ι : Type*} (f : ι → Subgroup α) (H : Subgroup α)\n    (g : H) (i : ι) :\n    quotientiInfSubgroupOfEmbedding f H (QuotientGroup.mk g) i =\n      (QuotientGroup.mk g : { x // x ∈ H } ⧸ subgroupOf (f i) H) :=\n  rfl\n\n"}
{"name":"AddSubgroup.quotientiInfAddSubgroupOfEmbedding_apply_mk","module":"Mathlib.GroupTheory.Coset.Basic","initialProofState":"α : Type u_1\ninst✝ : AddGroup α\nι : Type u_2\nf : ι → AddSubgroup α\nH : AddSubgroup α\ng : Subtype fun x => Membership.mem H x\ni : ι\n⊢ Eq ((AddSubgroup.quotientiInfAddSubgroupOfEmbedding f H) (↑g) i) ↑g","decl":"@[to_additive (attr := simp)]\ntheorem quotientiInfSubgroupOfEmbedding_apply_mk {ι : Type*} (f : ι → Subgroup α) (H : Subgroup α)\n    (g : H) (i : ι) :\n    quotientiInfSubgroupOfEmbedding f H (QuotientGroup.mk g) i =\n      (QuotientGroup.mk g : { x // x ∈ H } ⧸ subgroupOf (f i) H) :=\n  rfl\n\n"}
{"name":"Subgroup.quotientiInfEmbedding_apply","module":"Mathlib.GroupTheory.Coset.Basic","initialProofState":"α : Type u_1\ninst✝ : Group α\nι : Type u_2\nf : ι → Subgroup α\nq : HasQuotient.Quotient α (iInf fun i => f i)\ni : ι\n⊢ Eq ((Subgroup.quotientiInfEmbedding f) q i) (Subgroup.quotientMapOfLE ⋯ q)","decl":"/-- The natural embedding `α ⧸ (⨅ i, f i) ↪ Π i, α ⧸ f i`. -/\n@[to_additive (attr := simps) \"The natural embedding `α ⧸ (⨅ i, f i) ↪ Π i, α ⧸ f i`.\"]\ndef quotientiInfEmbedding {ι : Type*} (f : ι → Subgroup α) : (α ⧸ ⨅ i, f i) ↪ ∀ i, α ⧸ f i where\n  toFun q i := quotientMapOfLE (iInf_le f i) q\n  inj' :=\n    Quotient.ind₂' <| by\n      simp_rw [funext_iff, quotientMapOfLE_apply_mk, QuotientGroup.eq, mem_iInf, imp_self,\n        forall_const]\n\n"}
{"name":"AddSubgroup.quotientiInfEmbedding_apply","module":"Mathlib.GroupTheory.Coset.Basic","initialProofState":"α : Type u_1\ninst✝ : AddGroup α\nι : Type u_2\nf : ι → AddSubgroup α\nq : HasQuotient.Quotient α (iInf fun i => f i)\ni : ι\n⊢ Eq ((AddSubgroup.quotientiInfEmbedding f) q i) (AddSubgroup.quotientMapOfLE ⋯ q)","decl":"/-- The natural embedding `α ⧸ (⨅ i, f i) ↪ Π i, α ⧸ f i`. -/\n@[to_additive (attr := simps) \"The natural embedding `α ⧸ (⨅ i, f i) ↪ Π i, α ⧸ f i`.\"]\ndef quotientiInfEmbedding {ι : Type*} (f : ι → Subgroup α) : (α ⧸ ⨅ i, f i) ↪ ∀ i, α ⧸ f i where\n  toFun q i := quotientMapOfLE (iInf_le f i) q\n  inj' :=\n    Quotient.ind₂' <| by\n      simp_rw [funext_iff, quotientMapOfLE_apply_mk, QuotientGroup.eq, mem_iInf, imp_self,\n        forall_const]\n\n"}
{"name":"AddSubgroup.quotientiInfEmbedding_apply_mk","module":"Mathlib.GroupTheory.Coset.Basic","initialProofState":"α : Type u_1\ninst✝ : AddGroup α\nι : Type u_2\nf : ι → AddSubgroup α\ng : α\ni : ι\n⊢ Eq ((AddSubgroup.quotientiInfEmbedding f) (↑g) i) ↑g","decl":"@[to_additive (attr := simp)]\ntheorem quotientiInfEmbedding_apply_mk {ι : Type*} (f : ι → Subgroup α) (g : α) (i : ι) :\n    quotientiInfEmbedding f (QuotientGroup.mk g) i = QuotientGroup.mk g :=\n  rfl\n\n"}
{"name":"Subgroup.quotientiInfEmbedding_apply_mk","module":"Mathlib.GroupTheory.Coset.Basic","initialProofState":"α : Type u_1\ninst✝ : Group α\nι : Type u_2\nf : ι → Subgroup α\ng : α\ni : ι\n⊢ Eq ((Subgroup.quotientiInfEmbedding f) (↑g) i) ↑g","decl":"@[to_additive (attr := simp)]\ntheorem quotientiInfEmbedding_apply_mk {ι : Type*} (f : ι → Subgroup α) (g : α) (i : ι) :\n    quotientiInfEmbedding f (QuotientGroup.mk g) i = QuotientGroup.mk g :=\n  rfl\n\n"}
{"name":"MonoidHom.fiberEquivKer_apply","module":"Mathlib.GroupTheory.Coset.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Group α\nH : Type u_2\ninst✝ : Group H\nf : MonoidHom α H\na : α\ng : ↑(Set.preimage (⇑f) (Singleton.singleton (f a)))\n⊢ Eq (↑((f.fiberEquivKer a) g)) (HMul.hMul (Inv.inv a) ↑g)","decl":"@[to_additive (attr := simp)]\nlemma fiberEquivKer_apply (f : α →* H) (a : α) (g : f ⁻¹' {f a}) : f.fiberEquivKer a g = a⁻¹ * g :=\n  rfl\n\n"}
{"name":"AddMonoidHom.fiberEquivKer_apply","module":"Mathlib.GroupTheory.Coset.Basic","initialProofState":"α : Type u_1\ninst✝¹ : AddGroup α\nH : Type u_2\ninst✝ : AddGroup H\nf : AddMonoidHom α H\na : α\ng : ↑(Set.preimage (⇑f) (Singleton.singleton (f a)))\n⊢ Eq (↑((f.fiberEquivKer a) g)) (HAdd.hAdd (Neg.neg a) ↑g)","decl":"@[to_additive (attr := simp)]\nlemma fiberEquivKer_apply (f : α →* H) (a : α) (g : f ⁻¹' {f a}) : f.fiberEquivKer a g = a⁻¹ * g :=\n  rfl\n\n"}
{"name":"MonoidHom.fiberEquivKer_symm_apply","module":"Mathlib.GroupTheory.Coset.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Group α\nH : Type u_2\ninst✝ : Group H\nf : MonoidHom α H\na : α\ng : Subtype fun x => Membership.mem f.ker x\n⊢ Eq (↑((f.fiberEquivKer a).symm g)) (HMul.hMul a ↑g)","decl":"@[to_additive (attr := simp)]\nlemma fiberEquivKer_symm_apply (f : α →* H) (a : α) (g : f.ker) :\n    (f.fiberEquivKer a).symm g = a * g :=\n  rfl\n\n"}
{"name":"AddMonoidHom.fiberEquivKer_symm_apply","module":"Mathlib.GroupTheory.Coset.Basic","initialProofState":"α : Type u_1\ninst✝¹ : AddGroup α\nH : Type u_2\ninst✝ : AddGroup H\nf : AddMonoidHom α H\na : α\ng : Subtype fun x => Membership.mem f.ker x\n⊢ Eq (↑((f.fiberEquivKer a).symm g)) (HAdd.hAdd a ↑g)","decl":"@[to_additive (attr := simp)]\nlemma fiberEquivKer_symm_apply (f : α →* H) (a : α) (g : f.ker) :\n    (f.fiberEquivKer a).symm g = a * g :=\n  rfl\n\n"}
{"name":"AddMonoidHom.fiberEquiv_apply","module":"Mathlib.GroupTheory.Coset.Basic","initialProofState":"α : Type u_1\ninst✝¹ : AddGroup α\nH : Type u_2\ninst✝ : AddGroup H\nf : AddMonoidHom α H\na b : α\ng : ↑(Set.preimage (⇑f) (Singleton.singleton (f a)))\n⊢ Eq (↑((f.fiberEquiv a b) g)) (HAdd.hAdd b (HAdd.hAdd (Neg.neg a) ↑g))","decl":"@[to_additive (attr := simp)]\nlemma fiberEquiv_apply (f : α →* H) (a b : α) (g : f ⁻¹' {f a}) :\n    f.fiberEquiv a b g = b * (a⁻¹ * g) :=\n  rfl\n\n"}
{"name":"MonoidHom.fiberEquiv_apply","module":"Mathlib.GroupTheory.Coset.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Group α\nH : Type u_2\ninst✝ : Group H\nf : MonoidHom α H\na b : α\ng : ↑(Set.preimage (⇑f) (Singleton.singleton (f a)))\n⊢ Eq (↑((f.fiberEquiv a b) g)) (HMul.hMul b (HMul.hMul (Inv.inv a) ↑g))","decl":"@[to_additive (attr := simp)]\nlemma fiberEquiv_apply (f : α →* H) (a b : α) (g : f ⁻¹' {f a}) :\n    f.fiberEquiv a b g = b * (a⁻¹ * g) :=\n  rfl\n\n"}
{"name":"MonoidHom.fiberEquiv_symm_apply","module":"Mathlib.GroupTheory.Coset.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Group α\nH : Type u_2\ninst✝ : Group H\nf : MonoidHom α H\na b : α\ng : ↑(Set.preimage (⇑f) (Singleton.singleton (f b)))\n⊢ Eq (↑((f.fiberEquiv a b).symm g)) (HMul.hMul a (HMul.hMul (Inv.inv b) ↑g))","decl":"@[to_additive (attr := simp)]\nlemma fiberEquiv_symm_apply (f : α →* H) (a b : α) (g : f ⁻¹' {f b}) :\n    (f.fiberEquiv a b).symm g = a * (b⁻¹ * g) :=\n  rfl\n\n"}
{"name":"AddMonoidHom.fiberEquiv_symm_apply","module":"Mathlib.GroupTheory.Coset.Basic","initialProofState":"α : Type u_1\ninst✝¹ : AddGroup α\nH : Type u_2\ninst✝ : AddGroup H\nf : AddMonoidHom α H\na b : α\ng : ↑(Set.preimage (⇑f) (Singleton.singleton (f b)))\n⊢ Eq (↑((f.fiberEquiv a b).symm g)) (HAdd.hAdd a (HAdd.hAdd (Neg.neg b) ↑g))","decl":"@[to_additive (attr := simp)]\nlemma fiberEquiv_symm_apply (f : α →* H) (a b : α) (g : f ⁻¹' {f b}) :\n    (f.fiberEquiv a b).symm g = a * (b⁻¹ * g) :=\n  rfl\n\n"}
{"name":"QuotientGroup.univ_eq_iUnion_smul","module":"Mathlib.GroupTheory.Coset.Basic","initialProofState":"α : Type u_1\ninst✝ : Group α\nH : Subgroup α\n⊢ Eq Set.univ (Set.iUnion fun x => HSMul.hSMul (Quotient.out x) ↑H)","decl":"open MulAction in\n/-- A group is made up of a disjoint union of cosets of a subgroup. -/\n@[to_additive \"An additive group is made up of a disjoint union of cosets of an additive\nsubgroup.\"]\nlemma univ_eq_iUnion_smul (H : Subgroup α) :\n    (Set.univ (α := α)) = ⋃ x : α ⧸ H, x.out • (H : Set _) := by\n  simp_rw [univ_eq_iUnion_orbit H.op, orbit_eq_out_smul]\n  rfl\n\n"}
{"name":"QuotientAddGroup.univ_eq_iUnion_vadd","module":"Mathlib.GroupTheory.Coset.Basic","initialProofState":"α : Type u_1\ninst✝ : AddGroup α\nH : AddSubgroup α\n⊢ Eq Set.univ (Set.iUnion fun x => HVAdd.hVAdd (Quotient.out x) ↑H)","decl":"open MulAction in\n/-- A group is made up of a disjoint union of cosets of a subgroup. -/\n@[to_additive \"An additive group is made up of a disjoint union of cosets of an additive\nsubgroup.\"]\nlemma univ_eq_iUnion_smul (H : Subgroup α) :\n    (Set.univ (α := α)) = ⋃ x : α ⧸ H, x.out • (H : Set _) := by\n  simp_rw [univ_eq_iUnion_orbit H.op, orbit_eq_out_smul]\n  rfl\n\n"}
