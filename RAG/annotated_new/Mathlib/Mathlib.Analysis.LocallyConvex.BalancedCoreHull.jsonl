{"name":"balancedCore_subset","module":"Mathlib.Analysis.LocallyConvex.BalancedCoreHull","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝¹ : SeminormedRing 𝕜\ninst✝ : SMul 𝕜 E\ns : Set E\n⊢ HasSubset.Subset (balancedCore 𝕜 s) s","decl":"theorem balancedCore_subset (s : Set E) : balancedCore 𝕜 s ⊆ s :=\n  sUnion_subset fun _ ht => ht.2\n\n"}
{"name":"balancedCore_empty","module":"Mathlib.Analysis.LocallyConvex.BalancedCoreHull","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝¹ : SeminormedRing 𝕜\ninst✝ : SMul 𝕜 E\n⊢ Eq (balancedCore 𝕜 EmptyCollection.emptyCollection) EmptyCollection.emptyCollection","decl":"theorem balancedCore_empty : balancedCore 𝕜 (∅ : Set E) = ∅ :=\n  eq_empty_of_subset_empty (balancedCore_subset _)\n\n"}
{"name":"mem_balancedCore_iff","module":"Mathlib.Analysis.LocallyConvex.BalancedCoreHull","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝¹ : SeminormedRing 𝕜\ninst✝ : SMul 𝕜 E\ns : Set E\nx : E\n⊢ Iff (Membership.mem (balancedCore 𝕜 s) x) (Exists fun t => And (Balanced 𝕜 t) (And (HasSubset.Subset t s) (Membership.mem t x)))","decl":"theorem mem_balancedCore_iff : x ∈ balancedCore 𝕜 s ↔ ∃ t, Balanced 𝕜 t ∧ t ⊆ s ∧ x ∈ t := by\n  simp_rw [balancedCore, mem_sUnion, mem_setOf_eq, and_assoc]\n\n"}
{"name":"smul_balancedCore_subset","module":"Mathlib.Analysis.LocallyConvex.BalancedCoreHull","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝¹ : SeminormedRing 𝕜\ninst✝ : SMul 𝕜 E\ns : Set E\na : 𝕜\nha : LE.le (Norm.norm a) 1\n⊢ HasSubset.Subset (HSMul.hSMul a (balancedCore 𝕜 s)) (balancedCore 𝕜 s)","decl":"theorem smul_balancedCore_subset (s : Set E) {a : 𝕜} (ha : ‖a‖ ≤ 1) :\n    a • balancedCore 𝕜 s ⊆ balancedCore 𝕜 s := by\n  rintro x ⟨y, hy, rfl⟩\n  rw [mem_balancedCore_iff] at hy\n  rcases hy with ⟨t, ht1, ht2, hy⟩\n  exact ⟨t, ⟨ht1, ht2⟩, ht1 a ha (smul_mem_smul_set hy)⟩\n\n"}
{"name":"balancedCore_balanced","module":"Mathlib.Analysis.LocallyConvex.BalancedCoreHull","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝¹ : SeminormedRing 𝕜\ninst✝ : SMul 𝕜 E\ns : Set E\n⊢ Balanced 𝕜 (balancedCore 𝕜 s)","decl":"theorem balancedCore_balanced (s : Set E) : Balanced 𝕜 (balancedCore 𝕜 s) := fun _ =>\n  smul_balancedCore_subset s\n\n"}
{"name":"Balanced.subset_balancedCore_of_subset","module":"Mathlib.Analysis.LocallyConvex.BalancedCoreHull","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝¹ : SeminormedRing 𝕜\ninst✝ : SMul 𝕜 E\ns t : Set E\nhs : Balanced 𝕜 s\nh : HasSubset.Subset s t\n⊢ HasSubset.Subset s (balancedCore 𝕜 t)","decl":"/-- The balanced core of `t` is maximal in the sense that it contains any balanced subset\n`s` of `t`. -/\ntheorem Balanced.subset_balancedCore_of_subset (hs : Balanced 𝕜 s) (h : s ⊆ t) :\n    s ⊆ balancedCore 𝕜 t :=\n  subset_sUnion_of_mem ⟨hs, h⟩\n\n"}
{"name":"mem_balancedCoreAux_iff","module":"Mathlib.Analysis.LocallyConvex.BalancedCoreHull","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝¹ : SeminormedRing 𝕜\ninst✝ : SMul 𝕜 E\ns : Set E\nx : E\n⊢ Iff (Membership.mem (balancedCoreAux 𝕜 s) x) (∀ (r : 𝕜), LE.le 1 (Norm.norm r) → Membership.mem (HSMul.hSMul r s) x)","decl":"theorem mem_balancedCoreAux_iff : x ∈ balancedCoreAux 𝕜 s ↔ ∀ r : 𝕜, 1 ≤ ‖r‖ → x ∈ r • s :=\n  mem_iInter₂\n\n"}
{"name":"mem_balancedHull_iff","module":"Mathlib.Analysis.LocallyConvex.BalancedCoreHull","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝¹ : SeminormedRing 𝕜\ninst✝ : SMul 𝕜 E\ns : Set E\nx : E\n⊢ Iff (Membership.mem (balancedHull 𝕜 s) x) (Exists fun r => And (LE.le (Norm.norm r) 1) (Membership.mem (HSMul.hSMul r s) x))","decl":"theorem mem_balancedHull_iff : x ∈ balancedHull 𝕜 s ↔ ∃ r : 𝕜, ‖r‖ ≤ 1 ∧ x ∈ r • s := by\n  simp [balancedHull]\n\n"}
{"name":"Balanced.balancedHull_subset_of_subset","module":"Mathlib.Analysis.LocallyConvex.BalancedCoreHull","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝¹ : SeminormedRing 𝕜\ninst✝ : SMul 𝕜 E\ns t : Set E\nht : Balanced 𝕜 t\nh : HasSubset.Subset s t\n⊢ HasSubset.Subset (balancedHull 𝕜 s) t","decl":"/-- The balanced hull of `s` is minimal in the sense that it is contained in any balanced superset\n`t` of `s`. -/\ntheorem Balanced.balancedHull_subset_of_subset (ht : Balanced 𝕜 t) (h : s ⊆ t) :\n    balancedHull 𝕜 s ⊆ t := by\n  intros x hx\n  obtain ⟨r, hr, y, hy, rfl⟩ := mem_balancedHull_iff.1 hx\n  exact ht.smul_mem hr (h hy)\n\n"}
{"name":"balancedHull_mono","module":"Mathlib.Analysis.LocallyConvex.BalancedCoreHull","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝¹ : SeminormedRing 𝕜\ninst✝ : SMul 𝕜 E\ns t : Set E\nhst : HasSubset.Subset s t\n⊢ HasSubset.Subset (balancedHull 𝕜 s) (balancedHull 𝕜 t)","decl":"@[mono, gcongr]\ntheorem balancedHull_mono (hst : s ⊆ t) : balancedHull 𝕜 s ⊆ balancedHull 𝕜 t := by\n  intro x hx\n  rw [mem_balancedHull_iff] at *\n  obtain ⟨r, hr₁, hr₂⟩ := hx\n  use r\n  exact ⟨hr₁, smul_set_mono hst hr₂⟩\n\n"}
{"name":"balancedCore_zero_mem","module":"Mathlib.Analysis.LocallyConvex.BalancedCoreHull","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : SeminormedRing 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\ns : Set E\nhs : Membership.mem s 0\n⊢ Membership.mem (balancedCore 𝕜 s) 0","decl":"theorem balancedCore_zero_mem (hs : (0 : E) ∈ s) : (0 : E) ∈ balancedCore 𝕜 s :=\n  mem_balancedCore_iff.2 ⟨0, balanced_zero, zero_subset.2 hs, Set.zero_mem_zero⟩\n\n"}
{"name":"balancedCore_nonempty_iff","module":"Mathlib.Analysis.LocallyConvex.BalancedCoreHull","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : SeminormedRing 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\ns : Set E\n⊢ Iff (balancedCore 𝕜 s).Nonempty (Membership.mem s 0)","decl":"theorem balancedCore_nonempty_iff : (balancedCore 𝕜 s).Nonempty ↔ (0 : E) ∈ s :=\n  ⟨fun h => zero_subset.1 <| (zero_smul_set h).superset.trans <|\n    (balancedCore_balanced s (0 : 𝕜) <| norm_zero.trans_le zero_le_one).trans <|\n      balancedCore_subset _,\n    fun h => ⟨0, balancedCore_zero_mem h⟩⟩\n\n"}
{"name":"subset_balancedHull","module":"Mathlib.Analysis.LocallyConvex.BalancedCoreHull","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝³ : SeminormedRing 𝕜\ninst✝² : AddCommGroup E\ninst✝¹ : Module 𝕜 E\ninst✝ : NormOneClass 𝕜\ns : Set E\n⊢ HasSubset.Subset s (balancedHull 𝕜 s)","decl":"theorem subset_balancedHull [NormOneClass 𝕜] {s : Set E} : s ⊆ balancedHull 𝕜 s := fun _ hx =>\n  mem_balancedHull_iff.2 ⟨1, norm_one.le, _, hx, one_smul _ _⟩\n\n"}
{"name":"balancedHull.balanced","module":"Mathlib.Analysis.LocallyConvex.BalancedCoreHull","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : SeminormedRing 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\ns : Set E\n⊢ Balanced 𝕜 (balancedHull 𝕜 s)","decl":"theorem balancedHull.balanced (s : Set E) : Balanced 𝕜 (balancedHull 𝕜 s) := by\n  intro a ha\n  simp_rw [balancedHull, smul_set_iUnion₂, subset_def, mem_iUnion₂]\n  rintro x ⟨r, hr, hx⟩\n  rw [← smul_assoc] at hx\n  exact ⟨a • r, (SeminormedRing.norm_mul _ _).trans (mul_le_one₀ ha (norm_nonneg r) hr), hx⟩\n\n"}
{"name":"balancedHull_add_subset","module":"Mathlib.Analysis.LocallyConvex.BalancedCoreHull","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝³ : SeminormedRing 𝕜\ninst✝² : AddCommGroup E\ninst✝¹ : Module 𝕜 E\ns : Set E\ninst✝ : NormOneClass 𝕜\nt : Set E\n⊢ HasSubset.Subset (balancedHull 𝕜 (HAdd.hAdd s t)) (HAdd.hAdd (balancedHull 𝕜 s) (balancedHull 𝕜 t))","decl":"open Balanced in\ntheorem balancedHull_add_subset [NormOneClass 𝕜] {t : Set E} :\n    balancedHull 𝕜 (s + t) ⊆ balancedHull 𝕜 s + balancedHull 𝕜 t :=\n  balancedHull_subset_of_subset (add (balancedHull.balanced _) (balancedHull.balanced _))\n    (add_subset_add (subset_balancedHull _) (subset_balancedHull _))\n\n"}
{"name":"balancedCoreAux_empty","module":"Mathlib.Analysis.LocallyConvex.BalancedCoreHull","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : NormedDivisionRing 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\n⊢ Eq (balancedCoreAux 𝕜 EmptyCollection.emptyCollection) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem balancedCoreAux_empty : balancedCoreAux 𝕜 (∅ : Set E) = ∅ := by\n  simp_rw [balancedCoreAux, iInter₂_eq_empty_iff, smul_set_empty]\n  exact fun _ => ⟨1, norm_one.ge, not_mem_empty _⟩\n\n"}
{"name":"balancedCoreAux_subset","module":"Mathlib.Analysis.LocallyConvex.BalancedCoreHull","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : NormedDivisionRing 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\ns : Set E\n⊢ HasSubset.Subset (balancedCoreAux 𝕜 s) s","decl":"theorem balancedCoreAux_subset (s : Set E) : balancedCoreAux 𝕜 s ⊆ s := fun x hx => by\n  simpa only [one_smul] using mem_balancedCoreAux_iff.1 hx 1 norm_one.ge\n\n"}
{"name":"balancedCoreAux_balanced","module":"Mathlib.Analysis.LocallyConvex.BalancedCoreHull","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : NormedDivisionRing 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\ns : Set E\nh0 : Membership.mem (balancedCoreAux 𝕜 s) 0\n⊢ Balanced 𝕜 (balancedCoreAux 𝕜 s)","decl":"theorem balancedCoreAux_balanced (h0 : (0 : E) ∈ balancedCoreAux 𝕜 s) :\n    Balanced 𝕜 (balancedCoreAux 𝕜 s) := by\n  rintro a ha x ⟨y, hy, rfl⟩\n  obtain rfl | h := eq_or_ne a 0\n  · simp_rw [zero_smul, h0]\n  rw [mem_balancedCoreAux_iff] at hy ⊢\n  intro r hr\n  have h'' : 1 ≤ ‖a⁻¹ • r‖ := by\n    rw [norm_smul, norm_inv]\n    exact one_le_mul_of_one_le_of_one_le ((one_le_inv₀ (norm_pos_iff.mpr h)).2 ha) hr\n  have h' := hy (a⁻¹ • r) h''\n  rwa [smul_assoc, mem_inv_smul_set_iff₀ h] at h'\n\n"}
{"name":"balancedCoreAux_maximal","module":"Mathlib.Analysis.LocallyConvex.BalancedCoreHull","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : NormedDivisionRing 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\ns t : Set E\nh : HasSubset.Subset t s\nht : Balanced 𝕜 t\n⊢ HasSubset.Subset t (balancedCoreAux 𝕜 s)","decl":"theorem balancedCoreAux_maximal (h : t ⊆ s) (ht : Balanced 𝕜 t) : t ⊆ balancedCoreAux 𝕜 s := by\n  refine fun x hx => mem_balancedCoreAux_iff.2 fun r hr => ?_\n  rw [mem_smul_set_iff_inv_smul_mem₀ (norm_pos_iff.mp <| zero_lt_one.trans_le hr)]\n  refine h (ht.smul_mem ?_ hx)\n  rw [norm_inv]\n  exact inv_le_one_of_one_le₀ hr\n\n"}
{"name":"balancedCore_subset_balancedCoreAux","module":"Mathlib.Analysis.LocallyConvex.BalancedCoreHull","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : NormedDivisionRing 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\ns : Set E\n⊢ HasSubset.Subset (balancedCore 𝕜 s) (balancedCoreAux 𝕜 s)","decl":"theorem balancedCore_subset_balancedCoreAux : balancedCore 𝕜 s ⊆ balancedCoreAux 𝕜 s :=\n  balancedCoreAux_maximal (balancedCore_subset s) (balancedCore_balanced s)\n\n"}
{"name":"balancedCore_eq_iInter","module":"Mathlib.Analysis.LocallyConvex.BalancedCoreHull","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : NormedDivisionRing 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\ns : Set E\nhs : Membership.mem s 0\n⊢ Eq (balancedCore 𝕜 s) (Set.iInter fun r => Set.iInter fun x => HSMul.hSMul r s)","decl":"theorem balancedCore_eq_iInter (hs : (0 : E) ∈ s) :\n    balancedCore 𝕜 s = ⋂ (r : 𝕜) (_ : 1 ≤ ‖r‖), r • s := by\n  refine balancedCore_subset_balancedCoreAux.antisymm ?_\n  refine (balancedCoreAux_balanced ?_).subset_balancedCore_of_subset (balancedCoreAux_subset s)\n  exact balancedCore_subset_balancedCoreAux (balancedCore_zero_mem hs)\n\n"}
{"name":"subset_balancedCore","module":"Mathlib.Analysis.LocallyConvex.BalancedCoreHull","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : NormedDivisionRing 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\ns t : Set E\nht : Membership.mem t 0\nhst : ∀ (a : 𝕜), LE.le (Norm.norm a) 1 → HasSubset.Subset (HSMul.hSMul a s) t\n⊢ HasSubset.Subset s (balancedCore 𝕜 t)","decl":"theorem subset_balancedCore (ht : (0 : E) ∈ t) (hst : ∀ a : 𝕜, ‖a‖ ≤ 1 → a • s ⊆ t) :\n    s ⊆ balancedCore 𝕜 t := by\n  rw [balancedCore_eq_iInter ht]\n  refine subset_iInter₂ fun a ha ↦ ?_\n  rw [subset_smul_set_iff₀ (norm_pos_iff.mp <| zero_lt_one.trans_le ha)]\n  apply hst\n  rw [norm_inv]\n  exact inv_le_one_of_one_le₀ ha\n\n"}
{"name":"IsClosed.balancedCore","module":"Mathlib.Analysis.LocallyConvex.BalancedCoreHull","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁴ : NormedDivisionRing 𝕜\ninst✝³ : AddCommGroup E\ninst✝² : Module 𝕜 E\ninst✝¹ : TopologicalSpace E\ninst✝ : ContinuousSMul 𝕜 E\nU : Set E\nhU : IsClosed U\n⊢ IsClosed (balancedCore 𝕜 U)","decl":"protected theorem IsClosed.balancedCore (hU : IsClosed U) : IsClosed (balancedCore 𝕜 U) := by\n  by_cases h : (0 : E) ∈ U\n  · rw [balancedCore_eq_iInter h]\n    refine isClosed_iInter fun a => ?_\n    refine isClosed_iInter fun ha => ?_\n    have ha' := lt_of_lt_of_le zero_lt_one ha\n    rw [norm_pos_iff] at ha'\n    exact isClosedMap_smul_of_ne_zero ha' U hU\n  · have : balancedCore 𝕜 U = ∅ := by\n      contrapose! h\n      exact balancedCore_nonempty_iff.mp h\n    rw [this]\n    exact isClosed_empty\n\n-- We don't have a `NontriviallyNormedDivisionRing`, so we use a `NeBot` assumption instead\n"}
{"name":"balancedCore_mem_nhds_zero","module":"Mathlib.Analysis.LocallyConvex.BalancedCoreHull","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁵ : NormedDivisionRing 𝕜\ninst✝⁴ : AddCommGroup E\ninst✝³ : Module 𝕜 E\ninst✝² : TopologicalSpace E\ninst✝¹ : ContinuousSMul 𝕜 E\nU : Set E\ninst✝ : (nhdsWithin 0 (HasCompl.compl (Singleton.singleton 0))).NeBot\nhU : Membership.mem (nhds 0) U\n⊢ Membership.mem (nhds 0) (balancedCore 𝕜 U)","decl":"theorem balancedCore_mem_nhds_zero (hU : U ∈ 𝓝 (0 : E)) : balancedCore 𝕜 U ∈ 𝓝 (0 : E) := by\n  -- Getting neighborhoods of the origin for `0 : 𝕜` and `0 : E`\n  obtain ⟨r, V, hr, hV, hrVU⟩ : ∃ (r : ℝ) (V : Set E),\n      0 < r ∧ V ∈ 𝓝 (0 : E) ∧ ∀ (c : 𝕜) (y : E), ‖c‖ < r → y ∈ V → c • y ∈ U := by\n    have h : Filter.Tendsto (fun x : 𝕜 × E => x.fst • x.snd) (𝓝 (0, 0)) (𝓝 0) :=\n      continuous_smul.tendsto' (0, 0) _ (smul_zero _)\n    simpa only [← Prod.exists', ← Prod.forall', ← and_imp, ← and_assoc, exists_prop] using\n      h.basis_left (NormedAddCommGroup.nhds_zero_basis_norm_lt.prod_nhds (𝓝 _).basis_sets) U hU\n  obtain ⟨y, hyr, hy₀⟩ : ∃ y : 𝕜, ‖y‖ < r ∧ y ≠ 0 :=\n    Filter.nonempty_of_mem <|\n      (nhdsWithin_hasBasis NormedAddCommGroup.nhds_zero_basis_norm_lt {0}ᶜ).mem_of_mem hr\n  have : y • V ∈ 𝓝 (0 : E) := (set_smul_mem_nhds_zero_iff hy₀).mpr hV\n  -- It remains to show that `y • V ⊆ balancedCore 𝕜 U`\n  refine Filter.mem_of_superset this (subset_balancedCore (mem_of_mem_nhds hU) fun a ha => ?_)\n  rw [smul_smul]\n  rintro _ ⟨z, hz, rfl⟩\n  refine hrVU _ _ ?_ hz\n  rw [norm_mul, ← one_mul r]\n  exact mul_lt_mul' ha hyr (norm_nonneg y) one_pos\n\n"}
{"name":"nhds_basis_balanced","module":"Mathlib.Analysis.LocallyConvex.BalancedCoreHull","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁵ : NormedDivisionRing 𝕜\ninst✝⁴ : AddCommGroup E\ninst✝³ : Module 𝕜 E\ninst✝² : TopologicalSpace E\ninst✝¹ : ContinuousSMul 𝕜 E\ninst✝ : (nhdsWithin 0 (HasCompl.compl (Singleton.singleton 0))).NeBot\n⊢ (nhds 0).HasBasis (fun s => And (Membership.mem (nhds 0) s) (Balanced 𝕜 s)) id","decl":"theorem nhds_basis_balanced :\n    (𝓝 (0 : E)).HasBasis (fun s : Set E => s ∈ 𝓝 (0 : E) ∧ Balanced 𝕜 s) id :=\n  Filter.hasBasis_self.mpr fun s hs =>\n    ⟨balancedCore 𝕜 s, balancedCore_mem_nhds_zero hs, balancedCore_balanced s,\n      balancedCore_subset s⟩\n\n"}
{"name":"nhds_basis_closed_balanced","module":"Mathlib.Analysis.LocallyConvex.BalancedCoreHull","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁶ : NormedDivisionRing 𝕜\ninst✝⁵ : AddCommGroup E\ninst✝⁴ : Module 𝕜 E\ninst✝³ : TopologicalSpace E\ninst✝² : ContinuousSMul 𝕜 E\ninst✝¹ : (nhdsWithin 0 (HasCompl.compl (Singleton.singleton 0))).NeBot\ninst✝ : RegularSpace E\n⊢ (nhds 0).HasBasis (fun s => And (Membership.mem (nhds 0) s) (And (IsClosed s) (Balanced 𝕜 s))) id","decl":"theorem nhds_basis_closed_balanced [RegularSpace E] :\n    (𝓝 (0 : E)).HasBasis (fun s : Set E => s ∈ 𝓝 (0 : E) ∧ IsClosed s ∧ Balanced 𝕜 s) id := by\n  refine\n    (closed_nhds_basis 0).to_hasBasis (fun s hs => ?_) fun s hs => ⟨s, ⟨hs.1, hs.2.1⟩, rfl.subset⟩\n  refine ⟨balancedCore 𝕜 s, ⟨balancedCore_mem_nhds_zero hs.1, ?_⟩, balancedCore_subset s⟩\n  exact ⟨hs.2.balancedCore, balancedCore_balanced s⟩\n\n"}
