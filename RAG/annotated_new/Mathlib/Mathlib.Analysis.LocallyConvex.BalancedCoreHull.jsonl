{"name":"balancedCore_subset","module":"Mathlib.Analysis.LocallyConvex.BalancedCoreHull","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ¹ : SeminormedRing ğ•œ\ninstâœ : SMul ğ•œ E\ns : Set E\nâŠ¢ HasSubset.Subset (balancedCore ğ•œ s) s","decl":"theorem balancedCore_subset (s : Set E) : balancedCore ğ•œ s âŠ† s :=\n  sUnion_subset fun _ ht => ht.2\n\n"}
{"name":"balancedCore_empty","module":"Mathlib.Analysis.LocallyConvex.BalancedCoreHull","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ¹ : SeminormedRing ğ•œ\ninstâœ : SMul ğ•œ E\nâŠ¢ Eq (balancedCore ğ•œ EmptyCollection.emptyCollection) EmptyCollection.emptyCollection","decl":"theorem balancedCore_empty : balancedCore ğ•œ (âˆ… : Set E) = âˆ… :=\n  eq_empty_of_subset_empty (balancedCore_subset _)\n\n"}
{"name":"mem_balancedCore_iff","module":"Mathlib.Analysis.LocallyConvex.BalancedCoreHull","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ¹ : SeminormedRing ğ•œ\ninstâœ : SMul ğ•œ E\ns : Set E\nx : E\nâŠ¢ Iff (Membership.mem (balancedCore ğ•œ s) x) (Exists fun t => And (Balanced ğ•œ t) (And (HasSubset.Subset t s) (Membership.mem t x)))","decl":"theorem mem_balancedCore_iff : x âˆˆ balancedCore ğ•œ s â†” âˆƒ t, Balanced ğ•œ t âˆ§ t âŠ† s âˆ§ x âˆˆ t := by\n  simp_rw [balancedCore, mem_sUnion, mem_setOf_eq, and_assoc]\n\n"}
{"name":"smul_balancedCore_subset","module":"Mathlib.Analysis.LocallyConvex.BalancedCoreHull","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ¹ : SeminormedRing ğ•œ\ninstâœ : SMul ğ•œ E\ns : Set E\na : ğ•œ\nha : LE.le (Norm.norm a) 1\nâŠ¢ HasSubset.Subset (HSMul.hSMul a (balancedCore ğ•œ s)) (balancedCore ğ•œ s)","decl":"theorem smul_balancedCore_subset (s : Set E) {a : ğ•œ} (ha : â€–aâ€– â‰¤ 1) :\n    a â€¢ balancedCore ğ•œ s âŠ† balancedCore ğ•œ s := by\n  rintro x âŸ¨y, hy, rflâŸ©\n  rw [mem_balancedCore_iff] at hy\n  rcases hy with âŸ¨t, ht1, ht2, hyâŸ©\n  exact âŸ¨t, âŸ¨ht1, ht2âŸ©, ht1 a ha (smul_mem_smul_set hy)âŸ©\n\n"}
{"name":"balancedCore_balanced","module":"Mathlib.Analysis.LocallyConvex.BalancedCoreHull","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ¹ : SeminormedRing ğ•œ\ninstâœ : SMul ğ•œ E\ns : Set E\nâŠ¢ Balanced ğ•œ (balancedCore ğ•œ s)","decl":"theorem balancedCore_balanced (s : Set E) : Balanced ğ•œ (balancedCore ğ•œ s) := fun _ =>\n  smul_balancedCore_subset s\n\n"}
{"name":"Balanced.subset_balancedCore_of_subset","module":"Mathlib.Analysis.LocallyConvex.BalancedCoreHull","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ¹ : SeminormedRing ğ•œ\ninstâœ : SMul ğ•œ E\ns t : Set E\nhs : Balanced ğ•œ s\nh : HasSubset.Subset s t\nâŠ¢ HasSubset.Subset s (balancedCore ğ•œ t)","decl":"/-- The balanced core of `t` is maximal in the sense that it contains any balanced subset\n`s` of `t`. -/\ntheorem Balanced.subset_balancedCore_of_subset (hs : Balanced ğ•œ s) (h : s âŠ† t) :\n    s âŠ† balancedCore ğ•œ t :=\n  subset_sUnion_of_mem âŸ¨hs, hâŸ©\n\n"}
{"name":"mem_balancedCoreAux_iff","module":"Mathlib.Analysis.LocallyConvex.BalancedCoreHull","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ¹ : SeminormedRing ğ•œ\ninstâœ : SMul ğ•œ E\ns : Set E\nx : E\nâŠ¢ Iff (Membership.mem (balancedCoreAux ğ•œ s) x) (âˆ€ (r : ğ•œ), LE.le 1 (Norm.norm r) â†’ Membership.mem (HSMul.hSMul r s) x)","decl":"theorem mem_balancedCoreAux_iff : x âˆˆ balancedCoreAux ğ•œ s â†” âˆ€ r : ğ•œ, 1 â‰¤ â€–râ€– â†’ x âˆˆ r â€¢ s :=\n  mem_iInterâ‚‚\n\n"}
{"name":"mem_balancedHull_iff","module":"Mathlib.Analysis.LocallyConvex.BalancedCoreHull","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ¹ : SeminormedRing ğ•œ\ninstâœ : SMul ğ•œ E\ns : Set E\nx : E\nâŠ¢ Iff (Membership.mem (balancedHull ğ•œ s) x) (Exists fun r => And (LE.le (Norm.norm r) 1) (Membership.mem (HSMul.hSMul r s) x))","decl":"theorem mem_balancedHull_iff : x âˆˆ balancedHull ğ•œ s â†” âˆƒ r : ğ•œ, â€–râ€– â‰¤ 1 âˆ§ x âˆˆ r â€¢ s := by\n  simp [balancedHull]\n\n"}
{"name":"Balanced.balancedHull_subset_of_subset","module":"Mathlib.Analysis.LocallyConvex.BalancedCoreHull","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ¹ : SeminormedRing ğ•œ\ninstâœ : SMul ğ•œ E\ns t : Set E\nht : Balanced ğ•œ t\nh : HasSubset.Subset s t\nâŠ¢ HasSubset.Subset (balancedHull ğ•œ s) t","decl":"/-- The balanced hull of `s` is minimal in the sense that it is contained in any balanced superset\n`t` of `s`. -/\ntheorem Balanced.balancedHull_subset_of_subset (ht : Balanced ğ•œ t) (h : s âŠ† t) :\n    balancedHull ğ•œ s âŠ† t := by\n  intros x hx\n  obtain âŸ¨r, hr, y, hy, rflâŸ© := mem_balancedHull_iff.1 hx\n  exact ht.smul_mem hr (h hy)\n\n"}
{"name":"balancedHull_mono","module":"Mathlib.Analysis.LocallyConvex.BalancedCoreHull","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ¹ : SeminormedRing ğ•œ\ninstâœ : SMul ğ•œ E\ns t : Set E\nhst : HasSubset.Subset s t\nâŠ¢ HasSubset.Subset (balancedHull ğ•œ s) (balancedHull ğ•œ t)","decl":"@[mono, gcongr]\ntheorem balancedHull_mono (hst : s âŠ† t) : balancedHull ğ•œ s âŠ† balancedHull ğ•œ t := by\n  intro x hx\n  rw [mem_balancedHull_iff] at *\n  obtain âŸ¨r, hrâ‚, hrâ‚‚âŸ© := hx\n  use r\n  exact âŸ¨hrâ‚, smul_set_mono hst hrâ‚‚âŸ©\n\n"}
{"name":"balancedCore_zero_mem","module":"Mathlib.Analysis.LocallyConvex.BalancedCoreHull","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : SeminormedRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\ns : Set E\nhs : Membership.mem s 0\nâŠ¢ Membership.mem (balancedCore ğ•œ s) 0","decl":"theorem balancedCore_zero_mem (hs : (0 : E) âˆˆ s) : (0 : E) âˆˆ balancedCore ğ•œ s :=\n  mem_balancedCore_iff.2 âŸ¨0, balanced_zero, zero_subset.2 hs, Set.zero_mem_zeroâŸ©\n\n"}
{"name":"balancedCore_nonempty_iff","module":"Mathlib.Analysis.LocallyConvex.BalancedCoreHull","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : SeminormedRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\ns : Set E\nâŠ¢ Iff (balancedCore ğ•œ s).Nonempty (Membership.mem s 0)","decl":"theorem balancedCore_nonempty_iff : (balancedCore ğ•œ s).Nonempty â†” (0 : E) âˆˆ s :=\n  âŸ¨fun h => zero_subset.1 <| (zero_smul_set h).superset.trans <|\n    (balancedCore_balanced s (0 : ğ•œ) <| norm_zero.trans_le zero_le_one).trans <|\n      balancedCore_subset _,\n    fun h => âŸ¨0, balancedCore_zero_mem hâŸ©âŸ©\n\n"}
{"name":"subset_balancedHull","module":"Mathlib.Analysis.LocallyConvex.BalancedCoreHull","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : SeminormedRing ğ•œ\ninstâœÂ² : AddCommGroup E\ninstâœÂ¹ : Module ğ•œ E\ninstâœ : NormOneClass ğ•œ\ns : Set E\nâŠ¢ HasSubset.Subset s (balancedHull ğ•œ s)","decl":"theorem subset_balancedHull [NormOneClass ğ•œ] {s : Set E} : s âŠ† balancedHull ğ•œ s := fun _ hx =>\n  mem_balancedHull_iff.2 âŸ¨1, norm_one.le, _, hx, one_smul _ _âŸ©\n\n"}
{"name":"balancedHull.balanced","module":"Mathlib.Analysis.LocallyConvex.BalancedCoreHull","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : SeminormedRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\ns : Set E\nâŠ¢ Balanced ğ•œ (balancedHull ğ•œ s)","decl":"theorem balancedHull.balanced (s : Set E) : Balanced ğ•œ (balancedHull ğ•œ s) := by\n  intro a ha\n  simp_rw [balancedHull, smul_set_iUnionâ‚‚, subset_def, mem_iUnionâ‚‚]\n  rintro x âŸ¨r, hr, hxâŸ©\n  rw [â† smul_assoc] at hx\n  exact âŸ¨a â€¢ r, (SeminormedRing.norm_mul _ _).trans (mul_le_oneâ‚€ ha (norm_nonneg r) hr), hxâŸ©\n\n"}
{"name":"balancedHull_add_subset","module":"Mathlib.Analysis.LocallyConvex.BalancedCoreHull","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : SeminormedRing ğ•œ\ninstâœÂ² : AddCommGroup E\ninstâœÂ¹ : Module ğ•œ E\ns : Set E\ninstâœ : NormOneClass ğ•œ\nt : Set E\nâŠ¢ HasSubset.Subset (balancedHull ğ•œ (HAdd.hAdd s t)) (HAdd.hAdd (balancedHull ğ•œ s) (balancedHull ğ•œ t))","decl":"open Balanced in\ntheorem balancedHull_add_subset [NormOneClass ğ•œ] {t : Set E} :\n    balancedHull ğ•œ (s + t) âŠ† balancedHull ğ•œ s + balancedHull ğ•œ t :=\n  balancedHull_subset_of_subset (add (balancedHull.balanced _) (balancedHull.balanced _))\n    (add_subset_add (subset_balancedHull _) (subset_balancedHull _))\n\n"}
{"name":"balancedCoreAux_empty","module":"Mathlib.Analysis.LocallyConvex.BalancedCoreHull","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : NormedDivisionRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\nâŠ¢ Eq (balancedCoreAux ğ•œ EmptyCollection.emptyCollection) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem balancedCoreAux_empty : balancedCoreAux ğ•œ (âˆ… : Set E) = âˆ… := by\n  simp_rw [balancedCoreAux, iInterâ‚‚_eq_empty_iff, smul_set_empty]\n  exact fun _ => âŸ¨1, norm_one.ge, not_mem_empty _âŸ©\n\n"}
{"name":"balancedCoreAux_subset","module":"Mathlib.Analysis.LocallyConvex.BalancedCoreHull","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : NormedDivisionRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\ns : Set E\nâŠ¢ HasSubset.Subset (balancedCoreAux ğ•œ s) s","decl":"theorem balancedCoreAux_subset (s : Set E) : balancedCoreAux ğ•œ s âŠ† s := fun x hx => by\n  simpa only [one_smul] using mem_balancedCoreAux_iff.1 hx 1 norm_one.ge\n\n"}
{"name":"balancedCoreAux_balanced","module":"Mathlib.Analysis.LocallyConvex.BalancedCoreHull","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : NormedDivisionRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\ns : Set E\nh0 : Membership.mem (balancedCoreAux ğ•œ s) 0\nâŠ¢ Balanced ğ•œ (balancedCoreAux ğ•œ s)","decl":"theorem balancedCoreAux_balanced (h0 : (0 : E) âˆˆ balancedCoreAux ğ•œ s) :\n    Balanced ğ•œ (balancedCoreAux ğ•œ s) := by\n  rintro a ha x âŸ¨y, hy, rflâŸ©\n  obtain rfl | h := eq_or_ne a 0\n  Â· simp_rw [zero_smul, h0]\n  rw [mem_balancedCoreAux_iff] at hy âŠ¢\n  intro r hr\n  have h'' : 1 â‰¤ â€–aâ»Â¹ â€¢ râ€– := by\n    rw [norm_smul, norm_inv]\n    exact one_le_mul_of_one_le_of_one_le ((one_le_invâ‚€ (norm_pos_iff.mpr h)).2 ha) hr\n  have h' := hy (aâ»Â¹ â€¢ r) h''\n  rwa [smul_assoc, mem_inv_smul_set_iffâ‚€ h] at h'\n\n"}
{"name":"balancedCoreAux_maximal","module":"Mathlib.Analysis.LocallyConvex.BalancedCoreHull","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : NormedDivisionRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\ns t : Set E\nh : HasSubset.Subset t s\nht : Balanced ğ•œ t\nâŠ¢ HasSubset.Subset t (balancedCoreAux ğ•œ s)","decl":"theorem balancedCoreAux_maximal (h : t âŠ† s) (ht : Balanced ğ•œ t) : t âŠ† balancedCoreAux ğ•œ s := by\n  refine fun x hx => mem_balancedCoreAux_iff.2 fun r hr => ?_\n  rw [mem_smul_set_iff_inv_smul_memâ‚€ (norm_pos_iff.mp <| zero_lt_one.trans_le hr)]\n  refine h (ht.smul_mem ?_ hx)\n  rw [norm_inv]\n  exact inv_le_one_of_one_leâ‚€ hr\n\n"}
{"name":"balancedCore_subset_balancedCoreAux","module":"Mathlib.Analysis.LocallyConvex.BalancedCoreHull","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : NormedDivisionRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\ns : Set E\nâŠ¢ HasSubset.Subset (balancedCore ğ•œ s) (balancedCoreAux ğ•œ s)","decl":"theorem balancedCore_subset_balancedCoreAux : balancedCore ğ•œ s âŠ† balancedCoreAux ğ•œ s :=\n  balancedCoreAux_maximal (balancedCore_subset s) (balancedCore_balanced s)\n\n"}
{"name":"balancedCore_eq_iInter","module":"Mathlib.Analysis.LocallyConvex.BalancedCoreHull","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : NormedDivisionRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\ns : Set E\nhs : Membership.mem s 0\nâŠ¢ Eq (balancedCore ğ•œ s) (Set.iInter fun r => Set.iInter fun x => HSMul.hSMul r s)","decl":"theorem balancedCore_eq_iInter (hs : (0 : E) âˆˆ s) :\n    balancedCore ğ•œ s = â‹‚ (r : ğ•œ) (_ : 1 â‰¤ â€–râ€–), r â€¢ s := by\n  refine balancedCore_subset_balancedCoreAux.antisymm ?_\n  refine (balancedCoreAux_balanced ?_).subset_balancedCore_of_subset (balancedCoreAux_subset s)\n  exact balancedCore_subset_balancedCoreAux (balancedCore_zero_mem hs)\n\n"}
{"name":"subset_balancedCore","module":"Mathlib.Analysis.LocallyConvex.BalancedCoreHull","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : NormedDivisionRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\ns t : Set E\nht : Membership.mem t 0\nhst : âˆ€ (a : ğ•œ), LE.le (Norm.norm a) 1 â†’ HasSubset.Subset (HSMul.hSMul a s) t\nâŠ¢ HasSubset.Subset s (balancedCore ğ•œ t)","decl":"theorem subset_balancedCore (ht : (0 : E) âˆˆ t) (hst : âˆ€ a : ğ•œ, â€–aâ€– â‰¤ 1 â†’ a â€¢ s âŠ† t) :\n    s âŠ† balancedCore ğ•œ t := by\n  rw [balancedCore_eq_iInter ht]\n  refine subset_iInterâ‚‚ fun a ha â†¦ ?_\n  rw [subset_smul_set_iffâ‚€ (norm_pos_iff.mp <| zero_lt_one.trans_le ha)]\n  apply hst\n  rw [norm_inv]\n  exact inv_le_one_of_one_leâ‚€ ha\n\n"}
{"name":"IsClosed.balancedCore","module":"Mathlib.Analysis.LocallyConvex.BalancedCoreHull","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâ´ : NormedDivisionRing ğ•œ\ninstâœÂ³ : AddCommGroup E\ninstâœÂ² : Module ğ•œ E\ninstâœÂ¹ : TopologicalSpace E\ninstâœ : ContinuousSMul ğ•œ E\nU : Set E\nhU : IsClosed U\nâŠ¢ IsClosed (balancedCore ğ•œ U)","decl":"protected theorem IsClosed.balancedCore (hU : IsClosed U) : IsClosed (balancedCore ğ•œ U) := by\n  by_cases h : (0 : E) âˆˆ U\n  Â· rw [balancedCore_eq_iInter h]\n    refine isClosed_iInter fun a => ?_\n    refine isClosed_iInter fun ha => ?_\n    have ha' := lt_of_lt_of_le zero_lt_one ha\n    rw [norm_pos_iff] at ha'\n    exact isClosedMap_smul_of_ne_zero ha' U hU\n  Â· have : balancedCore ğ•œ U = âˆ… := by\n      contrapose! h\n      exact balancedCore_nonempty_iff.mp h\n    rw [this]\n    exact isClosed_empty\n\n-- We don't have a `NontriviallyNormedDivisionRing`, so we use a `NeBot` assumption instead\n"}
{"name":"balancedCore_mem_nhds_zero","module":"Mathlib.Analysis.LocallyConvex.BalancedCoreHull","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâµ : NormedDivisionRing ğ•œ\ninstâœâ´ : AddCommGroup E\ninstâœÂ³ : Module ğ•œ E\ninstâœÂ² : TopologicalSpace E\ninstâœÂ¹ : ContinuousSMul ğ•œ E\nU : Set E\ninstâœ : (nhdsWithin 0 (HasCompl.compl (Singleton.singleton 0))).NeBot\nhU : Membership.mem (nhds 0) U\nâŠ¢ Membership.mem (nhds 0) (balancedCore ğ•œ U)","decl":"theorem balancedCore_mem_nhds_zero (hU : U âˆˆ ğ“ (0 : E)) : balancedCore ğ•œ U âˆˆ ğ“ (0 : E) := by\n  -- Getting neighborhoods of the origin for `0 : ğ•œ` and `0 : E`\n  obtain âŸ¨r, V, hr, hV, hrVUâŸ© : âˆƒ (r : â„) (V : Set E),\n      0 < r âˆ§ V âˆˆ ğ“ (0 : E) âˆ§ âˆ€ (c : ğ•œ) (y : E), â€–câ€– < r â†’ y âˆˆ V â†’ c â€¢ y âˆˆ U := by\n    have h : Filter.Tendsto (fun x : ğ•œ Ã— E => x.fst â€¢ x.snd) (ğ“ (0, 0)) (ğ“ 0) :=\n      continuous_smul.tendsto' (0, 0) _ (smul_zero _)\n    simpa only [â† Prod.exists', â† Prod.forall', â† and_imp, â† and_assoc, exists_prop] using\n      h.basis_left (NormedAddCommGroup.nhds_zero_basis_norm_lt.prod_nhds (ğ“ _).basis_sets) U hU\n  obtain âŸ¨y, hyr, hyâ‚€âŸ© : âˆƒ y : ğ•œ, â€–yâ€– < r âˆ§ y â‰  0 :=\n    Filter.nonempty_of_mem <|\n      (nhdsWithin_hasBasis NormedAddCommGroup.nhds_zero_basis_norm_lt {0}á¶œ).mem_of_mem hr\n  have : y â€¢ V âˆˆ ğ“ (0 : E) := (set_smul_mem_nhds_zero_iff hyâ‚€).mpr hV\n  -- It remains to show that `y â€¢ V âŠ† balancedCore ğ•œ U`\n  refine Filter.mem_of_superset this (subset_balancedCore (mem_of_mem_nhds hU) fun a ha => ?_)\n  rw [smul_smul]\n  rintro _ âŸ¨z, hz, rflâŸ©\n  refine hrVU _ _ ?_ hz\n  rw [norm_mul, â† one_mul r]\n  exact mul_lt_mul' ha hyr (norm_nonneg y) one_pos\n\n"}
{"name":"nhds_basis_balanced","module":"Mathlib.Analysis.LocallyConvex.BalancedCoreHull","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâµ : NormedDivisionRing ğ•œ\ninstâœâ´ : AddCommGroup E\ninstâœÂ³ : Module ğ•œ E\ninstâœÂ² : TopologicalSpace E\ninstâœÂ¹ : ContinuousSMul ğ•œ E\ninstâœ : (nhdsWithin 0 (HasCompl.compl (Singleton.singleton 0))).NeBot\nâŠ¢ (nhds 0).HasBasis (fun s => And (Membership.mem (nhds 0) s) (Balanced ğ•œ s)) id","decl":"theorem nhds_basis_balanced :\n    (ğ“ (0 : E)).HasBasis (fun s : Set E => s âˆˆ ğ“ (0 : E) âˆ§ Balanced ğ•œ s) id :=\n  Filter.hasBasis_self.mpr fun s hs =>\n    âŸ¨balancedCore ğ•œ s, balancedCore_mem_nhds_zero hs, balancedCore_balanced s,\n      balancedCore_subset sâŸ©\n\n"}
{"name":"nhds_basis_closed_balanced","module":"Mathlib.Analysis.LocallyConvex.BalancedCoreHull","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâ¶ : NormedDivisionRing ğ•œ\ninstâœâµ : AddCommGroup E\ninstâœâ´ : Module ğ•œ E\ninstâœÂ³ : TopologicalSpace E\ninstâœÂ² : ContinuousSMul ğ•œ E\ninstâœÂ¹ : (nhdsWithin 0 (HasCompl.compl (Singleton.singleton 0))).NeBot\ninstâœ : RegularSpace E\nâŠ¢ (nhds 0).HasBasis (fun s => And (Membership.mem (nhds 0) s) (And (IsClosed s) (Balanced ğ•œ s))) id","decl":"theorem nhds_basis_closed_balanced [RegularSpace E] :\n    (ğ“ (0 : E)).HasBasis (fun s : Set E => s âˆˆ ğ“ (0 : E) âˆ§ IsClosed s âˆ§ Balanced ğ•œ s) id := by\n  refine\n    (closed_nhds_basis 0).to_hasBasis (fun s hs => ?_) fun s hs => âŸ¨s, âŸ¨hs.1, hs.2.1âŸ©, rfl.subsetâŸ©\n  refine âŸ¨balancedCore ğ•œ s, âŸ¨balancedCore_mem_nhds_zero hs.1, ?_âŸ©, balancedCore_subset sâŸ©\n  exact âŸ¨hs.2.balancedCore, balancedCore_balanced sâŸ©\n\n"}
