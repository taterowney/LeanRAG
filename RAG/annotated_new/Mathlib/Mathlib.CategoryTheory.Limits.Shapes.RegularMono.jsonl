{"name":"CategoryTheory.RegularMono.w","module":"Mathlib.CategoryTheory.Limits.Shapes.RegularMono","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX Y : C\nf : Quiver.Hom X Y\nself : CategoryTheory.RegularMono f\n⊢ Eq (CategoryTheory.CategoryStruct.comp f CategoryTheory.RegularMono.left) (CategoryTheory.CategoryStruct.comp f CategoryTheory.RegularMono.right)","decl":"/-- A regular monomorphism is a morphism which is the equalizer of some parallel pair. -/\nclass RegularMono (f : X ⟶ Y) where\n  /-- An object in `C` -/\n  Z : C -- Porting note: violates naming but what is better?\n  /-- A map from the codomain of `f` to `Z` -/\n  left : Y ⟶ Z\n  /-- Another map from the codomain of `f` to `Z` -/\n  right : Y ⟶ Z\n  /-- `f` equalizes the two maps -/\n  w : f ≫ left = f ≫ right := by aesop_cat\n  /-- `f` is the equalizer of the two maps -/\n  isLimit : IsLimit (Fork.ofι f w)\n\n"}
{"name":"CategoryTheory.RegularMono.w_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.RegularMono","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX Y : C\nf : Quiver.Hom X Y\nself : CategoryTheory.RegularMono f\nZ : C\nh : Quiver.Hom (CategoryTheory.RegularMono.Z f) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp CategoryTheory.RegularMono.left h)) (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp CategoryTheory.RegularMono.right h))","decl":"attribute [reassoc] RegularMono.w\n\n"}
{"name":"CategoryTheory.RegularMono.mono","module":"Mathlib.CategoryTheory.Limits.Shapes.RegularMono","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.RegularMono f\n⊢ CategoryTheory.Mono f","decl":"/-- Every regular monomorphism is a monomorphism. -/\ninstance (priority := 100) RegularMono.mono (f : X ⟶ Y) [RegularMono f] : Mono f :=\n  mono_of_isLimit_fork RegularMono.isLimit\n\n"}
{"name":"CategoryTheory.strongMono_of_regularMono","module":"Mathlib.CategoryTheory.Limits.Shapes.RegularMono","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.RegularMono f\n⊢ CategoryTheory.StrongMono f","decl":"instance (priority := 100) strongMono_of_regularMono (f : X ⟶ Y) [RegularMono f] : StrongMono f :=\n  StrongMono.mk' (by\n      intro A B z hz u v sq\n      have : v ≫ (RegularMono.left : Y ⟶ RegularMono.Z f) = v ≫ RegularMono.right := by\n        apply (cancel_epi z).1\n        repeat (rw [← Category.assoc, ← eq_whisker sq.w])\n        simp only [Category.assoc, RegularMono.w]\n      obtain ⟨t, ht⟩ := RegularMono.lift' _ _ this\n      refine CommSq.HasLift.mk' ⟨t, (cancel_mono f).1 ?_, ht⟩\n      simp only [Arrow.mk_hom, Arrow.homMk'_left, Category.assoc, ht, sq.w])\n\n"}
{"name":"CategoryTheory.isIso_of_regularMono_of_epi","module":"Mathlib.CategoryTheory.Limits.Shapes.RegularMono","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nX Y : C\nf : Quiver.Hom X Y\ninst✝¹ : CategoryTheory.RegularMono f\ninst✝ : CategoryTheory.Epi f\n⊢ CategoryTheory.IsIso f","decl":"/-- A regular monomorphism is an isomorphism if it is an epimorphism. -/\ntheorem isIso_of_regularMono_of_epi (f : X ⟶ Y) [RegularMono f] [Epi f] : IsIso f :=\n  isIso_of_epi_of_strongMono _\n\n"}
{"name":"CategoryTheory.IsRegularMonoCategory.regularMonoOfMono","module":"Mathlib.CategoryTheory.Limits.Shapes.RegularMono","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nself : CategoryTheory.IsRegularMonoCategory C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Mono f\n⊢ Nonempty (CategoryTheory.RegularMono f)","decl":"/-- A regular mono category is a category in which every monomorphism is regular. -/\nclass IsRegularMonoCategory : Prop where\n  /-- Every monomorphism is a regular monomorphism -/\n  regularMonoOfMono : ∀ {X Y : C} (f : X ⟶ Y) [Mono f], Nonempty (RegularMono f)\n\n"}
{"name":"CategoryTheory.regularMonoCategoryOfSplitMonoCategory","module":"Mathlib.CategoryTheory.Limits.Shapes.RegularMono","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.SplitMonoCategory C\n⊢ CategoryTheory.IsRegularMonoCategory C","decl":"instance (priority := 100) regularMonoCategoryOfSplitMonoCategory [SplitMonoCategory C] :\n    IsRegularMonoCategory C where\n  regularMonoOfMono f _ := ⟨by\n    haveI := isSplitMono_of_mono f\n    infer_instance⟩\n\n"}
{"name":"CategoryTheory.strongMonoCategory_of_regularMonoCategory","module":"Mathlib.CategoryTheory.Limits.Shapes.RegularMono","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.IsRegularMonoCategory C\n⊢ CategoryTheory.StrongMonoCategory C","decl":"instance (priority := 100) strongMonoCategory_of_regularMonoCategory [IsRegularMonoCategory C] :\n    StrongMonoCategory C where\n  strongMono_of_mono f _ := by\n    haveI := regularMonoOfMono f\n    infer_instance\n\n"}
{"name":"CategoryTheory.RegularEpi.w","module":"Mathlib.CategoryTheory.Limits.Shapes.RegularMono","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX Y : C\nf : Quiver.Hom X Y\nself : CategoryTheory.RegularEpi f\n⊢ Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.RegularEpi.left f) (CategoryTheory.CategoryStruct.comp CategoryTheory.RegularEpi.right f)","decl":"/-- A regular epimorphism is a morphism which is the coequalizer of some parallel pair. -/\nclass RegularEpi (f : X ⟶ Y) where\n  /-- An object from `C` -/\n  W : C -- Porting note: violates naming convention but what is better?\n  /-- Two maps to the domain of `f` -/\n  (left right : W ⟶ X)\n  /-- `f` coequalizes the two maps -/\n  w : left ≫ f = right ≫ f := by aesop_cat\n  /-- `f` is the coequalizer -/\n  isColimit : IsColimit (Cofork.ofπ f w)\n\n"}
{"name":"CategoryTheory.RegularEpi.w_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.RegularMono","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX Y : C\nf : Quiver.Hom X Y\nself : CategoryTheory.RegularEpi f\nZ : C\nh : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.RegularEpi.left (CategoryTheory.CategoryStruct.comp f h)) (CategoryTheory.CategoryStruct.comp CategoryTheory.RegularEpi.right (CategoryTheory.CategoryStruct.comp f h))","decl":"attribute [reassoc] RegularEpi.w\n\n"}
{"name":"CategoryTheory.RegularEpi.epi","module":"Mathlib.CategoryTheory.Limits.Shapes.RegularMono","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.RegularEpi f\n⊢ CategoryTheory.Epi f","decl":"/-- Every regular epimorphism is an epimorphism. -/\ninstance (priority := 100) RegularEpi.epi (f : X ⟶ Y) [RegularEpi f] : Epi f :=\n  epi_of_isColimit_cofork RegularEpi.isColimit\n\n"}
{"name":"CategoryTheory.strongEpi_of_regularEpi","module":"Mathlib.CategoryTheory.Limits.Shapes.RegularMono","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.RegularEpi f\n⊢ CategoryTheory.StrongEpi f","decl":"instance (priority := 100) strongEpi_of_regularEpi (f : X ⟶ Y) [RegularEpi f] : StrongEpi f :=\n  StrongEpi.mk'\n    (by\n      intro A B z hz u v sq\n      have : (RegularEpi.left : RegularEpi.W f ⟶ X) ≫ u = RegularEpi.right ≫ u := by\n        apply (cancel_mono z).1\n        simp only [Category.assoc, sq.w, RegularEpi.w_assoc]\n      obtain ⟨t, ht⟩ := RegularEpi.desc' f u this\n      exact\n        CommSq.HasLift.mk'\n          ⟨t, ht,\n            (cancel_epi f).1\n              (by simp only [← Category.assoc, ht, ← sq.w, Arrow.mk_hom, Arrow.homMk'_right])⟩)\n\n"}
{"name":"CategoryTheory.isIso_of_regularEpi_of_mono","module":"Mathlib.CategoryTheory.Limits.Shapes.RegularMono","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nX Y : C\nf : Quiver.Hom X Y\ninst✝¹ : CategoryTheory.RegularEpi f\ninst✝ : CategoryTheory.Mono f\n⊢ CategoryTheory.IsIso f","decl":"/-- A regular epimorphism is an isomorphism if it is a monomorphism. -/\ntheorem isIso_of_regularEpi_of_mono (f : X ⟶ Y) [RegularEpi f] [Mono f] : IsIso f :=\n  isIso_of_mono_of_strongEpi _\n\n"}
{"name":"CategoryTheory.IsRegularEpiCategory.regularEpiOfEpi","module":"Mathlib.CategoryTheory.Limits.Shapes.RegularMono","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nself : CategoryTheory.IsRegularEpiCategory C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Epi f\n⊢ Nonempty (CategoryTheory.RegularEpi f)","decl":"/-- A regular epi category is a category in which every epimorphism is regular. -/\nclass IsRegularEpiCategory : Prop where\n  /-- Everyone epimorphism is a regular epimorphism -/\n  regularEpiOfEpi : ∀ {X Y : C} (f : X ⟶ Y) [Epi f], Nonempty (RegularEpi f)\n\n"}
{"name":"CategoryTheory.regularEpiCategoryOfSplitEpiCategory","module":"Mathlib.CategoryTheory.Limits.Shapes.RegularMono","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.SplitEpiCategory C\n⊢ CategoryTheory.IsRegularEpiCategory C","decl":"instance (priority := 100) regularEpiCategoryOfSplitEpiCategory [SplitEpiCategory C] :\n    IsRegularEpiCategory C where\n  regularEpiOfEpi f _ := ⟨by\n    haveI := isSplitEpi_of_epi f\n    infer_instance⟩\n\n"}
{"name":"CategoryTheory.strongEpiCategory_of_regularEpiCategory","module":"Mathlib.CategoryTheory.Limits.Shapes.RegularMono","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.IsRegularEpiCategory C\n⊢ CategoryTheory.StrongEpiCategory C","decl":"instance (priority := 100) strongEpiCategory_of_regularEpiCategory [IsRegularEpiCategory C] :\n    StrongEpiCategory C where\n  strongEpi_of_epi f _ := by\n    haveI := regularEpiOfEpi f\n    infer_instance\n\n"}
