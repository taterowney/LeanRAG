{"name":"Traversable.pureTransformation_apply","module":"Mathlib.Control.Traversable.Lemmas","initialProofState":"F : Type u → Type u\ninst✝¹ : Applicative F\ninst✝ : LawfulApplicative F\nα : Type u\nx : id α\n⊢ Eq ((fun {α} => (Traversable.PureTransformation F).app α) x) (Pure.pure x)","decl":"@[simp]\ntheorem pureTransformation_apply {α} (x : id α) : PureTransformation F x = pure x :=\n  rfl\n\n"}
{"name":"Traversable.map_eq_traverse_id","module":"Mathlib.Control.Traversable.Lemmas","initialProofState":"t : Type u → Type u\ninst✝¹ : Traversable t\ninst✝ : LawfulTraversable t\nβ γ : Type u\nf : β → γ\n⊢ Eq (Functor.map f) (Traversable.traverse (Function.comp Pure.pure f))","decl":"theorem map_eq_traverse_id : map (f := t) f = traverse (m := Id) (pure ∘ f) :=\n  funext fun y => (traverse_eq_map_id f y).symm\n\n"}
{"name":"Traversable.map_traverse","module":"Mathlib.Control.Traversable.Lemmas","initialProofState":"t : Type u → Type u\ninst✝³ : Traversable t\ninst✝² : LawfulTraversable t\nF : Type u → Type u\ninst✝¹ : Applicative F\ninst✝ : LawfulApplicative F\nα β γ : Type u\ng : α → F β\nf : β → γ\nx : t α\n⊢ Eq (Functor.map (Functor.map f) (Traversable.traverse g x)) (Traversable.traverse (Function.comp (Functor.map f) g) x)","decl":"theorem map_traverse (x : t α) : map f <$> traverse g x = traverse (map f ∘ g) x := by\n  rw [map_eq_traverse_id f]\n  refine (comp_traverse (pure ∘ f) g x).symm.trans ?_\n  congr; apply Comp.applicative_comp_id\n\n"}
{"name":"Traversable.traverse_map","module":"Mathlib.Control.Traversable.Lemmas","initialProofState":"t : Type u → Type u\ninst✝³ : Traversable t\ninst✝² : LawfulTraversable t\nF : Type u → Type u\ninst✝¹ : Applicative F\ninst✝ : LawfulApplicative F\nα β γ : Type u\nf : β → F γ\ng : α → β\nx : t α\n⊢ Eq (Traversable.traverse f (Functor.map g x)) (Traversable.traverse (Function.comp f g) x)","decl":"theorem traverse_map (f : β → F γ) (g : α → β) (x : t α) :\n    traverse f (g <$> x) = traverse (f ∘ g) x := by\n  rw [@map_eq_traverse_id t _ _ _ _ g]\n  refine (comp_traverse (G := Id) f (pure ∘ g) x).symm.trans ?_\n  congr; apply Comp.applicative_id_comp\n\n"}
{"name":"Traversable.pure_traverse","module":"Mathlib.Control.Traversable.Lemmas","initialProofState":"t : Type u → Type u\ninst✝³ : Traversable t\ninst✝² : LawfulTraversable t\nF : Type u → Type u\ninst✝¹ : Applicative F\ninst✝ : LawfulApplicative F\nα : Type u\nx : t α\n⊢ Eq (Traversable.traverse Pure.pure x) (Pure.pure x)","decl":"theorem pure_traverse (x : t α) : traverse pure x = (pure x : F (t α)) := by\n  have : traverse pure x = pure (traverse (m := Id) pure x) :=\n      (naturality (PureTransformation F) pure x).symm\n  rwa [id_traverse] at this\n\n"}
{"name":"Traversable.id_sequence","module":"Mathlib.Control.Traversable.Lemmas","initialProofState":"t : Type u → Type u\ninst✝¹ : Traversable t\ninst✝ : LawfulTraversable t\nα : Type u\nx : t α\n⊢ Eq (sequence (Functor.map Pure.pure x)) (Pure.pure x)","decl":"theorem id_sequence (x : t α) : sequence (f := Id) (pure <$> x) = pure x := by\n  simp [sequence, traverse_map, id_traverse]\n\n"}
{"name":"Traversable.comp_sequence","module":"Mathlib.Control.Traversable.Lemmas","initialProofState":"t : Type u → Type u\ninst✝⁵ : Traversable t\ninst✝⁴ : LawfulTraversable t\nF G : Type u → Type u\ninst✝³ : Applicative F\ninst✝² : LawfulApplicative F\ninst✝¹ : Applicative G\ninst✝ : LawfulApplicative G\nα : Type u\nx : t (F (G α))\n⊢ Eq (sequence (Functor.map Functor.Comp.mk x)) (Functor.Comp.mk (Functor.map sequence (sequence x)))","decl":"theorem comp_sequence (x : t (F (G α))) :\n    sequence (Comp.mk <$> x) = Comp.mk (sequence <$> sequence x) := by\n  simp only [sequence, traverse_map, id_comp]; rw [← comp_traverse]; simp [map_id]\n\n"}
{"name":"Traversable.naturality'","module":"Mathlib.Control.Traversable.Lemmas","initialProofState":"t : Type u → Type u\ninst✝⁵ : Traversable t\ninst✝⁴ : LawfulTraversable t\nF G : Type u → Type u\ninst✝³ : Applicative F\ninst✝² : LawfulApplicative F\ninst✝¹ : Applicative G\ninst✝ : LawfulApplicative G\nα : Type u\nη : ApplicativeTransformation F G\nx : t (F α)\n⊢ Eq ((fun {α} => η.app α) (sequence x)) (sequence (Functor.map (fun {α} => η.app α) x))","decl":"theorem naturality' (η : ApplicativeTransformation F G) (x : t (F α)) :\n    η (sequence x) = sequence (@η _ <$> x) := by simp [sequence, naturality, traverse_map]\n\n"}
{"name":"Traversable.traverse_id","module":"Mathlib.Control.Traversable.Lemmas","initialProofState":"t : Type u → Type u\ninst✝¹ : Traversable t\ninst✝ : LawfulTraversable t\nα : Type u\n⊢ Eq (Traversable.traverse Pure.pure) Pure.pure","decl":"@[functor_norm]\ntheorem traverse_id : traverse pure = (pure : t α → Id (t α)) := by\n  ext\n  exact id_traverse _\n\n"}
{"name":"Traversable.traverse_comp","module":"Mathlib.Control.Traversable.Lemmas","initialProofState":"t : Type u → Type u\ninst✝⁵ : Traversable t\ninst✝⁴ : LawfulTraversable t\nF G : Type u → Type u\ninst✝³ : Applicative F\ninst✝² : LawfulApplicative F\ninst✝¹ : Applicative G\ninst✝ : LawfulApplicative G\nα β γ : Type u\ng : α → F β\nh : β → G γ\n⊢ Eq (Traversable.traverse (Function.comp Functor.Comp.mk (Function.comp (Functor.map h) g))) (Function.comp Functor.Comp.mk (Function.comp (Functor.map (Traversable.traverse h)) (Traversable.traverse g)))","decl":"@[functor_norm]\ntheorem traverse_comp (g : α → F β) (h : β → G γ) :\n    traverse (Comp.mk ∘ map h ∘ g) =\n      (Comp.mk ∘ map (traverse h) ∘ traverse g : t α → Comp F G (t γ)) := by\n  ext\n  exact comp_traverse _ _ _\n\n"}
{"name":"Traversable.traverse_eq_map_id'","module":"Mathlib.Control.Traversable.Lemmas","initialProofState":"t : Type u → Type u\ninst✝¹ : Traversable t\ninst✝ : LawfulTraversable t\nβ γ : Type u\nf : β → γ\n⊢ Eq (Traversable.traverse (Function.comp Pure.pure f)) (Function.comp Pure.pure (Functor.map f))","decl":"theorem traverse_eq_map_id' (f : β → γ) :\n    traverse (m := Id) (pure ∘ f) = pure ∘ (map f : t β → t γ) := by\n  ext\n  exact traverse_eq_map_id _ _\n\n-- @[functor_norm]\n"}
{"name":"Traversable.traverse_map'","module":"Mathlib.Control.Traversable.Lemmas","initialProofState":"t : Type u → Type u\ninst✝³ : Traversable t\ninst✝² : LawfulTraversable t\nG : Type u → Type u\ninst✝¹ : Applicative G\ninst✝ : LawfulApplicative G\nα β γ : Type u\ng : α → β\nh : β → G γ\n⊢ Eq (Traversable.traverse (Function.comp h g)) (Function.comp (Traversable.traverse h) (Functor.map g))","decl":"theorem traverse_map' (g : α → β) (h : β → G γ) :\n    traverse (h ∘ g) = (traverse h ∘ map g : t α → G (t γ)) := by\n  ext\n  rw [comp_apply, traverse_map]\n\n"}
{"name":"Traversable.map_traverse'","module":"Mathlib.Control.Traversable.Lemmas","initialProofState":"t : Type u → Type u\ninst✝³ : Traversable t\ninst✝² : LawfulTraversable t\nG : Type u → Type u\ninst✝¹ : Applicative G\ninst✝ : LawfulApplicative G\nα β γ : Type u\ng : α → G β\nh : β → γ\n⊢ Eq (Traversable.traverse (Function.comp (Functor.map h) g)) (Function.comp (Functor.map (Functor.map h)) (Traversable.traverse g))","decl":"theorem map_traverse' (g : α → G β) (h : β → γ) :\n    traverse (map h ∘ g) = (map (map h) ∘ traverse g : t α → G (t γ)) := by\n  ext\n  rw [comp_apply, map_traverse]\n\n"}
{"name":"Traversable.naturality_pf","module":"Mathlib.Control.Traversable.Lemmas","initialProofState":"t : Type u → Type u\ninst✝⁵ : Traversable t\ninst✝⁴ : LawfulTraversable t\nF G : Type u → Type u\ninst✝³ : Applicative F\ninst✝² : LawfulApplicative F\ninst✝¹ : Applicative G\ninst✝ : LawfulApplicative G\nα β : Type u\nη : ApplicativeTransformation F G\nf : α → F β\n⊢ Eq (Traversable.traverse (Function.comp (fun {α} => η.app α) f)) (Function.comp (fun {α} => η.app α) (Traversable.traverse f))","decl":"theorem naturality_pf (η : ApplicativeTransformation F G) (f : α → F β) :\n    traverse (@η _ ∘ f) = @η _ ∘ (traverse f : t α → F (t β)) := by\n  ext\n  rw [comp_apply, naturality]\n\n"}
