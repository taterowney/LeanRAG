{"name":"PartialFun.Iso.mk_hom","module":"Mathlib.CategoryTheory.Category.PartialFun","initialProofState":"α β : PartialFun\ne : Equiv α β\nx : α\n⊢ Eq ((PartialFun.Iso.mk e).hom x) ↑(Option.some (e x))","decl":"/-- Constructs a partial function isomorphism between types from an equivalence between them. -/\n@[simps]\ndef Iso.mk {α β : PartialFun.{u}} (e : α ≃ β) : α ≅ β where\n  hom x := e x\n  inv x := e.symm x\n  hom_inv_id := (PFun.coe_comp _ _).symm.trans (by\n    simp only [Equiv.symm_comp_self, PFun.coe_id]\n    rfl)\n  inv_hom_id := (PFun.coe_comp _ _).symm.trans (by\n    simp only [Equiv.self_comp_symm, PFun.coe_id]\n    rfl)\n\n"}
{"name":"PartialFun.Iso.mk_inv","module":"Mathlib.CategoryTheory.Category.PartialFun","initialProofState":"α β : PartialFun\ne : Equiv α β\nx : β\n⊢ Eq ((PartialFun.Iso.mk e).inv x) ↑(Option.some (e.symm x))","decl":"/-- Constructs a partial function isomorphism between types from an equivalence between them. -/\n@[simps]\ndef Iso.mk {α β : PartialFun.{u}} (e : α ≃ β) : α ≅ β where\n  hom x := e x\n  inv x := e.symm x\n  hom_inv_id := (PFun.coe_comp _ _).symm.trans (by\n    simp only [Equiv.symm_comp_self, PFun.coe_id]\n    rfl)\n  inv_hom_id := (PFun.coe_comp _ _).symm.trans (by\n    simp only [Equiv.self_comp_symm, PFun.coe_id]\n    rfl)\n\n"}
{"name":"instFaithfulPartialFunTypeToPartialFun","module":"Mathlib.CategoryTheory.Category.PartialFun","initialProofState":"⊢ typeToPartialFun.Faithful","decl":"instance : typeToPartialFun.Faithful where\n  map_injective {_ _} := PFun.lift_injective\n\n-- b ∈ PFun.toSubtype (fun x ↦ x ≠ X.point) Subtype.val a ↔ b ∈ Part.some a\n"}
{"name":"pointedToPartialFun_map","module":"Mathlib.CategoryTheory.Category.PartialFun","initialProofState":"X✝ Y✝ : Pointed\nf : Quiver.Hom X✝ Y✝\na✝ : Subtype fun x => Ne x X✝.point\n⊢ Eq (pointedToPartialFun.map f a✝) (Function.comp (PFun.toSubtype (fun x => Ne x Y✝.point) f.toFun) Subtype.val a✝)","decl":"/-- The functor which deletes the point of a pointed type. In return, this makes the maps partial.\nThis is the computable part of the equivalence `PartialFunEquivPointed`. -/\n@[simps obj map]\ndef pointedToPartialFun : Pointed.{u} ⥤ PartialFun where\n  obj X := { x : X // x ≠ X.point }\n  map f := PFun.toSubtype _ f.toFun ∘ Subtype.val\n  map_id _ :=\n    PFun.ext fun _ b =>\n      PFun.mem_toSubtype_iff (b := b).trans (Subtype.coe_inj.trans Part.mem_some_iff.symm)\n  map_comp f g := by\n    -- Porting note: the proof was changed because the original mathlib3 proof no longer works\n    apply PFun.ext _\n    rintro ⟨a, ha⟩ ⟨c, hc⟩\n    constructor\n    · rintro ⟨h₁, h₂⟩\n      exact ⟨⟨fun h₀ => h₁ ((congr_arg g.toFun h₀).trans g.map_point), h₁⟩, h₂⟩\n    · rintro ⟨_, _, _⟩\n      exact ⟨_, rfl⟩\n\n"}
{"name":"pointedToPartialFun_obj","module":"Mathlib.CategoryTheory.Category.PartialFun","initialProofState":"X : Pointed\n⊢ Eq (pointedToPartialFun.obj X) (Subtype fun x => Ne x X.point)","decl":"/-- The functor which deletes the point of a pointed type. In return, this makes the maps partial.\nThis is the computable part of the equivalence `PartialFunEquivPointed`. -/\n@[simps obj map]\ndef pointedToPartialFun : Pointed.{u} ⥤ PartialFun where\n  obj X := { x : X // x ≠ X.point }\n  map f := PFun.toSubtype _ f.toFun ∘ Subtype.val\n  map_id _ :=\n    PFun.ext fun _ b =>\n      PFun.mem_toSubtype_iff (b := b).trans (Subtype.coe_inj.trans Part.mem_some_iff.symm)\n  map_comp f g := by\n    -- Porting note: the proof was changed because the original mathlib3 proof no longer works\n    apply PFun.ext _\n    rintro ⟨a, ha⟩ ⟨c, hc⟩\n    constructor\n    · rintro ⟨h₁, h₂⟩\n      exact ⟨⟨fun h₀ => h₁ ((congr_arg g.toFun h₀).trans g.map_point), h₁⟩, h₂⟩\n    · rintro ⟨_, _, _⟩\n      exact ⟨_, rfl⟩\n\n"}
{"name":"partialFunToPointed_obj","module":"Mathlib.CategoryTheory.Category.PartialFun","initialProofState":"X : PartialFun\n⊢ Eq (partialFunToPointed.obj X) { X := Option X, point := Option.none }","decl":"/-- The functor which maps undefined values to a new point. This makes the maps total and creates\npointed types. This is the noncomputable part of the equivalence `PartialFunEquivPointed`. It can't\nbe computable because `= Option.none` is decidable while the domain of a general `Part` isn't. -/\n@[simps obj map]\nnoncomputable def partialFunToPointed : PartialFun ⥤ Pointed := by\n  classical\n  exact\n    { obj := fun X => ⟨Option X, none⟩\n      map := fun f => ⟨Option.elim' none fun a => (f a).toOption, rfl⟩\n      map_id := fun X => Pointed.Hom.ext <| funext fun o => Option.recOn o rfl fun a => (by\n        dsimp [CategoryStruct.id]\n        convert Part.some_toOption a)\n      map_comp := fun f g => Pointed.Hom.ext <| funext fun o => Option.recOn o rfl fun a => by\n        dsimp [CategoryStruct.comp]\n        rw [Part.bind_toOption g (f a), Option.elim'_eq_elim] }\n\n"}
{"name":"partialFunToPointed_map","module":"Mathlib.CategoryTheory.Category.PartialFun","initialProofState":"X✝ Y✝ : PartialFun\nf : Quiver.Hom X✝ Y✝\n⊢ Eq (partialFunToPointed.map f) { toFun := Option.elim' Option.none fun a => (f a).toOption, map_point := ⋯ }","decl":"/-- The functor which maps undefined values to a new point. This makes the maps total and creates\npointed types. This is the noncomputable part of the equivalence `PartialFunEquivPointed`. It can't\nbe computable because `= Option.none` is decidable while the domain of a general `Part` isn't. -/\n@[simps obj map]\nnoncomputable def partialFunToPointed : PartialFun ⥤ Pointed := by\n  classical\n  exact\n    { obj := fun X => ⟨Option X, none⟩\n      map := fun f => ⟨Option.elim' none fun a => (f a).toOption, rfl⟩\n      map_id := fun X => Pointed.Hom.ext <| funext fun o => Option.recOn o rfl fun a => (by\n        dsimp [CategoryStruct.id]\n        convert Part.some_toOption a)\n      map_comp := fun f g => Pointed.Hom.ext <| funext fun o => Option.recOn o rfl fun a => by\n        dsimp [CategoryStruct.comp]\n        rw [Part.bind_toOption g (f a), Option.elim'_eq_elim] }\n\n"}
{"name":"partialFunEquivPointed_functor_map_toFun","module":"Mathlib.CategoryTheory.Category.PartialFun","initialProofState":"X✝ Y✝ : PartialFun\nf : Quiver.Hom X✝ Y✝\na✝ : Option X✝\n⊢ Eq ((partialFunEquivPointed.functor.map f).toFun a✝) (Option.elim' Option.none (fun a => (f a).toOption) a✝)","decl":"/-- The equivalence induced by `PartialFunToPointed` and `PointedToPartialFun`.\n`Part.equivOption` made functorial. -/\n@[simps!]\nnoncomputable def partialFunEquivPointed : PartialFun.{u} ≌ Pointed where\n  functor := partialFunToPointed\n  inverse := pointedToPartialFun\n  unitIso := NatIso.ofComponents (fun X => PartialFun.Iso.mk\n      { toFun := fun a => ⟨some a, some_ne_none a⟩\n        invFun := fun a => Option.get _ (Option.ne_none_iff_isSome.1 a.2)\n        left_inv := fun _ => Option.get_some _ _\n        right_inv := fun a => by simp only [some_get, Subtype.coe_eta] })\n      fun f =>\n        PFun.ext fun a b => by\n          dsimp [PartialFun.Iso.mk, CategoryStruct.comp, pointedToPartialFun]\n          rw [Part.bind_some]\n          -- Porting note: the proof below has changed a lot because\n          -- `Part.mem_bind_iff` means that `b ∈ Part.bind f g` is equivalent\n          -- to `∃ (a : α), a ∈ f ∧ b ∈ g a`, while in mathlib3 it was equivalent\n          -- to `∃ (a : α) (H : a ∈ f), b ∈ g a`\n          refine (Part.mem_bind_iff.trans ?_).trans PFun.mem_toSubtype_iff.symm\n          obtain ⟨b | b, hb⟩ := b\n          · exact (hb rfl).elim\n          · dsimp [Part.toOption]\n            simp_rw [Part.mem_some_iff, Subtype.mk_eq_mk]\n            constructor\n            · rintro ⟨_, ⟨h₁, h₂⟩, h₃⟩\n              rw [h₃, ← h₂, dif_pos h₁]\n            · intro h\n              split_ifs at h with ha\n              rw [some_inj] at h\n              exact ⟨b, ⟨ha, h.symm⟩, rfl⟩\n  counitIso :=\n    NatIso.ofComponents\n      (fun X ↦ Pointed.Iso.mk (by classical exact Equiv.optionSubtypeNe X.point) (by rfl))\n      fun {X Y} f ↦ Pointed.Hom.ext <| funext fun a ↦ by\n        obtain _ | ⟨a, ha⟩ := a\n        · exact f.map_point.symm\n        simp_all [Option.casesOn'_eq_elim, Part.elim_toOption]\n  functor_unitIso_comp X := by\n    ext (_ | x)\n    · rfl\n    · simp\n      rfl\n\n"}
{"name":"partialFunEquivPointed_inverse_map_Dom","module":"Mathlib.CategoryTheory.Category.PartialFun","initialProofState":"X✝ Y✝ : Pointed\nf : Quiver.Hom X✝ Y✝\na✝ : Subtype fun x => Ne x X✝.point\n⊢ Eq (partialFunEquivPointed.inverse.map f a✝).Dom (Not (Eq (f.toFun ↑a✝) Y✝.point))","decl":"/-- The equivalence induced by `PartialFunToPointed` and `PointedToPartialFun`.\n`Part.equivOption` made functorial. -/\n@[simps!]\nnoncomputable def partialFunEquivPointed : PartialFun.{u} ≌ Pointed where\n  functor := partialFunToPointed\n  inverse := pointedToPartialFun\n  unitIso := NatIso.ofComponents (fun X => PartialFun.Iso.mk\n      { toFun := fun a => ⟨some a, some_ne_none a⟩\n        invFun := fun a => Option.get _ (Option.ne_none_iff_isSome.1 a.2)\n        left_inv := fun _ => Option.get_some _ _\n        right_inv := fun a => by simp only [some_get, Subtype.coe_eta] })\n      fun f =>\n        PFun.ext fun a b => by\n          dsimp [PartialFun.Iso.mk, CategoryStruct.comp, pointedToPartialFun]\n          rw [Part.bind_some]\n          -- Porting note: the proof below has changed a lot because\n          -- `Part.mem_bind_iff` means that `b ∈ Part.bind f g` is equivalent\n          -- to `∃ (a : α), a ∈ f ∧ b ∈ g a`, while in mathlib3 it was equivalent\n          -- to `∃ (a : α) (H : a ∈ f), b ∈ g a`\n          refine (Part.mem_bind_iff.trans ?_).trans PFun.mem_toSubtype_iff.symm\n          obtain ⟨b | b, hb⟩ := b\n          · exact (hb rfl).elim\n          · dsimp [Part.toOption]\n            simp_rw [Part.mem_some_iff, Subtype.mk_eq_mk]\n            constructor\n            · rintro ⟨_, ⟨h₁, h₂⟩, h₃⟩\n              rw [h₃, ← h₂, dif_pos h₁]\n            · intro h\n              split_ifs at h with ha\n              rw [some_inj] at h\n              exact ⟨b, ⟨ha, h.symm⟩, rfl⟩\n  counitIso :=\n    NatIso.ofComponents\n      (fun X ↦ Pointed.Iso.mk (by classical exact Equiv.optionSubtypeNe X.point) (by rfl))\n      fun {X Y} f ↦ Pointed.Hom.ext <| funext fun a ↦ by\n        obtain _ | ⟨a, ha⟩ := a\n        · exact f.map_point.symm\n        simp_all [Option.casesOn'_eq_elim, Part.elim_toOption]\n  functor_unitIso_comp X := by\n    ext (_ | x)\n    · rfl\n    · simp\n      rfl\n\n"}
{"name":"partialFunEquivPointed_functor_obj_X","module":"Mathlib.CategoryTheory.Category.PartialFun","initialProofState":"X : PartialFun\n⊢ Eq (partialFunEquivPointed.functor.obj X).X (Option X)","decl":"/-- The equivalence induced by `PartialFunToPointed` and `PointedToPartialFun`.\n`Part.equivOption` made functorial. -/\n@[simps!]\nnoncomputable def partialFunEquivPointed : PartialFun.{u} ≌ Pointed where\n  functor := partialFunToPointed\n  inverse := pointedToPartialFun\n  unitIso := NatIso.ofComponents (fun X => PartialFun.Iso.mk\n      { toFun := fun a => ⟨some a, some_ne_none a⟩\n        invFun := fun a => Option.get _ (Option.ne_none_iff_isSome.1 a.2)\n        left_inv := fun _ => Option.get_some _ _\n        right_inv := fun a => by simp only [some_get, Subtype.coe_eta] })\n      fun f =>\n        PFun.ext fun a b => by\n          dsimp [PartialFun.Iso.mk, CategoryStruct.comp, pointedToPartialFun]\n          rw [Part.bind_some]\n          -- Porting note: the proof below has changed a lot because\n          -- `Part.mem_bind_iff` means that `b ∈ Part.bind f g` is equivalent\n          -- to `∃ (a : α), a ∈ f ∧ b ∈ g a`, while in mathlib3 it was equivalent\n          -- to `∃ (a : α) (H : a ∈ f), b ∈ g a`\n          refine (Part.mem_bind_iff.trans ?_).trans PFun.mem_toSubtype_iff.symm\n          obtain ⟨b | b, hb⟩ := b\n          · exact (hb rfl).elim\n          · dsimp [Part.toOption]\n            simp_rw [Part.mem_some_iff, Subtype.mk_eq_mk]\n            constructor\n            · rintro ⟨_, ⟨h₁, h₂⟩, h₃⟩\n              rw [h₃, ← h₂, dif_pos h₁]\n            · intro h\n              split_ifs at h with ha\n              rw [some_inj] at h\n              exact ⟨b, ⟨ha, h.symm⟩, rfl⟩\n  counitIso :=\n    NatIso.ofComponents\n      (fun X ↦ Pointed.Iso.mk (by classical exact Equiv.optionSubtypeNe X.point) (by rfl))\n      fun {X Y} f ↦ Pointed.Hom.ext <| funext fun a ↦ by\n        obtain _ | ⟨a, ha⟩ := a\n        · exact f.map_point.symm\n        simp_all [Option.casesOn'_eq_elim, Part.elim_toOption]\n  functor_unitIso_comp X := by\n    ext (_ | x)\n    · rfl\n    · simp\n      rfl\n\n"}
{"name":"partialFunEquivPointed_counitIso_hom_app_toFun","module":"Mathlib.CategoryTheory.Category.PartialFun","initialProofState":"X : Pointed\na : ((pointedToPartialFun.comp partialFunToPointed).obj X).X\n⊢ Eq ((partialFunEquivPointed.counitIso.hom.app X).toFun a) (Option.casesOn' a X.point Subtype.val)","decl":"/-- The equivalence induced by `PartialFunToPointed` and `PointedToPartialFun`.\n`Part.equivOption` made functorial. -/\n@[simps!]\nnoncomputable def partialFunEquivPointed : PartialFun.{u} ≌ Pointed where\n  functor := partialFunToPointed\n  inverse := pointedToPartialFun\n  unitIso := NatIso.ofComponents (fun X => PartialFun.Iso.mk\n      { toFun := fun a => ⟨some a, some_ne_none a⟩\n        invFun := fun a => Option.get _ (Option.ne_none_iff_isSome.1 a.2)\n        left_inv := fun _ => Option.get_some _ _\n        right_inv := fun a => by simp only [some_get, Subtype.coe_eta] })\n      fun f =>\n        PFun.ext fun a b => by\n          dsimp [PartialFun.Iso.mk, CategoryStruct.comp, pointedToPartialFun]\n          rw [Part.bind_some]\n          -- Porting note: the proof below has changed a lot because\n          -- `Part.mem_bind_iff` means that `b ∈ Part.bind f g` is equivalent\n          -- to `∃ (a : α), a ∈ f ∧ b ∈ g a`, while in mathlib3 it was equivalent\n          -- to `∃ (a : α) (H : a ∈ f), b ∈ g a`\n          refine (Part.mem_bind_iff.trans ?_).trans PFun.mem_toSubtype_iff.symm\n          obtain ⟨b | b, hb⟩ := b\n          · exact (hb rfl).elim\n          · dsimp [Part.toOption]\n            simp_rw [Part.mem_some_iff, Subtype.mk_eq_mk]\n            constructor\n            · rintro ⟨_, ⟨h₁, h₂⟩, h₃⟩\n              rw [h₃, ← h₂, dif_pos h₁]\n            · intro h\n              split_ifs at h with ha\n              rw [some_inj] at h\n              exact ⟨b, ⟨ha, h.symm⟩, rfl⟩\n  counitIso :=\n    NatIso.ofComponents\n      (fun X ↦ Pointed.Iso.mk (by classical exact Equiv.optionSubtypeNe X.point) (by rfl))\n      fun {X Y} f ↦ Pointed.Hom.ext <| funext fun a ↦ by\n        obtain _ | ⟨a, ha⟩ := a\n        · exact f.map_point.symm\n        simp_all [Option.casesOn'_eq_elim, Part.elim_toOption]\n  functor_unitIso_comp X := by\n    ext (_ | x)\n    · rfl\n    · simp\n      rfl\n\n"}
{"name":"partialFunEquivPointed_functor_obj_point","module":"Mathlib.CategoryTheory.Category.PartialFun","initialProofState":"X : PartialFun\n⊢ Eq (partialFunEquivPointed.functor.obj X).point Option.none","decl":"/-- The equivalence induced by `PartialFunToPointed` and `PointedToPartialFun`.\n`Part.equivOption` made functorial. -/\n@[simps!]\nnoncomputable def partialFunEquivPointed : PartialFun.{u} ≌ Pointed where\n  functor := partialFunToPointed\n  inverse := pointedToPartialFun\n  unitIso := NatIso.ofComponents (fun X => PartialFun.Iso.mk\n      { toFun := fun a => ⟨some a, some_ne_none a⟩\n        invFun := fun a => Option.get _ (Option.ne_none_iff_isSome.1 a.2)\n        left_inv := fun _ => Option.get_some _ _\n        right_inv := fun a => by simp only [some_get, Subtype.coe_eta] })\n      fun f =>\n        PFun.ext fun a b => by\n          dsimp [PartialFun.Iso.mk, CategoryStruct.comp, pointedToPartialFun]\n          rw [Part.bind_some]\n          -- Porting note: the proof below has changed a lot because\n          -- `Part.mem_bind_iff` means that `b ∈ Part.bind f g` is equivalent\n          -- to `∃ (a : α), a ∈ f ∧ b ∈ g a`, while in mathlib3 it was equivalent\n          -- to `∃ (a : α) (H : a ∈ f), b ∈ g a`\n          refine (Part.mem_bind_iff.trans ?_).trans PFun.mem_toSubtype_iff.symm\n          obtain ⟨b | b, hb⟩ := b\n          · exact (hb rfl).elim\n          · dsimp [Part.toOption]\n            simp_rw [Part.mem_some_iff, Subtype.mk_eq_mk]\n            constructor\n            · rintro ⟨_, ⟨h₁, h₂⟩, h₃⟩\n              rw [h₃, ← h₂, dif_pos h₁]\n            · intro h\n              split_ifs at h with ha\n              rw [some_inj] at h\n              exact ⟨b, ⟨ha, h.symm⟩, rfl⟩\n  counitIso :=\n    NatIso.ofComponents\n      (fun X ↦ Pointed.Iso.mk (by classical exact Equiv.optionSubtypeNe X.point) (by rfl))\n      fun {X Y} f ↦ Pointed.Hom.ext <| funext fun a ↦ by\n        obtain _ | ⟨a, ha⟩ := a\n        · exact f.map_point.symm\n        simp_all [Option.casesOn'_eq_elim, Part.elim_toOption]\n  functor_unitIso_comp X := by\n    ext (_ | x)\n    · rfl\n    · simp\n      rfl\n\n"}
{"name":"partialFunEquivPointed_unitIso_hom_app","module":"Mathlib.CategoryTheory.Category.PartialFun","initialProofState":"X : PartialFun\n⊢ Eq (partialFunEquivPointed.unitIso.hom.app X) (PartialFun.Iso.mk { toFun := fun a => ⟨Option.some a, ⋯⟩, invFun := fun a => (↑a).get ⋯, left_inv := ⋯, right_inv := ⋯ }).hom","decl":"/-- The equivalence induced by `PartialFunToPointed` and `PointedToPartialFun`.\n`Part.equivOption` made functorial. -/\n@[simps!]\nnoncomputable def partialFunEquivPointed : PartialFun.{u} ≌ Pointed where\n  functor := partialFunToPointed\n  inverse := pointedToPartialFun\n  unitIso := NatIso.ofComponents (fun X => PartialFun.Iso.mk\n      { toFun := fun a => ⟨some a, some_ne_none a⟩\n        invFun := fun a => Option.get _ (Option.ne_none_iff_isSome.1 a.2)\n        left_inv := fun _ => Option.get_some _ _\n        right_inv := fun a => by simp only [some_get, Subtype.coe_eta] })\n      fun f =>\n        PFun.ext fun a b => by\n          dsimp [PartialFun.Iso.mk, CategoryStruct.comp, pointedToPartialFun]\n          rw [Part.bind_some]\n          -- Porting note: the proof below has changed a lot because\n          -- `Part.mem_bind_iff` means that `b ∈ Part.bind f g` is equivalent\n          -- to `∃ (a : α), a ∈ f ∧ b ∈ g a`, while in mathlib3 it was equivalent\n          -- to `∃ (a : α) (H : a ∈ f), b ∈ g a`\n          refine (Part.mem_bind_iff.trans ?_).trans PFun.mem_toSubtype_iff.symm\n          obtain ⟨b | b, hb⟩ := b\n          · exact (hb rfl).elim\n          · dsimp [Part.toOption]\n            simp_rw [Part.mem_some_iff, Subtype.mk_eq_mk]\n            constructor\n            · rintro ⟨_, ⟨h₁, h₂⟩, h₃⟩\n              rw [h₃, ← h₂, dif_pos h₁]\n            · intro h\n              split_ifs at h with ha\n              rw [some_inj] at h\n              exact ⟨b, ⟨ha, h.symm⟩, rfl⟩\n  counitIso :=\n    NatIso.ofComponents\n      (fun X ↦ Pointed.Iso.mk (by classical exact Equiv.optionSubtypeNe X.point) (by rfl))\n      fun {X Y} f ↦ Pointed.Hom.ext <| funext fun a ↦ by\n        obtain _ | ⟨a, ha⟩ := a\n        · exact f.map_point.symm\n        simp_all [Option.casesOn'_eq_elim, Part.elim_toOption]\n  functor_unitIso_comp X := by\n    ext (_ | x)\n    · rfl\n    · simp\n      rfl\n\n"}
{"name":"partialFunEquivPointed_inverse_map_get_coe","module":"Mathlib.CategoryTheory.Category.PartialFun","initialProofState":"X✝ Y✝ : Pointed\nf : Quiver.Hom X✝ Y✝\na✝ : Subtype fun x => Ne x X✝.point\nproperty : Ne (f.toFun ↑a✝) Y✝.point\n⊢ Eq (↑((partialFunEquivPointed.inverse.map f a✝).get property)) (f.toFun ↑a✝)","decl":"/-- The equivalence induced by `PartialFunToPointed` and `PointedToPartialFun`.\n`Part.equivOption` made functorial. -/\n@[simps!]\nnoncomputable def partialFunEquivPointed : PartialFun.{u} ≌ Pointed where\n  functor := partialFunToPointed\n  inverse := pointedToPartialFun\n  unitIso := NatIso.ofComponents (fun X => PartialFun.Iso.mk\n      { toFun := fun a => ⟨some a, some_ne_none a⟩\n        invFun := fun a => Option.get _ (Option.ne_none_iff_isSome.1 a.2)\n        left_inv := fun _ => Option.get_some _ _\n        right_inv := fun a => by simp only [some_get, Subtype.coe_eta] })\n      fun f =>\n        PFun.ext fun a b => by\n          dsimp [PartialFun.Iso.mk, CategoryStruct.comp, pointedToPartialFun]\n          rw [Part.bind_some]\n          -- Porting note: the proof below has changed a lot because\n          -- `Part.mem_bind_iff` means that `b ∈ Part.bind f g` is equivalent\n          -- to `∃ (a : α), a ∈ f ∧ b ∈ g a`, while in mathlib3 it was equivalent\n          -- to `∃ (a : α) (H : a ∈ f), b ∈ g a`\n          refine (Part.mem_bind_iff.trans ?_).trans PFun.mem_toSubtype_iff.symm\n          obtain ⟨b | b, hb⟩ := b\n          · exact (hb rfl).elim\n          · dsimp [Part.toOption]\n            simp_rw [Part.mem_some_iff, Subtype.mk_eq_mk]\n            constructor\n            · rintro ⟨_, ⟨h₁, h₂⟩, h₃⟩\n              rw [h₃, ← h₂, dif_pos h₁]\n            · intro h\n              split_ifs at h with ha\n              rw [some_inj] at h\n              exact ⟨b, ⟨ha, h.symm⟩, rfl⟩\n  counitIso :=\n    NatIso.ofComponents\n      (fun X ↦ Pointed.Iso.mk (by classical exact Equiv.optionSubtypeNe X.point) (by rfl))\n      fun {X Y} f ↦ Pointed.Hom.ext <| funext fun a ↦ by\n        obtain _ | ⟨a, ha⟩ := a\n        · exact f.map_point.symm\n        simp_all [Option.casesOn'_eq_elim, Part.elim_toOption]\n  functor_unitIso_comp X := by\n    ext (_ | x)\n    · rfl\n    · simp\n      rfl\n\n"}
{"name":"partialFunEquivPointed_inverse_obj","module":"Mathlib.CategoryTheory.Category.PartialFun","initialProofState":"X : Pointed\n⊢ Eq (partialFunEquivPointed.inverse.obj X) (Subtype fun x => Not (Eq x X.point))","decl":"/-- The equivalence induced by `PartialFunToPointed` and `PointedToPartialFun`.\n`Part.equivOption` made functorial. -/\n@[simps!]\nnoncomputable def partialFunEquivPointed : PartialFun.{u} ≌ Pointed where\n  functor := partialFunToPointed\n  inverse := pointedToPartialFun\n  unitIso := NatIso.ofComponents (fun X => PartialFun.Iso.mk\n      { toFun := fun a => ⟨some a, some_ne_none a⟩\n        invFun := fun a => Option.get _ (Option.ne_none_iff_isSome.1 a.2)\n        left_inv := fun _ => Option.get_some _ _\n        right_inv := fun a => by simp only [some_get, Subtype.coe_eta] })\n      fun f =>\n        PFun.ext fun a b => by\n          dsimp [PartialFun.Iso.mk, CategoryStruct.comp, pointedToPartialFun]\n          rw [Part.bind_some]\n          -- Porting note: the proof below has changed a lot because\n          -- `Part.mem_bind_iff` means that `b ∈ Part.bind f g` is equivalent\n          -- to `∃ (a : α), a ∈ f ∧ b ∈ g a`, while in mathlib3 it was equivalent\n          -- to `∃ (a : α) (H : a ∈ f), b ∈ g a`\n          refine (Part.mem_bind_iff.trans ?_).trans PFun.mem_toSubtype_iff.symm\n          obtain ⟨b | b, hb⟩ := b\n          · exact (hb rfl).elim\n          · dsimp [Part.toOption]\n            simp_rw [Part.mem_some_iff, Subtype.mk_eq_mk]\n            constructor\n            · rintro ⟨_, ⟨h₁, h₂⟩, h₃⟩\n              rw [h₃, ← h₂, dif_pos h₁]\n            · intro h\n              split_ifs at h with ha\n              rw [some_inj] at h\n              exact ⟨b, ⟨ha, h.symm⟩, rfl⟩\n  counitIso :=\n    NatIso.ofComponents\n      (fun X ↦ Pointed.Iso.mk (by classical exact Equiv.optionSubtypeNe X.point) (by rfl))\n      fun {X Y} f ↦ Pointed.Hom.ext <| funext fun a ↦ by\n        obtain _ | ⟨a, ha⟩ := a\n        · exact f.map_point.symm\n        simp_all [Option.casesOn'_eq_elim, Part.elim_toOption]\n  functor_unitIso_comp X := by\n    ext (_ | x)\n    · rfl\n    · simp\n      rfl\n\n"}
{"name":"partialFunEquivPointed_unitIso_inv_app","module":"Mathlib.CategoryTheory.Category.PartialFun","initialProofState":"X : PartialFun\n⊢ Eq (partialFunEquivPointed.unitIso.inv.app X) (PartialFun.Iso.mk { toFun := fun a => ⟨Option.some a, ⋯⟩, invFun := fun a => (↑a).get ⋯, left_inv := ⋯, right_inv := ⋯ }).inv","decl":"/-- The equivalence induced by `PartialFunToPointed` and `PointedToPartialFun`.\n`Part.equivOption` made functorial. -/\n@[simps!]\nnoncomputable def partialFunEquivPointed : PartialFun.{u} ≌ Pointed where\n  functor := partialFunToPointed\n  inverse := pointedToPartialFun\n  unitIso := NatIso.ofComponents (fun X => PartialFun.Iso.mk\n      { toFun := fun a => ⟨some a, some_ne_none a⟩\n        invFun := fun a => Option.get _ (Option.ne_none_iff_isSome.1 a.2)\n        left_inv := fun _ => Option.get_some _ _\n        right_inv := fun a => by simp only [some_get, Subtype.coe_eta] })\n      fun f =>\n        PFun.ext fun a b => by\n          dsimp [PartialFun.Iso.mk, CategoryStruct.comp, pointedToPartialFun]\n          rw [Part.bind_some]\n          -- Porting note: the proof below has changed a lot because\n          -- `Part.mem_bind_iff` means that `b ∈ Part.bind f g` is equivalent\n          -- to `∃ (a : α), a ∈ f ∧ b ∈ g a`, while in mathlib3 it was equivalent\n          -- to `∃ (a : α) (H : a ∈ f), b ∈ g a`\n          refine (Part.mem_bind_iff.trans ?_).trans PFun.mem_toSubtype_iff.symm\n          obtain ⟨b | b, hb⟩ := b\n          · exact (hb rfl).elim\n          · dsimp [Part.toOption]\n            simp_rw [Part.mem_some_iff, Subtype.mk_eq_mk]\n            constructor\n            · rintro ⟨_, ⟨h₁, h₂⟩, h₃⟩\n              rw [h₃, ← h₂, dif_pos h₁]\n            · intro h\n              split_ifs at h with ha\n              rw [some_inj] at h\n              exact ⟨b, ⟨ha, h.symm⟩, rfl⟩\n  counitIso :=\n    NatIso.ofComponents\n      (fun X ↦ Pointed.Iso.mk (by classical exact Equiv.optionSubtypeNe X.point) (by rfl))\n      fun {X Y} f ↦ Pointed.Hom.ext <| funext fun a ↦ by\n        obtain _ | ⟨a, ha⟩ := a\n        · exact f.map_point.symm\n        simp_all [Option.casesOn'_eq_elim, Part.elim_toOption]\n  functor_unitIso_comp X := by\n    ext (_ | x)\n    · rfl\n    · simp\n      rfl\n\n"}
{"name":"partialFunEquivPointed_counitIso_inv_app_toFun","module":"Mathlib.CategoryTheory.Category.PartialFun","initialProofState":"X : Pointed\na : ((CategoryTheory.Functor.id Pointed).obj X).X\n⊢ Eq ((partialFunEquivPointed.counitIso.inv.app X).toFun a) (dite (Eq a X.point) (fun h => Option.none) fun h => Option.some ⟨a, h⟩)","decl":"/-- The equivalence induced by `PartialFunToPointed` and `PointedToPartialFun`.\n`Part.equivOption` made functorial. -/\n@[simps!]\nnoncomputable def partialFunEquivPointed : PartialFun.{u} ≌ Pointed where\n  functor := partialFunToPointed\n  inverse := pointedToPartialFun\n  unitIso := NatIso.ofComponents (fun X => PartialFun.Iso.mk\n      { toFun := fun a => ⟨some a, some_ne_none a⟩\n        invFun := fun a => Option.get _ (Option.ne_none_iff_isSome.1 a.2)\n        left_inv := fun _ => Option.get_some _ _\n        right_inv := fun a => by simp only [some_get, Subtype.coe_eta] })\n      fun f =>\n        PFun.ext fun a b => by\n          dsimp [PartialFun.Iso.mk, CategoryStruct.comp, pointedToPartialFun]\n          rw [Part.bind_some]\n          -- Porting note: the proof below has changed a lot because\n          -- `Part.mem_bind_iff` means that `b ∈ Part.bind f g` is equivalent\n          -- to `∃ (a : α), a ∈ f ∧ b ∈ g a`, while in mathlib3 it was equivalent\n          -- to `∃ (a : α) (H : a ∈ f), b ∈ g a`\n          refine (Part.mem_bind_iff.trans ?_).trans PFun.mem_toSubtype_iff.symm\n          obtain ⟨b | b, hb⟩ := b\n          · exact (hb rfl).elim\n          · dsimp [Part.toOption]\n            simp_rw [Part.mem_some_iff, Subtype.mk_eq_mk]\n            constructor\n            · rintro ⟨_, ⟨h₁, h₂⟩, h₃⟩\n              rw [h₃, ← h₂, dif_pos h₁]\n            · intro h\n              split_ifs at h with ha\n              rw [some_inj] at h\n              exact ⟨b, ⟨ha, h.symm⟩, rfl⟩\n  counitIso :=\n    NatIso.ofComponents\n      (fun X ↦ Pointed.Iso.mk (by classical exact Equiv.optionSubtypeNe X.point) (by rfl))\n      fun {X Y} f ↦ Pointed.Hom.ext <| funext fun a ↦ by\n        obtain _ | ⟨a, ha⟩ := a\n        · exact f.map_point.symm\n        simp_all [Option.casesOn'_eq_elim, Part.elim_toOption]\n  functor_unitIso_comp X := by\n    ext (_ | x)\n    · rfl\n    · simp\n      rfl\n\n"}
{"name":"typeToPartialFunIsoPartialFunToPointed_hom_app_toFun","module":"Mathlib.CategoryTheory.Category.PartialFun","initialProofState":"X : Type u_1\na : ((typeToPartialFun.comp partialFunToPointed).obj X).X\n⊢ Eq ((typeToPartialFunIsoPartialFunToPointed.hom.app X).toFun a) a","decl":"/-- Forgetting that maps are total and making them total again by adding a point is the same as just\nadding a point. -/\n@[simps!]\nnoncomputable def typeToPartialFunIsoPartialFunToPointed :\n    typeToPartialFun ⋙ partialFunToPointed ≅ typeToPointed :=\n  NatIso.ofComponents\n    (fun _ =>\n      { hom := ⟨id, rfl⟩\n        inv := ⟨id, rfl⟩\n        hom_inv_id := rfl\n        inv_hom_id := rfl })\n    fun f =>\n    Pointed.Hom.ext <|\n      funext fun a => Option.recOn a rfl fun a => by\n        convert Part.some_toOption _\n        simpa using (Part.get_eq_iff_mem (by trivial)).mp rfl\n"}
{"name":"typeToPartialFunIsoPartialFunToPointed_inv_app_toFun","module":"Mathlib.CategoryTheory.Category.PartialFun","initialProofState":"X : Type u_1\na : (typeToPointed.obj X).X\n⊢ Eq ((typeToPartialFunIsoPartialFunToPointed.inv.app X).toFun a) a","decl":"/-- Forgetting that maps are total and making them total again by adding a point is the same as just\nadding a point. -/\n@[simps!]\nnoncomputable def typeToPartialFunIsoPartialFunToPointed :\n    typeToPartialFun ⋙ partialFunToPointed ≅ typeToPointed :=\n  NatIso.ofComponents\n    (fun _ =>\n      { hom := ⟨id, rfl⟩\n        inv := ⟨id, rfl⟩\n        hom_inv_id := rfl\n        inv_hom_id := rfl })\n    fun f =>\n    Pointed.Hom.ext <|\n      funext fun a => Option.recOn a rfl fun a => by\n        convert Part.some_toOption _\n        simpa using (Part.get_eq_iff_mem (by trivial)).mp rfl\n"}
