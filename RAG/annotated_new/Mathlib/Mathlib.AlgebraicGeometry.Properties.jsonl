{"name":"AlgebraicGeometry.instT0SpaceŒ±TopologicalSpaceCarrierCommRingCat","module":"Mathlib.AlgebraicGeometry.Properties","initialProofState":"X : AlgebraicGeometry.Scheme\n‚ä¢ T0Space ‚Üë‚ÜëX.toPresheafedSpace","decl":"instance : T0Space X :=\n  T0Space.of_open_cover fun x => ‚ü®_, X.affineCover.covers x,\n    (X.affineCover.map x).opensRange.2, IsEmbedding.t0Space (Y := PrimeSpectrum _)\n    (isAffineOpen_opensRange (X.affineCover.map x)).isoSpec.schemeIsoToHomeo.isEmbedding‚ü©\n\n"}
{"name":"AlgebraicGeometry.instQuasiSoberŒ±TopologicalSpaceCarrierCommRingCat","module":"Mathlib.AlgebraicGeometry.Properties","initialProofState":"X : AlgebraicGeometry.Scheme\n‚ä¢ QuasiSober ‚Üë‚ÜëX.toPresheafedSpace","decl":"instance : QuasiSober X := by\n  apply (config := { allowSynthFailures := true })\n    quasiSober_of_open_cover (Set.range fun x => Set.range <| (X.affineCover.map x).base)\n  ¬∑ rintro ‚ü®_, i, rfl‚ü©; exact (X.affineCover.map_prop i).base_open.isOpen_range\n  ¬∑ rintro ‚ü®_, i, rfl‚ü©\n    exact @IsOpenEmbedding.quasiSober _ _ _ _ _ (Homeomorph.ofIsEmbedding _\n      (X.affineCover.map_prop i).base_open.isEmbedding).symm.isOpenEmbedding\n        PrimeSpectrum.quasiSober\n  ¬∑ rw [Set.top_eq_univ, Set.sUnion_range, Set.eq_univ_iff_forall]\n    intro x; exact ‚ü®_, ‚ü®_, rfl‚ü©, X.affineCover.covers x‚ü©\n\n"}
{"name":"AlgebraicGeometry.IsReduced.component_reduced","module":"Mathlib.AlgebraicGeometry.Properties","initialProofState":"X : AlgebraicGeometry.Scheme\nself : AlgebraicGeometry.IsReduced X\nU : X.Opens\n‚ä¢ IsReduced ‚Üë(X.presheaf.obj { unop := U })","decl":"/-- A scheme `X` is reduced if all `ùí™‚Çì(U)` are reduced. -/\nclass IsReduced : Prop where\n  component_reduced : ‚àÄ U, _root_.IsReduced Œì(X, U) := by infer_instance\n\n"}
{"name":"AlgebraicGeometry.isReduced_of_isReduced_stalk","module":"Mathlib.AlgebraicGeometry.Properties","initialProofState":"X : AlgebraicGeometry.Scheme\ninst‚úù : ‚àÄ (x : ‚Üë‚ÜëX.toPresheafedSpace), IsReduced ‚Üë(X.presheaf.stalk x)\n‚ä¢ AlgebraicGeometry.IsReduced X","decl":"theorem isReduced_of_isReduced_stalk [‚àÄ x : X, _root_.IsReduced (X.presheaf.stalk x)] :\n    IsReduced X := by\n  refine ‚ü®fun U => ‚ü®fun s hs => ?_‚ü©‚ü©\n  apply Presheaf.section_ext X.sheaf U s 0\n  intro x hx\n  show (X.sheaf.presheaf.germ U x hx) s = (X.sheaf.presheaf.germ U x hx) 0\n  rw [RingHom.map_zero]\n  change X.presheaf.germ U x hx s = 0\n  exact (hs.map _).eq_zero\n\n"}
{"name":"AlgebraicGeometry.isReduced_stalk_of_isReduced","module":"Mathlib.AlgebraicGeometry.Properties","initialProofState":"X : AlgebraicGeometry.Scheme\ninst‚úù : AlgebraicGeometry.IsReduced X\nx : ‚Üë‚ÜëX.toPresheafedSpace\n‚ä¢ IsReduced ‚Üë(X.presheaf.stalk x)","decl":"instance isReduced_stalk_of_isReduced [IsReduced X] (x : X) :\n    _root_.IsReduced (X.presheaf.stalk x) := by\n  constructor\n  rintro g ‚ü®n, e‚ü©\n  obtain ‚ü®U, hxU, s, (rfl : (X.presheaf.germ U x hxU) s = g)‚ü© := X.presheaf.germ_exist x g\n  rw [‚Üê map_pow, ‚Üê map_zero (X.presheaf.germ _ x hxU).hom] at e\n  obtain ‚ü®V, hxV, iU, iV, (e' : (X.presheaf.map iU.op) (s ^ n) = (X.presheaf.map iV.op) 0)‚ü© :=\n    X.presheaf.germ_eq x hxU hxU _ 0 e\n  rw [map_pow, map_zero] at e'\n  replace e' := (IsNilpotent.mk _ _ e').eq_zero (R := Œì(X, V))\n  rw [‚Üê X.presheaf.germ_res iU x hxV, CommRingCat.comp_apply, e', map_zero]\n\n"}
{"name":"AlgebraicGeometry.isReduced_of_isOpenImmersion","module":"Mathlib.AlgebraicGeometry.Properties","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nH : AlgebraicGeometry.IsOpenImmersion f\ninst‚úù : AlgebraicGeometry.IsReduced Y\n‚ä¢ AlgebraicGeometry.IsReduced X","decl":"theorem isReduced_of_isOpenImmersion {X Y : Scheme} (f : X ‚ü∂ Y) [H : IsOpenImmersion f]\n    [IsReduced Y] : IsReduced X := by\n  constructor\n  intro U\n  have : U = f ‚Åª¬π·µÅ f ''·µÅ U := by\n    ext1; exact (Set.preimage_image_eq _ H.base_open.injective).symm\n  rw [this]\n  exact isReduced_of_injective (inv <| f.app (f ''·µÅ U)).hom\n    (asIso <| f.app (f ''·µÅ U) : Œì(Y, f ''·µÅ U) ‚âÖ _).symm.commRingCatIsoToRingEquiv.injective\n\n"}
{"name":"AlgebraicGeometry.instIsReducedSpecOfIsReducedCarrier","module":"Mathlib.AlgebraicGeometry.Properties","initialProofState":"R : CommRingCat\nH : IsReduced ‚ÜëR\n‚ä¢ AlgebraicGeometry.IsReduced (AlgebraicGeometry.Spec R)","decl":"instance {R : CommRingCat.{u}} [H : _root_.IsReduced R] : IsReduced (Spec R) := by\n  apply (config := { allowSynthFailures := true }) isReduced_of_isReduced_stalk\n  intro x; dsimp\n  have : _root_.IsReduced (CommRingCat.of <| Localization.AtPrime (PrimeSpectrum.asIdeal x)) := by\n    dsimp; infer_instance\n  exact isReduced_of_injective (StructureSheaf.stalkIso R x).hom.hom\n    (StructureSheaf.stalkIso R x).commRingCatIsoToRingEquiv.injective\n\n"}
{"name":"AlgebraicGeometry.affine_isReduced_iff","module":"Mathlib.AlgebraicGeometry.Properties","initialProofState":"R : CommRingCat\n‚ä¢ Iff (AlgebraicGeometry.IsReduced (AlgebraicGeometry.Spec R)) (IsReduced ‚ÜëR)","decl":"theorem affine_isReduced_iff (R : CommRingCat) :\n    IsReduced (Spec R) ‚Üî _root_.IsReduced R := by\n  refine ‚ü®?_, fun h => inferInstance‚ü©\n  intro h\n  exact isReduced_of_injective (Scheme.ŒìSpecIso R).inv.hom\n    (Scheme.ŒìSpecIso R).symm.commRingCatIsoToRingEquiv.injective\n\n"}
{"name":"AlgebraicGeometry.isReduced_of_isAffine_isReduced","module":"Mathlib.AlgebraicGeometry.Properties","initialProofState":"X : AlgebraicGeometry.Scheme\ninst‚úù¬π : AlgebraicGeometry.IsAffine X\ninst‚úù : IsReduced ‚Üë(X.presheaf.obj { unop := Top.top })\n‚ä¢ AlgebraicGeometry.IsReduced X","decl":"theorem isReduced_of_isAffine_isReduced [IsAffine X] [_root_.IsReduced Œì(X, ‚ä§)] :\n    IsReduced X :=\n  isReduced_of_isOpenImmersion X.isoSpec.hom\n\n"}
{"name":"AlgebraicGeometry.reduce_to_affine_global","module":"Mathlib.AlgebraicGeometry.Properties","initialProofState":"P : {X : AlgebraicGeometry.Scheme} ‚Üí X.Opens ‚Üí Prop\nX : AlgebraicGeometry.Scheme\nU : X.Opens\nh‚ÇÅ : ‚àÄ (X : AlgebraicGeometry.Scheme) (U : X.Opens), (‚àÄ (x : Subtype fun x => Membership.mem U x), Exists fun V => Exists fun x => Exists fun x => P V) ‚Üí P U\nh‚ÇÇ : ‚àÄ (X Y : AlgebraicGeometry.Scheme) (f : Quiver.Hom X Y) [inst : AlgebraicGeometry.IsOpenImmersion f], Exists fun U => Exists fun V => And (Eq U Top.top) (And (Eq V (AlgebraicGeometry.Scheme.Hom.opensRange f)) (P U ‚Üí P V))\nh‚ÇÉ : ‚àÄ (R : CommRingCat), P Top.top\n‚ä¢ P U","decl":"/-- To show that a statement `P` holds for all open subsets of all schemes, it suffices to show that\n1. In any scheme `X`, if `P` holds for an open cover of `U`, then `P` holds for `U`.\n2. For an open immerison `f : X ‚ü∂ Y`, if `P` holds for the entire space of `X`, then `P` holds for\n  the image of `f`.\n3. `P` holds for the entire space of an affine scheme.\n-/\n@[elab_as_elim]\ntheorem reduce_to_affine_global (P : ‚àÄ {X : Scheme} (_ : X.Opens), Prop)\n    {X : Scheme} (U : X.Opens)\n    (h‚ÇÅ : ‚àÄ (X : Scheme) (U : X.Opens),\n      (‚àÄ x : U, ‚àÉ (V : _) (_ : x.1 ‚àà V) (_ : V ‚ü∂ U), P V) ‚Üí P U)\n    (h‚ÇÇ : ‚àÄ (X Y) (f : X ‚ü∂ Y) [IsOpenImmersion f],\n      ‚àÉ (U : X.Opens) (V : Y.Opens), U = ‚ä§ ‚àß V = f.opensRange ‚àß (P U ‚Üí P V))\n    (h‚ÇÉ : ‚àÄ R : CommRingCat, P (X := Spec R) ‚ä§) : P U := by\n  apply h‚ÇÅ\n  intro x\n  obtain ‚ü®_, ‚ü®j, rfl‚ü©, hx, i‚ü© :=\n    X.affineBasisCover_is_basis.exists_subset_of_mem_open (SetLike.mem_coe.2 x.prop) U.isOpen\n  let U' : Opens _ := ‚ü®_, (X.affineBasisCover.map_prop j).base_open.isOpen_range‚ü©\n  let i' : U' ‚ü∂ U := homOfLE i\n  refine ‚ü®U', hx, i', ?_‚ü©\n  obtain ‚ü®_, _, rfl, rfl, h‚ÇÇ'‚ü© := h‚ÇÇ _ _ (X.affineBasisCover.map j)\n  apply h‚ÇÇ'\n  apply h‚ÇÉ\n\n"}
{"name":"AlgebraicGeometry.reduce_to_affine_nbhd","module":"Mathlib.AlgebraicGeometry.Properties","initialProofState":"P : (X : AlgebraicGeometry.Scheme) ‚Üí ‚Üë‚ÜëX.toPresheafedSpace ‚Üí Prop\nh‚ÇÅ : ‚àÄ (R : CommRingCat) (x : ‚Üë‚Üë(AlgebraicGeometry.Spec R).toPresheafedSpace), P (AlgebraicGeometry.Spec R) x\nh‚ÇÇ : ‚àÄ {X Y : AlgebraicGeometry.Scheme} (f : Quiver.Hom X Y) [inst : AlgebraicGeometry.IsOpenImmersion f] (x : ‚Üë‚ÜëX.toPresheafedSpace), P X x ‚Üí P Y (f.base x)\nX : AlgebraicGeometry.Scheme\nx : ‚Üë‚ÜëX.toPresheafedSpace\n‚ä¢ P X x","decl":"theorem reduce_to_affine_nbhd (P : ‚àÄ (X : Scheme) (_ : X), Prop)\n    (h‚ÇÅ : ‚àÄ R x, P (Spec R) x)\n    (h‚ÇÇ : ‚àÄ {X Y} (f : X ‚ü∂ Y) [IsOpenImmersion f] (x : X), P X x ‚Üí P Y (f.base x)) :\n    ‚àÄ (X : Scheme) (x : X), P X x := by\n  intro X x\n  obtain ‚ü®y, e‚ü© := X.affineCover.covers x\n  convert h‚ÇÇ (X.affineCover.map (X.affineCover.f x)) y _\n  ¬∑ rw [e]\n  apply h‚ÇÅ\n\n"}
{"name":"AlgebraicGeometry.eq_zero_of_basicOpen_eq_bot","module":"Mathlib.AlgebraicGeometry.Properties","initialProofState":"X : AlgebraicGeometry.Scheme\nhX : AlgebraicGeometry.IsReduced X\nU : X.Opens\ns : ‚Üë(X.presheaf.obj { unop := U })\nhs : Eq (X.basicOpen s) Bot.bot\n‚ä¢ Eq s 0","decl":"theorem eq_zero_of_basicOpen_eq_bot {X : Scheme} [hX : IsReduced X] {U : X.Opens}\n    (s : Œì(X, U)) (hs : X.basicOpen s = ‚ä•) : s = 0 := by\n  apply TopCat.Presheaf.section_ext X.sheaf U\n  intro x hx\n  show (X.sheaf.presheaf.germ U x hx) s = (X.sheaf.presheaf.germ U x hx) 0\n  rw [RingHom.map_zero]\n  induction U using reduce_to_affine_global generalizing hX with\n  | h‚ÇÅ X U H =>\n    obtain ‚ü®V, hx, i, H‚ü© := H ‚ü®x, hx‚ü©\n    specialize H (X.presheaf.map i.op s)\n    rw [Scheme.basicOpen_res, hs] at H\n    specialize H (inf_bot_eq _) x hx\n    -- This seems to be related to a mismatch of `X.sheaf.presheaf` and `X.presheaf` in `H`\n    rw [‚Üê CommRingCat.germ_res_apply X.sheaf.presheaf i x hx s]\n    exact H\n  | h‚ÇÇ X Y f =>\n    refine ‚ü®f ‚Åª¬π·µÅ f.opensRange, f.opensRange, by ext1; simp, rfl, ?_‚ü©\n    rintro H hX s hs _ ‚ü®x, rfl‚ü©\n    haveI := isReduced_of_isOpenImmersion f\n    specialize H (f.app _ s) _ x ‚ü®x, rfl‚ü©\n    ¬∑ rw [‚Üê Scheme.preimage_basicOpen, hs]; ext1; simp [Opens.map]\n    ¬∑ have H : (X.presheaf.germ _ x _).hom _ = 0 := H\n      rw [‚Üê Scheme.stalkMap_germ_apply f ‚ü®_, _‚ü© x] at H\n      apply_fun inv <| f.stalkMap x at H\n      rw [‚Üê CommRingCat.comp_apply, CategoryTheory.IsIso.hom_inv_id, map_zero] at H\n      exact H\n  | h‚ÇÉ R =>\n    rw [basicOpen_eq_of_affine', PrimeSpectrum.basicOpen_eq_bot_iff] at hs\n    replace hs := (hs.map (Scheme.ŒìSpecIso R).inv.hom).eq_zero\n    rw [‚Üê CommRingCat.comp_apply, Iso.hom_inv_id, CommRingCat.id_apply] at hs\n    rw [hs, map_zero]\n\n"}
{"name":"AlgebraicGeometry.basicOpen_eq_bot_iff","module":"Mathlib.AlgebraicGeometry.Properties","initialProofState":"X : AlgebraicGeometry.Scheme\ninst‚úù : AlgebraicGeometry.IsReduced X\nU : X.Opens\ns : ‚Üë(X.presheaf.obj { unop := U })\n‚ä¢ Iff (Eq (X.basicOpen s) Bot.bot) (Eq s 0)","decl":"@[simp]\ntheorem basicOpen_eq_bot_iff {X : Scheme} [IsReduced X] {U : X.Opens}\n    (s : Œì(X, U)) : X.basicOpen s = ‚ä• ‚Üî s = 0 := by\n  refine ‚ü®eq_zero_of_basicOpen_eq_bot s, ?_‚ü©\n  rintro rfl\n  simp\n\n"}
{"name":"AlgebraicGeometry.IsIntegral.nonempty","module":"Mathlib.AlgebraicGeometry.Properties","initialProofState":"X : AlgebraicGeometry.Scheme\nself : AlgebraicGeometry.IsIntegral X\n‚ä¢ Nonempty ‚Üë‚ÜëX.toPresheafedSpace","decl":"/-- A scheme `X` is integral if its is nonempty,\nand `ùí™‚Çì(U)` is an integral domain for each `U ‚â† ‚àÖ`. -/\nclass IsIntegral : Prop where\n  nonempty : Nonempty X := by infer_instance\n  component_integral : ‚àÄ (U : X.Opens) [Nonempty U], IsDomain Œì(X, U) := by infer_instance\n\n"}
{"name":"AlgebraicGeometry.IsIntegral.component_integral","module":"Mathlib.AlgebraicGeometry.Properties","initialProofState":"X : AlgebraicGeometry.Scheme\nself : AlgebraicGeometry.IsIntegral X\nU : X.Opens\ninst‚úù : Nonempty ‚Üë‚Üë(‚ÜëU).toPresheafedSpace\n‚ä¢ IsDomain ‚Üë(X.presheaf.obj { unop := U })","decl":"/-- A scheme `X` is integral if its is nonempty,\nand `ùí™‚Çì(U)` is an integral domain for each `U ‚â† ‚àÖ`. -/\nclass IsIntegral : Prop where\n  nonempty : Nonempty X := by infer_instance\n  component_integral : ‚àÄ (U : X.Opens) [Nonempty U], IsDomain Œì(X, U) := by infer_instance\n\n"}
{"name":"AlgebraicGeometry.instIsDomainCarrierObjOppositeOpensŒ±TopologicalSpaceCarrierCommRingCatPresheafOpOpensTopOfIsIntegral","module":"Mathlib.AlgebraicGeometry.Properties","initialProofState":"X : AlgebraicGeometry.Scheme\ninst‚úù : AlgebraicGeometry.IsIntegral X\n‚ä¢ IsDomain ‚Üë(X.presheaf.obj { unop := Top.top })","decl":"instance [IsIntegral X] : IsDomain Œì(X, ‚ä§) :=\n  @IsIntegral.component_integral _ _ _ ‚ü®Nonempty.some inferInstance, trivial‚ü©\n\n"}
{"name":"AlgebraicGeometry.isReduced_of_isIntegral","module":"Mathlib.AlgebraicGeometry.Properties","initialProofState":"X : AlgebraicGeometry.Scheme\ninst‚úù : AlgebraicGeometry.IsIntegral X\n‚ä¢ AlgebraicGeometry.IsReduced X","decl":"instance (priority := 900) isReduced_of_isIntegral [IsIntegral X] : IsReduced X := by\n  constructor\n  intro U\n  rcases U.1.eq_empty_or_nonempty with h | h\n  ¬∑ have : U = ‚ä• := SetLike.ext' h\n    haveI : Subsingleton Œì(X, U) :=\n      CommRingCat.subsingleton_of_isTerminal (X.sheaf.isTerminalOfEqEmpty this)\n    infer_instance\n  ¬∑ haveI : Nonempty U := by simpa\n    infer_instance\n\n"}
{"name":"AlgebraicGeometry.Scheme.component_nontrivial","module":"Mathlib.AlgebraicGeometry.Properties","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\ninst‚úù : Nonempty ‚Üë‚Üë(‚ÜëU).toPresheafedSpace\n‚ä¢ Nontrivial ‚Üë(X.presheaf.obj { unop := U })","decl":"instance Scheme.component_nontrivial (X : Scheme.{u}) (U : X.Opens) [Nonempty U] :\n    Nontrivial Œì(X, U) :=\n  LocallyRingedSpace.component_nontrivial (hU := ‚Äπ_‚Ä∫)\n\n"}
{"name":"AlgebraicGeometry.irreducibleSpace_of_isIntegral","module":"Mathlib.AlgebraicGeometry.Properties","initialProofState":"X : AlgebraicGeometry.Scheme\ninst‚úù : AlgebraicGeometry.IsIntegral X\n‚ä¢ IrreducibleSpace ‚Üë‚ÜëX.toPresheafedSpace","decl":"instance irreducibleSpace_of_isIntegral [IsIntegral X] : IrreducibleSpace X := by\n  by_contra H\n  replace H : ¬¨IsPreirreducible (‚ä§ : Set X) := fun h =>\n    H { toPreirreducibleSpace := ‚ü®h‚ü©\n        toNonempty := inferInstance }\n  simp_rw [isPreirreducible_iff_isClosed_union_isClosed, not_forall, not_or] at H\n  rcases H with ‚ü®S, T, hS, hT, h‚ÇÅ, h‚ÇÇ, h‚ÇÉ‚ü©\n  erw [not_forall] at h‚ÇÇ h‚ÇÉ\n  simp_rw [not_forall] at h‚ÇÇ h‚ÇÉ\n  haveI : Nonempty (‚ü®S·∂ú, hS.1‚ü© : X.Opens) := ‚ü®‚ü®_, h‚ÇÇ.choose_spec.choose_spec‚ü©‚ü©\n  haveI : Nonempty (‚ü®T·∂ú, hT.1‚ü© : X.Opens) := ‚ü®‚ü®_, h‚ÇÉ.choose_spec.choose_spec‚ü©‚ü©\n  haveI : Nonempty (‚ü®S·∂ú, hS.1‚ü© ‚äî ‚ü®T·∂ú, hT.1‚ü© : X.Opens) :=\n    ‚ü®‚ü®_, Or.inl h‚ÇÇ.choose_spec.choose_spec‚ü©‚ü©\n  let e : Œì(X, _) ‚âÖ CommRingCat.of _ :=\n    (X.sheaf.isProductOfDisjoint ‚ü®_, hS.1‚ü© ‚ü®_, hT.1‚ü© ?_).conePointUniqueUpToIso\n      (CommRingCat.prodFanIsLimit _ _)\n  ¬∑ have : IsDomain (Œì(X, ‚ü®S·∂ú, hS.1‚ü©) √ó Œì(X, ‚ü®T·∂ú, hT.1‚ü©)) :=\n      e.symm.commRingCatIsoToRingEquiv.toMulEquiv.isDomain _\n    exact false_of_nontrivial_of_product_domain Œì(X, ‚ü®S·∂ú, hS.1‚ü©) Œì(X, ‚ü®T·∂ú, hT.1‚ü©)\n  ¬∑ ext x\n    constructor\n    ¬∑ rintro ‚ü®hS, hT‚ü©\n      cases' h‚ÇÅ (show x ‚àà ‚ä§ by trivial) with h h\n      exacts [hS h, hT h]\n    ¬∑ simp\n\n"}
{"name":"AlgebraicGeometry.isIntegral_of_irreducibleSpace_of_isReduced","module":"Mathlib.AlgebraicGeometry.Properties","initialProofState":"X : AlgebraicGeometry.Scheme\ninst‚úù : AlgebraicGeometry.IsReduced X\nH : IrreducibleSpace ‚Üë‚ÜëX.toPresheafedSpace\n‚ä¢ AlgebraicGeometry.IsIntegral X","decl":"theorem isIntegral_of_irreducibleSpace_of_isReduced [IsReduced X] [H : IrreducibleSpace X] :\n    IsIntegral X := by\n  constructor; ¬∑ infer_instance\n  intro U hU\n  haveI := (@LocallyRingedSpace.component_nontrivial X.toLocallyRingedSpace U hU).1\n  have : NoZeroDivisors\n      (X.toLocallyRingedSpace.toSheafedSpace.toPresheafedSpace.presheaf.obj (op U)) := by\n    refine ‚ü®fun {a b} e => ?_‚ü©\n    simp_rw [‚Üê basicOpen_eq_bot_iff, ‚Üê Opens.not_nonempty_iff_eq_bot]\n    by_contra! h\n    obtain ‚ü®x, ‚ü®hxU, hx‚ÇÅ‚ü©, _, hx‚ÇÇ‚ü© :=\n      nonempty_preirreducible_inter (X.basicOpen a).2 (X.basicOpen b).2 h.1 h.2\n    replace e := congr_arg (X.presheaf.germ U x hxU) e\n    rw [RingHom.map_mul, RingHom.map_zero] at e\n    refine zero_ne_one' (X.presheaf.stalk x) (isUnit_zero_iff.1 ?_)\n    convert hx‚ÇÅ.mul hx‚ÇÇ\n    exact e.symm\n  exact NoZeroDivisors.to_isDomain _\n\n"}
{"name":"AlgebraicGeometry.isIntegral_iff_irreducibleSpace_and_isReduced","module":"Mathlib.AlgebraicGeometry.Properties","initialProofState":"X : AlgebraicGeometry.Scheme\n‚ä¢ Iff (AlgebraicGeometry.IsIntegral X) (And (IrreducibleSpace ‚Üë‚ÜëX.toPresheafedSpace) (AlgebraicGeometry.IsReduced X))","decl":"theorem isIntegral_iff_irreducibleSpace_and_isReduced :\n    IsIntegral X ‚Üî IrreducibleSpace X ‚àß IsReduced X :=\n  ‚ü®fun _ => ‚ü®inferInstance, inferInstance‚ü©, fun ‚ü®_, _‚ü© =>\n    isIntegral_of_irreducibleSpace_of_isReduced X‚ü©\n\n"}
{"name":"AlgebraicGeometry.isIntegral_of_isOpenImmersion","module":"Mathlib.AlgebraicGeometry.Properties","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nH : AlgebraicGeometry.IsOpenImmersion f\ninst‚úù¬π : AlgebraicGeometry.IsIntegral Y\ninst‚úù : Nonempty ‚Üë‚ÜëX.toPresheafedSpace\n‚ä¢ AlgebraicGeometry.IsIntegral X","decl":"theorem isIntegral_of_isOpenImmersion {X Y : Scheme} (f : X ‚ü∂ Y) [H : IsOpenImmersion f]\n    [IsIntegral Y] [Nonempty X] : IsIntegral X := by\n  constructor; ¬∑ infer_instance\n  intro U hU\n  have : U = f ‚Åª¬π·µÅ f ''·µÅ U := by ext1; exact (Set.preimage_image_eq _ H.base_open.injective).symm\n  rw [this]\n  have : IsDomain Œì(Y, f ''·µÅ U) := by\n    apply (config := { allowSynthFailures := true }) IsIntegral.component_integral\n    exact ‚ü®‚ü®_, _, hU.some.prop, rfl‚ü©‚ü©\n  exact (asIso <| f.app (f ''·µÅ U) :\n    Œì(Y, f ''·µÅ U) ‚âÖ _).symm.commRingCatIsoToRingEquiv.toMulEquiv.isDomain _\n\n"}
{"name":"AlgebraicGeometry.instIrreducibleSpaceŒ±TopologicalSpaceCarrierCommRingCatSpecOfIsDomainCarrier","module":"Mathlib.AlgebraicGeometry.Properties","initialProofState":"R : CommRingCat\ninst‚úù : IsDomain ‚ÜëR\n‚ä¢ IrreducibleSpace ‚Üë‚Üë(AlgebraicGeometry.Spec R).toPresheafedSpace","decl":"instance {R : CommRingCat} [IsDomain R] : IrreducibleSpace (Spec R) := by\n  convert PrimeSpectrum.irreducibleSpace (R := R)\n\n"}
{"name":"AlgebraicGeometry.instIsIntegralSpecOfIsDomainCarrier","module":"Mathlib.AlgebraicGeometry.Properties","initialProofState":"R : CommRingCat\ninst‚úù : IsDomain ‚ÜëR\n‚ä¢ AlgebraicGeometry.IsIntegral (AlgebraicGeometry.Spec R)","decl":"instance {R : CommRingCat} [IsDomain R] : IsIntegral (Spec R) :=\n  isIntegral_of_irreducibleSpace_of_isReduced _\n\n"}
{"name":"AlgebraicGeometry.affine_isIntegral_iff","module":"Mathlib.AlgebraicGeometry.Properties","initialProofState":"R : CommRingCat\n‚ä¢ Iff (AlgebraicGeometry.IsIntegral (AlgebraicGeometry.Spec R)) (IsDomain ‚ÜëR)","decl":"theorem affine_isIntegral_iff (R : CommRingCat) :\n    IsIntegral (Spec R) ‚Üî IsDomain R :=\n  ‚ü®fun _ => MulEquiv.isDomain Œì(Spec R, ‚ä§)\n    (Scheme.ŒìSpecIso R).symm.commRingCatIsoToRingEquiv.toMulEquiv, fun _ => inferInstance‚ü©\n\n"}
{"name":"AlgebraicGeometry.isIntegral_of_isAffine_of_isDomain","module":"Mathlib.AlgebraicGeometry.Properties","initialProofState":"X : AlgebraicGeometry.Scheme\ninst‚úù¬≤ : AlgebraicGeometry.IsAffine X\ninst‚úù¬π : Nonempty ‚Üë‚ÜëX.toPresheafedSpace\ninst‚úù : IsDomain ‚Üë(X.presheaf.obj { unop := Top.top })\n‚ä¢ AlgebraicGeometry.IsIntegral X","decl":"theorem isIntegral_of_isAffine_of_isDomain [IsAffine X] [Nonempty X] [IsDomain Œì(X, ‚ä§)] :\n    IsIntegral X :=\n  isIntegral_of_isOpenImmersion X.isoSpec.hom\n\n"}
{"name":"AlgebraicGeometry.map_injective_of_isIntegral","module":"Mathlib.AlgebraicGeometry.Properties","initialProofState":"X : AlgebraicGeometry.Scheme\ninst‚úù : AlgebraicGeometry.IsIntegral X\nU V : X.Opens\ni : Quiver.Hom U V\nH : Nonempty ‚Üë‚Üë(‚ÜëU).toPresheafedSpace\n‚ä¢ Function.Injective ‚áë(CategoryTheory.ConcreteCategory.hom (X.presheaf.map i.op))","decl":"theorem map_injective_of_isIntegral [IsIntegral X] {U V : X.Opens} (i : U ‚ü∂ V)\n    [H : Nonempty U] : Function.Injective (X.presheaf.map i.op) := by\n  rw [injective_iff_map_eq_zero]\n  intro x hx\n  rw [‚Üê basicOpen_eq_bot_iff] at hx ‚ä¢\n  rw [Scheme.basicOpen_res] at hx\n  revert hx\n  contrapose!\n  simp_rw [Ne, ‚Üê Opens.not_nonempty_iff_eq_bot, Classical.not_not]\n  apply nonempty_preirreducible_inter U.isOpen (RingedSpace.basicOpen _ _).isOpen\n  simpa using H\n\n"}
