{"name":"HurwitzKernelBounds.isBigO_exp_neg_mul_of_le","module":"Mathlib.NumberTheory.ModularForms.JacobiTheta.Bounds","initialProofState":"c d : Real\nhcd : LE.le c d\n⊢ Asymptotics.IsBigO Filter.atTop (fun t => Real.exp (HMul.hMul (Neg.neg d) t)) fun t => Real.exp (HMul.hMul (Neg.neg c) t)","decl":"lemma isBigO_exp_neg_mul_of_le {c d : ℝ} (hcd : c ≤ d) :\n    (fun t ↦ exp (-d * t)) =O[atTop] fun t ↦ exp (-c * t) := by\n  apply Eventually.isBigO\n  filter_upwards [eventually_gt_atTop 0] with t ht\n  rwa [norm_of_nonneg (exp_pos _).le, exp_le_exp, mul_le_mul_right ht, neg_le_neg_iff]\n\n"}
{"name":"HurwitzKernelBounds.f_le_g_nat","module":"Mathlib.NumberTheory.ModularForms.JacobiTheta.Bounds","initialProofState":"k : Nat\na t : Real\nha : LE.le 0 a\nht : LT.lt 0 t\nn : Nat\n⊢ LE.le (Norm.norm (HurwitzKernelBounds.f_nat k a t n)) (HurwitzKernelBounds.g_nat k a t n)","decl":"lemma f_le_g_nat (k : ℕ) {a t : ℝ} (ha : 0 ≤ a) (ht : 0 < t) (n : ℕ) :\n    ‖f_nat k a t n‖ ≤ g_nat k a t n := by\n  rw [f_nat, norm_of_nonneg (by positivity)]\n  refine mul_le_mul_of_nonneg_left ?_ (by positivity)\n  rw [Real.exp_le_exp, mul_le_mul_right ht,\n    mul_le_mul_left_of_neg (neg_lt_zero.mpr pi_pos), ← sub_nonneg]\n  have u : (n : ℝ) ≤ (n : ℝ) ^ 2 := by\n    simpa only [← Nat.cast_pow, Nat.cast_le] using Nat.le_self_pow two_ne_zero _\n  convert add_nonneg (sub_nonneg.mpr u) (by positivity : 0 ≤ 2 * n * a) using 1\n  ring\n\n"}
{"name":"HurwitzKernelBounds.summable_f_nat","module":"Mathlib.NumberTheory.ModularForms.JacobiTheta.Bounds","initialProofState":"k : Nat\na t : Real\nht : LT.lt 0 t\n⊢ Summable (HurwitzKernelBounds.f_nat k a t)","decl":"lemma summable_f_nat (k : ℕ) (a : ℝ) {t : ℝ} (ht : 0 < t) : Summable (f_nat k a t) := by\n  have : Summable fun n : ℕ ↦ n ^ k * exp (-π * (n + a) ^ 2 * t) := by\n    refine (((summable_pow_mul_jacobiTheta₂_term_bound (|a| * t) ht k).mul_right\n      (rexp (-π * a ^ 2 * t))).comp_injective Nat.cast_injective).of_norm_bounded _ (fun n ↦ ?_)\n    simp_rw [mul_assoc, Function.comp_apply, ← Real.exp_add, norm_mul, norm_pow, Int.cast_abs,\n      Int.cast_natCast, norm_eq_abs, Nat.abs_cast, abs_exp]\n    refine mul_le_mul_of_nonneg_left ?_ (pow_nonneg (Nat.cast_nonneg _) _)\n    rw [exp_le_exp, ← sub_nonneg]\n    rw [show -π * (t * n ^ 2 - 2 * (|a| * (t * n))) + -π * (a ^ 2 * t) - -π * ((n + a) ^ 2 * t)\n         = π * t * n * (|a| + a) * 2 by ring]\n    refine mul_nonneg (mul_nonneg (by positivity) ?_) two_pos.le\n    rw [← neg_le_iff_add_nonneg]\n    apply neg_le_abs\n  apply (this.mul_left (2 ^ k)).of_norm_bounded_eventually_nat\n  simp_rw [← mul_assoc, f_nat, norm_mul, norm_eq_abs, abs_exp,\n    mul_le_mul_iff_of_pos_right (exp_pos _), ← mul_pow, abs_pow, two_mul]\n  filter_upwards [eventually_ge_atTop (Nat.ceil |a|)] with n hn\n  gcongr\n  exact (abs_add_le ..).trans (add_le_add (Nat.abs_cast _).le (Nat.ceil_le.mp hn))\n\n"}
{"name":"HurwitzKernelBounds.F_nat_zero_le","module":"Mathlib.NumberTheory.ModularForms.JacobiTheta.Bounds","initialProofState":"a : Real\nha : LE.le 0 a\nt : Real\nht : LT.lt 0 t\n⊢ LE.le (Norm.norm (HurwitzKernelBounds.F_nat 0 a t)) (HDiv.hDiv (Real.exp (HMul.hMul (HMul.hMul (Neg.neg Real.pi) (HPow.hPow a 2)) t)) (HSub.hSub 1 (Real.exp (HMul.hMul (Neg.neg Real.pi) t))))","decl":"lemma F_nat_zero_le {a : ℝ} (ha : 0 ≤ a) {t : ℝ} (ht : 0 < t) :\n    ‖F_nat 0 a t‖ ≤ rexp (-π * a ^ 2 * t) / (1 - rexp (-π * t)) := by\n  refine tsum_of_norm_bounded ?_ (f_le_g_nat 0 ha ht)\n  convert (hasSum_geometric_of_lt_one (exp_pos _).le <| exp_lt_aux ht).mul_left _ using 1\n  ext1 n\n  simp only [g_nat]\n  rw [← Real.exp_nat_mul, ← Real.exp_add]\n  ring_nf\n\n"}
{"name":"HurwitzKernelBounds.F_nat_zero_zero_sub_le","module":"Mathlib.NumberTheory.ModularForms.JacobiTheta.Bounds","initialProofState":"t : Real\nht : LT.lt 0 t\n⊢ LE.le (Norm.norm (HSub.hSub (HurwitzKernelBounds.F_nat 0 0 t) 1)) (HDiv.hDiv (Real.exp (HMul.hMul (Neg.neg Real.pi) t)) (HSub.hSub 1 (Real.exp (HMul.hMul (Neg.neg Real.pi) t))))","decl":"lemma F_nat_zero_zero_sub_le {t : ℝ} (ht : 0 < t) :\n    ‖F_nat 0 0 t - 1‖ ≤ rexp (-π * t) / (1 - rexp (-π * t)) := by\n  convert F_nat_zero_le zero_le_one ht using 2\n  · rw [F_nat, tsum_eq_zero_add (summable_f_nat 0 0 ht), f_nat, Nat.cast_zero, add_zero, pow_zero,\n      one_mul, pow_two, mul_zero, mul_zero, zero_mul, exp_zero, add_comm, add_sub_cancel_right]\n    simp_rw [F_nat, f_nat, Nat.cast_add, Nat.cast_one, add_zero]\n  · rw [one_pow, mul_one]\n\n"}
{"name":"HurwitzKernelBounds.isBigO_atTop_F_nat_zero_sub","module":"Mathlib.NumberTheory.ModularForms.JacobiTheta.Bounds","initialProofState":"a : Real\nha : LE.le 0 a\n⊢ Exists fun p => And (LT.lt 0 p) (Asymptotics.IsBigO Filter.atTop (fun t => HSub.hSub (HurwitzKernelBounds.F_nat 0 a t) (ite (Eq a 0) 1 0)) fun t => Real.exp (HMul.hMul (Neg.neg p) t))","decl":"lemma isBigO_atTop_F_nat_zero_sub {a : ℝ} (ha : 0 ≤ a) : ∃ p, 0 < p ∧\n    (fun t ↦ F_nat 0 a t - (if a = 0 then 1 else 0)) =O[atTop] fun t ↦ exp (-p * t) := by\n  split_ifs with h\n  · rw [h]\n    have : (fun t ↦ F_nat 0 0 t - 1) =O[atTop] fun t ↦ rexp (-π * t) / (1 - rexp (-π * t)) := by\n      apply Eventually.isBigO\n      filter_upwards [eventually_gt_atTop 0] with t ht\n      exact F_nat_zero_zero_sub_le ht\n    refine ⟨_, pi_pos, this.trans ?_⟩\n    simpa using (isBigO_refl (fun t ↦ rexp (-π * t)) _).mul isBigO_one_aux\n  · simp_rw [sub_zero]\n    have : (fun t ↦ F_nat 0 a t) =O[atTop] fun t ↦ rexp (-π * a ^ 2 * t) / (1 - rexp (-π * t)) := by\n      apply Eventually.isBigO\n      filter_upwards [eventually_gt_atTop 0] with t ht\n      exact F_nat_zero_le ha ht\n    refine ⟨π * a ^ 2, mul_pos pi_pos (sq_pos_of_ne_zero h), this.trans ?_⟩\n    simpa only [neg_mul π (a ^ 2), mul_one] using (isBigO_refl _ _).mul isBigO_one_aux\n\n"}
{"name":"HurwitzKernelBounds.F_nat_one_le","module":"Mathlib.NumberTheory.ModularForms.JacobiTheta.Bounds","initialProofState":"a : Real\nha : LE.le 0 a\nt : Real\nht : LT.lt 0 t\n⊢ LE.le (Norm.norm (HurwitzKernelBounds.F_nat 1 a t)) (HAdd.hAdd (HDiv.hDiv (Real.exp (HMul.hMul (HMul.hMul (Neg.neg Real.pi) (HAdd.hAdd (HPow.hPow a 2) 1)) t)) (HPow.hPow (HSub.hSub 1 (Real.exp (HMul.hMul (Neg.neg Real.pi) t))) 2)) (HDiv.hDiv (HMul.hMul a (Real.exp (HMul.hMul (HMul.hMul (Neg.neg Real.pi) (HPow.hPow a 2)) t))) (HSub.hSub 1 (Real.exp (HMul.hMul (Neg.neg Real.pi) t)))))","decl":"lemma F_nat_one_le {a : ℝ} (ha : 0 ≤ a) {t : ℝ} (ht : 0 < t) :\n    ‖F_nat 1 a t‖ ≤ rexp (-π * (a ^ 2 + 1) * t) / (1 - rexp (-π * t)) ^ 2\n      + a * rexp (-π * a ^ 2 * t) / (1 - rexp (-π * t)) := by\n  refine tsum_of_norm_bounded ?_ (f_le_g_nat 1 ha ht)\n  unfold g_nat\n  simp_rw [pow_one, add_mul]\n  apply HasSum.add\n  · have h0' : ‖rexp (-π * t)‖ < 1 := by\n      simpa only [norm_eq_abs, abs_exp] using exp_lt_aux ht\n    convert (hasSum_coe_mul_geometric_of_norm_lt_one h0').mul_left (exp (-π * a ^ 2 * t)) using 1\n    · ext1 n\n      rw [mul_comm (exp _), ← Real.exp_nat_mul, mul_assoc (n : ℝ), ← Real.exp_add]\n      ring_nf\n    · rw [mul_add, add_mul, mul_one, exp_add, mul_div_assoc]\n  · convert (hasSum_geometric_of_lt_one (exp_pos _).le <| exp_lt_aux ht).mul_left _ using 1\n    ext1 n\n    rw [← Real.exp_nat_mul, mul_assoc _ (exp _), ← Real.exp_add]\n    ring_nf\n\n"}
{"name":"HurwitzKernelBounds.isBigO_atTop_F_nat_one","module":"Mathlib.NumberTheory.ModularForms.JacobiTheta.Bounds","initialProofState":"a : Real\nha : LE.le 0 a\n⊢ Exists fun p => And (LT.lt 0 p) (Asymptotics.IsBigO Filter.atTop (HurwitzKernelBounds.F_nat 1 a) fun t => Real.exp (HMul.hMul (Neg.neg p) t))","decl":"lemma isBigO_atTop_F_nat_one {a : ℝ} (ha : 0 ≤ a) : ∃ p, 0 < p ∧\n    F_nat 1 a =O[atTop] fun t ↦ exp (-p * t) := by\n  suffices ∃ p, 0 < p ∧ (fun t ↦ rexp (-π * (a ^ 2 + 1) * t) / (1 - rexp (-π * t)) ^ 2\n      + a * rexp (-π * a ^ 2 * t) / (1 - rexp (-π * t))) =O[atTop] fun t ↦ exp (-p * t) by\n    let ⟨p, hp, hp'⟩ := this\n    refine ⟨p, hp, (Eventually.isBigO ?_).trans hp'⟩\n    filter_upwards [eventually_gt_atTop 0] with t ht\n    exact F_nat_one_le ha ht\n  have aux' : IsBigO atTop (fun t : ℝ ↦ ((1 - rexp (-π * t)) ^ 2)⁻¹) (fun _ ↦ (1 : ℝ)) := by\n    simpa only [inv_pow, one_pow] using isBigO_one_aux.pow 2\n  rcases eq_or_lt_of_le ha with rfl | ha'\n  · exact ⟨_, pi_pos, by simpa only [zero_pow two_ne_zero, zero_add, mul_one, zero_mul, zero_div,\n      add_zero] using (isBigO_refl _ _).mul aux'⟩\n  · refine ⟨π * a ^ 2, mul_pos pi_pos <| pow_pos ha' _, IsBigO.add ?_ ?_⟩\n    · conv_rhs => enter [t]; rw [← mul_one (rexp _)]\n      refine (Eventually.isBigO ?_).mul aux'\n      filter_upwards [eventually_gt_atTop 0] with t ht\n      rw [norm_of_nonneg (exp_pos _).le, exp_le_exp]\n      nlinarith [pi_pos]\n    · simp_rw [mul_div_assoc, ← neg_mul]\n      apply IsBigO.const_mul_left\n      simpa only [mul_one] using (isBigO_refl _ _).mul isBigO_one_aux\n\n"}
{"name":"HurwitzKernelBounds.f_int_ofNat","module":"Mathlib.NumberTheory.ModularForms.JacobiTheta.Bounds","initialProofState":"k : Nat\na : Real\nha : LE.le 0 a\nt : Real\nn : Nat\n⊢ Eq (HurwitzKernelBounds.f_int k a t (Int.ofNat n)) (HurwitzKernelBounds.f_nat k a t n)","decl":"lemma f_int_ofNat (k : ℕ) {a : ℝ} (ha : 0 ≤ a) (t : ℝ) (n : ℕ) :\n    f_int k a t (Int.ofNat n) = f_nat k a t n := by\n  rw [f_int, f_nat, Int.ofNat_eq_coe, Int.cast_natCast, abs_of_nonneg (by positivity)]\n\n"}
{"name":"HurwitzKernelBounds.f_int_negSucc","module":"Mathlib.NumberTheory.ModularForms.JacobiTheta.Bounds","initialProofState":"k : Nat\na : Real\nha : LE.le a 1\nt : Real\nn : Nat\n⊢ Eq (HurwitzKernelBounds.f_int k a t (Int.negSucc n)) (HurwitzKernelBounds.f_nat k (HSub.hSub 1 a) t n)","decl":"lemma f_int_negSucc (k : ℕ) {a : ℝ} (ha : a ≤ 1) (t : ℝ) (n : ℕ) :\n    f_int k a t (Int.negSucc n) = f_nat k (1 - a) t n := by\n  have : (Int.negSucc n) + a = -(n + (1 - a)) := by { push_cast; ring }\n  rw [f_int, f_nat, this, abs_neg, neg_sq, abs_of_nonneg (by linarith)]\n\n"}
{"name":"HurwitzKernelBounds.summable_f_int","module":"Mathlib.NumberTheory.ModularForms.JacobiTheta.Bounds","initialProofState":"k : Nat\na t : Real\nht : LT.lt 0 t\n⊢ Summable (HurwitzKernelBounds.f_int k a t)","decl":"lemma summable_f_int (k : ℕ) (a : ℝ) {t : ℝ} (ht : 0 < t) : Summable (f_int k a t) := by\n  apply Summable.of_norm\n  suffices ∀ n, ‖f_int k a t n‖ = ‖(Int.rec (f_nat k a t) (f_nat k (1 - a) t) : ℤ → ℝ) n‖ from\n    funext this ▸ (HasSum.int_rec (summable_f_nat k a ht).hasSum\n      (summable_f_nat k (1 - a) ht).hasSum).summable.norm\n  intro n\n  cases' n with m m\n  · simp only [f_int, f_nat, Int.ofNat_eq_coe, Int.cast_natCast, norm_mul, norm_eq_abs, abs_pow,\n      abs_abs]\n  · simp only [f_int, f_nat, Int.cast_negSucc, norm_mul, norm_eq_abs, abs_pow, abs_abs,\n      (by { push_cast; ring } : -↑(m + 1) + a = -(m + (1 - a))), abs_neg, neg_sq]\n\n"}
{"name":"HurwitzKernelBounds.F_int_eq_of_mem_Icc","module":"Mathlib.NumberTheory.ModularForms.JacobiTheta.Bounds","initialProofState":"k : Nat\na : Real\nha : Membership.mem (Set.Icc 0 1) a\nt : Real\nht : LT.lt 0 t\n⊢ Eq (HurwitzKernelBounds.F_int k (↑a) t) (HAdd.hAdd (HurwitzKernelBounds.F_nat k a t) (HurwitzKernelBounds.F_nat k (HSub.hSub 1 a) t))","decl":"lemma F_int_eq_of_mem_Icc (k : ℕ) {a : ℝ} (ha : a ∈ Icc 0 1) {t : ℝ} (ht : 0 < t) :\n    F_int k a t = (F_nat k a t) + (F_nat k (1 - a) t) := by\n  simp only [F_int, F_nat, Function.Periodic.lift_coe]\n  convert ((summable_f_nat k a ht).hasSum.int_rec (summable_f_nat k (1 - a) ht).hasSum).tsum_eq\n    using 3 with n\n  cases' n with m m\n  · rw [f_int_ofNat _ ha.1]\n  · rw [f_int_negSucc _ ha.2]\n\n"}
{"name":"HurwitzKernelBounds.isBigO_atTop_F_int_zero_sub","module":"Mathlib.NumberTheory.ModularForms.JacobiTheta.Bounds","initialProofState":"a : UnitAddCircle\n⊢ Exists fun p => And (LT.lt 0 p) (Asymptotics.IsBigO Filter.atTop (fun t => HSub.hSub (HurwitzKernelBounds.F_int 0 a t) (ite (Eq a 0) 1 0)) fun t => Real.exp (HMul.hMul (Neg.neg p) t))","decl":"lemma isBigO_atTop_F_int_zero_sub (a : UnitAddCircle) : ∃ p, 0 < p ∧\n    (fun t ↦ F_int 0 a t - (if a = 0 then 1 else 0)) =O[atTop] fun t ↦ exp (-p * t) := by\n  obtain ⟨a, ha, rfl⟩ := a.eq_coe_Ico\n  obtain ⟨p, hp, hp'⟩ := isBigO_atTop_F_nat_zero_sub ha.1\n  obtain ⟨q, hq, hq'⟩ := isBigO_atTop_F_nat_zero_sub (sub_nonneg.mpr ha.2.le)\n  simp_rw [AddCircle.coe_eq_zero_iff_of_mem_Ico ha]\n  simp_rw [eq_false_intro (by linarith [ha.2] : 1 - a ≠ 0), if_false, sub_zero] at hq'\n  refine ⟨_, lt_min hp hq, ?_⟩\n  have : (fun t ↦ F_int 0 a t - (if a = 0 then 1 else 0)) =ᶠ[atTop]\n      fun t ↦ (F_nat 0 a t - (if a = 0 then 1 else 0)) + F_nat 0 (1 - a) t := by\n    filter_upwards [eventually_gt_atTop 0] with t ht\n    rw [F_int_eq_of_mem_Icc 0 (Ico_subset_Icc_self ha) ht]\n    ring\n  refine this.isBigO.trans ((hp'.trans ?_).add (hq'.trans ?_)) <;>\n  apply isBigO_exp_neg_mul_of_le\n  exacts [min_le_left .., min_le_right ..]\n\n"}
{"name":"HurwitzKernelBounds.isBigO_atTop_F_int_one","module":"Mathlib.NumberTheory.ModularForms.JacobiTheta.Bounds","initialProofState":"a : UnitAddCircle\n⊢ Exists fun p => And (LT.lt 0 p) (Asymptotics.IsBigO Filter.atTop (HurwitzKernelBounds.F_int 1 a) fun t => Real.exp (HMul.hMul (Neg.neg p) t))","decl":"lemma isBigO_atTop_F_int_one (a : UnitAddCircle) : ∃ p, 0 < p ∧\n    F_int 1 a =O[atTop] fun t ↦ exp (-p * t) := by\n  obtain ⟨a, ha, rfl⟩ := a.eq_coe_Ico\n  obtain ⟨p, hp, hp'⟩ := isBigO_atTop_F_nat_one ha.1\n  obtain ⟨q, hq, hq'⟩ := isBigO_atTop_F_nat_one (sub_nonneg.mpr ha.2.le)\n  refine ⟨_, lt_min hp hq, ?_⟩\n  have : F_int 1 a =ᶠ[atTop] fun t ↦ F_nat 1 a t + F_nat 1 (1 - a) t := by\n    filter_upwards [eventually_gt_atTop 0] with t ht\n    exact F_int_eq_of_mem_Icc 1 (Ico_subset_Icc_self ha) ht\n  refine this.isBigO.trans ((hp'.trans ?_).add (hq'.trans ?_)) <;>\n  apply isBigO_exp_neg_mul_of_le\n  exacts [min_le_left .., min_le_right ..]\n\n"}
