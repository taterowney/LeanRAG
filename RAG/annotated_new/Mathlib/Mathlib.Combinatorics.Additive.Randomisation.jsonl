{"name":"AddDissociated.randomisation","module":"Mathlib.Combinatorics.Additive.Randomisation","initialProofState":"G : Type u_1\ninst✝¹ : Fintype G\ninst✝ : AddCommGroup G\nc : AddChar G Complex → Real\nd : AddChar G Complex → Complex\nhcd : AddDissociated (setOf fun ψ => Ne (d ψ) 0)\n⊢ Eq (Finset.univ.expect fun a => Finset.univ.prod fun ψ => HAdd.hAdd (c ψ) (HMul.hMul (d ψ) (ψ a)).re) (Finset.univ.prod fun ψ => c ψ)","decl":"/-- One can randomise by a function of dissociated support. -/\nlemma AddDissociated.randomisation (c : AddChar G ℂ → ℝ) (d : AddChar G ℂ → ℂ)\n    (hcd : AddDissociated {ψ | d ψ ≠ 0}) : 𝔼 a, ∏ ψ, (c ψ + (d ψ * ψ a).re) = ∏ ψ, c ψ := by\n  refine Complex.ofReal_injective ?_\n  push_cast\n  calc\n    _ = ∑ t, (𝔼 a, ∏ ψ ∈ t, ((d ψ * ψ a) + conj (d ψ * ψ a)) / 2) * ∏ ψ ∈ tᶜ, (c ψ : ℂ) := by\n        simp_rw [expect_mul, ← expect_sum_comm, ← Fintype.prod_add, add_comm,\n          Complex.re_eq_add_conj]\n    _ = (𝔼 a, ∏ ψ ∈ ∅, ((d ψ * ψ a) + conj (d ψ * ψ a)) / 2) * ∏ ψ ∈ ∅ᶜ, (c ψ : ℂ) :=\n        Fintype.sum_eq_single ∅ fun t ht ↦ mul_eq_zero_of_left ?_ _\n    _ = ∏ ψ, (c ψ : ℂ) := by simp\n  simp only [map_mul, prod_div_distrib, prod_add, prod_const, ← expect_div, expect_sum_comm,\n    div_eq_zero_iff, pow_eq_zero_iff', OfNat.ofNat_ne_zero, ne_eq, card_eq_zero, compl_eq_empty_iff,\n    false_and, or_false]\n  refine sum_eq_zero fun u _ ↦ ?_\n  calc\n    𝔼 a, (∏ ψ ∈ u, d ψ * ψ a) * ∏ ψ ∈ t \\ u, conj (d ψ) * conj (ψ a)\n      = ((∏ ψ ∈ u, d ψ) * ∏ ψ ∈ t \\ u, conj (d ψ)) * 𝔼 a, (∑ ψ ∈ u, ψ - ∑ ψ ∈ t \\ u, ψ) a := by\n        simp_rw [mul_expect, AddChar.sub_apply, AddChar.sum_apply, mul_mul_mul_comm,\n          ← prod_mul_distrib, AddChar.map_neg_eq_conj]\n    _ = 0 := ?_\n  rw [mul_eq_zero, AddChar.expect_eq_zero_iff_ne_zero, sub_ne_zero, or_iff_not_imp_left, ← Ne,\n    mul_ne_zero_iff, prod_ne_zero_iff, prod_ne_zero_iff]\n  exact fun h ↦ hcd.ne h.1 (by simpa only [map_ne_zero] using h.2)\n    (sdiff_ne_right.2 <| .inl ht).symm\n"}
