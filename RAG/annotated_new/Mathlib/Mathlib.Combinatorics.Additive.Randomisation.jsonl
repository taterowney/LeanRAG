{"name":"AddDissociated.randomisation","module":"Mathlib.Combinatorics.Additive.Randomisation","initialProofState":"G : Type u_1\ninstâœÂ¹ : Fintype G\ninstâœ : AddCommGroup G\nc : AddChar G Complex â†’ Real\nd : AddChar G Complex â†’ Complex\nhcd : AddDissociated (setOf fun Ïˆ => Ne (d Ïˆ) 0)\nâŠ¢ Eq (Finset.univ.expect fun a => Finset.univ.prod fun Ïˆ => HAdd.hAdd (c Ïˆ) (HMul.hMul (d Ïˆ) (Ïˆ a)).re) (Finset.univ.prod fun Ïˆ => c Ïˆ)","decl":"/-- One can randomise by a function of dissociated support. -/\nlemma AddDissociated.randomisation (c : AddChar G â„‚ â†’ â„) (d : AddChar G â„‚ â†’ â„‚)\n    (hcd : AddDissociated {Ïˆ | d Ïˆ â‰  0}) : ğ”¼ a, âˆ Ïˆ, (c Ïˆ + (d Ïˆ * Ïˆ a).re) = âˆ Ïˆ, c Ïˆ := by\n  refine Complex.ofReal_injective ?_\n  push_cast\n  calc\n    _ = âˆ‘ t, (ğ”¼ a, âˆ Ïˆ âˆˆ t, ((d Ïˆ * Ïˆ a) + conj (d Ïˆ * Ïˆ a)) / 2) * âˆ Ïˆ âˆˆ tá¶œ, (c Ïˆ : â„‚) := by\n        simp_rw [expect_mul, â† expect_sum_comm, â† Fintype.prod_add, add_comm,\n          Complex.re_eq_add_conj]\n    _ = (ğ”¼ a, âˆ Ïˆ âˆˆ âˆ…, ((d Ïˆ * Ïˆ a) + conj (d Ïˆ * Ïˆ a)) / 2) * âˆ Ïˆ âˆˆ âˆ…á¶œ, (c Ïˆ : â„‚) :=\n        Fintype.sum_eq_single âˆ… fun t ht â†¦ mul_eq_zero_of_left ?_ _\n    _ = âˆ Ïˆ, (c Ïˆ : â„‚) := by simp\n  simp only [map_mul, prod_div_distrib, prod_add, prod_const, â† expect_div, expect_sum_comm,\n    div_eq_zero_iff, pow_eq_zero_iff', OfNat.ofNat_ne_zero, ne_eq, card_eq_zero, compl_eq_empty_iff,\n    false_and, or_false]\n  refine sum_eq_zero fun u _ â†¦ ?_\n  calc\n    ğ”¼ a, (âˆ Ïˆ âˆˆ u, d Ïˆ * Ïˆ a) * âˆ Ïˆ âˆˆ t \\ u, conj (d Ïˆ) * conj (Ïˆ a)\n      = ((âˆ Ïˆ âˆˆ u, d Ïˆ) * âˆ Ïˆ âˆˆ t \\ u, conj (d Ïˆ)) * ğ”¼ a, (âˆ‘ Ïˆ âˆˆ u, Ïˆ - âˆ‘ Ïˆ âˆˆ t \\ u, Ïˆ) a := by\n        simp_rw [mul_expect, AddChar.sub_apply, AddChar.sum_apply, mul_mul_mul_comm,\n          â† prod_mul_distrib, AddChar.map_neg_eq_conj]\n    _ = 0 := ?_\n  rw [mul_eq_zero, AddChar.expect_eq_zero_iff_ne_zero, sub_ne_zero, or_iff_not_imp_left, â† Ne,\n    mul_ne_zero_iff, prod_ne_zero_iff, prod_ne_zero_iff]\n  exact fun h â†¦ hcd.ne h.1 (by simpa only [map_ne_zero] using h.2)\n    (sdiff_ne_right.2 <| .inl ht).symm\n"}
