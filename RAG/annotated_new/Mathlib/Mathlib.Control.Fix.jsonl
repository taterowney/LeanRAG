{"name":"Part.fix_def","module":"Mathlib.Control.Fix","initialProofState":"α : Type u_1\nβ : α → Type u_2\nf : ((a : α) → Part (β a)) → (a : α) → Part (β a)\nx : α\nh' : Exists fun i => (Part.Fix.approx f i x).Dom\n⊢ Eq (Part.fix f x) (Part.Fix.approx f (Nat.find h').succ x)","decl":"open Classical in\nprotected theorem fix_def {x : α} (h' : ∃ i, (Fix.approx f i x).Dom) :\n    Part.fix f x = Fix.approx f (Nat.succ (Nat.find h')) x := by\n  let p := fun i : ℕ => (Fix.approx f i x).Dom\n  have : p (Nat.find h') := Nat.find_spec h'\n  generalize hk : Nat.find h' = k\n  replace hk : Nat.find h' = k + (@Upto.zero p).val := hk\n  rw [hk] at this\n  revert hk\n  dsimp [Part.fix]; rw [assert_pos h']; revert this\n  generalize Upto.zero = z; intro _this hk\n  suffices ∀ x',\n    WellFounded.fix (Part.fix.proof_1 f x h') (fixAux f) z x' = Fix.approx f (succ k) x'\n    from this _\n  induction k generalizing z with\n  | zero =>\n    intro x'\n    rw [Fix.approx, WellFounded.fix_eq, fixAux]\n    congr\n    ext x : 1\n    rw [assert_neg]\n    · rfl\n    · rw [Nat.zero_add] at _this\n      simpa only [not_not, Coe]\n  | succ n n_ih =>\n    intro x'\n    rw [Fix.approx, WellFounded.fix_eq, fixAux]\n    congr\n    ext : 1\n    have hh : ¬(Fix.approx f z.val x).Dom := by\n      apply Nat.find_min h'\n      rw [hk, Nat.succ_add_eq_add_succ]\n      apply Nat.lt_of_succ_le\n      apply Nat.le_add_left\n    rw [succ_add_eq_add_succ] at _this hk\n    rw [assert_pos hh, n_ih (Upto.succ z hh) _this hk]\n\n"}
{"name":"Part.fix_def'","module":"Mathlib.Control.Fix","initialProofState":"α : Type u_1\nβ : α → Type u_2\nf : ((a : α) → Part (β a)) → (a : α) → Part (β a)\nx : α\nh' : Not (Exists fun i => (Part.Fix.approx f i x).Dom)\n⊢ Eq (Part.fix f x) Part.none","decl":"theorem fix_def' {x : α} (h' : ¬∃ i, (Fix.approx f i x).Dom) : Part.fix f x = none := by\n  dsimp [Part.fix]\n  rw [assert_neg h']\n\n"}
