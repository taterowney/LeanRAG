{"name":"TopCat.Presheaf.isLocallySurjective_iff","module":"Mathlib.Topology.Sheaves.LocallySurjective","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.HasForget C\nX : TopCat\nℱ 𝒢 : TopCat.Presheaf C X\nT : Quiver.Hom ℱ 𝒢\n⊢ Iff (TopCat.Presheaf.IsLocallySurjective T) (∀ (U : TopologicalSpace.Opens ↑X) (t : (CategoryTheory.forget C).obj (𝒢.obj { unop := U })) (x : ↑X), Membership.mem U x → Exists fun V => Exists fun ι => And (Exists fun s => Eq ((T.app { unop := V }) s) (TopCat.Presheaf.restrict t ι)) (Membership.mem V x))","decl":"theorem isLocallySurjective_iff (T : ℱ ⟶ 𝒢) :\n    IsLocallySurjective T ↔\n      ∀ (U t), ∀ x ∈ U, ∃ (V : _) (ι : V ⟶ U), (∃ s, T.app _ s = t |_ₕ ι) ∧ x ∈ V :=\n  ⟨fun h _ => h.imageSieve_mem, fun h => ⟨h _⟩⟩\n\n"}
{"name":"TopCat.Presheaf.locally_surjective_iff_surjective_on_stalks","module":"Mathlib.Topology.Sheaves.LocallySurjective","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.HasForget C\nX : TopCat\nℱ 𝒢 : TopCat.Presheaf C X\ninst✝¹ : CategoryTheory.Limits.HasColimits C\ninst✝ : CategoryTheory.Limits.PreservesFilteredColimits (CategoryTheory.forget C)\nT : Quiver.Hom ℱ 𝒢\n⊢ Iff (TopCat.Presheaf.IsLocallySurjective T) (∀ (x : ↑X), Function.Surjective ⇑((TopCat.Presheaf.stalkFunctor C x).map T))","decl":"/-- An equivalent condition for a map of presheaves to be locally surjective\nis for all the induced maps on stalks to be surjective. -/\ntheorem locally_surjective_iff_surjective_on_stalks (T : ℱ ⟶ 𝒢) :\n    IsLocallySurjective T ↔ ∀ x : X, Function.Surjective ((stalkFunctor C x).map T) := by\n  constructor <;> intro hT\n  · /- human proof:\n        Let g ∈ Γₛₜ 𝒢 x be a germ. Represent it on an open set U ⊆ X\n        as ⟨t, U⟩. By local surjectivity, pass to a smaller open set V\n        on which there exists s ∈ Γ_ ℱ V mapping to t |_ V.\n        Then the germ of s maps to g -/\n    -- Let g ∈ Γₛₜ 𝒢 x be a germ.\n    intro x g\n    -- Represent it on an open set U ⊆ X as ⟨t, U⟩.\n    obtain ⟨U, hxU, t, rfl⟩ := 𝒢.germ_exist x g\n    -- By local surjectivity, pass to a smaller open set V\n    -- on which there exists s ∈ Γ_ ℱ V mapping to t |_ V.\n    rcases hT.imageSieve_mem t x hxU with ⟨V, ι, ⟨s, h_eq⟩, hxV⟩\n    -- Then the germ of s maps to g.\n    use ℱ.germ _ x hxV s\n    -- Porting note: `convert` went too deep and swapped LHS and RHS of the remaining goal relative\n    -- to lean 3.\n    convert stalkFunctor_map_germ_apply V x hxV T s using 1\n    simpa [h_eq] using (germ_res_apply 𝒢 ι x hxV t).symm\n  · /- human proof:\n        Let U be an open set, t ∈ Γ ℱ U a section, x ∈ U a point.\n        By surjectivity on stalks, the germ of t is the image of\n        some germ f ∈ Γₛₜ ℱ x. Represent f on some open set V ⊆ X as ⟨s, V⟩.\n        Then there is some possibly smaller open set x ∈ W ⊆ V ∩ U on which\n        we have T(s) |_ W = t |_ W. -/\n    constructor\n    intro U t x hxU\n    set t_x := 𝒢.germ _ x hxU t with ht_x\n    obtain ⟨s_x, hs_x : ((stalkFunctor C x).map T) s_x = t_x⟩ := hT x t_x\n    obtain ⟨V, hxV, s, rfl⟩ := ℱ.germ_exist x s_x\n    -- rfl : ℱ.germ x s = s_x\n    have key_W := 𝒢.germ_eq x hxV hxU (T.app _ s) t <| by\n      convert hs_x using 1\n      symm\n      convert stalkFunctor_map_germ_apply _ _ _ _ s\n    obtain ⟨W, hxW, hWV, hWU, h_eq⟩ := key_W\n    refine ⟨W, hWU, ⟨ℱ.map hWV.op s, ?_⟩, hxW⟩\n    convert h_eq using 1\n    simp only [← CategoryTheory.comp_apply, T.naturality]\n\n"}
