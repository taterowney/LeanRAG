{"name":"TopCat.Presheaf.isLocallySurjective_iff","module":"Mathlib.Topology.Sheaves.LocallySurjective","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.HasForget C\nX : TopCat\nâ„± ğ’¢ : TopCat.Presheaf C X\nT : Quiver.Hom â„± ğ’¢\nâŠ¢ Iff (TopCat.Presheaf.IsLocallySurjective T) (âˆ€ (U : TopologicalSpace.Opens â†‘X) (t : (CategoryTheory.forget C).obj (ğ’¢.obj { unop := U })) (x : â†‘X), Membership.mem U x â†’ Exists fun V => Exists fun Î¹ => And (Exists fun s => Eq ((T.app { unop := V }) s) (TopCat.Presheaf.restrict t Î¹)) (Membership.mem V x))","decl":"theorem isLocallySurjective_iff (T : â„± âŸ¶ ğ’¢) :\n    IsLocallySurjective T â†”\n      âˆ€ (U t), âˆ€ x âˆˆ U, âˆƒ (V : _) (Î¹ : V âŸ¶ U), (âˆƒ s, T.app _ s = t |_â‚• Î¹) âˆ§ x âˆˆ V :=\n  âŸ¨fun h _ => h.imageSieve_mem, fun h => âŸ¨h _âŸ©âŸ©\n\n"}
{"name":"TopCat.Presheaf.locally_surjective_iff_surjective_on_stalks","module":"Mathlib.Topology.Sheaves.LocallySurjective","initialProofState":"C : Type u\ninstâœÂ³ : CategoryTheory.Category.{v, u} C\ninstâœÂ² : CategoryTheory.HasForget C\nX : TopCat\nâ„± ğ’¢ : TopCat.Presheaf C X\ninstâœÂ¹ : CategoryTheory.Limits.HasColimits C\ninstâœ : CategoryTheory.Limits.PreservesFilteredColimits (CategoryTheory.forget C)\nT : Quiver.Hom â„± ğ’¢\nâŠ¢ Iff (TopCat.Presheaf.IsLocallySurjective T) (âˆ€ (x : â†‘X), Function.Surjective â‡‘((TopCat.Presheaf.stalkFunctor C x).map T))","decl":"/-- An equivalent condition for a map of presheaves to be locally surjective\nis for all the induced maps on stalks to be surjective. -/\ntheorem locally_surjective_iff_surjective_on_stalks (T : â„± âŸ¶ ğ’¢) :\n    IsLocallySurjective T â†” âˆ€ x : X, Function.Surjective ((stalkFunctor C x).map T) := by\n  constructor <;> intro hT\n  Â· /- human proof:\n        Let g âˆˆ Î“â‚›â‚œ ğ’¢ x be a germ. Represent it on an open set U âŠ† X\n        as âŸ¨t, UâŸ©. By local surjectivity, pass to a smaller open set V\n        on which there exists s âˆˆ Î“_ â„± V mapping to t |_ V.\n        Then the germ of s maps to g -/\n    -- Let g âˆˆ Î“â‚›â‚œ ğ’¢ x be a germ.\n    intro x g\n    -- Represent it on an open set U âŠ† X as âŸ¨t, UâŸ©.\n    obtain âŸ¨U, hxU, t, rflâŸ© := ğ’¢.germ_exist x g\n    -- By local surjectivity, pass to a smaller open set V\n    -- on which there exists s âˆˆ Î“_ â„± V mapping to t |_ V.\n    rcases hT.imageSieve_mem t x hxU with âŸ¨V, Î¹, âŸ¨s, h_eqâŸ©, hxVâŸ©\n    -- Then the germ of s maps to g.\n    use â„±.germ _ x hxV s\n    -- Porting note: `convert` went too deep and swapped LHS and RHS of the remaining goal relative\n    -- to lean 3.\n    convert stalkFunctor_map_germ_apply V x hxV T s using 1\n    simpa [h_eq] using (germ_res_apply ğ’¢ Î¹ x hxV t).symm\n  Â· /- human proof:\n        Let U be an open set, t âˆˆ Î“ â„± U a section, x âˆˆ U a point.\n        By surjectivity on stalks, the germ of t is the image of\n        some germ f âˆˆ Î“â‚›â‚œ â„± x. Represent f on some open set V âŠ† X as âŸ¨s, VâŸ©.\n        Then there is some possibly smaller open set x âˆˆ W âŠ† V âˆ© U on which\n        we have T(s) |_ W = t |_ W. -/\n    constructor\n    intro U t x hxU\n    set t_x := ğ’¢.germ _ x hxU t with ht_x\n    obtain âŸ¨s_x, hs_x : ((stalkFunctor C x).map T) s_x = t_xâŸ© := hT x t_x\n    obtain âŸ¨V, hxV, s, rflâŸ© := â„±.germ_exist x s_x\n    -- rfl : â„±.germ x s = s_x\n    have key_W := ğ’¢.germ_eq x hxV hxU (T.app _ s) t <| by\n      convert hs_x using 1\n      symm\n      convert stalkFunctor_map_germ_apply _ _ _ _ s\n    obtain âŸ¨W, hxW, hWV, hWU, h_eqâŸ© := key_W\n    refine âŸ¨W, hWU, âŸ¨â„±.map hWV.op s, ?_âŸ©, hxWâŸ©\n    convert h_eq using 1\n    simp only [â† CategoryTheory.comp_apply, T.naturality]\n\n"}
