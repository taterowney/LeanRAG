{"name":"KaehlerDifferential.mulActionBaseChange_smul_tmul","module":"Mathlib.RingTheory.Kaehler.TensorProduct","initialProofState":"R : Type u_1\nS : Type u_2\nA : Type u_3\ninst✝⁴ : CommRing R\ninst✝³ : CommRing S\ninst✝² : Algebra R S\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\na : A\ns : S\nx : KaehlerDifferential R A\n⊢ Eq (HSMul.hSMul a (TensorProduct.tmul R s x)) (TensorProduct.tmul R s (HSMul.hSMul a x))","decl":"@[simp]\nlemma mulActionBaseChange_smul_tmul (a : A) (s : S) (x : Ω[A⁄R]) :\n    a • (s ⊗ₜ[R] x) = s ⊗ₜ (a • x) := rfl\n\n"}
{"name":"KaehlerDifferential.mulActionBaseChange_smul_zero","module":"Mathlib.RingTheory.Kaehler.TensorProduct","initialProofState":"R : Type u_1\nS : Type u_2\nA : Type u_3\ninst✝⁴ : CommRing R\ninst✝³ : CommRing S\ninst✝² : Algebra R S\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\na : A\n⊢ Eq (HSMul.hSMul a 0) 0","decl":"@[local simp]\nlemma mulActionBaseChange_smul_zero (a : A) :\n    a • (0 : S ⊗[R] Ω[A⁄R]) = 0 := by\n  rw [← zero_tmul _ (0 : Ω[A⁄R]), mulActionBaseChange_smul_tmul, smul_zero]\n\n"}
{"name":"KaehlerDifferential.mulActionBaseChange_smul_add","module":"Mathlib.RingTheory.Kaehler.TensorProduct","initialProofState":"R : Type u_1\nS : Type u_2\nA : Type u_3\ninst✝⁴ : CommRing R\ninst✝³ : CommRing S\ninst✝² : Algebra R S\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\na : A\nx y : TensorProduct R S (KaehlerDifferential R A)\n⊢ Eq (HSMul.hSMul a (HAdd.hAdd x y)) (HAdd.hAdd (HSMul.hSMul a x) (HSMul.hSMul a y))","decl":"@[local simp]\nlemma mulActionBaseChange_smul_add (a : A) (x y : S ⊗[R] Ω[A⁄R]) :\n    a • (x + y) = a • x + a • y := by\n  show (TensorProduct.comm R S (Ω[A⁄R])).symm (a • (TensorProduct.comm R S (Ω[A⁄R])) (x + y)) = _\n  rw [map_add, smul_add, map_add]\n  rfl\n\n"}
{"name":"KaehlerDifferential.instIsScalarTowerTensorProduct","module":"Mathlib.RingTheory.Kaehler.TensorProduct","initialProofState":"R : Type u_1\nS : Type u_2\nA : Type u_3\ninst✝⁴ : CommRing R\ninst✝³ : CommRing S\ninst✝² : Algebra R S\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\n⊢ IsScalarTower R A (TensorProduct R S (KaehlerDifferential R A))","decl":"instance : IsScalarTower R A (S ⊗[R] Ω[A⁄R]) := by\n  apply IsScalarTower.of_algebraMap_smul\n  intro r x\n  induction x\n  · simp only [smul_zero]\n  · rw [mulActionBaseChange_smul_tmul, algebraMap_smul, tmul_smul]\n  · simp only [smul_add, *]\n\n"}
{"name":"KaehlerDifferential.instSMulCommClassTensorProduct","module":"Mathlib.RingTheory.Kaehler.TensorProduct","initialProofState":"R : Type u_1\nS : Type u_2\nA : Type u_3\ninst✝⁴ : CommRing R\ninst✝³ : CommRing S\ninst✝² : Algebra R S\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\n⊢ SMulCommClass S A (TensorProduct R S (KaehlerDifferential R A))","decl":"instance : SMulCommClass S A (S ⊗[R] Ω[A⁄R]) where\n  smul_comm s a x := by\n    induction x\n    · simp only [smul_zero]\n    · rw [mulActionBaseChange_smul_tmul, smul_tmul', smul_tmul', mulActionBaseChange_smul_tmul]\n    · simp only [smul_add, *]\n\n"}
{"name":"KaehlerDifferential.instSMulCommClassTensorProduct_1","module":"Mathlib.RingTheory.Kaehler.TensorProduct","initialProofState":"R : Type u_1\nS : Type u_2\nA : Type u_3\ninst✝⁴ : CommRing R\ninst✝³ : CommRing S\ninst✝² : Algebra R S\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\n⊢ SMulCommClass A S (TensorProduct R S (KaehlerDifferential R A))","decl":"instance : SMulCommClass A S (S ⊗[R] Ω[A⁄R]) where\n  smul_comm s a x := by rw [← smul_comm]\n\n"}
{"name":"KaehlerDifferential.instIsScalarTowerTensorProduct_1","module":"Mathlib.RingTheory.Kaehler.TensorProduct","initialProofState":"R : Type u_1\nS : Type u_2\nA : Type u_3\nB : Type u_4\ninst✝¹¹ : CommRing R\ninst✝¹⁰ : CommRing S\ninst✝⁹ : Algebra R S\ninst✝⁸ : CommRing A\ninst✝⁷ : CommRing B\ninst✝⁶ : Algebra R A\ninst✝⁵ : Algebra R B\ninst✝⁴ : Algebra A B\ninst✝³ : Algebra S B\ninst✝² : IsScalarTower R A B\ninst✝¹ : IsScalarTower R S B\ninst✝ : Algebra.IsPushout R S A B\n⊢ IsScalarTower A B (TensorProduct R S (KaehlerDifferential R A))","decl":"instance [Algebra.IsPushout R S A B] :\n    IsScalarTower A B (S ⊗[R] Ω[A⁄R]) := by\n  apply IsScalarTower.of_algebraMap_smul\n  intro r x\n  show (Algebra.pushoutDesc B (Algebra.lsmul R (A := S) S (S ⊗[R] Ω[A⁄R]))\n    (Algebra.lsmul R (A := A) _ _) (LinearMap.ext <| smul_comm · ·)\n      (algebraMap A B r)) • x = r • x\n  simp only [Algebra.pushoutDesc_right, LinearMap.smul_def, Algebra.lsmul_coe]\n\n"}
{"name":"KaehlerDifferential.instIsScalarTowerTensorProduct_2","module":"Mathlib.RingTheory.Kaehler.TensorProduct","initialProofState":"R : Type u_1\nS : Type u_2\nA : Type u_3\nB : Type u_4\ninst✝¹¹ : CommRing R\ninst✝¹⁰ : CommRing S\ninst✝⁹ : Algebra R S\ninst✝⁸ : CommRing A\ninst✝⁷ : CommRing B\ninst✝⁶ : Algebra R A\ninst✝⁵ : Algebra R B\ninst✝⁴ : Algebra A B\ninst✝³ : Algebra S B\ninst✝² : IsScalarTower R A B\ninst✝¹ : IsScalarTower R S B\ninst✝ : Algebra.IsPushout R S A B\n⊢ IsScalarTower S B (TensorProduct R S (KaehlerDifferential R A))","decl":"instance [Algebra.IsPushout R S A B] :\n    IsScalarTower S B (S ⊗[R] Ω[A⁄R]) := by\n  apply IsScalarTower.of_algebraMap_smul\n  intro r x\n  show (Algebra.pushoutDesc B (Algebra.lsmul R (A := S) S (S ⊗[R] Ω[A⁄R]))\n    (Algebra.lsmul R (A := A) _ _) (LinearMap.ext <| smul_comm · ·)\n      (algebraMap S B r)) • x = r • x\n  simp only [Algebra.pushoutDesc_left, LinearMap.smul_def, Algebra.lsmul_coe]\n\n"}
{"name":"KaehlerDifferential.map_liftBaseChange_smul","module":"Mathlib.RingTheory.Kaehler.TensorProduct","initialProofState":"R : Type u_1\nS : Type u_2\nA : Type u_3\nB : Type u_4\ninst✝¹⁰ : CommRing R\ninst✝⁹ : CommRing S\ninst✝⁸ : Algebra R S\ninst✝⁷ : CommRing A\ninst✝⁶ : CommRing B\ninst✝⁵ : Algebra R A\ninst✝⁴ : Algebra R B\ninst✝³ : Algebra A B\ninst✝² : Algebra S B\ninst✝¹ : IsScalarTower R A B\ninst✝ : IsScalarTower R S B\nh : Algebra.IsPushout R S A B\nb : B\nx : TensorProduct R S (KaehlerDifferential R A)\n⊢ Eq ((LinearMap.liftBaseChange S (↑R (KaehlerDifferential.map R S A B))) (HSMul.hSMul b x)) (HSMul.hSMul b ((LinearMap.liftBaseChange S (↑R (KaehlerDifferential.map R S A B))) x))","decl":"lemma map_liftBaseChange_smul [h : Algebra.IsPushout R S A B] (b : B) (x) :\n    ((map R S A B).restrictScalars R).liftBaseChange S (b • x) =\n    b • ((map R S A B).restrictScalars R).liftBaseChange S x := by\n  induction b using h.1.inductionOn with\n  | h₁ => simp only [zero_smul, map_zero]\n  | h₃ s b e => rw [smul_assoc, map_smul, e, smul_assoc]\n  | h₄ b₁ b₂ e₁ e₂ => simp only [map_add, e₁, e₂, add_smul]\n  | h₂ a =>\n    induction x\n    · simp only [smul_zero, map_zero]\n    · simp [smul_comm]\n    · simp only [map_add, smul_add, *]\n\n"}
{"name":"KaehlerDifferential.derivationTensorProduct_algebraMap","module":"Mathlib.RingTheory.Kaehler.TensorProduct","initialProofState":"R : Type u_1\nS : Type u_2\nA : Type u_3\nB : Type u_4\ninst✝¹¹ : CommRing R\ninst✝¹⁰ : CommRing S\ninst✝⁹ : Algebra R S\ninst✝⁸ : CommRing A\ninst✝⁷ : CommRing B\ninst✝⁶ : Algebra R A\ninst✝⁵ : Algebra R B\ninst✝⁴ : Algebra A B\ninst✝³ : Algebra S B\ninst✝² : IsScalarTower R A B\ninst✝¹ : IsScalarTower R S B\ninst✝ : Algebra.IsPushout R S A B\nx : A\n⊢ Eq ((KaehlerDifferential.derivationTensorProduct R S A B) ((algebraMap A B) x)) (TensorProduct.tmul R 1 ((KaehlerDifferential.D R A) x))","decl":"lemma derivationTensorProduct_algebraMap [Algebra.IsPushout R S A B] (x) :\n    derivationTensorProduct R S A B (algebraMap A B x) =\n    1 ⊗ₜ D _ _ x :=\nIsBaseChange.lift_eq _ _ _\n\n"}
{"name":"KaehlerDifferential.tensorKaehlerEquiv_left_inv","module":"Mathlib.RingTheory.Kaehler.TensorProduct","initialProofState":"R : Type u_1\nS : Type u_2\nA : Type u_3\nB : Type u_4\ninst✝¹¹ : CommRing R\ninst✝¹⁰ : CommRing S\ninst✝⁹ : Algebra R S\ninst✝⁸ : CommRing A\ninst✝⁷ : CommRing B\ninst✝⁶ : Algebra R A\ninst✝⁵ : Algebra R B\ninst✝⁴ : Algebra A B\ninst✝³ : Algebra S B\ninst✝² : IsScalarTower R A B\ninst✝¹ : IsScalarTower R S B\ninst✝ : Algebra.IsPushout R S A B\n⊢ Eq ((↑S (KaehlerDifferential.derivationTensorProduct R S A B).liftKaehlerDifferential).comp (LinearMap.liftBaseChange S (↑R (KaehlerDifferential.map R S A B)))) LinearMap.id","decl":"lemma tensorKaehlerEquiv_left_inv [Algebra.IsPushout R S A B] :\n    ((derivationTensorProduct R S A B).liftKaehlerDifferential.restrictScalars S).comp\n    (((map R S A B).restrictScalars R).liftBaseChange S) = LinearMap.id := by\n  refine LinearMap.restrictScalars_injective R ?_\n  apply TensorProduct.ext'\n  intro x y\n  obtain ⟨y, rfl⟩ := tensorProductTo_surjective _ _ y\n  induction y\n  · simp only [map_zero, TensorProduct.tmul_zero]\n  · simp only [LinearMap.restrictScalars_comp, Derivation.tensorProductTo_tmul, LinearMap.coe_comp,\n      LinearMap.coe_restrictScalars, Function.comp_apply, LinearMap.liftBaseChange_tmul, map_smul,\n      map_D, LinearMap.map_smul_of_tower, Derivation.liftKaehlerDifferential_comp_D,\n      LinearMap.id_coe, id_eq, derivationTensorProduct_algebraMap]\n    rw [smul_comm, TensorProduct.smul_tmul', smul_eq_mul, mul_one]\n    rfl\n  · simp only [map_add, TensorProduct.tmul_add, *]\n\n"}
{"name":"KaehlerDifferential.tensorKaehlerEquiv_symm_apply","module":"Mathlib.RingTheory.Kaehler.TensorProduct","initialProofState":"R : Type u_1\nS : Type u_2\nA : Type u_3\nB : Type u_4\ninst✝¹⁰ : CommRing R\ninst✝⁹ : CommRing S\ninst✝⁸ : Algebra R S\ninst✝⁷ : CommRing A\ninst✝⁶ : CommRing B\ninst✝⁵ : Algebra R A\ninst✝⁴ : Algebra R B\ninst✝³ : Algebra A B\ninst✝² : Algebra S B\ninst✝¹ : IsScalarTower R A B\ninst✝ : IsScalarTower R S B\nh : Algebra.IsPushout R S A B\na : KaehlerDifferential S B\n⊢ Eq ((KaehlerDifferential.tensorKaehlerEquiv R S A B).symm a) ((KaehlerDifferential.derivationTensorProduct R S A B).liftKaehlerDifferential a)","decl":"/-- The canonical isomorphism `(S ⊗[R] Ω[A⁄R]) ≃ₗ[S] Ω[B⁄S]` for `B = S ⊗[R] A`. -/\n@[simps! symm_apply] noncomputable\ndef tensorKaehlerEquiv [h : Algebra.IsPushout R S A B] :\n    (S ⊗[R] Ω[A⁄R]) ≃ₗ[S] Ω[B⁄S] where\n  __ := ((map R S A B).restrictScalars R).liftBaseChange S\n  invFun := (derivationTensorProduct R S A B).liftKaehlerDifferential\n  left_inv := LinearMap.congr_fun (tensorKaehlerEquiv_left_inv R S A B)\n  right_inv x := by\n    obtain ⟨x, rfl⟩ := tensorProductTo_surjective _ _ x\n    dsimp\n    induction x with\n    | zero => simp\n    | add x y e₁ e₂ => simp only [map_add, e₁, e₂]\n    | tmul x y =>\n      dsimp\n      simp only [Derivation.tensorProductTo_tmul, LinearMap.map_smul,\n        Derivation.liftKaehlerDifferential_comp_D, map_liftBaseChange_smul]\n      induction y using h.1.inductionOn\n      · simp only [map_zero, smul_zero]\n      · simp only [AlgHom.toLinearMap_apply, IsScalarTower.coe_toAlgHom',\n          derivationTensorProduct_algebraMap, LinearMap.liftBaseChange_tmul,\n          LinearMap.coe_restrictScalars, map_D, one_smul]\n      · simp only [Derivation.map_smul, LinearMap.map_smul, *, smul_comm x]\n      · simp only [map_add, smul_add, *]\n\n"}
{"name":"KaehlerDifferential.tensorKaehlerEquiv_tmul","module":"Mathlib.RingTheory.Kaehler.TensorProduct","initialProofState":"R : Type u_1\nS : Type u_2\nA : Type u_3\nB : Type u_4\ninst✝¹¹ : CommRing R\ninst✝¹⁰ : CommRing S\ninst✝⁹ : Algebra R S\ninst✝⁸ : CommRing A\ninst✝⁷ : CommRing B\ninst✝⁶ : Algebra R A\ninst✝⁵ : Algebra R B\ninst✝⁴ : Algebra A B\ninst✝³ : Algebra S B\ninst✝² : IsScalarTower R A B\ninst✝¹ : IsScalarTower R S B\ninst✝ : Algebra.IsPushout R S A B\na : S\nb : KaehlerDifferential R A\n⊢ Eq ((KaehlerDifferential.tensorKaehlerEquiv R S A B) (TensorProduct.tmul R a b)) (HSMul.hSMul a ((KaehlerDifferential.map R S A B) b))","decl":"@[simp]\nlemma tensorKaehlerEquiv_tmul [Algebra.IsPushout R S A B] (a b) :\n    tensorKaehlerEquiv R S A B (a ⊗ₜ b) = a • map R S A B b :=\n  LinearMap.liftBaseChange_tmul _ _ _ _\n\n"}
{"name":"KaehlerDifferential.isBaseChange","module":"Mathlib.RingTheory.Kaehler.TensorProduct","initialProofState":"R : Type u_1\nS : Type u_2\nA : Type u_3\nB : Type u_4\ninst✝¹⁰ : CommRing R\ninst✝⁹ : CommRing S\ninst✝⁸ : Algebra R S\ninst✝⁷ : CommRing A\ninst✝⁶ : CommRing B\ninst✝⁵ : Algebra R A\ninst✝⁴ : Algebra R B\ninst✝³ : Algebra A B\ninst✝² : Algebra S B\ninst✝¹ : IsScalarTower R A B\ninst✝ : IsScalarTower R S B\nh : Algebra.IsPushout R S A B\n⊢ IsBaseChange S (↑R (KaehlerDifferential.map R S A B))","decl":"/--\nIf `B` is the tensor product of `S` and `A` over `R`,\nthen `Ω[B⁄S]` is the base change of `Ω[A⁄R]` along `R → S`.\n-/\nlemma isBaseChange [h : Algebra.IsPushout R S A B] :\n    IsBaseChange S ((map R S A B).restrictScalars R) := by\n  convert (TensorProduct.isBaseChange R (Ω[A⁄R]) S).comp\n    (IsBaseChange.ofEquiv (tensorKaehlerEquiv R S A B))\n  refine LinearMap.ext fun x ↦ ?_\n  simp only [LinearMap.coe_restrictScalars, LinearMap.coe_comp, LinearEquiv.coe_coe,\n    Function.comp_apply, mk_apply, tensorKaehlerEquiv_tmul, one_smul]\n\n"}
{"name":"KaehlerDifferential.isLocalizedModule","module":"Mathlib.RingTheory.Kaehler.TensorProduct","initialProofState":"R : Type u_1\nS : Type u_2\nA : Type u_3\nB : Type u_4\ninst✝¹² : CommRing R\ninst✝¹¹ : CommRing S\ninst✝¹⁰ : Algebra R S\ninst✝⁹ : CommRing A\ninst✝⁸ : CommRing B\ninst✝⁷ : Algebra R A\ninst✝⁶ : Algebra R B\ninst✝⁵ : Algebra A B\ninst✝⁴ : Algebra S B\ninst✝³ : IsScalarTower R A B\ninst✝² : IsScalarTower R S B\np : Submonoid R\ninst✝¹ : IsLocalization p S\ninst✝ : IsLocalization (Algebra.algebraMapSubmonoid A p) B\n⊢ IsLocalizedModule p (↑R (KaehlerDifferential.map R S A B))","decl":"instance isLocalizedModule (p : Submonoid R) [IsLocalization p S]\n      [IsLocalization (Algebra.algebraMapSubmonoid A p) B] :\n    IsLocalizedModule p ((map R S A B).restrictScalars R) :=\n  have := (Algebra.isPushout_of_isLocalization p S A B).symm\n  (isLocalizedModule_iff_isBaseChange p S _).mpr (isBaseChange R S A B)\n\n"}
{"name":"KaehlerDifferential.isLocalizedModule_of_isLocalizedModule","module":"Mathlib.RingTheory.Kaehler.TensorProduct","initialProofState":"R : Type u_1\nS : Type u_2\nA : Type u_3\nB : Type u_4\ninst✝¹² : CommRing R\ninst✝¹¹ : CommRing S\ninst✝¹⁰ : Algebra R S\ninst✝⁹ : CommRing A\ninst✝⁸ : CommRing B\ninst✝⁷ : Algebra R A\ninst✝⁶ : Algebra R B\ninst✝⁵ : Algebra A B\ninst✝⁴ : Algebra S B\ninst✝³ : IsScalarTower R A B\ninst✝² : IsScalarTower R S B\np : Submonoid R\ninst✝¹ : IsLocalization p S\ninst✝ : IsLocalizedModule p (IsScalarTower.toAlgHom R A B).toLinearMap\n⊢ IsLocalizedModule p (↑R (KaehlerDifferential.map R S A B))","decl":"instance isLocalizedModule_of_isLocalizedModule (p : Submonoid R) [IsLocalization p S]\n      [IsLocalizedModule p (IsScalarTower.toAlgHom R A B).toLinearMap] :\n    IsLocalizedModule p ((map R S A B).restrictScalars R) :=\n  have : IsLocalization (Algebra.algebraMapSubmonoid A p) B :=\n    isLocalizedModule_iff_isLocalization.mp inferInstance\n  inferInstance\n\n"}
