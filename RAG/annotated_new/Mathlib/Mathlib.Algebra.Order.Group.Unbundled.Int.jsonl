{"name":"Int.natCast_strictMono","module":"Mathlib.Algebra.Order.Group.Unbundled.Int","initialProofState":"⊢ StrictMono fun x => ↑x","decl":"theorem natCast_strictMono : StrictMono (· : ℕ → ℤ) := fun _ _ ↦ Int.ofNat_lt.2\n\n"}
{"name":"Int.abs_eq_natAbs","module":"Mathlib.Algebra.Order.Group.Unbundled.Int","initialProofState":"a : Int\n⊢ Eq (abs a) ↑a.natAbs","decl":"theorem abs_eq_natAbs : ∀ a : ℤ, |a| = natAbs a\n  | (n : ℕ) => abs_of_nonneg <| ofNat_zero_le _\n  | -[_+1] => abs_of_nonpos <| le_of_lt <| negSucc_lt_zero _\n\n"}
{"name":"Int.natCast_natAbs","module":"Mathlib.Algebra.Order.Group.Unbundled.Int","initialProofState":"n : Int\n⊢ Eq (↑n.natAbs) (abs n)","decl":"@[simp, norm_cast] lemma natCast_natAbs (n : ℤ) : (n.natAbs : ℤ) = |n| := n.abs_eq_natAbs.symm\n\n"}
{"name":"Int.natAbs_abs","module":"Mathlib.Algebra.Order.Group.Unbundled.Int","initialProofState":"a : Int\n⊢ Eq (abs a).natAbs a.natAbs","decl":"theorem natAbs_abs (a : ℤ) : natAbs |a| = natAbs a := by rw [abs_eq_natAbs]; rfl\n\n"}
{"name":"Int.sign_mul_abs","module":"Mathlib.Algebra.Order.Group.Unbundled.Int","initialProofState":"a : Int\n⊢ Eq (HMul.hMul a.sign (abs a)) a","decl":"theorem sign_mul_abs (a : ℤ) : sign a * |a| = a := by\n  rw [abs_eq_natAbs, sign_mul_natAbs a]\n\n"}
{"name":"Int.sign_mul_self_eq_abs","module":"Mathlib.Algebra.Order.Group.Unbundled.Int","initialProofState":"a : Int\n⊢ Eq (HMul.hMul a.sign a) (abs a)","decl":"theorem sign_mul_self_eq_abs (a : ℤ) : sign a * a = |a| := by\n  rw [abs_eq_natAbs, sign_mul_self_eq_natAbs]\n\n"}
{"name":"Int.natAbs_le_self_sq","module":"Mathlib.Algebra.Order.Group.Unbundled.Int","initialProofState":"a : Int\n⊢ LE.le (↑a.natAbs) (HPow.hPow a 2)","decl":"lemma natAbs_le_self_sq (a : ℤ) : (Int.natAbs a : ℤ) ≤ a ^ 2 := by\n  rw [← Int.natAbs_sq a, sq]\n  norm_cast\n  apply Nat.le_mul_self\n\n"}
{"name":"Int.natAbs_le_self_pow_two","module":"Mathlib.Algebra.Order.Group.Unbundled.Int","initialProofState":"a : Int\n⊢ LE.le (↑a.natAbs) (HPow.hPow a 2)","decl":"alias natAbs_le_self_pow_two := natAbs_le_self_sq\n\n"}
{"name":"Int.le_self_sq","module":"Mathlib.Algebra.Order.Group.Unbundled.Int","initialProofState":"b : Int\n⊢ LE.le b (HPow.hPow b 2)","decl":"lemma le_self_sq (b : ℤ) : b ≤ b ^ 2 := le_trans le_natAbs (natAbs_le_self_sq _)\n\n"}
{"name":"Int.le_self_pow_two","module":"Mathlib.Algebra.Order.Group.Unbundled.Int","initialProofState":"b : Int\n⊢ LE.le b (HPow.hPow b 2)","decl":"alias le_self_pow_two := le_self_sq\n\n"}
{"name":"Int.abs_natCast","module":"Mathlib.Algebra.Order.Group.Unbundled.Int","initialProofState":"n : Nat\n⊢ Eq (abs ↑n) ↑n","decl":"@[norm_cast] lemma abs_natCast (n : ℕ) : |(n : ℤ)| = n := abs_of_nonneg (natCast_nonneg n)\n\n"}
{"name":"Int.natAbs_sub_pos_iff","module":"Mathlib.Algebra.Order.Group.Unbundled.Int","initialProofState":"i j : Int\n⊢ Iff (LT.lt 0 (HSub.hSub i j).natAbs) (Ne i j)","decl":"theorem natAbs_sub_pos_iff {i j : ℤ} : 0 < natAbs (i - j) ↔ i ≠ j := by\n  rw [natAbs_pos, ne_eq, sub_eq_zero]\n\n"}
{"name":"Int.natAbs_sub_ne_zero_iff","module":"Mathlib.Algebra.Order.Group.Unbundled.Int","initialProofState":"i j : Int\n⊢ Iff (Ne (HSub.hSub i j).natAbs 0) (Ne i j)","decl":"theorem natAbs_sub_ne_zero_iff {i j : ℤ} : natAbs (i - j) ≠ 0 ↔ i ≠ j :=\n  Nat.ne_zero_iff_zero_lt.trans natAbs_sub_pos_iff\n\n"}
{"name":"Int.abs_lt_one_iff","module":"Mathlib.Algebra.Order.Group.Unbundled.Int","initialProofState":"a : Int\n⊢ Iff (LT.lt (abs a) 1) (Eq a 0)","decl":"@[simp]\ntheorem abs_lt_one_iff {a : ℤ} : |a| < 1 ↔ a = 0 := by\n  rw [← zero_add 1, lt_add_one_iff, abs_nonpos_iff]\n\n"}
{"name":"Int.abs_le_one_iff","module":"Mathlib.Algebra.Order.Group.Unbundled.Int","initialProofState":"a : Int\n⊢ Iff (LE.le (abs a) 1) (Or (Eq a 0) (Or (Eq a 1) (Eq a (-1))))","decl":"theorem abs_le_one_iff {a : ℤ} : |a| ≤ 1 ↔ a = 0 ∨ a = 1 ∨ a = -1 := by\n  rw [le_iff_lt_or_eq, abs_lt_one_iff]\n  match a with\n  | (n : ℕ) => simp [abs_eq_natAbs]\n  | -[n+1] =>\n      simp only [negSucc_ne_zero, abs_eq_natAbs, natAbs_negSucc, succ_eq_add_one,\n        natCast_add, Nat.cast_ofNat_Int, add_left_eq_self, natCast_eq_zero, false_or, reduceNeg]\n      rw [negSucc_eq']\n      omega\n\n"}
{"name":"Int.one_le_abs","module":"Mathlib.Algebra.Order.Group.Unbundled.Int","initialProofState":"z : Int\nh₀ : Ne z 0\n⊢ LE.le 1 (abs z)","decl":"theorem one_le_abs {z : ℤ} (h₀ : z ≠ 0) : 1 ≤ |z| :=\n  add_one_le_iff.mpr (abs_pos.mpr h₀)\n\n"}
{"name":"Int.eq_zero_of_abs_lt_dvd","module":"Mathlib.Algebra.Order.Group.Unbundled.Int","initialProofState":"m x : Int\nh1 : Dvd.dvd m x\nh2 : LT.lt (abs x) m\n⊢ Eq x 0","decl":"lemma eq_zero_of_abs_lt_dvd {m x : ℤ} (h1 : m ∣ x) (h2 : |x| < m) : x = 0 := by\n  by_contra h\n  have := Int.natAbs_le_of_dvd_ne_zero h1 h\n  rw [Int.abs_eq_natAbs] at h2\n  omega\n\n"}
{"name":"Int.abs_sub_lt_of_lt_lt","module":"Mathlib.Algebra.Order.Group.Unbundled.Int","initialProofState":"m a b : Nat\nha : LT.lt a m\nhb : LT.lt b m\n⊢ LT.lt (abs (HSub.hSub ↑b ↑a)) ↑m","decl":"lemma abs_sub_lt_of_lt_lt {m a b : ℕ} (ha : a < m) (hb : b < m) : |(b : ℤ) - a| < m := by\n  rw [abs_lt]; omega\n\n"}
{"name":"Int.ediv_eq_zero_of_lt_abs","module":"Mathlib.Algebra.Order.Group.Unbundled.Int","initialProofState":"a b : Int\nH1 : LE.le 0 a\nH2 : LT.lt a (abs b)\n⊢ Eq (HDiv.hDiv a b) 0","decl":"theorem ediv_eq_zero_of_lt_abs {a b : ℤ} (H1 : 0 ≤ a) (H2 : a < |b|) : a / b = 0 :=\n  match b, |b|, abs_eq_natAbs b, H2 with\n  | (n : ℕ), _, rfl, H2 => ediv_eq_zero_of_lt H1 H2\n  | -[n+1], _, rfl, H2 => neg_injective <| by rw [← Int.ediv_neg]; exact ediv_eq_zero_of_lt H1 H2\n\n"}
{"name":"Int.emod_abs","module":"Mathlib.Algebra.Order.Group.Unbundled.Int","initialProofState":"a b : Int\n⊢ Eq (HMod.hMod a (abs b)) (HMod.hMod a b)","decl":"@[simp]\ntheorem emod_abs (a b : ℤ) : a % |b| = a % b :=\n  abs_by_cases (fun i => a % i = a % b) rfl (emod_neg _ _)\n\n"}
{"name":"Int.emod_lt","module":"Mathlib.Algebra.Order.Group.Unbundled.Int","initialProofState":"a b : Int\nH : Ne b 0\n⊢ LT.lt (HMod.hMod a b) (abs b)","decl":"theorem emod_lt (a : ℤ) {b : ℤ} (H : b ≠ 0) : a % b < |b| := by\n  rw [← emod_abs]; exact emod_lt_of_pos _ (abs_pos.2 H)\n\n"}
{"name":"Int.abs_ediv_le_abs","module":"Mathlib.Algebra.Order.Group.Unbundled.Int","initialProofState":"a b : Int\n⊢ LE.le (abs (HDiv.hDiv a b)) (abs a)","decl":"theorem abs_ediv_le_abs : ∀ a b : ℤ, |a / b| ≤ |a| :=\n  suffices ∀ (a : ℤ) (n : ℕ), |a / n| ≤ |a| from fun a b =>\n    match b, eq_nat_or_neg b with\n    | _, ⟨n, Or.inl rfl⟩ => this _ _\n    | _, ⟨n, Or.inr rfl⟩ => by rw [Int.ediv_neg, abs_neg]; apply this\n  fun a n => by\n  rw [abs_eq_natAbs, abs_eq_natAbs];\n  exact ofNat_le_ofNat_of_le\n    (match a, n with\n      | (m : ℕ), n => Nat.div_le_self _ _\n      | -[m+1], 0 => Nat.zero_le _\n      | -[m+1], n + 1 => Nat.succ_le_succ (Nat.div_le_self _ _))\n\n"}
{"name":"Int.abs_sign_of_nonzero","module":"Mathlib.Algebra.Order.Group.Unbundled.Int","initialProofState":"z : Int\nhz : Ne z 0\n⊢ Eq (abs z.sign) 1","decl":"theorem abs_sign_of_nonzero {z : ℤ} (hz : z ≠ 0) : |z.sign| = 1 := by\n  rw [abs_eq_natAbs, natAbs_sign_of_nonzero hz, Int.ofNat_one]\n\n"}
{"name":"Int.sign_eq_ediv_abs","module":"Mathlib.Algebra.Order.Group.Unbundled.Int","initialProofState":"a : Int\n⊢ Eq a.sign (HDiv.hDiv a (abs a))","decl":"protected theorem sign_eq_ediv_abs (a : ℤ) : sign a = a / |a| :=\n  if az : a = 0 then by simp [az]\n  else (Int.ediv_eq_of_eq_mul_left (mt abs_eq_zero.1 az) (sign_mul_abs _).symm).symm\n\n"}
{"name":"Int.sign_eq_abs_ediv","module":"Mathlib.Algebra.Order.Group.Unbundled.Int","initialProofState":"a : Int\n⊢ Eq a.sign (HDiv.hDiv (abs a) a)","decl":"protected theorem sign_eq_abs_ediv (a : ℤ) : sign a = |a| / a :=\n  if az : a = 0 then by simp [az]\n  else (Int.ediv_eq_of_eq_mul_left az (sign_mul_self_eq_abs _).symm).symm\n\n"}
{"name":"zpow_abs_eq_one","module":"Mathlib.Algebra.Order.Group.Unbundled.Int","initialProofState":"G : Type u_1\ninst✝ : Group G\na : G\nn : Int\n⊢ Iff (Eq (HPow.hPow a (abs n)) 1) (Eq (HPow.hPow a n) 1)","decl":"@[to_additive (attr := simp) abs_zsmul_eq_zero]\nlemma zpow_abs_eq_one (a : G) (n : ℤ) : a ^ |n| = 1 ↔ a ^ n = 1 := by\n  rw [← Int.natCast_natAbs, zpow_natCast, pow_natAbs_eq_one]\n\n"}
{"name":"abs_zsmul_eq_zero","module":"Mathlib.Algebra.Order.Group.Unbundled.Int","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\na : G\nn : Int\n⊢ Iff (Eq (HSMul.hSMul (abs n) a) 0) (Eq (HSMul.hSMul n a) 0)","decl":"@[to_additive (attr := simp) abs_zsmul_eq_zero]\nlemma zpow_abs_eq_one (a : G) (n : ℤ) : a ^ |n| = 1 ↔ a ^ n = 1 := by\n  rw [← Int.natCast_natAbs, zpow_natCast, pow_natAbs_eq_one]\n\n"}
