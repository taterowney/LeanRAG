{"name":"tendstoUniformlyOnFilter_iff_tendsto","module":"Mathlib.Topology.UniformSpace.UniformConvergence","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒπ : Type x\ninst‚úù : UniformSpace Œ≤\nF : Œπ ‚Üí Œ± ‚Üí Œ≤\nf : Œ± ‚Üí Œ≤\np : Filter Œπ\np' : Filter Œ±\n‚ä¢ Iff (TendstoUniformlyOnFilter F f p p') (Filter.Tendsto (fun q => { fst := f q.2, snd := F q.1 q.2 }) (SProd.sprod p p') (uniformity Œ≤))","decl":"/--\nA sequence of functions `F‚Çô` converges uniformly on a filter `p'` to a limiting function `f` w.r.t.\nfilter `p` iff the function `(n, x) ‚Ü¶ (f x, F‚Çô x)` converges along `p √óÀ¢ p'` to the uniformity.\nIn other words: one knows nothing about the behavior of `x` in this limit besides it being in `p'`.\n-/\ntheorem tendstoUniformlyOnFilter_iff_tendsto :\n    TendstoUniformlyOnFilter F f p p' ‚Üî\n      Tendsto (fun q : Œπ √ó Œ± => (f q.2, F q.1 q.2)) (p √óÀ¢ p') (ùì§ Œ≤) :=\n  Iff.rfl\n\n"}
{"name":"tendstoUniformlyOn_iff_tendstoUniformlyOnFilter","module":"Mathlib.Topology.UniformSpace.UniformConvergence","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒπ : Type x\ninst‚úù : UniformSpace Œ≤\nF : Œπ ‚Üí Œ± ‚Üí Œ≤\nf : Œ± ‚Üí Œ≤\ns : Set Œ±\np : Filter Œπ\n‚ä¢ Iff (TendstoUniformlyOn F f p s) (TendstoUniformlyOnFilter F f p (Filter.principal s))","decl":"theorem tendstoUniformlyOn_iff_tendstoUniformlyOnFilter :\n    TendstoUniformlyOn F f p s ‚Üî TendstoUniformlyOnFilter F f p (ùìü s) := by\n  simp only [TendstoUniformlyOn, TendstoUniformlyOnFilter]\n  apply forall‚ÇÇ_congr\n  simp_rw [eventually_prod_principal_iff]\n  simp\n\n\n"}
{"name":"TendstoUniformlyOn.tendstoUniformlyOnFilter","module":"Mathlib.Topology.UniformSpace.UniformConvergence","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒπ : Type x\ninst‚úù : UniformSpace Œ≤\nF : Œπ ‚Üí Œ± ‚Üí Œ≤\nf : Œ± ‚Üí Œ≤\ns : Set Œ±\np : Filter Œπ\na‚úù : TendstoUniformlyOn F f p s\n‚ä¢ TendstoUniformlyOnFilter F f p (Filter.principal s)","decl":"alias ‚ü®TendstoUniformlyOn.tendstoUniformlyOnFilter, TendstoUniformlyOnFilter.tendstoUniformlyOn‚ü© :=\n  tendstoUniformlyOn_iff_tendstoUniformlyOnFilter\n\n"}
{"name":"TendstoUniformlyOnFilter.tendstoUniformlyOn","module":"Mathlib.Topology.UniformSpace.UniformConvergence","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒπ : Type x\ninst‚úù : UniformSpace Œ≤\nF : Œπ ‚Üí Œ± ‚Üí Œ≤\nf : Œ± ‚Üí Œ≤\ns : Set Œ±\np : Filter Œπ\na‚úù : TendstoUniformlyOnFilter F f p (Filter.principal s)\n‚ä¢ TendstoUniformlyOn F f p s","decl":"alias ‚ü®TendstoUniformlyOn.tendstoUniformlyOnFilter, TendstoUniformlyOnFilter.tendstoUniformlyOn‚ü© :=\n  tendstoUniformlyOn_iff_tendstoUniformlyOnFilter\n\n"}
{"name":"tendstoUniformlyOn_iff_tendsto","module":"Mathlib.Topology.UniformSpace.UniformConvergence","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒπ : Type x\ninst‚úù : UniformSpace Œ≤\nF : Œπ ‚Üí Œ± ‚Üí Œ≤\nf : Œ± ‚Üí Œ≤\np : Filter Œπ\ns : Set Œ±\n‚ä¢ Iff (TendstoUniformlyOn F f p s) (Filter.Tendsto (fun q => { fst := f q.2, snd := F q.1 q.2 }) (SProd.sprod p (Filter.principal s)) (uniformity Œ≤))","decl":"/-- A sequence of functions `F‚Çô` converges uniformly on a set `s` to a limiting function `f` w.r.t.\nfilter `p` iff the function `(n, x) ‚Ü¶ (f x, F‚Çô x)` converges along `p √óÀ¢ ùìü s` to the uniformity.\nIn other words: one knows nothing about the behavior of `x` in this limit besides it being in `s`.\n-/\ntheorem tendstoUniformlyOn_iff_tendsto {F : Œπ ‚Üí Œ± ‚Üí Œ≤} {f : Œ± ‚Üí Œ≤} {p : Filter Œπ} {s : Set Œ±} :\n    TendstoUniformlyOn F f p s ‚Üî\n    Tendsto (fun q : Œπ √ó Œ± => (f q.2, F q.1 q.2)) (p √óÀ¢ ùìü s) (ùì§ Œ≤) := by\n  simp [tendstoUniformlyOn_iff_tendstoUniformlyOnFilter, tendstoUniformlyOnFilter_iff_tendsto]\n\n"}
{"name":"tendstoUniformlyOn_univ","module":"Mathlib.Topology.UniformSpace.UniformConvergence","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒπ : Type x\ninst‚úù : UniformSpace Œ≤\nF : Œπ ‚Üí Œ± ‚Üí Œ≤\nf : Œ± ‚Üí Œ≤\np : Filter Œπ\n‚ä¢ Iff (TendstoUniformlyOn F f p Set.univ) (TendstoUniformly F f p)","decl":"theorem tendstoUniformlyOn_univ : TendstoUniformlyOn F f p univ ‚Üî TendstoUniformly F f p := by\n  simp [TendstoUniformlyOn, TendstoUniformly]\n\n"}
{"name":"tendstoUniformly_iff_tendstoUniformlyOnFilter","module":"Mathlib.Topology.UniformSpace.UniformConvergence","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒπ : Type x\ninst‚úù : UniformSpace Œ≤\nF : Œπ ‚Üí Œ± ‚Üí Œ≤\nf : Œ± ‚Üí Œ≤\np : Filter Œπ\n‚ä¢ Iff (TendstoUniformly F f p) (TendstoUniformlyOnFilter F f p Top.top)","decl":"theorem tendstoUniformly_iff_tendstoUniformlyOnFilter :\n    TendstoUniformly F f p ‚Üî TendstoUniformlyOnFilter F f p ‚ä§ := by\n  rw [‚Üê tendstoUniformlyOn_univ, tendstoUniformlyOn_iff_tendstoUniformlyOnFilter, principal_univ]\n\n"}
{"name":"TendstoUniformly.tendstoUniformlyOnFilter","module":"Mathlib.Topology.UniformSpace.UniformConvergence","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒπ : Type x\ninst‚úù : UniformSpace Œ≤\nF : Œπ ‚Üí Œ± ‚Üí Œ≤\nf : Œ± ‚Üí Œ≤\np : Filter Œπ\nh : TendstoUniformly F f p\n‚ä¢ TendstoUniformlyOnFilter F f p Top.top","decl":"theorem TendstoUniformly.tendstoUniformlyOnFilter (h : TendstoUniformly F f p) :\n    TendstoUniformlyOnFilter F f p ‚ä§ := by rwa [‚Üê tendstoUniformly_iff_tendstoUniformlyOnFilter]\n\n"}
{"name":"tendstoUniformlyOn_iff_tendstoUniformly_comp_coe","module":"Mathlib.Topology.UniformSpace.UniformConvergence","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒπ : Type x\ninst‚úù : UniformSpace Œ≤\nF : Œπ ‚Üí Œ± ‚Üí Œ≤\nf : Œ± ‚Üí Œ≤\ns : Set Œ±\np : Filter Œπ\n‚ä¢ Iff (TendstoUniformlyOn F f p s) (TendstoUniformly (fun i x => F i ‚Üëx) (Function.comp f Subtype.val) p)","decl":"theorem tendstoUniformlyOn_iff_tendstoUniformly_comp_coe :\n    TendstoUniformlyOn F f p s ‚Üî TendstoUniformly (fun i (x : s) => F i x) (f ‚àò (‚Üë)) p :=\n  forall‚ÇÇ_congr fun u _ => by simp\n\n"}
{"name":"tendstoUniformly_iff_tendsto","module":"Mathlib.Topology.UniformSpace.UniformConvergence","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒπ : Type x\ninst‚úù : UniformSpace Œ≤\nF : Œπ ‚Üí Œ± ‚Üí Œ≤\nf : Œ± ‚Üí Œ≤\np : Filter Œπ\n‚ä¢ Iff (TendstoUniformly F f p) (Filter.Tendsto (fun q => { fst := f q.2, snd := F q.1 q.2 }) (SProd.sprod p Top.top) (uniformity Œ≤))","decl":"/-- A sequence of functions `F‚Çô` converges uniformly to a limiting function `f` w.r.t.\nfilter `p` iff the function `(n, x) ‚Ü¶ (f x, F‚Çô x)` converges along `p √óÀ¢ ‚ä§` to the uniformity.\nIn other words: one knows nothing about the behavior of `x` in this limit.\n-/\ntheorem tendstoUniformly_iff_tendsto {F : Œπ ‚Üí Œ± ‚Üí Œ≤} {f : Œ± ‚Üí Œ≤} {p : Filter Œπ} :\n    TendstoUniformly F f p ‚Üî Tendsto (fun q : Œπ √ó Œ± => (f q.2, F q.1 q.2)) (p √óÀ¢ ‚ä§) (ùì§ Œ≤) := by\n  simp [tendstoUniformly_iff_tendstoUniformlyOnFilter, tendstoUniformlyOnFilter_iff_tendsto]\n\n"}
{"name":"TendstoUniformlyOnFilter.tendsto_at","module":"Mathlib.Topology.UniformSpace.UniformConvergence","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒπ : Type x\ninst‚úù : UniformSpace Œ≤\nF : Œπ ‚Üí Œ± ‚Üí Œ≤\nf : Œ± ‚Üí Œ≤\nx : Œ±\np : Filter Œπ\np' : Filter Œ±\nh : TendstoUniformlyOnFilter F f p p'\nhx : LE.le (Filter.principal (Singleton.singleton x)) p'\n‚ä¢ Filter.Tendsto (fun n => F n x) p (nhds (f x))","decl":"/-- Uniform converence implies pointwise convergence. -/\ntheorem TendstoUniformlyOnFilter.tendsto_at (h : TendstoUniformlyOnFilter F f p p')\n    (hx : ùìü {x} ‚â§ p') : Tendsto (fun n => F n x) p <| ùìù (f x) := by\n  refine Uniform.tendsto_nhds_right.mpr fun u hu => mem_map.mpr ?_\n  filter_upwards [(h u hu).curry]\n  intro i h\n  simpa using h.filter_mono hx\n\n"}
{"name":"TendstoUniformlyOn.tendsto_at","module":"Mathlib.Topology.UniformSpace.UniformConvergence","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒπ : Type x\ninst‚úù : UniformSpace Œ≤\nF : Œπ ‚Üí Œ± ‚Üí Œ≤\nf : Œ± ‚Üí Œ≤\ns : Set Œ±\np : Filter Œπ\nh : TendstoUniformlyOn F f p s\nx : Œ±\nhx : Membership.mem s x\n‚ä¢ Filter.Tendsto (fun n => F n x) p (nhds (f x))","decl":"/-- Uniform converence implies pointwise convergence. -/\ntheorem TendstoUniformlyOn.tendsto_at (h : TendstoUniformlyOn F f p s) {x : Œ±} (hx : x ‚àà s) :\n    Tendsto (fun n => F n x) p <| ùìù (f x) :=\n  h.tendstoUniformlyOnFilter.tendsto_at\n    (le_principal_iff.mpr <| mem_principal.mpr <| singleton_subset_iff.mpr <| hx)\n\n"}
{"name":"TendstoUniformly.tendsto_at","module":"Mathlib.Topology.UniformSpace.UniformConvergence","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒπ : Type x\ninst‚úù : UniformSpace Œ≤\nF : Œπ ‚Üí Œ± ‚Üí Œ≤\nf : Œ± ‚Üí Œ≤\np : Filter Œπ\nh : TendstoUniformly F f p\nx : Œ±\n‚ä¢ Filter.Tendsto (fun n => F n x) p (nhds (f x))","decl":"/-- Uniform converence implies pointwise convergence. -/\ntheorem TendstoUniformly.tendsto_at (h : TendstoUniformly F f p) (x : Œ±) :\n    Tendsto (fun n => F n x) p <| ùìù (f x) :=\n  h.tendstoUniformlyOnFilter.tendsto_at le_top\n\n-- Porting note: tendstoUniformlyOn_univ moved up\n\n"}
{"name":"TendstoUniformlyOnFilter.mono_left","module":"Mathlib.Topology.UniformSpace.UniformConvergence","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒπ : Type x\ninst‚úù : UniformSpace Œ≤\nF : Œπ ‚Üí Œ± ‚Üí Œ≤\nf : Œ± ‚Üí Œ≤\np : Filter Œπ\np' : Filter Œ±\np'' : Filter Œπ\nh : TendstoUniformlyOnFilter F f p p'\nhp : LE.le p'' p\n‚ä¢ TendstoUniformlyOnFilter F f p'' p'","decl":"theorem TendstoUniformlyOnFilter.mono_left {p'' : Filter Œπ} (h : TendstoUniformlyOnFilter F f p p')\n    (hp : p'' ‚â§ p) : TendstoUniformlyOnFilter F f p'' p' := fun u hu =>\n  (h u hu).filter_mono (p'.prod_mono_left hp)\n\n"}
{"name":"TendstoUniformlyOnFilter.mono_right","module":"Mathlib.Topology.UniformSpace.UniformConvergence","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒπ : Type x\ninst‚úù : UniformSpace Œ≤\nF : Œπ ‚Üí Œ± ‚Üí Œ≤\nf : Œ± ‚Üí Œ≤\np : Filter Œπ\np' p'' : Filter Œ±\nh : TendstoUniformlyOnFilter F f p p'\nhp : LE.le p'' p'\n‚ä¢ TendstoUniformlyOnFilter F f p p''","decl":"theorem TendstoUniformlyOnFilter.mono_right {p'' : Filter Œ±} (h : TendstoUniformlyOnFilter F f p p')\n    (hp : p'' ‚â§ p') : TendstoUniformlyOnFilter F f p p'' := fun u hu =>\n  (h u hu).filter_mono (p.prod_mono_right hp)\n\n"}
{"name":"TendstoUniformlyOn.mono","module":"Mathlib.Topology.UniformSpace.UniformConvergence","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒπ : Type x\ninst‚úù : UniformSpace Œ≤\nF : Œπ ‚Üí Œ± ‚Üí Œ≤\nf : Œ± ‚Üí Œ≤\ns : Set Œ±\np : Filter Œπ\ns' : Set Œ±\nh : TendstoUniformlyOn F f p s\nh' : HasSubset.Subset s' s\n‚ä¢ TendstoUniformlyOn F f p s'","decl":"theorem TendstoUniformlyOn.mono {s' : Set Œ±} (h : TendstoUniformlyOn F f p s) (h' : s' ‚äÜ s) :\n    TendstoUniformlyOn F f p s' :=\n  tendstoUniformlyOn_iff_tendstoUniformlyOnFilter.mpr\n    (h.tendstoUniformlyOnFilter.mono_right (le_principal_iff.mpr <| mem_principal.mpr h'))\n\n"}
{"name":"TendstoUniformlyOnFilter.congr","module":"Mathlib.Topology.UniformSpace.UniformConvergence","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒπ : Type x\ninst‚úù : UniformSpace Œ≤\nF : Œπ ‚Üí Œ± ‚Üí Œ≤\nf : Œ± ‚Üí Œ≤\np : Filter Œπ\np' : Filter Œ±\nF' : Œπ ‚Üí Œ± ‚Üí Œ≤\nhf : TendstoUniformlyOnFilter F f p p'\nhff' : Filter.Eventually (fun n => Eq (F n.1 n.2) (F' n.1 n.2)) (SProd.sprod p p')\n‚ä¢ TendstoUniformlyOnFilter F' f p p'","decl":"theorem TendstoUniformlyOnFilter.congr {F' : Œπ ‚Üí Œ± ‚Üí Œ≤} (hf : TendstoUniformlyOnFilter F f p p')\n    (hff' : ‚àÄ·∂† n : Œπ √ó Œ± in p √óÀ¢ p', F n.fst n.snd = F' n.fst n.snd) :\n    TendstoUniformlyOnFilter F' f p p' := by\n  refine fun u hu => ((hf u hu).and hff').mono fun n h => ?_\n  rw [‚Üê h.right]\n  exact h.left\n\n"}
{"name":"TendstoUniformlyOn.congr","module":"Mathlib.Topology.UniformSpace.UniformConvergence","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒπ : Type x\ninst‚úù : UniformSpace Œ≤\nF : Œπ ‚Üí Œ± ‚Üí Œ≤\nf : Œ± ‚Üí Œ≤\ns : Set Œ±\np : Filter Œπ\nF' : Œπ ‚Üí Œ± ‚Üí Œ≤\nhf : TendstoUniformlyOn F f p s\nhff' : Filter.Eventually (fun n => Set.EqOn (F n) (F' n) s) p\n‚ä¢ TendstoUniformlyOn F' f p s","decl":"theorem TendstoUniformlyOn.congr {F' : Œπ ‚Üí Œ± ‚Üí Œ≤} (hf : TendstoUniformlyOn F f p s)\n    (hff' : ‚àÄ·∂† n in p, Set.EqOn (F n) (F' n) s) : TendstoUniformlyOn F' f p s := by\n  rw [tendstoUniformlyOn_iff_tendstoUniformlyOnFilter] at hf ‚ä¢\n  refine hf.congr ?_\n  rw [eventually_iff] at hff' ‚ä¢\n  simp only [Set.EqOn] at hff'\n  simp only [mem_prod_principal, hff', mem_setOf_eq]\n\n"}
{"name":"tendstoUniformly_congr","module":"Mathlib.Topology.UniformSpace.UniformConvergence","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒπ : Type x\ninst‚úù : UniformSpace Œ≤\np : Filter Œπ\nF F' : Œπ ‚Üí Œ± ‚Üí Œ≤\nf : Œ± ‚Üí Œ≤\nhF : p.EventuallyEq F F'\n‚ä¢ Iff (TendstoUniformly F f p) (TendstoUniformly F' f p)","decl":"lemma tendstoUniformly_congr {F F' : Œπ ‚Üí Œ± ‚Üí Œ≤} {f : Œ± ‚Üí Œ≤} (hF : F =·∂†[p] F') :\n    TendstoUniformly F f p ‚Üî TendstoUniformly F' f p := by\n  simp_rw [‚Üê tendstoUniformlyOn_univ] at *\n  have HF := EventuallyEq.exists_mem hF\n  exact ‚ü®fun h => h.congr (by aesop), fun h => h.congr (by simp_rw [eqOn_comm]; aesop)‚ü©\n\n"}
{"name":"TendstoUniformlyOn.congr_right","module":"Mathlib.Topology.UniformSpace.UniformConvergence","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒπ : Type x\ninst‚úù : UniformSpace Œ≤\nF : Œπ ‚Üí Œ± ‚Üí Œ≤\nf : Œ± ‚Üí Œ≤\ns : Set Œ±\np : Filter Œπ\ng : Œ± ‚Üí Œ≤\nhf : TendstoUniformlyOn F f p s\nhfg : Set.EqOn f g s\n‚ä¢ TendstoUniformlyOn F g p s","decl":"theorem TendstoUniformlyOn.congr_right {g : Œ± ‚Üí Œ≤} (hf : TendstoUniformlyOn F f p s)\n    (hfg : EqOn f g s) : TendstoUniformlyOn F g p s := fun u hu => by\n  filter_upwards [hf u hu] with i hi a ha using hfg ha ‚ñ∏ hi a ha\n\n"}
{"name":"TendstoUniformly.tendstoUniformlyOn","module":"Mathlib.Topology.UniformSpace.UniformConvergence","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒπ : Type x\ninst‚úù : UniformSpace Œ≤\nF : Œπ ‚Üí Œ± ‚Üí Œ≤\nf : Œ± ‚Üí Œ≤\ns : Set Œ±\np : Filter Œπ\nh : TendstoUniformly F f p\n‚ä¢ TendstoUniformlyOn F f p s","decl":"protected theorem TendstoUniformly.tendstoUniformlyOn (h : TendstoUniformly F f p) :\n    TendstoUniformlyOn F f p s :=\n  (tendstoUniformlyOn_univ.2 h).mono (subset_univ s)\n\n"}
{"name":"TendstoUniformlyOnFilter.comp","module":"Mathlib.Topology.UniformSpace.UniformConvergence","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒ≥ : Type w\nŒπ : Type x\ninst‚úù : UniformSpace Œ≤\nF : Œπ ‚Üí Œ± ‚Üí Œ≤\nf : Œ± ‚Üí Œ≤\np : Filter Œπ\np' : Filter Œ±\nh : TendstoUniformlyOnFilter F f p p'\ng : Œ≥ ‚Üí Œ±\n‚ä¢ TendstoUniformlyOnFilter (fun n => Function.comp (F n) g) (Function.comp f g) p (Filter.comap g p')","decl":"/-- Composing on the right by a function preserves uniform convergence on a filter -/\ntheorem TendstoUniformlyOnFilter.comp (h : TendstoUniformlyOnFilter F f p p') (g : Œ≥ ‚Üí Œ±) :\n    TendstoUniformlyOnFilter (fun n => F n ‚àò g) (f ‚àò g) p (p'.comap g) := by\n  rw [tendstoUniformlyOnFilter_iff_tendsto] at h ‚ä¢\n  exact h.comp (tendsto_id.prod_map tendsto_comap)\n\n"}
{"name":"TendstoUniformlyOn.comp","module":"Mathlib.Topology.UniformSpace.UniformConvergence","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒ≥ : Type w\nŒπ : Type x\ninst‚úù : UniformSpace Œ≤\nF : Œπ ‚Üí Œ± ‚Üí Œ≤\nf : Œ± ‚Üí Œ≤\ns : Set Œ±\np : Filter Œπ\nh : TendstoUniformlyOn F f p s\ng : Œ≥ ‚Üí Œ±\n‚ä¢ TendstoUniformlyOn (fun n => Function.comp (F n) g) (Function.comp f g) p (Set.preimage g s)","decl":"/-- Composing on the right by a function preserves uniform convergence on a set -/\ntheorem TendstoUniformlyOn.comp (h : TendstoUniformlyOn F f p s) (g : Œ≥ ‚Üí Œ±) :\n    TendstoUniformlyOn (fun n => F n ‚àò g) (f ‚àò g) p (g ‚Åª¬π' s) := by\n  rw [tendstoUniformlyOn_iff_tendstoUniformlyOnFilter] at h ‚ä¢\n  simpa [TendstoUniformlyOn, comap_principal] using TendstoUniformlyOnFilter.comp h g\n\n"}
{"name":"TendstoUniformly.comp","module":"Mathlib.Topology.UniformSpace.UniformConvergence","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒ≥ : Type w\nŒπ : Type x\ninst‚úù : UniformSpace Œ≤\nF : Œπ ‚Üí Œ± ‚Üí Œ≤\nf : Œ± ‚Üí Œ≤\np : Filter Œπ\nh : TendstoUniformly F f p\ng : Œ≥ ‚Üí Œ±\n‚ä¢ TendstoUniformly (fun n => Function.comp (F n) g) (Function.comp f g) p","decl":"/-- Composing on the right by a function preserves uniform convergence -/\ntheorem TendstoUniformly.comp (h : TendstoUniformly F f p) (g : Œ≥ ‚Üí Œ±) :\n    TendstoUniformly (fun n => F n ‚àò g) (f ‚àò g) p := by\n  rw [tendstoUniformly_iff_tendstoUniformlyOnFilter] at h ‚ä¢\n  simpa [principal_univ, comap_principal] using h.comp g\n\n"}
{"name":"UniformContinuous.comp_tendstoUniformlyOnFilter","module":"Mathlib.Topology.UniformSpace.UniformConvergence","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒ≥ : Type w\nŒπ : Type x\ninst‚úù¬π : UniformSpace Œ≤\nF : Œπ ‚Üí Œ± ‚Üí Œ≤\nf : Œ± ‚Üí Œ≤\np : Filter Œπ\np' : Filter Œ±\ninst‚úù : UniformSpace Œ≥\ng : Œ≤ ‚Üí Œ≥\nhg : UniformContinuous g\nh : TendstoUniformlyOnFilter F f p p'\n‚ä¢ TendstoUniformlyOnFilter (fun i => Function.comp g (F i)) (Function.comp g f) p p'","decl":"/-- Composing on the left by a uniformly continuous function preserves\n  uniform convergence on a filter -/\ntheorem UniformContinuous.comp_tendstoUniformlyOnFilter [UniformSpace Œ≥] {g : Œ≤ ‚Üí Œ≥}\n    (hg : UniformContinuous g) (h : TendstoUniformlyOnFilter F f p p') :\n    TendstoUniformlyOnFilter (fun i => g ‚àò F i) (g ‚àò f) p p' := fun _u hu => h _ (hg hu)\n\n"}
{"name":"UniformContinuous.comp_tendstoUniformlyOn","module":"Mathlib.Topology.UniformSpace.UniformConvergence","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒ≥ : Type w\nŒπ : Type x\ninst‚úù¬π : UniformSpace Œ≤\nF : Œπ ‚Üí Œ± ‚Üí Œ≤\nf : Œ± ‚Üí Œ≤\ns : Set Œ±\np : Filter Œπ\ninst‚úù : UniformSpace Œ≥\ng : Œ≤ ‚Üí Œ≥\nhg : UniformContinuous g\nh : TendstoUniformlyOn F f p s\n‚ä¢ TendstoUniformlyOn (fun i => Function.comp g (F i)) (Function.comp g f) p s","decl":"/-- Composing on the left by a uniformly continuous function preserves\n  uniform convergence on a set -/\ntheorem UniformContinuous.comp_tendstoUniformlyOn [UniformSpace Œ≥] {g : Œ≤ ‚Üí Œ≥}\n    (hg : UniformContinuous g) (h : TendstoUniformlyOn F f p s) :\n    TendstoUniformlyOn (fun i => g ‚àò F i) (g ‚àò f) p s := fun _u hu => h _ (hg hu)\n\n"}
{"name":"UniformContinuous.comp_tendstoUniformly","module":"Mathlib.Topology.UniformSpace.UniformConvergence","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒ≥ : Type w\nŒπ : Type x\ninst‚úù¬π : UniformSpace Œ≤\nF : Œπ ‚Üí Œ± ‚Üí Œ≤\nf : Œ± ‚Üí Œ≤\np : Filter Œπ\ninst‚úù : UniformSpace Œ≥\ng : Œ≤ ‚Üí Œ≥\nhg : UniformContinuous g\nh : TendstoUniformly F f p\n‚ä¢ TendstoUniformly (fun i => Function.comp g (F i)) (Function.comp g f) p","decl":"/-- Composing on the left by a uniformly continuous function preserves uniform convergence -/\ntheorem UniformContinuous.comp_tendstoUniformly [UniformSpace Œ≥] {g : Œ≤ ‚Üí Œ≥}\n    (hg : UniformContinuous g) (h : TendstoUniformly F f p) :\n    TendstoUniformly (fun i => g ‚àò F i) (g ‚àò f) p := fun _u hu => h _ (hg hu)\n\n"}
{"name":"TendstoUniformlyOnFilter.prod_map","module":"Mathlib.Topology.UniformSpace.UniformConvergence","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒπ : Type x\ninst‚úù¬π : UniformSpace Œ≤\nF : Œπ ‚Üí Œ± ‚Üí Œ≤\nf : Œ± ‚Üí Œ≤\np : Filter Œπ\np' : Filter Œ±\nŒπ' : Type u_1\nŒ±' : Type u_2\nŒ≤' : Type u_3\ninst‚úù : UniformSpace Œ≤'\nF' : Œπ' ‚Üí Œ±' ‚Üí Œ≤'\nf' : Œ±' ‚Üí Œ≤'\nq : Filter Œπ'\nq' : Filter Œ±'\nh : TendstoUniformlyOnFilter F f p p'\nh' : TendstoUniformlyOnFilter F' f' q q'\n‚ä¢ TendstoUniformlyOnFilter (fun i => Prod.map (F i.1) (F' i.2)) (Prod.map f f') (SProd.sprod p q) (SProd.sprod p' q')","decl":"theorem TendstoUniformlyOnFilter.prod_map {Œπ' Œ±' Œ≤' : Type*} [UniformSpace Œ≤'] {F' : Œπ' ‚Üí Œ±' ‚Üí Œ≤'}\n    {f' : Œ±' ‚Üí Œ≤'} {q : Filter Œπ'} {q' : Filter Œ±'} (h : TendstoUniformlyOnFilter F f p p')\n    (h' : TendstoUniformlyOnFilter F' f' q q') :\n    TendstoUniformlyOnFilter (fun i : Œπ √ó Œπ' => Prod.map (F i.1) (F' i.2)) (Prod.map f f')\n      (p √óÀ¢ q) (p' √óÀ¢ q') := by\n  rw [tendstoUniformlyOnFilter_iff_tendsto] at h h' ‚ä¢\n  rw [uniformity_prod_eq_comap_prod, tendsto_comap_iff, ‚Üê map_swap4_prod, tendsto_map'_iff]\n  convert h.prod_map h' -- seems to be faster than `exact` here\n\n"}
{"name":"TendstoUniformlyOn.prod_map","module":"Mathlib.Topology.UniformSpace.UniformConvergence","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒπ : Type x\ninst‚úù¬π : UniformSpace Œ≤\nF : Œπ ‚Üí Œ± ‚Üí Œ≤\nf : Œ± ‚Üí Œ≤\ns : Set Œ±\np : Filter Œπ\nŒπ' : Type u_1\nŒ±' : Type u_2\nŒ≤' : Type u_3\ninst‚úù : UniformSpace Œ≤'\nF' : Œπ' ‚Üí Œ±' ‚Üí Œ≤'\nf' : Œ±' ‚Üí Œ≤'\np' : Filter Œπ'\ns' : Set Œ±'\nh : TendstoUniformlyOn F f p s\nh' : TendstoUniformlyOn F' f' p' s'\n‚ä¢ TendstoUniformlyOn (fun i => Prod.map (F i.1) (F' i.2)) (Prod.map f f') (SProd.sprod p p') (SProd.sprod s s')","decl":"theorem TendstoUniformlyOn.prod_map {Œπ' Œ±' Œ≤' : Type*} [UniformSpace Œ≤'] {F' : Œπ' ‚Üí Œ±' ‚Üí Œ≤'}\n    {f' : Œ±' ‚Üí Œ≤'} {p' : Filter Œπ'} {s' : Set Œ±'} (h : TendstoUniformlyOn F f p s)\n    (h' : TendstoUniformlyOn F' f' p' s') :\n    TendstoUniformlyOn (fun i : Œπ √ó Œπ' => Prod.map (F i.1) (F' i.2)) (Prod.map f f') (p √óÀ¢ p')\n      (s √óÀ¢ s') := by\n  rw [tendstoUniformlyOn_iff_tendstoUniformlyOnFilter] at h h' ‚ä¢\n  simpa only [prod_principal_principal] using h.prod_map h'\n\n"}
{"name":"TendstoUniformly.prod_map","module":"Mathlib.Topology.UniformSpace.UniformConvergence","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒπ : Type x\ninst‚úù¬π : UniformSpace Œ≤\nF : Œπ ‚Üí Œ± ‚Üí Œ≤\nf : Œ± ‚Üí Œ≤\np : Filter Œπ\nŒπ' : Type u_1\nŒ±' : Type u_2\nŒ≤' : Type u_3\ninst‚úù : UniformSpace Œ≤'\nF' : Œπ' ‚Üí Œ±' ‚Üí Œ≤'\nf' : Œ±' ‚Üí Œ≤'\np' : Filter Œπ'\nh : TendstoUniformly F f p\nh' : TendstoUniformly F' f' p'\n‚ä¢ TendstoUniformly (fun i => Prod.map (F i.1) (F' i.2)) (Prod.map f f') (SProd.sprod p p')","decl":"theorem TendstoUniformly.prod_map {Œπ' Œ±' Œ≤' : Type*} [UniformSpace Œ≤'] {F' : Œπ' ‚Üí Œ±' ‚Üí Œ≤'}\n    {f' : Œ±' ‚Üí Œ≤'} {p' : Filter Œπ'} (h : TendstoUniformly F f p) (h' : TendstoUniformly F' f' p') :\n    TendstoUniformly (fun i : Œπ √ó Œπ' => Prod.map (F i.1) (F' i.2)) (Prod.map f f') (p √óÀ¢ p') := by\n  rw [‚Üê tendstoUniformlyOn_univ, ‚Üê univ_prod_univ] at *\n  exact h.prod_map h'\n\n"}
{"name":"TendstoUniformlyOnFilter.prod","module":"Mathlib.Topology.UniformSpace.UniformConvergence","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒπ : Type x\ninst‚úù¬π : UniformSpace Œ≤\nF : Œπ ‚Üí Œ± ‚Üí Œ≤\nf : Œ± ‚Üí Œ≤\np : Filter Œπ\np' : Filter Œ±\nŒπ' : Type u_1\nŒ≤' : Type u_2\ninst‚úù : UniformSpace Œ≤'\nF' : Œπ' ‚Üí Œ± ‚Üí Œ≤'\nf' : Œ± ‚Üí Œ≤'\nq : Filter Œπ'\nh : TendstoUniformlyOnFilter F f p p'\nh' : TendstoUniformlyOnFilter F' f' q p'\n‚ä¢ TendstoUniformlyOnFilter (fun i a => { fst := F i.1 a, snd := F' i.2 a }) (fun a => { fst := f a, snd := f' a }) (SProd.sprod p q) p'","decl":"theorem TendstoUniformlyOnFilter.prod {Œπ' Œ≤' : Type*} [UniformSpace Œ≤'] {F' : Œπ' ‚Üí Œ± ‚Üí Œ≤'}\n    {f' : Œ± ‚Üí Œ≤'} {q : Filter Œπ'} (h : TendstoUniformlyOnFilter F f p p')\n    (h' : TendstoUniformlyOnFilter F' f' q p') :\n    TendstoUniformlyOnFilter (fun (i : Œπ √ó Œπ') a => (F i.1 a, F' i.2 a)) (fun a => (f a, f' a))\n      (p √óÀ¢ q) p' :=\n  fun u hu => ((h.prod_map h') u hu).diag_of_prod_right\n\n"}
{"name":"TendstoUniformlyOn.prod","module":"Mathlib.Topology.UniformSpace.UniformConvergence","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒπ : Type x\ninst‚úù¬π : UniformSpace Œ≤\nF : Œπ ‚Üí Œ± ‚Üí Œ≤\nf : Œ± ‚Üí Œ≤\ns : Set Œ±\np : Filter Œπ\nŒπ' : Type u_1\nŒ≤' : Type u_2\ninst‚úù : UniformSpace Œ≤'\nF' : Œπ' ‚Üí Œ± ‚Üí Œ≤'\nf' : Œ± ‚Üí Œ≤'\np' : Filter Œπ'\nh : TendstoUniformlyOn F f p s\nh' : TendstoUniformlyOn F' f' p' s\n‚ä¢ TendstoUniformlyOn (fun i a => { fst := F i.1 a, snd := F' i.2 a }) (fun a => { fst := f a, snd := f' a }) (SProd.sprod p p') s","decl":"protected theorem TendstoUniformlyOn.prod {Œπ' Œ≤' : Type*} [UniformSpace Œ≤']\n    {F' : Œπ' ‚Üí Œ± ‚Üí Œ≤'} {f' : Œ± ‚Üí Œ≤'} {p' : Filter Œπ'}\n    (h : TendstoUniformlyOn F f p s) (h' : TendstoUniformlyOn F' f' p' s) :\n    TendstoUniformlyOn (fun (i : Œπ √ó Œπ') a => (F i.1 a, F' i.2 a)) (fun a => (f a, f' a))\n      (p √óÀ¢ p') s :=\n  (congr_arg _ s.inter_self).mp ((h.prod_map h').comp fun a => (a, a))\n\n"}
{"name":"TendstoUniformly.prod","module":"Mathlib.Topology.UniformSpace.UniformConvergence","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒπ : Type x\ninst‚úù¬π : UniformSpace Œ≤\nF : Œπ ‚Üí Œ± ‚Üí Œ≤\nf : Œ± ‚Üí Œ≤\np : Filter Œπ\nŒπ' : Type u_1\nŒ≤' : Type u_2\ninst‚úù : UniformSpace Œ≤'\nF' : Œπ' ‚Üí Œ± ‚Üí Œ≤'\nf' : Œ± ‚Üí Œ≤'\np' : Filter Œπ'\nh : TendstoUniformly F f p\nh' : TendstoUniformly F' f' p'\n‚ä¢ TendstoUniformly (fun i a => { fst := F i.1 a, snd := F' i.2 a }) (fun a => { fst := f a, snd := f' a }) (SProd.sprod p p')","decl":"theorem TendstoUniformly.prod {Œπ' Œ≤' : Type*} [UniformSpace Œ≤'] {F' : Œπ' ‚Üí Œ± ‚Üí Œ≤'} {f' : Œ± ‚Üí Œ≤'}\n    {p' : Filter Œπ'} (h : TendstoUniformly F f p) (h' : TendstoUniformly F' f' p') :\n    TendstoUniformly (fun (i : Œπ √ó Œπ') a => (F i.1 a, F' i.2 a)) (fun a => (f a, f' a))\n      (p √óÀ¢ p') :=\n  (h.prod_map h').comp fun a => (a, a)\n\n"}
{"name":"tendsto_prod_filter_iff","module":"Mathlib.Topology.UniformSpace.UniformConvergence","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒπ : Type x\ninst‚úù : UniformSpace Œ≤\nF : Œπ ‚Üí Œ± ‚Üí Œ≤\np : Filter Œπ\np' : Filter Œ±\nc : Œ≤\n‚ä¢ Iff (Filter.Tendsto (Function.HasUncurry.uncurry F) (SProd.sprod p p') (nhds c)) (TendstoUniformlyOnFilter F (fun x => c) p p')","decl":"/-- Uniform convergence on a filter `p'` to a constant function is equivalent to convergence in\n`p √óÀ¢ p'`. -/\ntheorem tendsto_prod_filter_iff {c : Œ≤} :\n    Tendsto (‚ÜøF) (p √óÀ¢ p') (ùìù c) ‚Üî TendstoUniformlyOnFilter F (fun _ => c) p p' := by\n  simp_rw [nhds_eq_comap_uniformity, tendsto_comap_iff]\n  rfl\n\n"}
{"name":"tendsto_prod_principal_iff","module":"Mathlib.Topology.UniformSpace.UniformConvergence","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒπ : Type x\ninst‚úù : UniformSpace Œ≤\nF : Œπ ‚Üí Œ± ‚Üí Œ≤\ns : Set Œ±\np : Filter Œπ\nc : Œ≤\n‚ä¢ Iff (Filter.Tendsto (Function.HasUncurry.uncurry F) (SProd.sprod p (Filter.principal s)) (nhds c)) (TendstoUniformlyOn F (fun x => c) p s)","decl":"/-- Uniform convergence on a set `s` to a constant function is equivalent to convergence in\n`p √óÀ¢ ùìü s`. -/\ntheorem tendsto_prod_principal_iff {c : Œ≤} :\n    Tendsto (‚ÜøF) (p √óÀ¢ ùìü s) (ùìù c) ‚Üî TendstoUniformlyOn F (fun _ => c) p s := by\n  rw [tendstoUniformlyOn_iff_tendstoUniformlyOnFilter]\n  exact tendsto_prod_filter_iff\n\n"}
{"name":"tendsto_prod_top_iff","module":"Mathlib.Topology.UniformSpace.UniformConvergence","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒπ : Type x\ninst‚úù : UniformSpace Œ≤\nF : Œπ ‚Üí Œ± ‚Üí Œ≤\np : Filter Œπ\nc : Œ≤\n‚ä¢ Iff (Filter.Tendsto (Function.HasUncurry.uncurry F) (SProd.sprod p Top.top) (nhds c)) (TendstoUniformly F (fun x => c) p)","decl":"/-- Uniform convergence to a constant function is equivalent to convergence in `p √óÀ¢ ‚ä§`. -/\ntheorem tendsto_prod_top_iff {c : Œ≤} :\n    Tendsto (‚ÜøF) (p √óÀ¢ ‚ä§) (ùìù c) ‚Üî TendstoUniformly F (fun _ => c) p := by\n  rw [tendstoUniformly_iff_tendstoUniformlyOnFilter]\n  exact tendsto_prod_filter_iff\n\n"}
{"name":"tendstoUniformlyOn_empty","module":"Mathlib.Topology.UniformSpace.UniformConvergence","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒπ : Type x\ninst‚úù : UniformSpace Œ≤\nF : Œπ ‚Üí Œ± ‚Üí Œ≤\nf : Œ± ‚Üí Œ≤\np : Filter Œπ\n‚ä¢ TendstoUniformlyOn F f p EmptyCollection.emptyCollection","decl":"/-- Uniform convergence on the empty set is vacuously true -/\ntheorem tendstoUniformlyOn_empty : TendstoUniformlyOn F f p ‚àÖ := fun u _ => by simp\n\n"}
{"name":"tendstoUniformlyOn_singleton_iff_tendsto","module":"Mathlib.Topology.UniformSpace.UniformConvergence","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒπ : Type x\ninst‚úù : UniformSpace Œ≤\nF : Œπ ‚Üí Œ± ‚Üí Œ≤\nf : Œ± ‚Üí Œ≤\nx : Œ±\np : Filter Œπ\n‚ä¢ Iff (TendstoUniformlyOn F f p (Singleton.singleton x)) (Filter.Tendsto (fun n => F n x) p (nhds (f x)))","decl":"/-- Uniform convergence on a singleton is equivalent to regular convergence -/\ntheorem tendstoUniformlyOn_singleton_iff_tendsto :\n    TendstoUniformlyOn F f p {x} ‚Üî Tendsto (fun n : Œπ => F n x) p (ùìù (f x)) := by\n  simp_rw [tendstoUniformlyOn_iff_tendsto, Uniform.tendsto_nhds_right, tendsto_def]\n  exact forall‚ÇÇ_congr fun u _ => by simp [mem_prod_principal, preimage]\n\n"}
{"name":"Filter.Tendsto.tendstoUniformlyOnFilter_const","module":"Mathlib.Topology.UniformSpace.UniformConvergence","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒπ : Type x\ninst‚úù : UniformSpace Œ≤\np : Filter Œπ\ng : Œπ ‚Üí Œ≤\nb : Œ≤\nhg : Filter.Tendsto g p (nhds b)\np' : Filter Œ±\n‚ä¢ TendstoUniformlyOnFilter (fun n x => g n) (fun x => b) p p'","decl":"/-- If a sequence `g` converges to some `b`, then the sequence of constant functions\n`fun n ‚Ü¶ fun a ‚Ü¶ g n` converges to the constant function `fun a ‚Ü¶ b` on any set `s` -/\ntheorem Filter.Tendsto.tendstoUniformlyOnFilter_const {g : Œπ ‚Üí Œ≤} {b : Œ≤} (hg : Tendsto g p (ùìù b))\n    (p' : Filter Œ±) :\n    TendstoUniformlyOnFilter (fun n : Œπ => fun _ : Œ± => g n) (fun _ : Œ± => b) p p' := by\n  simpa only [nhds_eq_comap_uniformity, tendsto_comap_iff] using hg.comp (tendsto_fst (g := p'))\n\n"}
{"name":"Filter.Tendsto.tendstoUniformlyOn_const","module":"Mathlib.Topology.UniformSpace.UniformConvergence","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒπ : Type x\ninst‚úù : UniformSpace Œ≤\np : Filter Œπ\ng : Œπ ‚Üí Œ≤\nb : Œ≤\nhg : Filter.Tendsto g p (nhds b)\ns : Set Œ±\n‚ä¢ TendstoUniformlyOn (fun n x => g n) (fun x => b) p s","decl":"/-- If a sequence `g` converges to some `b`, then the sequence of constant functions\n`fun n ‚Ü¶ fun a ‚Ü¶ g n` converges to the constant function `fun a ‚Ü¶ b` on any set `s` -/\ntheorem Filter.Tendsto.tendstoUniformlyOn_const {g : Œπ ‚Üí Œ≤} {b : Œ≤} (hg : Tendsto g p (ùìù b))\n    (s : Set Œ±) : TendstoUniformlyOn (fun n : Œπ => fun _ : Œ± => g n) (fun _ : Œ± => b) p s :=\n  tendstoUniformlyOn_iff_tendstoUniformlyOnFilter.mpr (hg.tendstoUniformlyOnFilter_const (ùìü s))\n\n"}
{"name":"UniformContinuousOn.tendstoUniformlyOn","module":"Mathlib.Topology.UniformSpace.UniformConvergence","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒ≥ : Type w\ninst‚úù¬≤ : UniformSpace Œ≤\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : UniformSpace Œ≥\nx : Œ±\nU : Set Œ±\nV : Set Œ≤\nF : Œ± ‚Üí Œ≤ ‚Üí Œ≥\nhF : UniformContinuousOn (Function.HasUncurry.uncurry F) (SProd.sprod U V)\nhU : Membership.mem U x\n‚ä¢ TendstoUniformlyOn F (F x) (nhdsWithin x U) V","decl":"theorem UniformContinuousOn.tendstoUniformlyOn [UniformSpace Œ±] [UniformSpace Œ≥] {x : Œ±} {U : Set Œ±}\n    {V : Set Œ≤} {F : Œ± ‚Üí Œ≤ ‚Üí Œ≥} (hF : UniformContinuousOn (‚ÜøF) (U √óÀ¢ V)) (hU : x ‚àà U) :\n    TendstoUniformlyOn F (F x) (ùìù[U] x) V := by\n  set œÜ := fun q : Œ± √ó Œ≤ => ((x, q.2), q)\n  rw [tendstoUniformlyOn_iff_tendsto]\n  change Tendsto (Prod.map (‚ÜøF) ‚ÜøF ‚àò œÜ) (ùìù[U] x √óÀ¢ ùìü V) (ùì§ Œ≥)\n  simp only [nhdsWithin, Filter.prod_eq_inf, comap_inf, inf_assoc, comap_principal, inf_principal]\n  refine hF.comp (Tendsto.inf ?_ <| tendsto_principal_principal.2 fun x hx => ‚ü®‚ü®hU, hx.2‚ü©, hx‚ü©)\n  simp only [uniformity_prod_eq_comap_prod, tendsto_comap_iff, (¬∑ ‚àò ¬∑),\n    nhds_eq_comap_uniformity, comap_comap]\n  exact tendsto_comap.prod_mk (tendsto_diag_uniformity _ _)\n\n"}
{"name":"UniformContinuousOn.tendstoUniformly","module":"Mathlib.Topology.UniformSpace.UniformConvergence","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒ≥ : Type w\ninst‚úù¬≤ : UniformSpace Œ≤\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : UniformSpace Œ≥\nx : Œ±\nU : Set Œ±\nhU : Membership.mem (nhds x) U\nF : Œ± ‚Üí Œ≤ ‚Üí Œ≥\nhF : UniformContinuousOn (Function.HasUncurry.uncurry F) (SProd.sprod U Set.univ)\n‚ä¢ TendstoUniformly F (F x) (nhds x)","decl":"theorem UniformContinuousOn.tendstoUniformly [UniformSpace Œ±] [UniformSpace Œ≥] {x : Œ±} {U : Set Œ±}\n    (hU : U ‚àà ùìù x) {F : Œ± ‚Üí Œ≤ ‚Üí Œ≥} (hF : UniformContinuousOn (‚ÜøF) (U √óÀ¢ (univ : Set Œ≤))) :\n    TendstoUniformly F (F x) (ùìù x) := by\n  simpa only [tendstoUniformlyOn_univ, nhdsWithin_eq_nhds.2 hU]\n    using hF.tendstoUniformlyOn (mem_of_mem_nhds hU)\n\n"}
{"name":"UniformContinuous‚ÇÇ.tendstoUniformly","module":"Mathlib.Topology.UniformSpace.UniformConvergence","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒ≥ : Type w\ninst‚úù¬≤ : UniformSpace Œ≤\ninst‚úù¬π : UniformSpace Œ±\ninst‚úù : UniformSpace Œ≥\nf : Œ± ‚Üí Œ≤ ‚Üí Œ≥\nh : UniformContinuous‚ÇÇ f\nx : Œ±\n‚ä¢ TendstoUniformly f (f x) (nhds x)","decl":"theorem UniformContinuous‚ÇÇ.tendstoUniformly [UniformSpace Œ±] [UniformSpace Œ≥] {f : Œ± ‚Üí Œ≤ ‚Üí Œ≥}\n    (h : UniformContinuous‚ÇÇ f) {x : Œ±} : TendstoUniformly f (f x) (ùìù x) :=\n  UniformContinuousOn.tendstoUniformly univ_mem <| by rwa [univ_prod_univ, uniformContinuousOn_univ]\n\n"}
{"name":"uniformCauchySeqOn_iff_uniformCauchySeqOnFilter","module":"Mathlib.Topology.UniformSpace.UniformConvergence","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒπ : Type x\ninst‚úù : UniformSpace Œ≤\nF : Œπ ‚Üí Œ± ‚Üí Œ≤\ns : Set Œ±\np : Filter Œπ\n‚ä¢ Iff (UniformCauchySeqOn F p s) (UniformCauchySeqOnFilter F p (Filter.principal s))","decl":"theorem uniformCauchySeqOn_iff_uniformCauchySeqOnFilter :\n    UniformCauchySeqOn F p s ‚Üî UniformCauchySeqOnFilter F p (ùìü s) := by\n  simp only [UniformCauchySeqOn, UniformCauchySeqOnFilter]\n  refine forall‚ÇÇ_congr fun u hu => ?_\n  rw [eventually_prod_principal_iff]\n\n"}
{"name":"UniformCauchySeqOn.uniformCauchySeqOnFilter","module":"Mathlib.Topology.UniformSpace.UniformConvergence","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒπ : Type x\ninst‚úù : UniformSpace Œ≤\nF : Œπ ‚Üí Œ± ‚Üí Œ≤\ns : Set Œ±\np : Filter Œπ\nhF : UniformCauchySeqOn F p s\n‚ä¢ UniformCauchySeqOnFilter F p (Filter.principal s)","decl":"theorem UniformCauchySeqOn.uniformCauchySeqOnFilter (hF : UniformCauchySeqOn F p s) :\n    UniformCauchySeqOnFilter F p (ùìü s) := by rwa [‚Üê uniformCauchySeqOn_iff_uniformCauchySeqOnFilter]\n\n"}
{"name":"TendstoUniformlyOnFilter.uniformCauchySeqOnFilter","module":"Mathlib.Topology.UniformSpace.UniformConvergence","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒπ : Type x\ninst‚úù : UniformSpace Œ≤\nF : Œπ ‚Üí Œ± ‚Üí Œ≤\nf : Œ± ‚Üí Œ≤\np : Filter Œπ\np' : Filter Œ±\nhF : TendstoUniformlyOnFilter F f p p'\n‚ä¢ UniformCauchySeqOnFilter F p p'","decl":"/-- A sequence that converges uniformly is also uniformly Cauchy -/\ntheorem TendstoUniformlyOnFilter.uniformCauchySeqOnFilter (hF : TendstoUniformlyOnFilter F f p p') :\n    UniformCauchySeqOnFilter F p p' := by\n  intro u hu\n  rcases comp_symm_of_uniformity hu with ‚ü®t, ht, htsymm, htmem‚ü©\n  have := tendsto_swap4_prod.eventually ((hF t ht).prod_mk (hF t ht))\n  apply this.diag_of_prod_right.mono\n  simp only [and_imp, Prod.forall]\n  intro n1 n2 x hl hr\n  exact Set.mem_of_mem_of_subset (prod_mk_mem_compRel (htsymm hl) hr) htmem\n\n"}
{"name":"TendstoUniformlyOn.uniformCauchySeqOn","module":"Mathlib.Topology.UniformSpace.UniformConvergence","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒπ : Type x\ninst‚úù : UniformSpace Œ≤\nF : Œπ ‚Üí Œ± ‚Üí Œ≤\nf : Œ± ‚Üí Œ≤\ns : Set Œ±\np : Filter Œπ\nhF : TendstoUniformlyOn F f p s\n‚ä¢ UniformCauchySeqOn F p s","decl":"/-- A sequence that converges uniformly is also uniformly Cauchy -/\ntheorem TendstoUniformlyOn.uniformCauchySeqOn (hF : TendstoUniformlyOn F f p s) :\n    UniformCauchySeqOn F p s :=\n  uniformCauchySeqOn_iff_uniformCauchySeqOnFilter.mpr\n    hF.tendstoUniformlyOnFilter.uniformCauchySeqOnFilter\n\n"}
{"name":"UniformCauchySeqOnFilter.tendstoUniformlyOnFilter_of_tendsto","module":"Mathlib.Topology.UniformSpace.UniformConvergence","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒπ : Type x\ninst‚úù : UniformSpace Œ≤\nF : Œπ ‚Üí Œ± ‚Üí Œ≤\nf : Œ± ‚Üí Œ≤\np : Filter Œπ\np' : Filter Œ±\nhF : UniformCauchySeqOnFilter F p p'\nhF' : Filter.Eventually (fun x => Filter.Tendsto (fun n => F n x) p (nhds (f x))) p'\n‚ä¢ TendstoUniformlyOnFilter F f p p'","decl":"/-- A uniformly Cauchy sequence converges uniformly to its limit -/\ntheorem UniformCauchySeqOnFilter.tendstoUniformlyOnFilter_of_tendsto\n    (hF : UniformCauchySeqOnFilter F p p')\n    (hF' : ‚àÄ·∂† x : Œ± in p', Tendsto (fun n => F n x) p (ùìù (f x))) :\n    TendstoUniformlyOnFilter F f p p' := by\n  rcases p.eq_or_neBot with rfl | _\n  ¬∑ simp only [TendstoUniformlyOnFilter, bot_prod, eventually_bot, implies_true]\n  -- Proof idea: |f_n(x) - f(x)| ‚â§ |f_n(x) - f_m(x)| + |f_m(x) - f(x)|. We choose `n`\n  -- so that |f_n(x) - f_m(x)| is uniformly small across `s` whenever `m ‚â• n`. Then for\n  -- a fixed `x`, we choose `m` sufficiently large such that |f_m(x) - f(x)| is small.\n  intro u hu\n  rcases comp_symm_of_uniformity hu with ‚ü®t, ht, htsymm, htmem‚ü©\n  -- We will choose n, x, and m simultaneously. n and x come from hF. m comes from hF'\n  -- But we need to promote hF' to the full product filter to use it\n  have hmc : ‚àÄ·∂† x in (p √óÀ¢ p) √óÀ¢ p', Tendsto (fun n : Œπ => F n x.snd) p (ùìù (f x.snd)) := by\n    rw [eventually_prod_iff]\n    exact ‚ü®fun _ => True, by simp, _, hF', by simp‚ü©\n  -- To apply filter operations we'll need to do some order manipulation\n  rw [Filter.eventually_swap_iff]\n  have := tendsto_prodAssoc.eventually (tendsto_prod_swap.eventually ((hF t ht).and hmc))\n  apply this.curry.mono\n  simp only [Equiv.prodAssoc_apply, eventually_and, eventually_const, Prod.snd_swap, Prod.fst_swap,\n    and_imp, Prod.forall]\n  -- Complete the proof\n  intro x n hx hm'\n  refine Set.mem_of_mem_of_subset (mem_compRel.mpr ?_) htmem\n  rw [Uniform.tendsto_nhds_right] at hm'\n  have := hx.and (hm' ht)\n  obtain ‚ü®m, hm‚ü© := this.exists\n  exact ‚ü®F m x, ‚ü®hm.2, htsymm hm.1‚ü©‚ü©\n\n"}
{"name":"UniformCauchySeqOn.tendstoUniformlyOn_of_tendsto","module":"Mathlib.Topology.UniformSpace.UniformConvergence","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒπ : Type x\ninst‚úù : UniformSpace Œ≤\nF : Œπ ‚Üí Œ± ‚Üí Œ≤\nf : Œ± ‚Üí Œ≤\ns : Set Œ±\np : Filter Œπ\nhF : UniformCauchySeqOn F p s\nhF' : ‚àÄ (x : Œ±), Membership.mem s x ‚Üí Filter.Tendsto (fun n => F n x) p (nhds (f x))\n‚ä¢ TendstoUniformlyOn F f p s","decl":"/-- A uniformly Cauchy sequence converges uniformly to its limit -/\ntheorem UniformCauchySeqOn.tendstoUniformlyOn_of_tendsto (hF : UniformCauchySeqOn F p s)\n    (hF' : ‚àÄ x : Œ±, x ‚àà s ‚Üí Tendsto (fun n => F n x) p (ùìù (f x))) : TendstoUniformlyOn F f p s :=\n  tendstoUniformlyOn_iff_tendstoUniformlyOnFilter.mpr\n    (hF.uniformCauchySeqOnFilter.tendstoUniformlyOnFilter_of_tendsto hF')\n\n"}
{"name":"UniformCauchySeqOnFilter.mono_left","module":"Mathlib.Topology.UniformSpace.UniformConvergence","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒπ : Type x\ninst‚úù : UniformSpace Œ≤\nF : Œπ ‚Üí Œ± ‚Üí Œ≤\np : Filter Œπ\np' : Filter Œ±\np'' : Filter Œπ\nhf : UniformCauchySeqOnFilter F p p'\nhp : LE.le p'' p\n‚ä¢ UniformCauchySeqOnFilter F p'' p'","decl":"theorem UniformCauchySeqOnFilter.mono_left {p'' : Filter Œπ} (hf : UniformCauchySeqOnFilter F p p')\n    (hp : p'' ‚â§ p) : UniformCauchySeqOnFilter F p'' p' := by\n  intro u hu\n  have := (hf u hu).filter_mono (p'.prod_mono_left (Filter.prod_mono hp hp))\n  exact this.mono (by simp)\n\n"}
{"name":"UniformCauchySeqOnFilter.mono_right","module":"Mathlib.Topology.UniformSpace.UniformConvergence","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒπ : Type x\ninst‚úù : UniformSpace Œ≤\nF : Œπ ‚Üí Œ± ‚Üí Œ≤\np : Filter Œπ\np' p'' : Filter Œ±\nhf : UniformCauchySeqOnFilter F p p'\nhp : LE.le p'' p'\n‚ä¢ UniformCauchySeqOnFilter F p p''","decl":"theorem UniformCauchySeqOnFilter.mono_right {p'' : Filter Œ±} (hf : UniformCauchySeqOnFilter F p p')\n    (hp : p'' ‚â§ p') : UniformCauchySeqOnFilter F p p'' := fun u hu =>\n  have := (hf u hu).filter_mono ((p √óÀ¢ p).prod_mono_right hp)\n  this.mono (by simp)\n\n"}
{"name":"UniformCauchySeqOn.mono","module":"Mathlib.Topology.UniformSpace.UniformConvergence","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒπ : Type x\ninst‚úù : UniformSpace Œ≤\nF : Œπ ‚Üí Œ± ‚Üí Œ≤\ns : Set Œ±\np : Filter Œπ\ns' : Set Œ±\nhf : UniformCauchySeqOn F p s\nhss' : HasSubset.Subset s' s\n‚ä¢ UniformCauchySeqOn F p s'","decl":"theorem UniformCauchySeqOn.mono {s' : Set Œ±} (hf : UniformCauchySeqOn F p s) (hss' : s' ‚äÜ s) :\n    UniformCauchySeqOn F p s' := by\n  rw [uniformCauchySeqOn_iff_uniformCauchySeqOnFilter] at hf ‚ä¢\n  exact hf.mono_right (le_principal_iff.mpr <| mem_principal.mpr hss')\n\n"}
{"name":"UniformCauchySeqOnFilter.comp","module":"Mathlib.Topology.UniformSpace.UniformConvergence","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒπ : Type x\ninst‚úù : UniformSpace Œ≤\nF : Œπ ‚Üí Œ± ‚Üí Œ≤\np : Filter Œπ\np' : Filter Œ±\nŒ≥ : Type u_1\nhf : UniformCauchySeqOnFilter F p p'\ng : Œ≥ ‚Üí Œ±\n‚ä¢ UniformCauchySeqOnFilter (fun n => Function.comp (F n) g) p (Filter.comap g p')","decl":"/-- Composing on the right by a function preserves uniform Cauchy sequences -/\ntheorem UniformCauchySeqOnFilter.comp {Œ≥ : Type*} (hf : UniformCauchySeqOnFilter F p p')\n    (g : Œ≥ ‚Üí Œ±) : UniformCauchySeqOnFilter (fun n => F n ‚àò g) p (p'.comap g) := fun u hu => by\n  obtain ‚ü®pa, hpa, pb, hpb, hpapb‚ü© := eventually_prod_iff.mp (hf u hu)\n  rw [eventually_prod_iff]\n  refine ‚ü®pa, hpa, pb ‚àò g, ?_, fun hx _ hy => hpapb hx hy‚ü©\n  exact eventually_comap.mpr (hpb.mono fun x hx y hy => by simp only [hx, hy, Function.comp_apply])\n\n"}
{"name":"UniformCauchySeqOn.comp","module":"Mathlib.Topology.UniformSpace.UniformConvergence","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒπ : Type x\ninst‚úù : UniformSpace Œ≤\nF : Œπ ‚Üí Œ± ‚Üí Œ≤\ns : Set Œ±\np : Filter Œπ\nŒ≥ : Type u_1\nhf : UniformCauchySeqOn F p s\ng : Œ≥ ‚Üí Œ±\n‚ä¢ UniformCauchySeqOn (fun n => Function.comp (F n) g) p (Set.preimage g s)","decl":"/-- Composing on the right by a function preserves uniform Cauchy sequences -/\ntheorem UniformCauchySeqOn.comp {Œ≥ : Type*} (hf : UniformCauchySeqOn F p s) (g : Œ≥ ‚Üí Œ±) :\n    UniformCauchySeqOn (fun n => F n ‚àò g) p (g ‚Åª¬π' s) := by\n  rw [uniformCauchySeqOn_iff_uniformCauchySeqOnFilter] at hf ‚ä¢\n  simpa only [UniformCauchySeqOn, comap_principal] using hf.comp g\n\n"}
{"name":"UniformContinuous.comp_uniformCauchySeqOn","module":"Mathlib.Topology.UniformSpace.UniformConvergence","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒ≥ : Type w\nŒπ : Type x\ninst‚úù¬π : UniformSpace Œ≤\nF : Œπ ‚Üí Œ± ‚Üí Œ≤\ns : Set Œ±\np : Filter Œπ\ninst‚úù : UniformSpace Œ≥\ng : Œ≤ ‚Üí Œ≥\nhg : UniformContinuous g\nhf : UniformCauchySeqOn F p s\n‚ä¢ UniformCauchySeqOn (fun n => Function.comp g (F n)) p s","decl":"/-- Composing on the left by a uniformly continuous function preserves\nuniform Cauchy sequences -/\ntheorem UniformContinuous.comp_uniformCauchySeqOn [UniformSpace Œ≥] {g : Œ≤ ‚Üí Œ≥}\n    (hg : UniformContinuous g) (hf : UniformCauchySeqOn F p s) :\n    UniformCauchySeqOn (fun n => g ‚àò F n) p s := fun _u hu => hf _ (hg hu)\n\n"}
{"name":"UniformCauchySeqOn.prod_map","module":"Mathlib.Topology.UniformSpace.UniformConvergence","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒπ : Type x\ninst‚úù¬π : UniformSpace Œ≤\nF : Œπ ‚Üí Œ± ‚Üí Œ≤\ns : Set Œ±\np : Filter Œπ\nŒπ' : Type u_1\nŒ±' : Type u_2\nŒ≤' : Type u_3\ninst‚úù : UniformSpace Œ≤'\nF' : Œπ' ‚Üí Œ±' ‚Üí Œ≤'\np' : Filter Œπ'\ns' : Set Œ±'\nh : UniformCauchySeqOn F p s\nh' : UniformCauchySeqOn F' p' s'\n‚ä¢ UniformCauchySeqOn (fun i => Prod.map (F i.1) (F' i.2)) (SProd.sprod p p') (SProd.sprod s s')","decl":"theorem UniformCauchySeqOn.prod_map {Œπ' Œ±' Œ≤' : Type*} [UniformSpace Œ≤'] {F' : Œπ' ‚Üí Œ±' ‚Üí Œ≤'}\n    {p' : Filter Œπ'} {s' : Set Œ±'} (h : UniformCauchySeqOn F p s)\n    (h' : UniformCauchySeqOn F' p' s') :\n    UniformCauchySeqOn (fun i : Œπ √ó Œπ' => Prod.map (F i.1) (F' i.2)) (p √óÀ¢ p') (s √óÀ¢ s') := by\n  intro u hu\n  rw [uniformity_prod_eq_prod, mem_map, mem_prod_iff] at hu\n  obtain ‚ü®v, hv, w, hw, hvw‚ü© := hu\n  simp_rw [mem_prod, and_imp, Prod.forall, Prod.map_apply]\n  rw [‚Üê Set.image_subset_iff] at hvw\n  apply (tendsto_swap4_prod.eventually ((h v hv).prod_mk (h' w hw))).mono\n  intro x hx a b ha hb\n  exact hvw ‚ü®_, mk_mem_prod (hx.1 a ha) (hx.2 b hb), rfl‚ü©\n\n"}
{"name":"UniformCauchySeqOn.prod","module":"Mathlib.Topology.UniformSpace.UniformConvergence","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒπ : Type x\ninst‚úù¬π : UniformSpace Œ≤\nF : Œπ ‚Üí Œ± ‚Üí Œ≤\ns : Set Œ±\np : Filter Œπ\nŒπ' : Type u_1\nŒ≤' : Type u_2\ninst‚úù : UniformSpace Œ≤'\nF' : Œπ' ‚Üí Œ± ‚Üí Œ≤'\np' : Filter Œπ'\nh : UniformCauchySeqOn F p s\nh' : UniformCauchySeqOn F' p' s\n‚ä¢ UniformCauchySeqOn (fun i a => { fst := F i.1 a, snd := F' i.2 a }) (SProd.sprod p p') s","decl":"theorem UniformCauchySeqOn.prod {Œπ' Œ≤' : Type*} [UniformSpace Œ≤'] {F' : Œπ' ‚Üí Œ± ‚Üí Œ≤'}\n    {p' : Filter Œπ'} (h : UniformCauchySeqOn F p s) (h' : UniformCauchySeqOn F' p' s) :\n    UniformCauchySeqOn (fun (i : Œπ √ó Œπ') a => (F i.fst a, F' i.snd a)) (p √óÀ¢ p') s :=\n  (congr_arg _ s.inter_self).mp ((h.prod_map h').comp fun a => (a, a))\n\n"}
{"name":"UniformCauchySeqOn.prod'","module":"Mathlib.Topology.UniformSpace.UniformConvergence","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒπ : Type x\ninst‚úù¬π : UniformSpace Œ≤\nF : Œπ ‚Üí Œ± ‚Üí Œ≤\ns : Set Œ±\np : Filter Œπ\nŒ≤' : Type u_1\ninst‚úù : UniformSpace Œ≤'\nF' : Œπ ‚Üí Œ± ‚Üí Œ≤'\nh : UniformCauchySeqOn F p s\nh' : UniformCauchySeqOn F' p s\n‚ä¢ UniformCauchySeqOn (fun i a => { fst := F i a, snd := F' i a }) p s","decl":"theorem UniformCauchySeqOn.prod' {Œ≤' : Type*} [UniformSpace Œ≤'] {F' : Œπ ‚Üí Œ± ‚Üí Œ≤'}\n    (h : UniformCauchySeqOn F p s) (h' : UniformCauchySeqOn F' p s) :\n    UniformCauchySeqOn (fun (i : Œπ) a => (F i a, F' i a)) p s := fun u hu =>\n  have hh : Tendsto (fun x : Œπ => (x, x)) p (p √óÀ¢ p) := tendsto_diag\n  (hh.prod_map hh).eventually ((h.prod h') u hu)\n\n"}
{"name":"UniformCauchySeqOn.cauchy_map","module":"Mathlib.Topology.UniformSpace.UniformConvergence","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒπ : Type x\ninst‚úù : UniformSpace Œ≤\nF : Œπ ‚Üí Œ± ‚Üí Œ≤\ns : Set Œ±\nx : Œ±\np : Filter Œπ\nhp : p.NeBot\nhf : UniformCauchySeqOn F p s\nhx : Membership.mem s x\n‚ä¢ Cauchy (Filter.map (fun i => F i x) p)","decl":"/-- If a sequence of functions is uniformly Cauchy on a set, then the values at each point form\na Cauchy sequence. -/\ntheorem UniformCauchySeqOn.cauchy_map [hp : NeBot p] (hf : UniformCauchySeqOn F p s) (hx : x ‚àà s) :\n    Cauchy (map (fun i => F i x) p) := by\n  simp only [cauchy_map_iff, hp, true_and]\n  intro u hu\n  rw [mem_map]\n  filter_upwards [hf u hu] with p hp using hp x hx\n\n"}
{"name":"UniformCauchySeqOn.cauchySeq","module":"Mathlib.Topology.UniformSpace.UniformConvergence","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒπ : Type x\ninst‚úù¬≤ : UniformSpace Œ≤\nF : Œπ ‚Üí Œ± ‚Üí Œ≤\ns : Set Œ±\nx : Œ±\ninst‚úù¬π : Nonempty Œπ\ninst‚úù : SemilatticeSup Œπ\nhf : UniformCauchySeqOn F Filter.atTop s\nhx : Membership.mem s x\n‚ä¢ CauchySeq fun i => F i x","decl":"/-- If a sequence of functions is uniformly Cauchy on a set, then the values at each point form\na Cauchy sequence.  See `UniformCauchSeqOn.cauchy_map` for the non-`atTop` case. -/\ntheorem UniformCauchySeqOn.cauchySeq [Nonempty Œπ] [SemilatticeSup Œπ]\n    (hf : UniformCauchySeqOn F atTop s) (hx : x ‚àà s) :\n    CauchySeq fun i ‚Ü¶ F i x :=\n  hf.cauchy_map (hp := atTop_neBot) hx\n\n"}
{"name":"tendstoUniformlyOn_of_seq_tendstoUniformlyOn","module":"Mathlib.Topology.UniformSpace.UniformConvergence","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒπ : Type x\ninst‚úù¬π : UniformSpace Œ≤\nF : Œπ ‚Üí Œ± ‚Üí Œ≤\nf : Œ± ‚Üí Œ≤\ns : Set Œ±\nl : Filter Œπ\ninst‚úù : l.IsCountablyGenerated\nh : ‚àÄ (u : Nat ‚Üí Œπ), Filter.Tendsto u Filter.atTop l ‚Üí TendstoUniformlyOn (fun n => F (u n)) f Filter.atTop s\n‚ä¢ TendstoUniformlyOn F f l s","decl":"theorem tendstoUniformlyOn_of_seq_tendstoUniformlyOn {l : Filter Œπ} [l.IsCountablyGenerated]\n    (h : ‚àÄ u : ‚Ñï ‚Üí Œπ, Tendsto u atTop l ‚Üí TendstoUniformlyOn (fun n => F (u n)) f atTop s) :\n    TendstoUniformlyOn F f l s := by\n  rw [tendstoUniformlyOn_iff_tendsto, tendsto_iff_seq_tendsto]\n  intro u hu\n  rw [tendsto_prod_iff'] at hu\n  specialize h (fun n => (u n).fst) hu.1\n  rw [tendstoUniformlyOn_iff_tendsto] at h\n  exact h.comp (tendsto_id.prod_mk hu.2)\n\n"}
{"name":"TendstoUniformlyOn.seq_tendstoUniformlyOn","module":"Mathlib.Topology.UniformSpace.UniformConvergence","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒπ : Type x\ninst‚úù : UniformSpace Œ≤\nF : Œπ ‚Üí Œ± ‚Üí Œ≤\nf : Œ± ‚Üí Œ≤\ns : Set Œ±\nl : Filter Œπ\nh : TendstoUniformlyOn F f l s\nu : Nat ‚Üí Œπ\nhu : Filter.Tendsto u Filter.atTop l\n‚ä¢ TendstoUniformlyOn (fun n => F (u n)) f Filter.atTop s","decl":"theorem TendstoUniformlyOn.seq_tendstoUniformlyOn {l : Filter Œπ} (h : TendstoUniformlyOn F f l s)\n    (u : ‚Ñï ‚Üí Œπ) (hu : Tendsto u atTop l) : TendstoUniformlyOn (fun n => F (u n)) f atTop s := by\n  rw [tendstoUniformlyOn_iff_tendsto] at h ‚ä¢\n  exact h.comp ((hu.comp tendsto_fst).prod_mk tendsto_snd)\n\n"}
{"name":"tendstoUniformlyOn_iff_seq_tendstoUniformlyOn","module":"Mathlib.Topology.UniformSpace.UniformConvergence","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒπ : Type x\ninst‚úù¬π : UniformSpace Œ≤\nF : Œπ ‚Üí Œ± ‚Üí Œ≤\nf : Œ± ‚Üí Œ≤\ns : Set Œ±\nl : Filter Œπ\ninst‚úù : l.IsCountablyGenerated\n‚ä¢ Iff (TendstoUniformlyOn F f l s) (‚àÄ (u : Nat ‚Üí Œπ), Filter.Tendsto u Filter.atTop l ‚Üí TendstoUniformlyOn (fun n => F (u n)) f Filter.atTop s)","decl":"theorem tendstoUniformlyOn_iff_seq_tendstoUniformlyOn {l : Filter Œπ} [l.IsCountablyGenerated] :\n    TendstoUniformlyOn F f l s ‚Üî\n      ‚àÄ u : ‚Ñï ‚Üí Œπ, Tendsto u atTop l ‚Üí TendstoUniformlyOn (fun n => F (u n)) f atTop s :=\n  ‚ü®TendstoUniformlyOn.seq_tendstoUniformlyOn, tendstoUniformlyOn_of_seq_tendstoUniformlyOn‚ü©\n\n"}
{"name":"tendstoUniformly_iff_seq_tendstoUniformly","module":"Mathlib.Topology.UniformSpace.UniformConvergence","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒπ : Type x\ninst‚úù¬π : UniformSpace Œ≤\nF : Œπ ‚Üí Œ± ‚Üí Œ≤\nf : Œ± ‚Üí Œ≤\nl : Filter Œπ\ninst‚úù : l.IsCountablyGenerated\n‚ä¢ Iff (TendstoUniformly F f l) (‚àÄ (u : Nat ‚Üí Œπ), Filter.Tendsto u Filter.atTop l ‚Üí TendstoUniformly (fun n => F (u n)) f Filter.atTop)","decl":"theorem tendstoUniformly_iff_seq_tendstoUniformly {l : Filter Œπ} [l.IsCountablyGenerated] :\n    TendstoUniformly F f l ‚Üî\n      ‚àÄ u : ‚Ñï ‚Üí Œπ, Tendsto u atTop l ‚Üí TendstoUniformly (fun n => F (u n)) f atTop := by\n  simp_rw [‚Üê tendstoUniformlyOn_univ]\n  exact tendstoUniformlyOn_iff_seq_tendstoUniformlyOn\n\n"}
{"name":"TendstoUniformlyOnFilter.tendsto_of_eventually_tendsto","module":"Mathlib.Topology.UniformSpace.UniformConvergence","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒπ : Type x\ninst‚úù¬π : UniformSpace Œ≤\nF : Œπ ‚Üí Œ± ‚Üí Œ≤\nf : Œ± ‚Üí Œ≤\np : Filter Œπ\np' : Filter Œ±\ninst‚úù : p.NeBot\nL : Œπ ‚Üí Œ≤\n‚Ñì : Œ≤\nh1 : TendstoUniformlyOnFilter F f p p'\nh2 : Filter.Eventually (fun i => Filter.Tendsto (F i) p' (nhds (L i))) p\nh3 : Filter.Tendsto L p (nhds ‚Ñì)\n‚ä¢ Filter.Tendsto f p' (nhds ‚Ñì)","decl":"theorem TendstoUniformlyOnFilter.tendsto_of_eventually_tendsto\n    (h1 : TendstoUniformlyOnFilter F f p p') (h2 : ‚àÄ·∂† i in p, Tendsto (F i) p' (ùìù (L i)))\n    (h3 : Tendsto L p (ùìù ‚Ñì)) : Tendsto f p' (ùìù ‚Ñì) := by\n  rw [tendsto_nhds_left]\n  intro s hs\n  rw [mem_map, Set.preimage, ‚Üê eventually_iff]\n  obtain ‚ü®t, ht, hts‚ü© := comp3_mem_uniformity hs\n  have p1 : ‚àÄ·∂† i in p, (L i, ‚Ñì) ‚àà t := tendsto_nhds_left.mp h3 ht\n  have p2 : ‚àÄ·∂† i in p, ‚àÄ·∂† x in p', (F i x, L i) ‚àà t := by\n    filter_upwards [h2] with i h2 using tendsto_nhds_left.mp h2 ht\n  have p3 : ‚àÄ·∂† i in p, ‚àÄ·∂† x in p', (f x, F i x) ‚àà t := (h1 t ht).curry\n  obtain ‚ü®i, p4, p5, p6‚ü© := (p1.and (p2.and p3)).exists\n  filter_upwards [p5, p6] with x p5 p6 using hts ‚ü®F i x, p6, L i, p5, p4‚ü©\n\n"}
{"name":"TendstoUniformly.tendsto_of_eventually_tendsto","module":"Mathlib.Topology.UniformSpace.UniformConvergence","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒπ : Type x\ninst‚úù¬π : UniformSpace Œ≤\nF : Œπ ‚Üí Œ± ‚Üí Œ≤\nf : Œ± ‚Üí Œ≤\np : Filter Œπ\np' : Filter Œ±\ninst‚úù : p.NeBot\nL : Œπ ‚Üí Œ≤\n‚Ñì : Œ≤\nh1 : TendstoUniformly F f p\nh2 : Filter.Eventually (fun i => Filter.Tendsto (F i) p' (nhds (L i))) p\nh3 : Filter.Tendsto L p (nhds ‚Ñì)\n‚ä¢ Filter.Tendsto f p' (nhds ‚Ñì)","decl":"theorem TendstoUniformly.tendsto_of_eventually_tendsto\n    (h1 : TendstoUniformly F f p) (h2 : ‚àÄ·∂† i in p, Tendsto (F i) p' (ùìù (L i)))\n    (h3 : Tendsto L p (ùìù ‚Ñì)) : Tendsto f p' (ùìù ‚Ñì) :=\n  (h1.tendstoUniformlyOnFilter.mono_right le_top).tendsto_of_eventually_tendsto h2 h3\n\n"}
{"name":"tendstoLocallyUniformlyOn_univ","module":"Mathlib.Topology.UniformSpace.UniformConvergence","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒπ : Type x\ninst‚úù¬π : UniformSpace Œ≤\nF : Œπ ‚Üí Œ± ‚Üí Œ≤\nf : Œ± ‚Üí Œ≤\np : Filter Œπ\ninst‚úù : TopologicalSpace Œ±\n‚ä¢ Iff (TendstoLocallyUniformlyOn F f p Set.univ) (TendstoLocallyUniformly F f p)","decl":"theorem tendstoLocallyUniformlyOn_univ :\n    TendstoLocallyUniformlyOn F f p univ ‚Üî TendstoLocallyUniformly F f p := by\n  simp [TendstoLocallyUniformlyOn, TendstoLocallyUniformly, nhdsWithin_univ]\n\n"}
{"name":"tendstoLocallyUniformlyOn_iff_forall_tendsto","module":"Mathlib.Topology.UniformSpace.UniformConvergence","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒπ : Type x\ninst‚úù¬π : UniformSpace Œ≤\nF : Œπ ‚Üí Œ± ‚Üí Œ≤\nf : Œ± ‚Üí Œ≤\ns : Set Œ±\np : Filter Œπ\ninst‚úù : TopologicalSpace Œ±\n‚ä¢ Iff (TendstoLocallyUniformlyOn F f p s) (‚àÄ (x : Œ±), Membership.mem s x ‚Üí Filter.Tendsto (fun y => { fst := f y.2, snd := F y.1 y.2 }) (SProd.sprod p (nhdsWithin x s)) (uniformity Œ≤))","decl":"theorem tendstoLocallyUniformlyOn_iff_forall_tendsto :\n    TendstoLocallyUniformlyOn F f p s ‚Üî\n      ‚àÄ x ‚àà s, Tendsto (fun y : Œπ √ó Œ± => (f y.2, F y.1 y.2)) (p √óÀ¢ ùìù[s] x) (ùì§ Œ≤) :=\n  forall‚ÇÇ_swap.trans <| forall‚ÇÑ_congr fun _ _ _ _ => by\n    rw [mem_map, mem_prod_iff_right]; rfl\n\n"}
{"name":"IsOpen.tendstoLocallyUniformlyOn_iff_forall_tendsto","module":"Mathlib.Topology.UniformSpace.UniformConvergence","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒπ : Type x\ninst‚úù¬π : UniformSpace Œ≤\nF : Œπ ‚Üí Œ± ‚Üí Œ≤\nf : Œ± ‚Üí Œ≤\ns : Set Œ±\np : Filter Œπ\ninst‚úù : TopologicalSpace Œ±\nhs : IsOpen s\n‚ä¢ Iff (TendstoLocallyUniformlyOn F f p s) (‚àÄ (x : Œ±), Membership.mem s x ‚Üí Filter.Tendsto (fun y => { fst := f y.2, snd := F y.1 y.2 }) (SProd.sprod p (nhds x)) (uniformity Œ≤))","decl":"nonrec theorem IsOpen.tendstoLocallyUniformlyOn_iff_forall_tendsto (hs : IsOpen s) :\n    TendstoLocallyUniformlyOn F f p s ‚Üî\n      ‚àÄ x ‚àà s, Tendsto (fun y : Œπ √ó Œ± => (f y.2, F y.1 y.2)) (p √óÀ¢ ùìù x) (ùì§ Œ≤) :=\n  tendstoLocallyUniformlyOn_iff_forall_tendsto.trans <| forall‚ÇÇ_congr fun x hx => by\n    rw [hs.nhdsWithin_eq hx]\n\n"}
{"name":"tendstoLocallyUniformly_iff_forall_tendsto","module":"Mathlib.Topology.UniformSpace.UniformConvergence","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒπ : Type x\ninst‚úù¬π : UniformSpace Œ≤\nF : Œπ ‚Üí Œ± ‚Üí Œ≤\nf : Œ± ‚Üí Œ≤\np : Filter Œπ\ninst‚úù : TopologicalSpace Œ±\n‚ä¢ Iff (TendstoLocallyUniformly F f p) (‚àÄ (x : Œ±), Filter.Tendsto (fun y => { fst := f y.2, snd := F y.1 y.2 }) (SProd.sprod p (nhds x)) (uniformity Œ≤))","decl":"theorem tendstoLocallyUniformly_iff_forall_tendsto :\n    TendstoLocallyUniformly F f p ‚Üî\n      ‚àÄ x, Tendsto (fun y : Œπ √ó Œ± => (f y.2, F y.1 y.2)) (p √óÀ¢ ùìù x) (ùì§ Œ≤) := by\n  simp [‚Üê tendstoLocallyUniformlyOn_univ, isOpen_univ.tendstoLocallyUniformlyOn_iff_forall_tendsto]\n\n"}
{"name":"tendstoLocallyUniformlyOn_iff_tendstoLocallyUniformly_comp_coe","module":"Mathlib.Topology.UniformSpace.UniformConvergence","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒπ : Type x\ninst‚úù¬π : UniformSpace Œ≤\nF : Œπ ‚Üí Œ± ‚Üí Œ≤\nf : Œ± ‚Üí Œ≤\ns : Set Œ±\np : Filter Œπ\ninst‚úù : TopologicalSpace Œ±\n‚ä¢ Iff (TendstoLocallyUniformlyOn F f p s) (TendstoLocallyUniformly (fun i x => F i ‚Üëx) (Function.comp f Subtype.val) p)","decl":"theorem tendstoLocallyUniformlyOn_iff_tendstoLocallyUniformly_comp_coe :\n    TendstoLocallyUniformlyOn F f p s ‚Üî\n      TendstoLocallyUniformly (fun i (x : s) => F i x) (f ‚àò (‚Üë)) p := by\n  simp only [tendstoLocallyUniformly_iff_forall_tendsto, Subtype.forall', tendsto_map'_iff,\n    tendstoLocallyUniformlyOn_iff_forall_tendsto, ‚Üê map_nhds_subtype_val, prod_map_right]; rfl\n\n"}
{"name":"TendstoUniformlyOn.tendstoLocallyUniformlyOn","module":"Mathlib.Topology.UniformSpace.UniformConvergence","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒπ : Type x\ninst‚úù¬π : UniformSpace Œ≤\nF : Œπ ‚Üí Œ± ‚Üí Œ≤\nf : Œ± ‚Üí Œ≤\ns : Set Œ±\np : Filter Œπ\ninst‚úù : TopologicalSpace Œ±\nh : TendstoUniformlyOn F f p s\n‚ä¢ TendstoLocallyUniformlyOn F f p s","decl":"protected theorem TendstoUniformlyOn.tendstoLocallyUniformlyOn (h : TendstoUniformlyOn F f p s) :\n    TendstoLocallyUniformlyOn F f p s := fun u hu _ _ =>\n  ‚ü®s, self_mem_nhdsWithin, by simpa using h u hu‚ü©\n\n"}
{"name":"TendstoUniformly.tendstoLocallyUniformly","module":"Mathlib.Topology.UniformSpace.UniformConvergence","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒπ : Type x\ninst‚úù¬π : UniformSpace Œ≤\nF : Œπ ‚Üí Œ± ‚Üí Œ≤\nf : Œ± ‚Üí Œ≤\np : Filter Œπ\ninst‚úù : TopologicalSpace Œ±\nh : TendstoUniformly F f p\n‚ä¢ TendstoLocallyUniformly F f p","decl":"protected theorem TendstoUniformly.tendstoLocallyUniformly (h : TendstoUniformly F f p) :\n    TendstoLocallyUniformly F f p := fun u hu _ => ‚ü®univ, univ_mem, by simpa using h u hu‚ü©\n\n"}
{"name":"TendstoLocallyUniformlyOn.mono","module":"Mathlib.Topology.UniformSpace.UniformConvergence","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒπ : Type x\ninst‚úù¬π : UniformSpace Œ≤\nF : Œπ ‚Üí Œ± ‚Üí Œ≤\nf : Œ± ‚Üí Œ≤\ns s' : Set Œ±\np : Filter Œπ\ninst‚úù : TopologicalSpace Œ±\nh : TendstoLocallyUniformlyOn F f p s\nh' : HasSubset.Subset s' s\n‚ä¢ TendstoLocallyUniformlyOn F f p s'","decl":"theorem TendstoLocallyUniformlyOn.mono (h : TendstoLocallyUniformlyOn F f p s) (h' : s' ‚äÜ s) :\n    TendstoLocallyUniformlyOn F f p s' := by\n  intro u hu x hx\n  rcases h u hu x (h' hx) with ‚ü®t, ht, H‚ü©\n  exact ‚ü®t, nhdsWithin_mono x h' ht, H.mono fun n => id‚ü©\n\n-- Porting note: generalized from `Type` to `Sort`\n"}
{"name":"tendstoLocallyUniformlyOn_iUnion","module":"Mathlib.Topology.UniformSpace.UniformConvergence","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒπ : Type x\ninst‚úù¬π : UniformSpace Œ≤\nF : Œπ ‚Üí Œ± ‚Üí Œ≤\nf : Œ± ‚Üí Œ≤\np : Filter Œπ\ninst‚úù : TopologicalSpace Œ±\nŒπ' : Sort u_1\nS : Œπ' ‚Üí Set Œ±\nhS : ‚àÄ (i : Œπ'), IsOpen (S i)\nh : ‚àÄ (i : Œπ'), TendstoLocallyUniformlyOn F f p (S i)\n‚ä¢ TendstoLocallyUniformlyOn F f p (Set.iUnion fun i => S i)","decl":"theorem tendstoLocallyUniformlyOn_iUnion {Œπ' : Sort*} {S : Œπ' ‚Üí Set Œ±} (hS : ‚àÄ i, IsOpen (S i))\n    (h : ‚àÄ i, TendstoLocallyUniformlyOn F f p (S i)) :\n    TendstoLocallyUniformlyOn F f p (‚ãÉ i, S i) :=\n  (isOpen_iUnion hS).tendstoLocallyUniformlyOn_iff_forall_tendsto.2 fun _x hx =>\n    let ‚ü®i, hi‚ü© := mem_iUnion.1 hx\n    (hS i).tendstoLocallyUniformlyOn_iff_forall_tendsto.1 (h i) _ hi\n\n"}
{"name":"tendstoLocallyUniformlyOn_biUnion","module":"Mathlib.Topology.UniformSpace.UniformConvergence","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒ≥ : Type w\nŒπ : Type x\ninst‚úù¬π : UniformSpace Œ≤\nF : Œπ ‚Üí Œ± ‚Üí Œ≤\nf : Œ± ‚Üí Œ≤\np : Filter Œπ\ninst‚úù : TopologicalSpace Œ±\ns : Set Œ≥\nS : Œ≥ ‚Üí Set Œ±\nhS : ‚àÄ (i : Œ≥), Membership.mem s i ‚Üí IsOpen (S i)\nh : ‚àÄ (i : Œ≥), Membership.mem s i ‚Üí TendstoLocallyUniformlyOn F f p (S i)\n‚ä¢ TendstoLocallyUniformlyOn F f p (Set.iUnion fun i => Set.iUnion fun h => S i)","decl":"theorem tendstoLocallyUniformlyOn_biUnion {s : Set Œ≥} {S : Œ≥ ‚Üí Set Œ±} (hS : ‚àÄ i ‚àà s, IsOpen (S i))\n    (h : ‚àÄ i ‚àà s, TendstoLocallyUniformlyOn F f p (S i)) :\n    TendstoLocallyUniformlyOn F f p (‚ãÉ i ‚àà s, S i) :=\n  tendstoLocallyUniformlyOn_iUnion (fun i => isOpen_iUnion (hS i)) fun i =>\n   tendstoLocallyUniformlyOn_iUnion (hS i) (h i)\n\n"}
{"name":"tendstoLocallyUniformlyOn_sUnion","module":"Mathlib.Topology.UniformSpace.UniformConvergence","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒπ : Type x\ninst‚úù¬π : UniformSpace Œ≤\nF : Œπ ‚Üí Œ± ‚Üí Œ≤\nf : Œ± ‚Üí Œ≤\np : Filter Œπ\ninst‚úù : TopologicalSpace Œ±\nS : Set (Set Œ±)\nhS : ‚àÄ (s : Set Œ±), Membership.mem S s ‚Üí IsOpen s\nh : ‚àÄ (s : Set Œ±), Membership.mem S s ‚Üí TendstoLocallyUniformlyOn F f p s\n‚ä¢ TendstoLocallyUniformlyOn F f p S.sUnion","decl":"theorem tendstoLocallyUniformlyOn_sUnion (S : Set (Set Œ±)) (hS : ‚àÄ s ‚àà S, IsOpen s)\n    (h : ‚àÄ s ‚àà S, TendstoLocallyUniformlyOn F f p s) : TendstoLocallyUniformlyOn F f p (‚ãÉ‚ÇÄ S) := by\n  rw [sUnion_eq_biUnion]\n  exact tendstoLocallyUniformlyOn_biUnion hS h\n\n"}
{"name":"TendstoLocallyUniformlyOn.union","module":"Mathlib.Topology.UniformSpace.UniformConvergence","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒπ : Type x\ninst‚úù¬π : UniformSpace Œ≤\nF : Œπ ‚Üí Œ± ‚Üí Œ≤\nf : Œ± ‚Üí Œ≤\np : Filter Œπ\ninst‚úù : TopologicalSpace Œ±\ns‚ÇÅ s‚ÇÇ : Set Œ±\nhs‚ÇÅ : IsOpen s‚ÇÅ\nhs‚ÇÇ : IsOpen s‚ÇÇ\nh‚ÇÅ : TendstoLocallyUniformlyOn F f p s‚ÇÅ\nh‚ÇÇ : TendstoLocallyUniformlyOn F f p s‚ÇÇ\n‚ä¢ TendstoLocallyUniformlyOn F f p (Union.union s‚ÇÅ s‚ÇÇ)","decl":"theorem TendstoLocallyUniformlyOn.union {s‚ÇÅ s‚ÇÇ : Set Œ±} (hs‚ÇÅ : IsOpen s‚ÇÅ) (hs‚ÇÇ : IsOpen s‚ÇÇ)\n    (h‚ÇÅ : TendstoLocallyUniformlyOn F f p s‚ÇÅ) (h‚ÇÇ : TendstoLocallyUniformlyOn F f p s‚ÇÇ) :\n    TendstoLocallyUniformlyOn F f p (s‚ÇÅ ‚à™ s‚ÇÇ) := by\n  rw [‚Üê sUnion_pair]\n  refine tendstoLocallyUniformlyOn_sUnion _ ?_ ?_ <;> simp [*]\n\n-- Porting note: tendstoLocallyUniformlyOn_univ moved up\n\n"}
{"name":"TendstoLocallyUniformly.tendstoLocallyUniformlyOn","module":"Mathlib.Topology.UniformSpace.UniformConvergence","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒπ : Type x\ninst‚úù¬π : UniformSpace Œ≤\nF : Œπ ‚Üí Œ± ‚Üí Œ≤\nf : Œ± ‚Üí Œ≤\ns : Set Œ±\np : Filter Œπ\ninst‚úù : TopologicalSpace Œ±\nh : TendstoLocallyUniformly F f p\n‚ä¢ TendstoLocallyUniformlyOn F f p s","decl":"protected theorem TendstoLocallyUniformly.tendstoLocallyUniformlyOn\n    (h : TendstoLocallyUniformly F f p) : TendstoLocallyUniformlyOn F f p s :=\n  (tendstoLocallyUniformlyOn_univ.mpr h).mono (subset_univ _)\n\n"}
{"name":"tendstoLocallyUniformly_iff_tendstoUniformly_of_compactSpace","module":"Mathlib.Topology.UniformSpace.UniformConvergence","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒπ : Type x\ninst‚úù¬≤ : UniformSpace Œ≤\nF : Œπ ‚Üí Œ± ‚Üí Œ≤\nf : Œ± ‚Üí Œ≤\np : Filter Œπ\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : CompactSpace Œ±\n‚ä¢ Iff (TendstoLocallyUniformly F f p) (TendstoUniformly F f p)","decl":"/-- On a compact space, locally uniform convergence is just uniform convergence. -/\ntheorem tendstoLocallyUniformly_iff_tendstoUniformly_of_compactSpace [CompactSpace Œ±] :\n    TendstoLocallyUniformly F f p ‚Üî TendstoUniformly F f p := by\n  refine ‚ü®fun h V hV => ?_, TendstoUniformly.tendstoLocallyUniformly‚ü©\n  choose U hU using h V hV\n  obtain ‚ü®t, ht‚ü© := isCompact_univ.elim_nhds_subcover' (fun k _ => U k) fun k _ => (hU k).1\n  replace hU := fun x : t => (hU x).2\n  rw [‚Üê eventually_all] at hU\n  refine hU.mono fun i hi x => ?_\n  specialize ht (mem_univ x)\n  simp only [exists_prop, mem_iUnion, SetCoe.exists, exists_and_right, Subtype.coe_mk] at ht\n  obtain ‚ü®y, ‚ü®hy‚ÇÅ, hy‚ÇÇ‚ü©, hy‚ÇÉ‚ü© := ht\n  exact hi ‚ü®‚ü®y, hy‚ÇÅ‚ü©, hy‚ÇÇ‚ü© x hy‚ÇÉ\n\n"}
{"name":"tendstoLocallyUniformlyOn_iff_tendstoUniformlyOn_of_compact","module":"Mathlib.Topology.UniformSpace.UniformConvergence","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒπ : Type x\ninst‚úù¬π : UniformSpace Œ≤\nF : Œπ ‚Üí Œ± ‚Üí Œ≤\nf : Œ± ‚Üí Œ≤\ns : Set Œ±\np : Filter Œπ\ninst‚úù : TopologicalSpace Œ±\nhs : IsCompact s\n‚ä¢ Iff (TendstoLocallyUniformlyOn F f p s) (TendstoUniformlyOn F f p s)","decl":"/-- For a compact set `s`, locally uniform convergence on `s` is just uniform convergence on `s`. -/\ntheorem tendstoLocallyUniformlyOn_iff_tendstoUniformlyOn_of_compact (hs : IsCompact s) :\n    TendstoLocallyUniformlyOn F f p s ‚Üî TendstoUniformlyOn F f p s := by\n  haveI : CompactSpace s := isCompact_iff_compactSpace.mp hs\n  refine ‚ü®fun h => ?_, TendstoUniformlyOn.tendstoLocallyUniformlyOn‚ü©\n  rwa [tendstoLocallyUniformlyOn_iff_tendstoLocallyUniformly_comp_coe,\n    tendstoLocallyUniformly_iff_tendstoUniformly_of_compactSpace, ‚Üê\n    tendstoUniformlyOn_iff_tendstoUniformly_comp_coe] at h\n\n"}
{"name":"TendstoLocallyUniformlyOn.comp","module":"Mathlib.Topology.UniformSpace.UniformConvergence","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒ≥ : Type w\nŒπ : Type x\ninst‚úù¬≤ : UniformSpace Œ≤\nF : Œπ ‚Üí Œ± ‚Üí Œ≤\nf : Œ± ‚Üí Œ≤\ns : Set Œ±\np : Filter Œπ\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : TopologicalSpace Œ≥\nt : Set Œ≥\nh : TendstoLocallyUniformlyOn F f p s\ng : Œ≥ ‚Üí Œ±\nhg : Set.MapsTo g t s\ncg : ContinuousOn g t\n‚ä¢ TendstoLocallyUniformlyOn (fun n => Function.comp (F n) g) (Function.comp f g) p t","decl":"theorem TendstoLocallyUniformlyOn.comp [TopologicalSpace Œ≥] {t : Set Œ≥}\n    (h : TendstoLocallyUniformlyOn F f p s) (g : Œ≥ ‚Üí Œ±) (hg : MapsTo g t s)\n    (cg : ContinuousOn g t) : TendstoLocallyUniformlyOn (fun n => F n ‚àò g) (f ‚àò g) p t := by\n  intro u hu x hx\n  rcases h u hu (g x) (hg hx) with ‚ü®a, ha, H‚ü©\n  have : g ‚Åª¬π' a ‚àà ùìù[t] x :=\n    (cg x hx).preimage_mem_nhdsWithin' (nhdsWithin_mono (g x) hg.image_subset ha)\n  exact ‚ü®g ‚Åª¬π' a, this, H.mono fun n hn y hy => hn _ hy‚ü©\n\n"}
{"name":"TendstoLocallyUniformly.comp","module":"Mathlib.Topology.UniformSpace.UniformConvergence","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒ≥ : Type w\nŒπ : Type x\ninst‚úù¬≤ : UniformSpace Œ≤\nF : Œπ ‚Üí Œ± ‚Üí Œ≤\nf : Œ± ‚Üí Œ≤\np : Filter Œπ\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : TopologicalSpace Œ≥\nh : TendstoLocallyUniformly F f p\ng : Œ≥ ‚Üí Œ±\ncg : Continuous g\n‚ä¢ TendstoLocallyUniformly (fun n => Function.comp (F n) g) (Function.comp f g) p","decl":"theorem TendstoLocallyUniformly.comp [TopologicalSpace Œ≥] (h : TendstoLocallyUniformly F f p)\n    (g : Œ≥ ‚Üí Œ±) (cg : Continuous g) : TendstoLocallyUniformly (fun n => F n ‚àò g) (f ‚àò g) p := by\n  rw [‚Üê tendstoLocallyUniformlyOn_univ] at h ‚ä¢\n  rw [continuous_iff_continuousOn_univ] at cg\n  exact h.comp _ (mapsTo_univ _ _) cg\n\n"}
{"name":"tendstoLocallyUniformlyOn_TFAE","module":"Mathlib.Topology.UniformSpace.UniformConvergence","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒπ : Type x\ninst‚úù¬≤ : UniformSpace Œ≤\ns : Set Œ±\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : LocallyCompactSpace Œ±\nG : Œπ ‚Üí Œ± ‚Üí Œ≤\ng : Œ± ‚Üí Œ≤\np : Filter Œπ\nhs : IsOpen s\n‚ä¢ (List.cons (TendstoLocallyUniformlyOn G g p s) (List.cons (‚àÄ (K : Set Œ±), HasSubset.Subset K s ‚Üí IsCompact K ‚Üí TendstoUniformlyOn G g p K) (List.cons (‚àÄ (x : Œ±), Membership.mem s x ‚Üí Exists fun v => And (Membership.mem (nhdsWithin x s) v) (TendstoUniformlyOn G g p v)) List.nil))).TFAE","decl":"theorem tendstoLocallyUniformlyOn_TFAE [LocallyCompactSpace Œ±] (G : Œπ ‚Üí Œ± ‚Üí Œ≤) (g : Œ± ‚Üí Œ≤)\n    (p : Filter Œπ) (hs : IsOpen s) :\n    List.TFAE [\n      TendstoLocallyUniformlyOn G g p s,\n      ‚àÄ K, K ‚äÜ s ‚Üí IsCompact K ‚Üí TendstoUniformlyOn G g p K,\n      ‚àÄ x ‚àà s, ‚àÉ v ‚àà ùìù[s] x, TendstoUniformlyOn G g p v] := by\n  tfae_have 1 ‚Üí 2\n  | h, K, hK1, hK2 =>\n    (tendstoLocallyUniformlyOn_iff_tendstoUniformlyOn_of_compact hK2).mp (h.mono hK1)\n  tfae_have 2 ‚Üí 3\n  | h, x, hx => by\n    obtain ‚ü®K, ‚ü®hK1, hK2‚ü©, hK3‚ü© := (compact_basis_nhds x).mem_iff.mp (hs.mem_nhds hx)\n    exact ‚ü®K, nhdsWithin_le_nhds hK1, h K hK3 hK2‚ü©\n  tfae_have 3 ‚Üí 1\n  | h, u, hu, x, hx => by\n    obtain ‚ü®v, hv1, hv2‚ü© := h x hx\n    exact ‚ü®v, hv1, hv2 u hu‚ü©\n  tfae_finish\n\n"}
{"name":"tendstoLocallyUniformlyOn_iff_forall_isCompact","module":"Mathlib.Topology.UniformSpace.UniformConvergence","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒπ : Type x\ninst‚úù¬≤ : UniformSpace Œ≤\nF : Œπ ‚Üí Œ± ‚Üí Œ≤\nf : Œ± ‚Üí Œ≤\ns : Set Œ±\np : Filter Œπ\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : LocallyCompactSpace Œ±\nhs : IsOpen s\n‚ä¢ Iff (TendstoLocallyUniformlyOn F f p s) (‚àÄ (K : Set Œ±), HasSubset.Subset K s ‚Üí IsCompact K ‚Üí TendstoUniformlyOn F f p K)","decl":"theorem tendstoLocallyUniformlyOn_iff_forall_isCompact [LocallyCompactSpace Œ±] (hs : IsOpen s) :\n    TendstoLocallyUniformlyOn F f p s ‚Üî ‚àÄ K, K ‚äÜ s ‚Üí IsCompact K ‚Üí TendstoUniformlyOn F f p K :=\n  (tendstoLocallyUniformlyOn_TFAE F f p hs).out 0 1\n\n"}
{"name":"tendstoLocallyUniformly_iff_forall_isCompact","module":"Mathlib.Topology.UniformSpace.UniformConvergence","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒπ : Type x\ninst‚úù¬≤ : UniformSpace Œ≤\nF : Œπ ‚Üí Œ± ‚Üí Œ≤\nf : Œ± ‚Üí Œ≤\np : Filter Œπ\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : LocallyCompactSpace Œ±\n‚ä¢ Iff (TendstoLocallyUniformly F f p) (‚àÄ (K : Set Œ±), IsCompact K ‚Üí TendstoUniformlyOn F f p K)","decl":"lemma tendstoLocallyUniformly_iff_forall_isCompact [LocallyCompactSpace Œ±]  :\n    TendstoLocallyUniformly F f p ‚Üî ‚àÄ K : Set Œ±, IsCompact K ‚Üí TendstoUniformlyOn F f p K := by\n  simp only [‚Üê tendstoLocallyUniformlyOn_univ,\n    tendstoLocallyUniformlyOn_iff_forall_isCompact isOpen_univ, Set.subset_univ, forall_true_left]\n\n"}
{"name":"tendstoLocallyUniformlyOn_iff_filter","module":"Mathlib.Topology.UniformSpace.UniformConvergence","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒπ : Type x\ninst‚úù¬π : UniformSpace Œ≤\nF : Œπ ‚Üí Œ± ‚Üí Œ≤\nf : Œ± ‚Üí Œ≤\ns : Set Œ±\np : Filter Œπ\ninst‚úù : TopologicalSpace Œ±\n‚ä¢ Iff (TendstoLocallyUniformlyOn F f p s) (‚àÄ (x : Œ±), Membership.mem s x ‚Üí TendstoUniformlyOnFilter F f p (nhdsWithin x s))","decl":"theorem tendstoLocallyUniformlyOn_iff_filter :\n    TendstoLocallyUniformlyOn F f p s ‚Üî ‚àÄ x ‚àà s, TendstoUniformlyOnFilter F f p (ùìù[s] x) := by\n  simp only [TendstoUniformlyOnFilter, eventually_prod_iff]\n  constructor\n  ¬∑ rintro h x hx u hu\n    obtain ‚ü®s, hs1, hs2‚ü© := h u hu x hx\n    exact ‚ü®_, hs2, _, eventually_of_mem hs1 fun x => id, fun hi y hy => hi y hy‚ü©\n  ¬∑ rintro h u hu x hx\n    obtain ‚ü®pa, hpa, pb, hpb, h‚ü© := h x hx u hu\n    exact ‚ü®pb, hpb, eventually_of_mem hpa fun i hi y hy => h hi hy‚ü©\n\n"}
{"name":"tendstoLocallyUniformly_iff_filter","module":"Mathlib.Topology.UniformSpace.UniformConvergence","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒπ : Type x\ninst‚úù¬π : UniformSpace Œ≤\nF : Œπ ‚Üí Œ± ‚Üí Œ≤\nf : Œ± ‚Üí Œ≤\np : Filter Œπ\ninst‚úù : TopologicalSpace Œ±\n‚ä¢ Iff (TendstoLocallyUniformly F f p) (‚àÄ (x : Œ±), TendstoUniformlyOnFilter F f p (nhds x))","decl":"theorem tendstoLocallyUniformly_iff_filter :\n    TendstoLocallyUniformly F f p ‚Üî ‚àÄ x, TendstoUniformlyOnFilter F f p (ùìù x) := by\n  simpa [‚Üê tendstoLocallyUniformlyOn_univ, ‚Üê nhdsWithin_univ] using\n    @tendstoLocallyUniformlyOn_iff_filter _ _ _ _ F f univ p _\n\n"}
{"name":"TendstoLocallyUniformlyOn.tendsto_at","module":"Mathlib.Topology.UniformSpace.UniformConvergence","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒπ : Type x\ninst‚úù¬π : UniformSpace Œ≤\nF : Œπ ‚Üí Œ± ‚Üí Œ≤\nf : Œ± ‚Üí Œ≤\ns : Set Œ±\np : Filter Œπ\ninst‚úù : TopologicalSpace Œ±\nhf : TendstoLocallyUniformlyOn F f p s\na : Œ±\nha : Membership.mem s a\n‚ä¢ Filter.Tendsto (fun i => F i a) p (nhds (f a))","decl":"theorem TendstoLocallyUniformlyOn.tendsto_at (hf : TendstoLocallyUniformlyOn F f p s) {a : Œ±}\n    (ha : a ‚àà s) : Tendsto (fun i => F i a) p (ùìù (f a)) := by\n  refine ((tendstoLocallyUniformlyOn_iff_filter.mp hf) a ha).tendsto_at ?_\n  simpa only [Filter.principal_singleton] using pure_le_nhdsWithin ha\n\n"}
{"name":"TendstoLocallyUniformlyOn.unique","module":"Mathlib.Topology.UniformSpace.UniformConvergence","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒπ : Type x\ninst‚úù¬≥ : UniformSpace Œ≤\nF : Œπ ‚Üí Œ± ‚Üí Œ≤\nf : Œ± ‚Üí Œ≤\ns : Set Œ±\np : Filter Œπ\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : p.NeBot\ninst‚úù : T2Space Œ≤\ng : Œ± ‚Üí Œ≤\nhf : TendstoLocallyUniformlyOn F f p s\nhg : TendstoLocallyUniformlyOn F g p s\n‚ä¢ Set.EqOn f g s","decl":"theorem TendstoLocallyUniformlyOn.unique [p.NeBot] [T2Space Œ≤] {g : Œ± ‚Üí Œ≤}\n    (hf : TendstoLocallyUniformlyOn F f p s) (hg : TendstoLocallyUniformlyOn F g p s) :\n    s.EqOn f g := fun _a ha => tendsto_nhds_unique (hf.tendsto_at ha) (hg.tendsto_at ha)\n\n"}
{"name":"TendstoLocallyUniformlyOn.congr","module":"Mathlib.Topology.UniformSpace.UniformConvergence","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒπ : Type x\ninst‚úù¬π : UniformSpace Œ≤\nF : Œπ ‚Üí Œ± ‚Üí Œ≤\nf : Œ± ‚Üí Œ≤\ns : Set Œ±\np : Filter Œπ\ninst‚úù : TopologicalSpace Œ±\nG : Œπ ‚Üí Œ± ‚Üí Œ≤\nhf : TendstoLocallyUniformlyOn F f p s\nhg : ‚àÄ (n : Œπ), Set.EqOn (F n) (G n) s\n‚ä¢ TendstoLocallyUniformlyOn G f p s","decl":"theorem TendstoLocallyUniformlyOn.congr {G : Œπ ‚Üí Œ± ‚Üí Œ≤} (hf : TendstoLocallyUniformlyOn F f p s)\n    (hg : ‚àÄ n, s.EqOn (F n) (G n)) : TendstoLocallyUniformlyOn G f p s := by\n  rintro u hu x hx\n  obtain ‚ü®t, ht, h‚ü© := hf u hu x hx\n  refine ‚ü®s ‚à© t, inter_mem self_mem_nhdsWithin ht, ?_‚ü©\n  filter_upwards [h] with i hi y hy using hg i hy.1 ‚ñ∏ hi y hy.2\n\n"}
{"name":"TendstoLocallyUniformlyOn.congr_right","module":"Mathlib.Topology.UniformSpace.UniformConvergence","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒπ : Type x\ninst‚úù¬π : UniformSpace Œ≤\nF : Œπ ‚Üí Œ± ‚Üí Œ≤\nf : Œ± ‚Üí Œ≤\ns : Set Œ±\np : Filter Œπ\ninst‚úù : TopologicalSpace Œ±\ng : Œ± ‚Üí Œ≤\nhf : TendstoLocallyUniformlyOn F f p s\nhg : Set.EqOn f g s\n‚ä¢ TendstoLocallyUniformlyOn F g p s","decl":"theorem TendstoLocallyUniformlyOn.congr_right {g : Œ± ‚Üí Œ≤} (hf : TendstoLocallyUniformlyOn F f p s)\n    (hg : s.EqOn f g) : TendstoLocallyUniformlyOn F g p s := by\n  rintro u hu x hx\n  obtain ‚ü®t, ht, h‚ü© := hf u hu x hx\n  refine ‚ü®s ‚à© t, inter_mem self_mem_nhdsWithin ht, ?_‚ü©\n  filter_upwards [h] with i hi y hy using hg hy.1 ‚ñ∏ hi y hy.2\n\n"}
{"name":"continuousWithinAt_of_locally_uniform_approx_of_continuousWithinAt","module":"Mathlib.Topology.UniformSpace.UniformConvergence","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : UniformSpace Œ≤\nf : Œ± ‚Üí Œ≤\ns : Set Œ±\nx : Œ±\ninst‚úù : TopologicalSpace Œ±\nhx : Membership.mem s x\nL : ‚àÄ (u : Set (Prod Œ≤ Œ≤)), Membership.mem (uniformity Œ≤) u ‚Üí Exists fun t => And (Membership.mem (nhdsWithin x s) t) (Exists fun F => And (ContinuousWithinAt F s x) (‚àÄ (y : Œ±), Membership.mem t y ‚Üí Membership.mem u { fst := f y, snd := F y }))\n‚ä¢ ContinuousWithinAt f s x","decl":"/-- A function which can be locally uniformly approximated by functions which are continuous\nwithin a set at a point is continuous within this set at this point. -/\ntheorem continuousWithinAt_of_locally_uniform_approx_of_continuousWithinAt (hx : x ‚àà s)\n    (L : ‚àÄ u ‚àà ùì§ Œ≤, ‚àÉ t ‚àà ùìù[s] x, ‚àÉ F : Œ± ‚Üí Œ≤, ContinuousWithinAt F s x ‚àß ‚àÄ y ‚àà t, (f y, F y) ‚àà u) :\n    ContinuousWithinAt f s x := by\n  refine Uniform.continuousWithinAt_iff'_left.2 fun u‚ÇÄ hu‚ÇÄ => ?_\n  obtain ‚ü®u‚ÇÅ, h‚ÇÅ, u‚ÇÅ‚ÇÄ‚ü© : ‚àÉ u ‚àà ùì§ Œ≤, u ‚óã u ‚äÜ u‚ÇÄ := comp_mem_uniformity_sets hu‚ÇÄ\n  obtain ‚ü®u‚ÇÇ, h‚ÇÇ, hsymm, u‚ÇÇ‚ÇÅ‚ü© : ‚àÉ u ‚àà ùì§ Œ≤, (‚àÄ {a b}, (a, b) ‚àà u ‚Üí (b, a) ‚àà u) ‚àß u ‚óã u ‚äÜ u‚ÇÅ :=\n    comp_symm_of_uniformity h‚ÇÅ\n  rcases L u‚ÇÇ h‚ÇÇ with ‚ü®t, tx, F, hFc, hF‚ü©\n  have A : ‚àÄ·∂† y in ùìù[s] x, (f y, F y) ‚àà u‚ÇÇ := Eventually.mono tx hF\n  have B : ‚àÄ·∂† y in ùìù[s] x, (F y, F x) ‚àà u‚ÇÇ := Uniform.continuousWithinAt_iff'_left.1 hFc h‚ÇÇ\n  have C : ‚àÄ·∂† y in ùìù[s] x, (f y, F x) ‚àà u‚ÇÅ :=\n    (A.and B).mono fun y hy => u‚ÇÇ‚ÇÅ (prod_mk_mem_compRel hy.1 hy.2)\n  have : (F x, f x) ‚àà u‚ÇÅ :=\n    u‚ÇÇ‚ÇÅ (prod_mk_mem_compRel (refl_mem_uniformity h‚ÇÇ) (hsymm (A.self_of_nhdsWithin hx)))\n  exact C.mono fun y hy => u‚ÇÅ‚ÇÄ (prod_mk_mem_compRel hy this)\n\n"}
{"name":"continuousAt_of_locally_uniform_approx_of_continuousAt","module":"Mathlib.Topology.UniformSpace.UniformConvergence","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : UniformSpace Œ≤\nf : Œ± ‚Üí Œ≤\nx : Œ±\ninst‚úù : TopologicalSpace Œ±\nL : ‚àÄ (u : Set (Prod Œ≤ Œ≤)), Membership.mem (uniformity Œ≤) u ‚Üí Exists fun t => And (Membership.mem (nhds x) t) (Exists fun F => And (ContinuousAt F x) (‚àÄ (y : Œ±), Membership.mem t y ‚Üí Membership.mem u { fst := f y, snd := F y }))\n‚ä¢ ContinuousAt f x","decl":"/-- A function which can be locally uniformly approximated by functions which are continuous at\na point is continuous at this point. -/\ntheorem continuousAt_of_locally_uniform_approx_of_continuousAt\n    (L : ‚àÄ u ‚àà ùì§ Œ≤, ‚àÉ t ‚àà ùìù x, ‚àÉ F, ContinuousAt F x ‚àß ‚àÄ y ‚àà t, (f y, F y) ‚àà u) :\n    ContinuousAt f x := by\n  rw [‚Üê continuousWithinAt_univ]\n  apply continuousWithinAt_of_locally_uniform_approx_of_continuousWithinAt (mem_univ _) _\n  simpa only [exists_prop, nhdsWithin_univ, continuousWithinAt_univ] using L\n\n"}
{"name":"continuousOn_of_locally_uniform_approx_of_continuousWithinAt","module":"Mathlib.Topology.UniformSpace.UniformConvergence","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : UniformSpace Œ≤\nf : Œ± ‚Üí Œ≤\ns : Set Œ±\ninst‚úù : TopologicalSpace Œ±\nL : ‚àÄ (x : Œ±), Membership.mem s x ‚Üí ‚àÄ (u : Set (Prod Œ≤ Œ≤)), Membership.mem (uniformity Œ≤) u ‚Üí Exists fun t => And (Membership.mem (nhdsWithin x s) t) (Exists fun F => And (ContinuousWithinAt F s x) (‚àÄ (y : Œ±), Membership.mem t y ‚Üí Membership.mem u { fst := f y, snd := F y }))\n‚ä¢ ContinuousOn f s","decl":"/-- A function which can be locally uniformly approximated by functions which are continuous\non a set is continuous on this set. -/\ntheorem continuousOn_of_locally_uniform_approx_of_continuousWithinAt\n    (L : ‚àÄ x ‚àà s, ‚àÄ u ‚àà ùì§ Œ≤, ‚àÉ t ‚àà ùìù[s] x, ‚àÉ F,\n      ContinuousWithinAt F s x ‚àß ‚àÄ y ‚àà t, (f y, F y) ‚àà u) :\n    ContinuousOn f s := fun x hx =>\n  continuousWithinAt_of_locally_uniform_approx_of_continuousWithinAt hx (L x hx)\n\n"}
{"name":"continuousOn_of_uniform_approx_of_continuousOn","module":"Mathlib.Topology.UniformSpace.UniformConvergence","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : UniformSpace Œ≤\nf : Œ± ‚Üí Œ≤\ns : Set Œ±\ninst‚úù : TopologicalSpace Œ±\nL : ‚àÄ (u : Set (Prod Œ≤ Œ≤)), Membership.mem (uniformity Œ≤) u ‚Üí Exists fun F => And (ContinuousOn F s) (‚àÄ (y : Œ±), Membership.mem s y ‚Üí Membership.mem u { fst := f y, snd := F y })\n‚ä¢ ContinuousOn f s","decl":"/-- A function which can be uniformly approximated by functions which are continuous on a set\nis continuous on this set. -/\ntheorem continuousOn_of_uniform_approx_of_continuousOn\n    (L : ‚àÄ u ‚àà ùì§ Œ≤, ‚àÉ F, ContinuousOn F s ‚àß ‚àÄ y ‚àà s, (f y, F y) ‚àà u) : ContinuousOn f s :=\n  continuousOn_of_locally_uniform_approx_of_continuousWithinAt fun _x hx u hu =>\n    ‚ü®s, self_mem_nhdsWithin, (L u hu).imp fun _F hF => ‚ü®hF.1.continuousWithinAt hx, hF.2‚ü©‚ü©\n\n"}
{"name":"continuous_of_locally_uniform_approx_of_continuousAt","module":"Mathlib.Topology.UniformSpace.UniformConvergence","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : UniformSpace Œ≤\nf : Œ± ‚Üí Œ≤\ninst‚úù : TopologicalSpace Œ±\nL : ‚àÄ (x : Œ±) (u : Set (Prod Œ≤ Œ≤)), Membership.mem (uniformity Œ≤) u ‚Üí Exists fun t => And (Membership.mem (nhds x) t) (Exists fun F => And (ContinuousAt F x) (‚àÄ (y : Œ±), Membership.mem t y ‚Üí Membership.mem u { fst := f y, snd := F y }))\n‚ä¢ Continuous f","decl":"/-- A function which can be locally uniformly approximated by continuous functions is continuous. -/\ntheorem continuous_of_locally_uniform_approx_of_continuousAt\n    (L : ‚àÄ x : Œ±, ‚àÄ u ‚àà ùì§ Œ≤, ‚àÉ t ‚àà ùìù x, ‚àÉ F, ContinuousAt F x ‚àß ‚àÄ y ‚àà t, (f y, F y) ‚àà u) :\n    Continuous f :=\n  continuous_iff_continuousAt.2 fun x =>\n    continuousAt_of_locally_uniform_approx_of_continuousAt (L x)\n\n"}
{"name":"continuous_of_uniform_approx_of_continuous","module":"Mathlib.Topology.UniformSpace.UniformConvergence","initialProofState":"Œ± : Type u\nŒ≤ : Type v\ninst‚úù¬π : UniformSpace Œ≤\nf : Œ± ‚Üí Œ≤\ninst‚úù : TopologicalSpace Œ±\nL : ‚àÄ (u : Set (Prod Œ≤ Œ≤)), Membership.mem (uniformity Œ≤) u ‚Üí Exists fun F => And (Continuous F) (‚àÄ (y : Œ±), Membership.mem u { fst := f y, snd := F y })\n‚ä¢ Continuous f","decl":"/-- A function which can be uniformly approximated by continuous functions is continuous. -/\ntheorem continuous_of_uniform_approx_of_continuous\n    (L : ‚àÄ u ‚àà ùì§ Œ≤, ‚àÉ F, Continuous F ‚àß ‚àÄ y, (f y, F y) ‚àà u) : Continuous f :=\n  continuous_iff_continuousOn_univ.mpr <|\n    continuousOn_of_uniform_approx_of_continuousOn <| by\n      simpa [continuous_iff_continuousOn_univ] using L\n\n"}
{"name":"TendstoLocallyUniformlyOn.continuousOn","module":"Mathlib.Topology.UniformSpace.UniformConvergence","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒπ : Type x\ninst‚úù¬≤ : UniformSpace Œ≤\nF : Œπ ‚Üí Œ± ‚Üí Œ≤\nf : Œ± ‚Üí Œ≤\ns : Set Œ±\np : Filter Œπ\ninst‚úù¬π : TopologicalSpace Œ±\nh : TendstoLocallyUniformlyOn F f p s\nhc : Filter.Eventually (fun n => ContinuousOn (F n) s) p\ninst‚úù : p.NeBot\n‚ä¢ ContinuousOn f s","decl":"/-- A locally uniform limit on a set of functions which are continuous on this set is itself\ncontinuous on this set. -/\nprotected theorem TendstoLocallyUniformlyOn.continuousOn (h : TendstoLocallyUniformlyOn F f p s)\n    (hc : ‚àÄ·∂† n in p, ContinuousOn (F n) s) [NeBot p] : ContinuousOn f s := by\n  refine continuousOn_of_locally_uniform_approx_of_continuousWithinAt fun x hx u hu => ?_\n  rcases h u hu x hx with ‚ü®t, ht, H‚ü©\n  rcases (hc.and H).exists with ‚ü®n, hFc, hF‚ü©\n  exact ‚ü®t, ht, ‚ü®F n, hFc.continuousWithinAt hx, hF‚ü©‚ü©\n\n"}
{"name":"TendstoUniformlyOn.continuousOn","module":"Mathlib.Topology.UniformSpace.UniformConvergence","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒπ : Type x\ninst‚úù¬≤ : UniformSpace Œ≤\nF : Œπ ‚Üí Œ± ‚Üí Œ≤\nf : Œ± ‚Üí Œ≤\ns : Set Œ±\np : Filter Œπ\ninst‚úù¬π : TopologicalSpace Œ±\nh : TendstoUniformlyOn F f p s\nhc : Filter.Eventually (fun n => ContinuousOn (F n) s) p\ninst‚úù : p.NeBot\n‚ä¢ ContinuousOn f s","decl":"/-- A uniform limit on a set of functions which are continuous on this set is itself continuous\non this set. -/\nprotected theorem TendstoUniformlyOn.continuousOn (h : TendstoUniformlyOn F f p s)\n    (hc : ‚àÄ·∂† n in p, ContinuousOn (F n) s) [NeBot p] : ContinuousOn f s :=\n  h.tendstoLocallyUniformlyOn.continuousOn hc\n\n"}
{"name":"TendstoLocallyUniformly.continuous","module":"Mathlib.Topology.UniformSpace.UniformConvergence","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒπ : Type x\ninst‚úù¬≤ : UniformSpace Œ≤\nF : Œπ ‚Üí Œ± ‚Üí Œ≤\nf : Œ± ‚Üí Œ≤\np : Filter Œπ\ninst‚úù¬π : TopologicalSpace Œ±\nh : TendstoLocallyUniformly F f p\nhc : Filter.Eventually (fun n => Continuous (F n)) p\ninst‚úù : p.NeBot\n‚ä¢ Continuous f","decl":"/-- A locally uniform limit of continuous functions is continuous. -/\nprotected theorem TendstoLocallyUniformly.continuous (h : TendstoLocallyUniformly F f p)\n    (hc : ‚àÄ·∂† n in p, Continuous (F n)) [NeBot p] : Continuous f :=\n  continuous_iff_continuousOn_univ.mpr <|\n    h.tendstoLocallyUniformlyOn.continuousOn <| hc.mono fun _n hn => hn.continuousOn\n\n"}
{"name":"TendstoUniformly.continuous","module":"Mathlib.Topology.UniformSpace.UniformConvergence","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒπ : Type x\ninst‚úù¬≤ : UniformSpace Œ≤\nF : Œπ ‚Üí Œ± ‚Üí Œ≤\nf : Œ± ‚Üí Œ≤\np : Filter Œπ\ninst‚úù¬π : TopologicalSpace Œ±\nh : TendstoUniformly F f p\nhc : Filter.Eventually (fun n => Continuous (F n)) p\ninst‚úù : p.NeBot\n‚ä¢ Continuous f","decl":"/-- A uniform limit of continuous functions is continuous. -/\nprotected theorem TendstoUniformly.continuous (h : TendstoUniformly F f p)\n    (hc : ‚àÄ·∂† n in p, Continuous (F n)) [NeBot p] : Continuous f :=\n  h.tendstoLocallyUniformly.continuous hc\n\n"}
{"name":"tendsto_comp_of_locally_uniform_limit_within","module":"Mathlib.Topology.UniformSpace.UniformConvergence","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒπ : Type x\ninst‚úù¬π : UniformSpace Œ≤\nF : Œπ ‚Üí Œ± ‚Üí Œ≤\nf : Œ± ‚Üí Œ≤\ns : Set Œ±\nx : Œ±\np : Filter Œπ\ng : Œπ ‚Üí Œ±\ninst‚úù : TopologicalSpace Œ±\nh : ContinuousWithinAt f s x\nhg : Filter.Tendsto g p (nhdsWithin x s)\nhunif : ‚àÄ (u : Set (Prod Œ≤ Œ≤)), Membership.mem (uniformity Œ≤) u ‚Üí Exists fun t => And (Membership.mem (nhdsWithin x s) t) (Filter.Eventually (fun n => ‚àÄ (y : Œ±), Membership.mem t y ‚Üí Membership.mem u { fst := f y, snd := F n y }) p)\n‚ä¢ Filter.Tendsto (fun n => F n (g n)) p (nhds (f x))","decl":"/-- If `F‚Çô` converges locally uniformly on a neighborhood of `x` within a set `s` to a function `f`\nwhich is continuous at `x` within `s`, and `g‚Çô` tends to `x` within `s`, then `F‚Çô (g‚Çô)` tends\nto `f x`. -/\ntheorem tendsto_comp_of_locally_uniform_limit_within (h : ContinuousWithinAt f s x)\n    (hg : Tendsto g p (ùìù[s] x))\n    (hunif : ‚àÄ u ‚àà ùì§ Œ≤, ‚àÉ t ‚àà ùìù[s] x, ‚àÄ·∂† n in p, ‚àÄ y ‚àà t, (f y, F n y) ‚àà u) :\n    Tendsto (fun n => F n (g n)) p (ùìù (f x)) := by\n  refine Uniform.tendsto_nhds_right.2 fun u‚ÇÄ hu‚ÇÄ => ?_\n  obtain ‚ü®u‚ÇÅ, h‚ÇÅ, u‚ÇÅ‚ÇÄ‚ü© : ‚àÉ u ‚àà ùì§ Œ≤, u ‚óã u ‚äÜ u‚ÇÄ := comp_mem_uniformity_sets hu‚ÇÄ\n  rcases hunif u‚ÇÅ h‚ÇÅ with ‚ü®s, sx, hs‚ü©\n  have A : ‚àÄ·∂† n in p, g n ‚àà s := hg sx\n  have B : ‚àÄ·∂† n in p, (f x, f (g n)) ‚àà u‚ÇÅ := hg (Uniform.continuousWithinAt_iff'_right.1 h h‚ÇÅ)\n  exact B.mp <| A.mp <| hs.mono fun y H1 H2 H3 => u‚ÇÅ‚ÇÄ (prod_mk_mem_compRel H3 (H1 _ H2))\n\n"}
{"name":"tendsto_comp_of_locally_uniform_limit","module":"Mathlib.Topology.UniformSpace.UniformConvergence","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒπ : Type x\ninst‚úù¬π : UniformSpace Œ≤\nF : Œπ ‚Üí Œ± ‚Üí Œ≤\nf : Œ± ‚Üí Œ≤\nx : Œ±\np : Filter Œπ\ng : Œπ ‚Üí Œ±\ninst‚úù : TopologicalSpace Œ±\nh : ContinuousAt f x\nhg : Filter.Tendsto g p (nhds x)\nhunif : ‚àÄ (u : Set (Prod Œ≤ Œ≤)), Membership.mem (uniformity Œ≤) u ‚Üí Exists fun t => And (Membership.mem (nhds x) t) (Filter.Eventually (fun n => ‚àÄ (y : Œ±), Membership.mem t y ‚Üí Membership.mem u { fst := f y, snd := F n y }) p)\n‚ä¢ Filter.Tendsto (fun n => F n (g n)) p (nhds (f x))","decl":"/-- If `F‚Çô` converges locally uniformly on a neighborhood of `x` to a function `f` which is\ncontinuous at `x`, and `g‚Çô` tends to `x`, then `F‚Çô (g‚Çô)` tends to `f x`. -/\ntheorem tendsto_comp_of_locally_uniform_limit (h : ContinuousAt f x) (hg : Tendsto g p (ùìù x))\n    (hunif : ‚àÄ u ‚àà ùì§ Œ≤, ‚àÉ t ‚àà ùìù x, ‚àÄ·∂† n in p, ‚àÄ y ‚àà t, (f y, F n y) ‚àà u) :\n    Tendsto (fun n => F n (g n)) p (ùìù (f x)) := by\n  rw [‚Üê continuousWithinAt_univ] at h\n  rw [‚Üê nhdsWithin_univ] at hunif hg\n  exact tendsto_comp_of_locally_uniform_limit_within h hg hunif\n\n"}
{"name":"TendstoLocallyUniformlyOn.tendsto_comp","module":"Mathlib.Topology.UniformSpace.UniformConvergence","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒπ : Type x\ninst‚úù¬π : UniformSpace Œ≤\nF : Œπ ‚Üí Œ± ‚Üí Œ≤\nf : Œ± ‚Üí Œ≤\ns : Set Œ±\nx : Œ±\np : Filter Œπ\ng : Œπ ‚Üí Œ±\ninst‚úù : TopologicalSpace Œ±\nh : TendstoLocallyUniformlyOn F f p s\nhf : ContinuousWithinAt f s x\nhx : Membership.mem s x\nhg : Filter.Tendsto g p (nhdsWithin x s)\n‚ä¢ Filter.Tendsto (fun n => F n (g n)) p (nhds (f x))","decl":"/-- If `F‚Çô` tends locally uniformly to `f` on a set `s`, and `g‚Çô` tends to `x` within `s`, then\n`F‚Çô g‚Çô` tends to `f x` if `f` is continuous at `x` within `s` and `x ‚àà s`. -/\ntheorem TendstoLocallyUniformlyOn.tendsto_comp (h : TendstoLocallyUniformlyOn F f p s)\n    (hf : ContinuousWithinAt f s x) (hx : x ‚àà s) (hg : Tendsto g p (ùìù[s] x)) :\n    Tendsto (fun n => F n (g n)) p (ùìù (f x)) :=\n  tendsto_comp_of_locally_uniform_limit_within hf hg fun u hu => h u hu x hx\n\n"}
{"name":"TendstoUniformlyOn.tendsto_comp","module":"Mathlib.Topology.UniformSpace.UniformConvergence","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒπ : Type x\ninst‚úù¬π : UniformSpace Œ≤\nF : Œπ ‚Üí Œ± ‚Üí Œ≤\nf : Œ± ‚Üí Œ≤\ns : Set Œ±\nx : Œ±\np : Filter Œπ\ng : Œπ ‚Üí Œ±\ninst‚úù : TopologicalSpace Œ±\nh : TendstoUniformlyOn F f p s\nhf : ContinuousWithinAt f s x\nhg : Filter.Tendsto g p (nhdsWithin x s)\n‚ä¢ Filter.Tendsto (fun n => F n (g n)) p (nhds (f x))","decl":"/-- If `F‚Çô` tends uniformly to `f` on a set `s`, and `g‚Çô` tends to `x` within `s`, then `F‚Çô g‚Çô`\ntends to `f x` if `f` is continuous at `x` within `s`. -/\ntheorem TendstoUniformlyOn.tendsto_comp (h : TendstoUniformlyOn F f p s)\n    (hf : ContinuousWithinAt f s x) (hg : Tendsto g p (ùìù[s] x)) :\n    Tendsto (fun n => F n (g n)) p (ùìù (f x)) :=\n  tendsto_comp_of_locally_uniform_limit_within hf hg fun u hu => ‚ü®s, self_mem_nhdsWithin, h u hu‚ü©\n\n"}
{"name":"TendstoLocallyUniformly.tendsto_comp","module":"Mathlib.Topology.UniformSpace.UniformConvergence","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒπ : Type x\ninst‚úù¬π : UniformSpace Œ≤\nF : Œπ ‚Üí Œ± ‚Üí Œ≤\nf : Œ± ‚Üí Œ≤\nx : Œ±\np : Filter Œπ\ng : Œπ ‚Üí Œ±\ninst‚úù : TopologicalSpace Œ±\nh : TendstoLocallyUniformly F f p\nhf : ContinuousAt f x\nhg : Filter.Tendsto g p (nhds x)\n‚ä¢ Filter.Tendsto (fun n => F n (g n)) p (nhds (f x))","decl":"/-- If `F‚Çô` tends locally uniformly to `f`, and `g‚Çô` tends to `x`, then `F‚Çô g‚Çô` tends to `f x`. -/\ntheorem TendstoLocallyUniformly.tendsto_comp (h : TendstoLocallyUniformly F f p)\n    (hf : ContinuousAt f x) (hg : Tendsto g p (ùìù x)) : Tendsto (fun n => F n (g n)) p (ùìù (f x)) :=\n  tendsto_comp_of_locally_uniform_limit hf hg fun u hu => h u hu x\n\n"}
{"name":"TendstoUniformly.tendsto_comp","module":"Mathlib.Topology.UniformSpace.UniformConvergence","initialProofState":"Œ± : Type u\nŒ≤ : Type v\nŒπ : Type x\ninst‚úù¬π : UniformSpace Œ≤\nF : Œπ ‚Üí Œ± ‚Üí Œ≤\nf : Œ± ‚Üí Œ≤\nx : Œ±\np : Filter Œπ\ng : Œπ ‚Üí Œ±\ninst‚úù : TopologicalSpace Œ±\nh : TendstoUniformly F f p\nhf : ContinuousAt f x\nhg : Filter.Tendsto g p (nhds x)\n‚ä¢ Filter.Tendsto (fun n => F n (g n)) p (nhds (f x))","decl":"/-- If `F‚Çô` tends uniformly to `f`, and `g‚Çô` tends to `x`, then `F‚Çô g‚Çô` tends to `f x`. -/\ntheorem TendstoUniformly.tendsto_comp (h : TendstoUniformly F f p) (hf : ContinuousAt f x)\n    (hg : Tendsto g p (ùìù x)) : Tendsto (fun n => F n (g n)) p (ùìù (f x)) :=\n  h.tendstoLocallyUniformly.tendsto_comp hf hg\n"}
