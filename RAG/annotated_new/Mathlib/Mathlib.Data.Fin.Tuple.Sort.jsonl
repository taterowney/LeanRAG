{"name":"Tuple.graph.card","module":"Mathlib.Data.Fin.Tuple.Sort","initialProofState":"n : Nat\nα : Type u_1\ninst✝ : LinearOrder α\nf : Fin n → α\n⊢ Eq (Tuple.graph f).card n","decl":"@[simp]\ntheorem graph.card (f : Fin n → α) : (graph f).card = n := by\n  rw [graph, Finset.card_image_of_injective]\n  · exact Finset.card_fin _\n  · intro _ _\n    -- Porting note (https://github.com/leanprover-community/mathlib4/issues/10745): was `simp`\n    dsimp only\n    rw [Prod.ext_iff]\n    simp\n\n"}
{"name":"Tuple.proj_equiv₁'","module":"Mathlib.Data.Fin.Tuple.Sort","initialProofState":"n : Nat\nα : Type u_1\ninst✝ : LinearOrder α\nf : Fin n → α\n⊢ Eq (Function.comp Tuple.graph.proj ⇑(Tuple.graphEquiv₁ f)) f","decl":"@[simp]\ntheorem proj_equiv₁' (f : Fin n → α) : graph.proj ∘ graphEquiv₁ f = f :=\n  rfl\n\n"}
{"name":"Tuple.graphEquiv₂_apply","module":"Mathlib.Data.Fin.Tuple.Sort","initialProofState":"n : Nat\nα : Type u_1\ninst✝ : LinearOrder α\nf : Fin n → α\ni : Fin n\n⊢ Eq ((Tuple.graphEquiv₂ f) i) ((Tuple.graphEquiv₁ f) ((Tuple.sort f) i))","decl":"theorem graphEquiv₂_apply (f : Fin n → α) (i : Fin n) :\n    graphEquiv₂ f i = graphEquiv₁ f (sort f i) :=\n  ((graphEquiv₁ f).apply_symm_apply _).symm\n\n"}
{"name":"Tuple.self_comp_sort","module":"Mathlib.Data.Fin.Tuple.Sort","initialProofState":"n : Nat\nα : Type u_1\ninst✝ : LinearOrder α\nf : Fin n → α\n⊢ Eq (Function.comp f ⇑(Tuple.sort f)) (Function.comp Tuple.graph.proj ⇑(Tuple.graphEquiv₂ f))","decl":"theorem self_comp_sort (f : Fin n → α) : f ∘ sort f = graph.proj ∘ graphEquiv₂ f :=\n  show graph.proj ∘ (graphEquiv₁ f ∘ (graphEquiv₁ f).symm) ∘ (graphEquiv₂ f).toEquiv = _ by simp\n\n"}
{"name":"Tuple.monotone_proj","module":"Mathlib.Data.Fin.Tuple.Sort","initialProofState":"n : Nat\nα : Type u_1\ninst✝ : LinearOrder α\nf : Fin n → α\n⊢ Monotone Tuple.graph.proj","decl":"theorem monotone_proj (f : Fin n → α) : Monotone (graph.proj : graph f → α) := by\n  rintro ⟨⟨x, i⟩, hx⟩ ⟨⟨y, j⟩, hy⟩ (_ | h)\n  · exact le_of_lt ‹_›\n  · simp [graph.proj]\n\n"}
{"name":"Tuple.monotone_sort","module":"Mathlib.Data.Fin.Tuple.Sort","initialProofState":"n : Nat\nα : Type u_1\ninst✝ : LinearOrder α\nf : Fin n → α\n⊢ Monotone (Function.comp f ⇑(Tuple.sort f))","decl":"theorem monotone_sort (f : Fin n → α) : Monotone (f ∘ sort f) := by\n  rw [self_comp_sort]\n  exact (monotone_proj f).comp (graphEquiv₂ f).monotone\n\n"}
{"name":"Tuple.lt_card_le_iff_apply_le_of_monotone","module":"Mathlib.Data.Fin.Tuple.Sort","initialProofState":"α : Type u_1\ninst✝¹ : PartialOrder α\ninst✝ : DecidableRel LE.le\nm : Nat\nf : Fin m → α\na : α\nh_sorted : Monotone f\nj : Fin m\n⊢ Iff (LT.lt (↑j) (Fintype.card (Subtype fun i => LE.le (f i) a))) (LE.le (f j) a)","decl":"/-- If `f₀ ≤ f₁ ≤ f₂ ≤ ⋯` is a sorted `m`-tuple of elements of `α`, then for any `j : Fin m` and\n`a : α` we have `j < #{i | fᵢ ≤ a}` iff `fⱼ ≤ a`. -/\ntheorem lt_card_le_iff_apply_le_of_monotone [PartialOrder α] [DecidableRel (α := α) LE.le]\n    {m : ℕ} (f : Fin m → α) (a : α) (h_sorted : Monotone f) (j : Fin m) :\n    j < Fintype.card {i // f i ≤ a} ↔ f j ≤ a := by\n  suffices h1 : ∀ k : Fin m, (k < Fintype.card {i // f i ≤ a}) → f k ≤ a by\n    refine ⟨h1 j, fun h ↦ ?_⟩\n    by_contra! hc\n    let p : Fin m → Prop := fun x ↦ f x ≤ a\n    let q : Fin m → Prop := fun x ↦ x < Fintype.card {i // f i ≤ a}\n    let q' : {i // f i ≤ a} → Prop := fun x ↦ q x\n    have hw : 0 < Fintype.card {j : {x : Fin m // f x ≤ a} // ¬ q' j} :=\n      Fintype.card_pos_iff.2 ⟨⟨⟨j, h⟩, not_lt.2 hc⟩⟩\n    apply hw.ne'\n    have he := Fintype.card_congr <| Equiv.sumCompl <| q'\n    have h4 := (Fintype.card_congr (@Equiv.subtypeSubtypeEquivSubtype _ p q (h1 _)))\n    have h_le : Fintype.card { i // f i ≤ a } ≤ m := by\n      conv_rhs => rw [← Fintype.card_fin m]\n      exact Fintype.card_subtype_le _\n    rwa [Fintype.card_sum, h4, Fintype.card_fin_lt_of_le h_le, add_right_eq_self] at he\n  intro _ h\n  contrapose! h\n  rw [← Fin.card_Iio, Fintype.card_subtype]\n  refine Finset.card_mono (fun i => Function.mtr ?_)\n  simp_rw [Finset.mem_filter, Finset.mem_univ, true_and, Finset.mem_Iio]\n  intro hij hia\n  apply h\n  exact (h_sorted (le_of_not_lt hij)).trans hia\n\n"}
{"name":"Tuple.lt_card_ge_iff_apply_ge_of_antitone","module":"Mathlib.Data.Fin.Tuple.Sort","initialProofState":"α : Type u_1\ninst✝¹ : PartialOrder α\ninst✝ : DecidableRel LE.le\nm : Nat\nf : Fin m → α\na : α\nh_sorted : Antitone f\nj : Fin m\n⊢ Iff (LT.lt (↑j) (Fintype.card (Subtype fun i => LE.le a (f i)))) (LE.le a (f j))","decl":"theorem lt_card_ge_iff_apply_ge_of_antitone [PartialOrder α] [DecidableRel (α := α) LE.le]\n    {m : ℕ} (f : Fin m → α) (a : α) (h_sorted : Antitone f) (j : Fin m) :\n    j < Fintype.card {i // a ≤ f i} ↔ a ≤ f j :=\n  lt_card_le_iff_apply_le_of_monotone _ (OrderDual.toDual a) h_sorted.dual_right j\n\n"}
{"name":"Tuple.unique_monotone","module":"Mathlib.Data.Fin.Tuple.Sort","initialProofState":"n : Nat\nα : Type u_1\ninst✝ : PartialOrder α\nf : Fin n → α\nσ τ : Equiv.Perm (Fin n)\nhfσ : Monotone (Function.comp f ⇑σ)\nhfτ : Monotone (Function.comp f ⇑τ)\n⊢ Eq (Function.comp f ⇑σ) (Function.comp f ⇑τ)","decl":"/-- If two permutations of a tuple `f` are both monotone, then they are equal. -/\ntheorem unique_monotone [PartialOrder α] {f : Fin n → α} {σ τ : Equiv.Perm (Fin n)}\n    (hfσ : Monotone (f ∘ σ)) (hfτ : Monotone (f ∘ τ)) : f ∘ σ = f ∘ τ :=\n  ofFn_injective <|\n    eq_of_perm_of_sorted ((σ.ofFn_comp_perm f).trans (τ.ofFn_comp_perm f).symm)\n      hfσ.ofFn_sorted hfτ.ofFn_sorted\n\n"}
{"name":"Tuple.eq_sort_iff'","module":"Mathlib.Data.Fin.Tuple.Sort","initialProofState":"n : Nat\nα : Type u_1\ninst✝ : LinearOrder α\nf : Fin n → α\nσ : Equiv.Perm (Fin n)\n⊢ Iff (Eq σ (Tuple.sort f)) (StrictMono ⇑(Equiv.trans σ (Tuple.graphEquiv₁ f)))","decl":"/-- A permutation `σ` equals `sort f` if and only if the map `i ↦ (f (σ i), σ i)` is\nstrictly monotone (w.r.t. the lexicographic ordering on the target). -/\ntheorem eq_sort_iff' : σ = sort f ↔ StrictMono (σ.trans <| graphEquiv₁ f) := by\n  constructor <;> intro h\n  · rw [h, sort, Equiv.trans_assoc, Equiv.symm_trans_self]\n    exact (graphEquiv₂ f).strictMono\n  · have := Subsingleton.elim (graphEquiv₂ f) (h.orderIsoOfSurjective _ <| Equiv.surjective _)\n    ext1 x\n    exact (graphEquiv₁ f).apply_eq_iff_eq_symm_apply.1 (DFunLike.congr_fun this x).symm\n\n"}
{"name":"Tuple.eq_sort_iff","module":"Mathlib.Data.Fin.Tuple.Sort","initialProofState":"n : Nat\nα : Type u_1\ninst✝ : LinearOrder α\nf : Fin n → α\nσ : Equiv.Perm (Fin n)\n⊢ Iff (Eq σ (Tuple.sort f)) (And (Monotone (Function.comp f ⇑σ)) (∀ (i j : Fin n), LT.lt i j → Eq (f (σ i)) (f (σ j)) → LT.lt (σ i) (σ j)))","decl":"/-- A permutation `σ` equals `sort f` if and only if `f ∘ σ` is monotone and whenever `i < j`\nand `f (σ i) = f (σ j)`, then `σ i < σ j`. This means that `sort f` is the lexicographically\nsmallest permutation `σ` such that `f ∘ σ` is monotone. -/\ntheorem eq_sort_iff :\n    σ = sort f ↔ Monotone (f ∘ σ) ∧ ∀ i j, i < j → f (σ i) = f (σ j) → σ i < σ j := by\n  rw [eq_sort_iff']\n  refine ⟨fun h => ⟨(monotone_proj f).comp h.monotone, fun i j hij hfij => ?_⟩, fun h i j hij => ?_⟩\n  · exact ((Prod.Lex.toLex_lt_toLex.1 <| h hij).resolve_left hfij.not_lt).2\n  · obtain he | hl := (h.1 hij.le).eq_or_lt <;> apply Prod.Lex.toLex_lt_toLex.2\n    exacts [Or.inr ⟨he, h.2 i j hij he⟩, Or.inl hl]\n\n"}
{"name":"Tuple.sort_eq_refl_iff_monotone","module":"Mathlib.Data.Fin.Tuple.Sort","initialProofState":"n : Nat\nα : Type u_1\ninst✝ : LinearOrder α\nf : Fin n → α\n⊢ Iff (Eq (Tuple.sort f) (Equiv.refl (Fin n))) (Monotone f)","decl":"/-- The permutation that sorts `f` is the identity if and only if `f` is monotone. -/\ntheorem sort_eq_refl_iff_monotone : sort f = Equiv.refl _ ↔ Monotone f := by\n  rw [eq_comm, eq_sort_iff, Equiv.coe_refl, Function.comp_id]\n  simp only [id, and_iff_left_iff_imp]\n  exact fun _ _ _ hij _ => hij\n\n"}
{"name":"Tuple.comp_sort_eq_comp_iff_monotone","module":"Mathlib.Data.Fin.Tuple.Sort","initialProofState":"n : Nat\nα : Type u_1\ninst✝ : LinearOrder α\nf : Fin n → α\nσ : Equiv.Perm (Fin n)\n⊢ Iff (Eq (Function.comp f ⇑σ) (Function.comp f ⇑(Tuple.sort f))) (Monotone (Function.comp f ⇑σ))","decl":"/-- A permutation of a tuple `f` is `f` sorted if and only if it is monotone. -/\ntheorem comp_sort_eq_comp_iff_monotone : f ∘ σ = f ∘ sort f ↔ Monotone (f ∘ σ) :=\n  ⟨fun h => h.symm ▸ monotone_sort f, fun h => unique_monotone h (monotone_sort f)⟩\n\n"}
{"name":"Tuple.comp_perm_comp_sort_eq_comp_sort","module":"Mathlib.Data.Fin.Tuple.Sort","initialProofState":"n : Nat\nα : Type u_1\ninst✝ : LinearOrder α\nf : Fin n → α\nσ : Equiv.Perm (Fin n)\n⊢ Eq (Function.comp (Function.comp f ⇑σ) ⇑(Tuple.sort (Function.comp f ⇑σ))) (Function.comp f ⇑(Tuple.sort f))","decl":"/-- The sorted versions of a tuple `f` and of any permutation of `f` agree. -/\ntheorem comp_perm_comp_sort_eq_comp_sort : (f ∘ σ) ∘ sort (f ∘ σ) = f ∘ sort f := by\n  rw [Function.comp_assoc, ← Equiv.Perm.coe_mul]\n  exact unique_monotone (monotone_sort (f ∘ σ)) (monotone_sort f)\n\n"}
{"name":"Tuple.antitone_pair_of_not_sorted'","module":"Mathlib.Data.Fin.Tuple.Sort","initialProofState":"n : Nat\nα : Type u_1\ninst✝ : LinearOrder α\nf : Fin n → α\nσ : Equiv.Perm (Fin n)\nh : Ne (Function.comp f ⇑σ) (Function.comp f ⇑(Tuple.sort f))\n⊢ Exists fun i => Exists fun j => And (LT.lt i j) (LT.lt (Function.comp f (⇑σ) j) (Function.comp f (⇑σ) i))","decl":"/-- If a permutation `f ∘ σ` of the tuple `f` is not the same as `f ∘ sort f`, then `f ∘ σ`\nhas a pair of strictly decreasing entries. -/\ntheorem antitone_pair_of_not_sorted' (h : f ∘ σ ≠ f ∘ sort f) :\n    ∃ i j, i < j ∧ (f ∘ σ) j < (f ∘ σ) i := by\n  contrapose! h\n  exact comp_sort_eq_comp_iff_monotone.mpr (monotone_iff_forall_lt.mpr h)\n\n"}
{"name":"Tuple.antitone_pair_of_not_sorted","module":"Mathlib.Data.Fin.Tuple.Sort","initialProofState":"n : Nat\nα : Type u_1\ninst✝ : LinearOrder α\nf : Fin n → α\nh : Ne f (Function.comp f ⇑(Tuple.sort f))\n⊢ Exists fun i => Exists fun j => And (LT.lt i j) (LT.lt (f j) (f i))","decl":"/-- If the tuple `f` is not the same as `f ∘ sort f`, then `f` has a pair of strictly decreasing\nentries. -/\ntheorem antitone_pair_of_not_sorted (h : f ≠ f ∘ sort f) : ∃ i j, i < j ∧ f j < f i :=\n  antitone_pair_of_not_sorted' (id h : f ∘ Equiv.refl _ ≠ _)\n\n"}
