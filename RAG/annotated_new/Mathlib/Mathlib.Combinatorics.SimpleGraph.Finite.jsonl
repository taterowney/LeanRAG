{"name":"SimpleGraph.coe_edgeFinset","module":"Mathlib.Combinatorics.SimpleGraph.Finite","initialProofState":"V : Type u_1\nG : SimpleGraph V\ninstâœ : Fintype â†‘G.edgeSet\nâŠ¢ Eq (â†‘G.edgeFinset) G.edgeSet","decl":"@[norm_cast]\ntheorem coe_edgeFinset : (G.edgeFinset : Set (Sym2 V)) = G.edgeSet :=\n  Set.coe_toFinset _\n\n"}
{"name":"SimpleGraph.mem_edgeFinset","module":"Mathlib.Combinatorics.SimpleGraph.Finite","initialProofState":"V : Type u_1\nG : SimpleGraph V\ne : Sym2 V\ninstâœ : Fintype â†‘G.edgeSet\nâŠ¢ Iff (Membership.mem G.edgeFinset e) (Membership.mem G.edgeSet e)","decl":"theorem mem_edgeFinset : e âˆˆ G.edgeFinset â†” e âˆˆ G.edgeSet :=\n  Set.mem_toFinset\n\n"}
{"name":"SimpleGraph.not_isDiag_of_mem_edgeFinset","module":"Mathlib.Combinatorics.SimpleGraph.Finite","initialProofState":"V : Type u_1\nG : SimpleGraph V\ne : Sym2 V\ninstâœ : Fintype â†‘G.edgeSet\naâœ : Membership.mem G.edgeFinset e\nâŠ¢ Not e.IsDiag","decl":"theorem not_isDiag_of_mem_edgeFinset : e âˆˆ G.edgeFinset â†’ Â¬e.IsDiag :=\n  not_isDiag_of_mem_edgeSet _ âˆ˜ mem_edgeFinset.1\n\n"}
{"name":"SimpleGraph.edgeFinset_inj","module":"Mathlib.Combinatorics.SimpleGraph.Finite","initialProofState":"V : Type u_1\nGâ‚ Gâ‚‚ : SimpleGraph V\ninstâœÂ¹ : Fintype â†‘Gâ‚.edgeSet\ninstâœ : Fintype â†‘Gâ‚‚.edgeSet\nâŠ¢ Iff (Eq Gâ‚.edgeFinset Gâ‚‚.edgeFinset) (Eq Gâ‚ Gâ‚‚)","decl":"theorem edgeFinset_inj : Gâ‚.edgeFinset = Gâ‚‚.edgeFinset â†” Gâ‚ = Gâ‚‚ := by simp\n\n"}
{"name":"SimpleGraph.edgeFinset_subset_edgeFinset","module":"Mathlib.Combinatorics.SimpleGraph.Finite","initialProofState":"V : Type u_1\nGâ‚ Gâ‚‚ : SimpleGraph V\ninstâœÂ¹ : Fintype â†‘Gâ‚.edgeSet\ninstâœ : Fintype â†‘Gâ‚‚.edgeSet\nâŠ¢ Iff (HasSubset.Subset Gâ‚.edgeFinset Gâ‚‚.edgeFinset) (LE.le Gâ‚ Gâ‚‚)","decl":"theorem edgeFinset_subset_edgeFinset : Gâ‚.edgeFinset âŠ† Gâ‚‚.edgeFinset â†” Gâ‚ â‰¤ Gâ‚‚ := by simp\n\n"}
{"name":"SimpleGraph.edgeFinset_ssubset_edgeFinset","module":"Mathlib.Combinatorics.SimpleGraph.Finite","initialProofState":"V : Type u_1\nGâ‚ Gâ‚‚ : SimpleGraph V\ninstâœÂ¹ : Fintype â†‘Gâ‚.edgeSet\ninstâœ : Fintype â†‘Gâ‚‚.edgeSet\nâŠ¢ Iff (HasSSubset.SSubset Gâ‚.edgeFinset Gâ‚‚.edgeFinset) (LT.lt Gâ‚ Gâ‚‚)","decl":"theorem edgeFinset_ssubset_edgeFinset : Gâ‚.edgeFinset âŠ‚ Gâ‚‚.edgeFinset â†” Gâ‚ < Gâ‚‚ := by simp\n\n"}
{"name":"SimpleGraph.edgeFinset_mono","module":"Mathlib.Combinatorics.SimpleGraph.Finite","initialProofState":"V : Type u_1\nGâ‚ Gâ‚‚ : SimpleGraph V\ninstâœÂ¹ : Fintype â†‘Gâ‚.edgeSet\ninstâœ : Fintype â†‘Gâ‚‚.edgeSet\naâœ : LE.le Gâ‚ Gâ‚‚\nâŠ¢ HasSubset.Subset Gâ‚.edgeFinset Gâ‚‚.edgeFinset","decl":"@[gcongr] alias âŸ¨_, edgeFinset_monoâŸ© := edgeFinset_subset_edgeFinset\n\n"}
{"name":"SimpleGraph.edgeFinset_strict_mono","module":"Mathlib.Combinatorics.SimpleGraph.Finite","initialProofState":"V : Type u_1\nGâ‚ Gâ‚‚ : SimpleGraph V\ninstâœÂ¹ : Fintype â†‘Gâ‚.edgeSet\ninstâœ : Fintype â†‘Gâ‚‚.edgeSet\naâœ : LT.lt Gâ‚ Gâ‚‚\nâŠ¢ HasSSubset.SSubset Gâ‚.edgeFinset Gâ‚‚.edgeFinset","decl":"alias âŸ¨_, edgeFinset_strict_monoâŸ© := edgeFinset_ssubset_edgeFinset\n\n"}
{"name":"SimpleGraph.edgeFinset_bot","module":"Mathlib.Combinatorics.SimpleGraph.Finite","initialProofState":"V : Type u_1\nâŠ¢ Eq Bot.bot.edgeFinset EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem edgeFinset_bot : (âŠ¥ : SimpleGraph V).edgeFinset = âˆ… := by simp [edgeFinset]\n\n"}
{"name":"SimpleGraph.edgeFinset_sup","module":"Mathlib.Combinatorics.SimpleGraph.Finite","initialProofState":"V : Type u_1\nGâ‚ Gâ‚‚ : SimpleGraph V\ninstâœÂ³ : Fintype â†‘Gâ‚.edgeSet\ninstâœÂ² : Fintype â†‘Gâ‚‚.edgeSet\ninstâœÂ¹ : Fintype â†‘(Max.max Gâ‚ Gâ‚‚).edgeSet\ninstâœ : DecidableEq V\nâŠ¢ Eq (Max.max Gâ‚ Gâ‚‚).edgeFinset (Union.union Gâ‚.edgeFinset Gâ‚‚.edgeFinset)","decl":"@[simp]\ntheorem edgeFinset_sup [Fintype (edgeSet (Gâ‚ âŠ” Gâ‚‚))] [DecidableEq V] :\n    (Gâ‚ âŠ” Gâ‚‚).edgeFinset = Gâ‚.edgeFinset âˆª Gâ‚‚.edgeFinset := by simp [edgeFinset]\n\n"}
{"name":"SimpleGraph.edgeFinset_inf","module":"Mathlib.Combinatorics.SimpleGraph.Finite","initialProofState":"V : Type u_1\nGâ‚ Gâ‚‚ : SimpleGraph V\ninstâœÂ² : Fintype â†‘Gâ‚.edgeSet\ninstâœÂ¹ : Fintype â†‘Gâ‚‚.edgeSet\ninstâœ : DecidableEq V\nâŠ¢ Eq (Min.min Gâ‚ Gâ‚‚).edgeFinset (Inter.inter Gâ‚.edgeFinset Gâ‚‚.edgeFinset)","decl":"@[simp]\ntheorem edgeFinset_inf [DecidableEq V] : (Gâ‚ âŠ“ Gâ‚‚).edgeFinset = Gâ‚.edgeFinset âˆ© Gâ‚‚.edgeFinset := by\n  simp [edgeFinset]\n\n"}
{"name":"SimpleGraph.edgeFinset_sdiff","module":"Mathlib.Combinatorics.SimpleGraph.Finite","initialProofState":"V : Type u_1\nGâ‚ Gâ‚‚ : SimpleGraph V\ninstâœÂ² : Fintype â†‘Gâ‚.edgeSet\ninstâœÂ¹ : Fintype â†‘Gâ‚‚.edgeSet\ninstâœ : DecidableEq V\nâŠ¢ Eq (SDiff.sdiff Gâ‚ Gâ‚‚).edgeFinset (SDiff.sdiff Gâ‚.edgeFinset Gâ‚‚.edgeFinset)","decl":"@[simp]\ntheorem edgeFinset_sdiff [DecidableEq V] :\n    (Gâ‚ \\ Gâ‚‚).edgeFinset = Gâ‚.edgeFinset \\ Gâ‚‚.edgeFinset := by simp [edgeFinset]\n\n"}
{"name":"SimpleGraph.disjoint_edgeFinset","module":"Mathlib.Combinatorics.SimpleGraph.Finite","initialProofState":"V : Type u_1\nGâ‚ Gâ‚‚ : SimpleGraph V\ninstâœÂ¹ : Fintype â†‘Gâ‚.edgeSet\ninstâœ : Fintype â†‘Gâ‚‚.edgeSet\nâŠ¢ Iff (Disjoint Gâ‚.edgeFinset Gâ‚‚.edgeFinset) (Disjoint Gâ‚ Gâ‚‚)","decl":"lemma disjoint_edgeFinset : Disjoint Gâ‚.edgeFinset Gâ‚‚.edgeFinset â†” Disjoint Gâ‚ Gâ‚‚ := by\n  simp_rw [â† Finset.disjoint_coe, coe_edgeFinset, disjoint_edgeSet]\n\n"}
{"name":"SimpleGraph.edgeFinset_eq_empty","module":"Mathlib.Combinatorics.SimpleGraph.Finite","initialProofState":"V : Type u_1\nG : SimpleGraph V\ninstâœ : Fintype â†‘G.edgeSet\nâŠ¢ Iff (Eq G.edgeFinset EmptyCollection.emptyCollection) (Eq G Bot.bot)","decl":"lemma edgeFinset_eq_empty : G.edgeFinset = âˆ… â†” G = âŠ¥ := by\n  rw [â† edgeFinset_bot, edgeFinset_inj]\n\n"}
{"name":"SimpleGraph.edgeFinset_nonempty","module":"Mathlib.Combinatorics.SimpleGraph.Finite","initialProofState":"V : Type u_1\nG : SimpleGraph V\ninstâœ : Fintype â†‘G.edgeSet\nâŠ¢ Iff G.edgeFinset.Nonempty (Ne G Bot.bot)","decl":"lemma edgeFinset_nonempty : G.edgeFinset.Nonempty â†” G â‰  âŠ¥ := by\n  rw [Finset.nonempty_iff_ne_empty, edgeFinset_eq_empty.ne]\n\n"}
{"name":"SimpleGraph.edgeFinset_card","module":"Mathlib.Combinatorics.SimpleGraph.Finite","initialProofState":"V : Type u_1\nG : SimpleGraph V\ninstâœ : Fintype â†‘G.edgeSet\nâŠ¢ Eq G.edgeFinset.card (Fintype.card â†‘G.edgeSet)","decl":"theorem edgeFinset_card : #G.edgeFinset = Fintype.card G.edgeSet :=\n  Set.toFinset_card _\n\n"}
{"name":"SimpleGraph.edgeSet_univ_card","module":"Mathlib.Combinatorics.SimpleGraph.Finite","initialProofState":"V : Type u_1\nG : SimpleGraph V\ninstâœ : Fintype â†‘G.edgeSet\nâŠ¢ Eq Finset.univ.card G.edgeFinset.card","decl":"@[simp]\ntheorem edgeSet_univ_card : #(univ : Finset G.edgeSet) = #G.edgeFinset :=\n  Fintype.card_of_subtype G.edgeFinset fun _ => mem_edgeFinset\n\n"}
{"name":"SimpleGraph.edgeFinset_top","module":"Mathlib.Combinatorics.SimpleGraph.Finite","initialProofState":"V : Type u_1\ninstâœÂ¹ : Fintype V\ninstâœ : DecidableEq V\nâŠ¢ Eq Top.top.edgeFinset (Finset.filter (fun e => Not e.IsDiag) Finset.univ)","decl":"@[simp]\ntheorem edgeFinset_top [DecidableEq V] :\n    (âŠ¤ : SimpleGraph V).edgeFinset = ({e | Â¬e.IsDiag} : Finset _) := by simp [â† coe_inj]\n\n"}
{"name":"SimpleGraph.card_edgeFinset_top_eq_card_choose_two","module":"Mathlib.Combinatorics.SimpleGraph.Finite","initialProofState":"V : Type u_1\ninstâœÂ¹ : Fintype V\ninstâœ : DecidableEq V\nâŠ¢ Eq Top.top.edgeFinset.card ((Fintype.card V).choose 2)","decl":"/-- The complete graph on `n` vertices has `n.choose 2` edges. -/\ntheorem card_edgeFinset_top_eq_card_choose_two [DecidableEq V] :\n    #(âŠ¤ : SimpleGraph V).edgeFinset = (Fintype.card V).choose 2 := by\n  simp_rw [Set.toFinset_card, edgeSet_top, Set.coe_setOf, â† Sym2.card_subtype_not_diag]\n\n"}
{"name":"SimpleGraph.card_edgeFinset_le_card_choose_two","module":"Mathlib.Combinatorics.SimpleGraph.Finite","initialProofState":"V : Type u_1\nG : SimpleGraph V\ninstâœÂ¹ : Fintype â†‘G.edgeSet\ninstâœ : Fintype V\nâŠ¢ LE.le G.edgeFinset.card ((Fintype.card V).choose 2)","decl":"/-- Any graph on `n` vertices has at most `n.choose 2` edges. -/\ntheorem card_edgeFinset_le_card_choose_two : #G.edgeFinset â‰¤ (Fintype.card V).choose 2 := by\n  classical\n  rw [â† card_edgeFinset_top_eq_card_choose_two]\n  exact card_le_card (edgeFinset_mono le_top)\n\n"}
{"name":"SimpleGraph.edgeFinset_deleteEdges","module":"Mathlib.Combinatorics.SimpleGraph.Finite","initialProofState":"V : Type u_1\nG : SimpleGraph V\ninstâœÂ² : DecidableEq V\ninstâœÂ¹ : Fintype â†‘G.edgeSet\ns : Finset (Sym2 V)\ninstâœ : Fintype â†‘(G.deleteEdges â†‘s).edgeSet\nâŠ¢ Eq (G.deleteEdges â†‘s).edgeFinset (SDiff.sdiff G.edgeFinset s)","decl":"theorem edgeFinset_deleteEdges [DecidableEq V] [Fintype G.edgeSet] (s : Finset (Sym2 V))\n    [Fintype (G.deleteEdges s).edgeSet] :\n    (G.deleteEdges s).edgeFinset = G.edgeFinset \\ s := by\n  ext e\n  simp [edgeSet_deleteEdges]\n\n"}
{"name":"SimpleGraph.deleteFar_iff","module":"Mathlib.Combinatorics.SimpleGraph.Finite","initialProofState":"V : Type u_1\nG : SimpleGraph V\nğ•œ : Type u_2\ninstâœÂ² : OrderedRing ğ•œ\ninstâœÂ¹ : Fintype â†‘G.edgeSet\np : SimpleGraph V â†’ Prop\nr : ğ•œ\ninstâœ : Fintype (Sym2 V)\nâŠ¢ Iff (G.DeleteFar p r) (âˆ€ â¦ƒH : SimpleGraph Vâ¦„ [inst : DecidableRel H.Adj], LE.le H G â†’ p H â†’ LE.le r (HSub.hSub â†‘G.edgeFinset.card â†‘H.edgeFinset.card))","decl":"theorem deleteFar_iff [Fintype (Sym2 V)] :\n    G.DeleteFar p r â†” âˆ€ â¦ƒH : SimpleGraph _â¦„ [DecidableRel H.Adj],\n      H â‰¤ G â†’ p H â†’ r â‰¤ #G.edgeFinset - #H.edgeFinset := by\n  classical\n  refine âŸ¨fun h H _ hHG hH â†¦ ?_, fun h s hs hG â†¦ ?_âŸ©\n  Â· have := h (sdiff_subset (t := H.edgeFinset))\n    simp only [deleteEdges_sdiff_eq_of_le hHG, edgeFinset_mono hHG, card_sdiff,\n      card_le_card, coe_sdiff, coe_edgeFinset, Nat.cast_sub] at this\n    exact this hH\n  Â· classical\n    simpa [card_sdiff hs, edgeFinset_deleteEdges, -Set.toFinset_card, Nat.cast_sub,\n      card_le_card hs] using h (G.deleteEdges_le s) hG\n\n"}
{"name":"SimpleGraph.DeleteFar.le_card_sub_card","module":"Mathlib.Combinatorics.SimpleGraph.Finite","initialProofState":"V : Type u_1\nG : SimpleGraph V\nğ•œ : Type u_2\ninstâœÂ³ : OrderedRing ğ•œ\ninstâœÂ² : Fintype â†‘G.edgeSet\np : SimpleGraph V â†’ Prop\nr : ğ•œ\ninstâœÂ¹ : Fintype (Sym2 V)\naâœÂ² : G.DeleteFar p r\nH : SimpleGraph V\ninstâœ : DecidableRel H.Adj\naâœÂ¹ : LE.le H G\naâœ : p H\nâŠ¢ LE.le r (HSub.hSub â†‘G.edgeFinset.card â†‘H.edgeFinset.card)","decl":"alias âŸ¨DeleteFar.le_card_sub_card, _âŸ© := deleteFar_iff\n\n"}
{"name":"SimpleGraph.DeleteFar.mono","module":"Mathlib.Combinatorics.SimpleGraph.Finite","initialProofState":"V : Type u_1\nG : SimpleGraph V\nğ•œ : Type u_2\ninstâœÂ¹ : OrderedRing ğ•œ\ninstâœ : Fintype â†‘G.edgeSet\np : SimpleGraph V â†’ Prop\nrâ‚ râ‚‚ : ğ•œ\nh : G.DeleteFar p râ‚‚\nhr : LE.le râ‚ râ‚‚\nâŠ¢ G.DeleteFar p râ‚","decl":"theorem DeleteFar.mono (h : G.DeleteFar p râ‚‚) (hr : râ‚ â‰¤ râ‚‚) : G.DeleteFar p râ‚ := fun _ hs hG =>\n  hr.trans <| h hs hG\n\n"}
{"name":"SimpleGraph.neighborFinset_def","module":"Mathlib.Combinatorics.SimpleGraph.Finite","initialProofState":"V : Type u_1\nG : SimpleGraph V\nv : V\ninstâœ : Fintype â†‘(G.neighborSet v)\nâŠ¢ Eq (G.neighborFinset v) (G.neighborSet v).toFinset","decl":"theorem neighborFinset_def : G.neighborFinset v = (G.neighborSet v).toFinset :=\n  rfl\n\n"}
{"name":"SimpleGraph.mem_neighborFinset","module":"Mathlib.Combinatorics.SimpleGraph.Finite","initialProofState":"V : Type u_1\nG : SimpleGraph V\nv : V\ninstâœ : Fintype â†‘(G.neighborSet v)\nw : V\nâŠ¢ Iff (Membership.mem (G.neighborFinset v) w) (G.Adj v w)","decl":"@[simp]\ntheorem mem_neighborFinset (w : V) : w âˆˆ G.neighborFinset v â†” G.Adj v w :=\n  Set.mem_toFinset\n\n"}
{"name":"SimpleGraph.not_mem_neighborFinset_self","module":"Mathlib.Combinatorics.SimpleGraph.Finite","initialProofState":"V : Type u_1\nG : SimpleGraph V\nv : V\ninstâœ : Fintype â†‘(G.neighborSet v)\nâŠ¢ Not (Membership.mem (G.neighborFinset v) v)","decl":"theorem not_mem_neighborFinset_self : v âˆ‰ G.neighborFinset v := by simp\n\n"}
{"name":"SimpleGraph.neighborFinset_disjoint_singleton","module":"Mathlib.Combinatorics.SimpleGraph.Finite","initialProofState":"V : Type u_1\nG : SimpleGraph V\nv : V\ninstâœ : Fintype â†‘(G.neighborSet v)\nâŠ¢ Disjoint (G.neighborFinset v) (Singleton.singleton v)","decl":"theorem neighborFinset_disjoint_singleton : Disjoint (G.neighborFinset v) {v} :=\n  Finset.disjoint_singleton_right.mpr <| not_mem_neighborFinset_self _ _\n\n"}
{"name":"SimpleGraph.singleton_disjoint_neighborFinset","module":"Mathlib.Combinatorics.SimpleGraph.Finite","initialProofState":"V : Type u_1\nG : SimpleGraph V\nv : V\ninstâœ : Fintype â†‘(G.neighborSet v)\nâŠ¢ Disjoint (Singleton.singleton v) (G.neighborFinset v)","decl":"theorem singleton_disjoint_neighborFinset : Disjoint {v} (G.neighborFinset v) :=\n  Finset.disjoint_singleton_left.mpr <| not_mem_neighborFinset_self _ _\n\n"}
{"name":"SimpleGraph.card_neighborFinset_eq_degree","module":"Mathlib.Combinatorics.SimpleGraph.Finite","initialProofState":"V : Type u_1\nG : SimpleGraph V\nv : V\ninstâœ : Fintype â†‘(G.neighborSet v)\nâŠ¢ Eq (G.neighborFinset v).card (G.degree v)","decl":"@[simp]\ntheorem card_neighborFinset_eq_degree : #(G.neighborFinset v) = G.degree v := rfl\n\n"}
{"name":"SimpleGraph.card_neighborSet_eq_degree","module":"Mathlib.Combinatorics.SimpleGraph.Finite","initialProofState":"V : Type u_1\nG : SimpleGraph V\nv : V\ninstâœ : Fintype â†‘(G.neighborSet v)\nâŠ¢ Eq (Fintype.card â†‘(G.neighborSet v)) (G.degree v)","decl":"@[simp]\ntheorem card_neighborSet_eq_degree : Fintype.card (G.neighborSet v) = G.degree v :=\n  (Set.toFinset_card _).symm\n\n"}
{"name":"SimpleGraph.degree_pos_iff_exists_adj","module":"Mathlib.Combinatorics.SimpleGraph.Finite","initialProofState":"V : Type u_1\nG : SimpleGraph V\nv : V\ninstâœ : Fintype â†‘(G.neighborSet v)\nâŠ¢ Iff (LT.lt 0 (G.degree v)) (Exists fun w => G.Adj v w)","decl":"theorem degree_pos_iff_exists_adj : 0 < G.degree v â†” âˆƒ w, G.Adj v w := by\n  simp only [degree, card_pos, Finset.Nonempty, mem_neighborFinset]\n\n"}
{"name":"SimpleGraph.degree_compl","module":"Mathlib.Combinatorics.SimpleGraph.Finite","initialProofState":"V : Type u_1\nG : SimpleGraph V\nv : V\ninstâœÂ² : Fintype â†‘(G.neighborSet v)\ninstâœÂ¹ : Fintype â†‘((HasCompl.compl G).neighborSet v)\ninstâœ : Fintype V\nâŠ¢ Eq ((HasCompl.compl G).degree v) (HSub.hSub (HSub.hSub (Fintype.card V) 1) (G.degree v))","decl":"theorem degree_compl [Fintype (Gá¶œ.neighborSet v)] [Fintype V] :\n    Gá¶œ.degree v = Fintype.card V - 1 - G.degree v := by\n  classical\n    rw [â† card_neighborSet_union_compl_neighborSet G v, Set.toFinset_union]\n    simp [card_union_of_disjoint (Set.disjoint_toFinset.mpr (compl_neighborSet_disjoint G v))]\n\n"}
{"name":"SimpleGraph.card_incidenceSet_eq_degree","module":"Mathlib.Combinatorics.SimpleGraph.Finite","initialProofState":"V : Type u_1\nG : SimpleGraph V\nv : V\ninstâœÂ¹ : Fintype â†‘(G.neighborSet v)\ninstâœ : DecidableEq V\nâŠ¢ Eq (Fintype.card â†‘(G.incidenceSet v)) (G.degree v)","decl":"@[simp]\ntheorem card_incidenceSet_eq_degree [DecidableEq V] :\n    Fintype.card (G.incidenceSet v) = G.degree v := by\n  rw [Fintype.card_congr (G.incidenceSetEquivNeighborSet v)]\n  simp\n\n"}
{"name":"SimpleGraph.card_incidenceFinset_eq_degree","module":"Mathlib.Combinatorics.SimpleGraph.Finite","initialProofState":"V : Type u_1\nG : SimpleGraph V\nv : V\ninstâœÂ¹ : Fintype â†‘(G.neighborSet v)\ninstâœ : DecidableEq V\nâŠ¢ Eq (G.incidenceFinset v).card (G.degree v)","decl":"@[simp]\ntheorem card_incidenceFinset_eq_degree [DecidableEq V] : #(G.incidenceFinset v) = G.degree v := by\n  rw [â† G.card_incidenceSet_eq_degree]\n  apply Set.toFinset_card\n\n"}
{"name":"SimpleGraph.mem_incidenceFinset","module":"Mathlib.Combinatorics.SimpleGraph.Finite","initialProofState":"V : Type u_1\nG : SimpleGraph V\nv : V\ninstâœÂ¹ : Fintype â†‘(G.neighborSet v)\ninstâœ : DecidableEq V\ne : Sym2 V\nâŠ¢ Iff (Membership.mem (G.incidenceFinset v) e) (Membership.mem (G.incidenceSet v) e)","decl":"@[simp]\ntheorem mem_incidenceFinset [DecidableEq V] (e : Sym2 V) :\n    e âˆˆ G.incidenceFinset v â†” e âˆˆ G.incidenceSet v :=\n  Set.mem_toFinset\n\n"}
{"name":"SimpleGraph.incidenceFinset_eq_filter","module":"Mathlib.Combinatorics.SimpleGraph.Finite","initialProofState":"V : Type u_1\nG : SimpleGraph V\nv : V\ninstâœÂ² : Fintype â†‘(G.neighborSet v)\ninstâœÂ¹ : DecidableEq V\ninstâœ : Fintype â†‘G.edgeSet\nâŠ¢ Eq (G.incidenceFinset v) (Finset.filter (fun e => Membership.mem e v) G.edgeFinset)","decl":"theorem incidenceFinset_eq_filter [DecidableEq V] [Fintype G.edgeSet] :\n    G.incidenceFinset v = {e âˆˆ G.edgeFinset | v âˆˆ e} := by\n  ext e\n  induction e\n  simp [mk'_mem_incidenceSet_iff]\n\n"}
{"name":"SimpleGraph.IsRegularOfDegree.degree_eq","module":"Mathlib.Combinatorics.SimpleGraph.Finite","initialProofState":"V : Type u_1\nG : SimpleGraph V\ninstâœ : G.LocallyFinite\nd : Nat\nh : G.IsRegularOfDegree d\nv : V\nâŠ¢ Eq (G.degree v) d","decl":"theorem IsRegularOfDegree.degree_eq {d : â„•} (h : G.IsRegularOfDegree d) (v : V) : G.degree v = d :=\n  h v\n\n"}
{"name":"SimpleGraph.IsRegularOfDegree.compl","module":"Mathlib.Combinatorics.SimpleGraph.Finite","initialProofState":"V : Type u_1\ninstâœÂ² : Fintype V\ninstâœÂ¹ : DecidableEq V\nG : SimpleGraph V\ninstâœ : DecidableRel G.Adj\nk : Nat\nh : G.IsRegularOfDegree k\nâŠ¢ (HasCompl.compl G).IsRegularOfDegree (HSub.hSub (HSub.hSub (Fintype.card V) 1) k)","decl":"theorem IsRegularOfDegree.compl [Fintype V] [DecidableEq V] {G : SimpleGraph V} [DecidableRel G.Adj]\n    {k : â„•} (h : G.IsRegularOfDegree k) : Gá¶œ.IsRegularOfDegree (Fintype.card V - 1 - k) := by\n  intro v\n  rw [degree_compl, h v]\n\n"}
{"name":"SimpleGraph.neighborFinset_eq_filter","module":"Mathlib.Combinatorics.SimpleGraph.Finite","initialProofState":"V : Type u_1\nG : SimpleGraph V\ninstâœÂ¹ : Fintype V\nv : V\ninstâœ : DecidableRel G.Adj\nâŠ¢ Eq (G.neighborFinset v) (Finset.filter (fun w => G.Adj v w) Finset.univ)","decl":"theorem neighborFinset_eq_filter {v : V} [DecidableRel G.Adj] :\n    G.neighborFinset v = ({w | G.Adj v w} : Finset _) := by ext; simp\n\n"}
{"name":"SimpleGraph.neighborFinset_compl","module":"Mathlib.Combinatorics.SimpleGraph.Finite","initialProofState":"V : Type u_1\nG : SimpleGraph V\ninstâœÂ² : Fintype V\ninstâœÂ¹ : DecidableEq V\ninstâœ : DecidableRel G.Adj\nv : V\nâŠ¢ Eq ((HasCompl.compl G).neighborFinset v) (SDiff.sdiff (HasCompl.compl (G.neighborFinset v)) (Singleton.singleton v))","decl":"theorem neighborFinset_compl [DecidableEq V] [DecidableRel G.Adj] (v : V) :\n    Gá¶œ.neighborFinset v = (G.neighborFinset v)á¶œ \\ {v} := by\n  simp only [neighborFinset, neighborSet_compl, Set.toFinset_diff, Set.toFinset_compl,\n    Set.toFinset_singleton]\n\n"}
{"name":"SimpleGraph.complete_graph_degree","module":"Mathlib.Combinatorics.SimpleGraph.Finite","initialProofState":"V : Type u_1\ninstâœÂ¹ : Fintype V\ninstâœ : DecidableEq V\nv : V\nâŠ¢ Eq (Top.top.degree v) (HSub.hSub (Fintype.card V) 1)","decl":"@[simp]\ntheorem complete_graph_degree [DecidableEq V] (v : V) :\n    (âŠ¤ : SimpleGraph V).degree v = Fintype.card V - 1 := by\n  erw [degree, neighborFinset_eq_filter, filter_ne, card_erase_of_mem (mem_univ v), card_univ]\n\n"}
{"name":"SimpleGraph.bot_degree","module":"Mathlib.Combinatorics.SimpleGraph.Finite","initialProofState":"V : Type u_1\ninstâœ : Fintype V\nv : V\nâŠ¢ Eq (Bot.bot.degree v) 0","decl":"theorem bot_degree (v : V) : (âŠ¥ : SimpleGraph V).degree v = 0 := by\n  erw [degree, neighborFinset_eq_filter, filter_False]\n  exact Finset.card_empty\n\n"}
{"name":"SimpleGraph.IsRegularOfDegree.top","module":"Mathlib.Combinatorics.SimpleGraph.Finite","initialProofState":"V : Type u_1\ninstâœÂ¹ : Fintype V\ninstâœ : DecidableEq V\nâŠ¢ Top.top.IsRegularOfDegree (HSub.hSub (Fintype.card V) 1)","decl":"theorem IsRegularOfDegree.top [DecidableEq V] :\n    (âŠ¤ : SimpleGraph V).IsRegularOfDegree (Fintype.card V - 1) := by\n  intro v\n  simp\n\n"}
{"name":"SimpleGraph.exists_minimal_degree_vertex","module":"Mathlib.Combinatorics.SimpleGraph.Finite","initialProofState":"V : Type u_1\nG : SimpleGraph V\ninstâœÂ² : Fintype V\ninstâœÂ¹ : DecidableRel G.Adj\ninstâœ : Nonempty V\nâŠ¢ Exists fun v => Eq G.minDegree (G.degree v)","decl":"/-- There exists a vertex of minimal degree. Note the assumption of being nonempty is necessary, as\nthe lemma implies there exists a vertex. -/\ntheorem exists_minimal_degree_vertex [DecidableRel G.Adj] [Nonempty V] :\n    âˆƒ v, G.minDegree = G.degree v := by\n  obtain âŸ¨t, ht : _ = _âŸ© := min_of_nonempty (univ_nonempty.image fun v => G.degree v)\n  obtain âŸ¨v, _, rflâŸ© := mem_image.mp (mem_of_min ht)\n  exact âŸ¨v, by simp [minDegree, ht]âŸ©\n\n"}
{"name":"SimpleGraph.minDegree_le_degree","module":"Mathlib.Combinatorics.SimpleGraph.Finite","initialProofState":"V : Type u_1\nG : SimpleGraph V\ninstâœÂ¹ : Fintype V\ninstâœ : DecidableRel G.Adj\nv : V\nâŠ¢ LE.le G.minDegree (G.degree v)","decl":"/-- The minimum degree in the graph is at most the degree of any particular vertex. -/\ntheorem minDegree_le_degree [DecidableRel G.Adj] (v : V) : G.minDegree â‰¤ G.degree v := by\n  obtain âŸ¨t, htâŸ© := Finset.min_of_mem (mem_image_of_mem (fun v => G.degree v) (mem_univ v))\n  have := Finset.min_le_of_eq (mem_image_of_mem _ (mem_univ v)) ht\n  rwa [minDegree, ht]\n\n"}
{"name":"SimpleGraph.le_minDegree_of_forall_le_degree","module":"Mathlib.Combinatorics.SimpleGraph.Finite","initialProofState":"V : Type u_1\nG : SimpleGraph V\ninstâœÂ² : Fintype V\ninstâœÂ¹ : DecidableRel G.Adj\ninstâœ : Nonempty V\nk : Nat\nh : âˆ€ (v : V), LE.le k (G.degree v)\nâŠ¢ LE.le k G.minDegree","decl":"/-- In a nonempty graph, if `k` is at most the degree of every vertex, it is at most the minimum\ndegree. Note the assumption that the graph is nonempty is necessary as long as `G.minDegree` is\ndefined to be a natural. -/\ntheorem le_minDegree_of_forall_le_degree [DecidableRel G.Adj] [Nonempty V] (k : â„•)\n    (h : âˆ€ v, k â‰¤ G.degree v) : k â‰¤ G.minDegree := by\n  rcases G.exists_minimal_degree_vertex with âŸ¨v, hvâŸ©\n  rw [hv]\n  apply h\n\n"}
{"name":"SimpleGraph.exists_maximal_degree_vertex","module":"Mathlib.Combinatorics.SimpleGraph.Finite","initialProofState":"V : Type u_1\nG : SimpleGraph V\ninstâœÂ² : Fintype V\ninstâœÂ¹ : DecidableRel G.Adj\ninstâœ : Nonempty V\nâŠ¢ Exists fun v => Eq G.maxDegree (G.degree v)","decl":"/-- There exists a vertex of maximal degree. Note the assumption of being nonempty is necessary, as\nthe lemma implies there exists a vertex. -/\ntheorem exists_maximal_degree_vertex [DecidableRel G.Adj] [Nonempty V] :\n    âˆƒ v, G.maxDegree = G.degree v := by\n  obtain âŸ¨t, htâŸ© := max_of_nonempty (univ_nonempty.image fun v => G.degree v)\n  have htâ‚‚ := mem_of_max ht\n  simp only [mem_image, mem_univ, exists_prop_of_true] at htâ‚‚\n  rcases htâ‚‚ with âŸ¨v, _, rflâŸ©\n  refine âŸ¨v, ?_âŸ©\n  rw [maxDegree, ht]\n  rfl\n\n"}
{"name":"SimpleGraph.degree_le_maxDegree","module":"Mathlib.Combinatorics.SimpleGraph.Finite","initialProofState":"V : Type u_1\nG : SimpleGraph V\ninstâœÂ¹ : Fintype V\ninstâœ : DecidableRel G.Adj\nv : V\nâŠ¢ LE.le (G.degree v) G.maxDegree","decl":"/-- The maximum degree in the graph is at least the degree of any particular vertex. -/\ntheorem degree_le_maxDegree [DecidableRel G.Adj] (v : V) : G.degree v â‰¤ G.maxDegree := by\n  obtain âŸ¨t, ht : _ = _âŸ© := Finset.max_of_mem (mem_image_of_mem (fun v => G.degree v) (mem_univ v))\n  have := Finset.le_max_of_eq (mem_image_of_mem _ (mem_univ v)) ht\n  rwa [maxDegree, ht]\n\n"}
{"name":"SimpleGraph.maxDegree_le_of_forall_degree_le","module":"Mathlib.Combinatorics.SimpleGraph.Finite","initialProofState":"V : Type u_1\nG : SimpleGraph V\ninstâœÂ¹ : Fintype V\ninstâœ : DecidableRel G.Adj\nk : Nat\nh : âˆ€ (v : V), LE.le (G.degree v) k\nâŠ¢ LE.le G.maxDegree k","decl":"/-- In a graph, if `k` is at least the degree of every vertex, then it is at least the maximum\ndegree. -/\ntheorem maxDegree_le_of_forall_degree_le [DecidableRel G.Adj] (k : â„•) (h : âˆ€ v, G.degree v â‰¤ k) :\n    G.maxDegree â‰¤ k := by\n  by_cases hV : (univ : Finset V).Nonempty\n  Â· haveI : Nonempty V := univ_nonempty_iff.mp hV\n    obtain âŸ¨v, hvâŸ© := G.exists_maximal_degree_vertex\n    rw [hv]\n    apply h\n  Â· rw [not_nonempty_iff_eq_empty] at hV\n    rw [maxDegree, hV, image_empty]\n    exact k.zero_le\n\n"}
{"name":"SimpleGraph.degree_lt_card_verts","module":"Mathlib.Combinatorics.SimpleGraph.Finite","initialProofState":"V : Type u_1\nG : SimpleGraph V\ninstâœÂ¹ : Fintype V\ninstâœ : DecidableRel G.Adj\nv : V\nâŠ¢ LT.lt (G.degree v) (Fintype.card V)","decl":"theorem degree_lt_card_verts [DecidableRel G.Adj] (v : V) : G.degree v < Fintype.card V := by\n  classical\n  apply Finset.card_lt_card\n  rw [Finset.ssubset_iff]\n  exact âŸ¨v, by simp, Finset.subset_univ _âŸ©\n\n"}
{"name":"SimpleGraph.maxDegree_lt_card_verts","module":"Mathlib.Combinatorics.SimpleGraph.Finite","initialProofState":"V : Type u_1\nG : SimpleGraph V\ninstâœÂ² : Fintype V\ninstâœÂ¹ : DecidableRel G.Adj\ninstâœ : Nonempty V\nâŠ¢ LT.lt G.maxDegree (Fintype.card V)","decl":"/--\nThe maximum degree of a nonempty graph is less than the number of vertices. Note that the assumption\nthat `V` is nonempty is necessary, as otherwise this would assert the existence of a\nnatural number less than zero. -/\ntheorem maxDegree_lt_card_verts [DecidableRel G.Adj] [Nonempty V] :\n    G.maxDegree < Fintype.card V := by\n  cases' G.exists_maximal_degree_vertex with v hv\n  rw [hv]\n  apply G.degree_lt_card_verts v\n\n"}
{"name":"SimpleGraph.card_commonNeighbors_le_degree_left","module":"Mathlib.Combinatorics.SimpleGraph.Finite","initialProofState":"V : Type u_1\nG : SimpleGraph V\ninstâœÂ¹ : Fintype V\ninstâœ : DecidableRel G.Adj\nv w : V\nâŠ¢ LE.le (Fintype.card â†‘(G.commonNeighbors v w)) (G.degree v)","decl":"theorem card_commonNeighbors_le_degree_left [DecidableRel G.Adj] (v w : V) :\n    Fintype.card (G.commonNeighbors v w) â‰¤ G.degree v := by\n  rw [â† card_neighborSet_eq_degree]\n  exact Set.card_le_card Set.inter_subset_left\n\n"}
{"name":"SimpleGraph.card_commonNeighbors_le_degree_right","module":"Mathlib.Combinatorics.SimpleGraph.Finite","initialProofState":"V : Type u_1\nG : SimpleGraph V\ninstâœÂ¹ : Fintype V\ninstâœ : DecidableRel G.Adj\nv w : V\nâŠ¢ LE.le (Fintype.card â†‘(G.commonNeighbors v w)) (G.degree w)","decl":"theorem card_commonNeighbors_le_degree_right [DecidableRel G.Adj] (v w : V) :\n    Fintype.card (G.commonNeighbors v w) â‰¤ G.degree w := by\n  simp_rw [commonNeighbors_symm _ v w, card_commonNeighbors_le_degree_left]\n\n"}
{"name":"SimpleGraph.card_commonNeighbors_lt_card_verts","module":"Mathlib.Combinatorics.SimpleGraph.Finite","initialProofState":"V : Type u_1\nG : SimpleGraph V\ninstâœÂ¹ : Fintype V\ninstâœ : DecidableRel G.Adj\nv w : V\nâŠ¢ LT.lt (Fintype.card â†‘(G.commonNeighbors v w)) (Fintype.card V)","decl":"theorem card_commonNeighbors_lt_card_verts [DecidableRel G.Adj] (v w : V) :\n    Fintype.card (G.commonNeighbors v w) < Fintype.card V :=\n  Nat.lt_of_le_of_lt (G.card_commonNeighbors_le_degree_left _ _) (G.degree_lt_card_verts v)\n\n"}
{"name":"SimpleGraph.Adj.card_commonNeighbors_lt_degree","module":"Mathlib.Combinatorics.SimpleGraph.Finite","initialProofState":"V : Type u_1\ninstâœÂ¹ : Fintype V\nG : SimpleGraph V\ninstâœ : DecidableRel G.Adj\nv w : V\nh : G.Adj v w\nâŠ¢ LT.lt (Fintype.card â†‘(G.commonNeighbors v w)) (G.degree v)","decl":"/-- If the condition `G.Adj v w` fails, then `card_commonNeighbors_le_degree` is\nthe best we can do in general. -/\ntheorem Adj.card_commonNeighbors_lt_degree {G : SimpleGraph V} [DecidableRel G.Adj] {v w : V}\n    (h : G.Adj v w) : Fintype.card (G.commonNeighbors v w) < G.degree v := by\n  classical\n  rw [â† Set.toFinset_card]\n  apply Finset.card_lt_card\n  rw [Finset.ssubset_iff]\n  use w\n  constructor\n  Â· rw [Set.mem_toFinset]\n    apply not_mem_commonNeighbors_right\n  Â· rw [Finset.insert_subset_iff]\n    constructor\n    Â· simpa\n    Â· rw [neighborFinset, Set.toFinset_subset_toFinset]\n      exact G.commonNeighbors_subset_neighborSet_left _ _\n\n"}
{"name":"SimpleGraph.card_commonNeighbors_top","module":"Mathlib.Combinatorics.SimpleGraph.Finite","initialProofState":"V : Type u_1\ninstâœÂ¹ : Fintype V\ninstâœ : DecidableEq V\nv w : V\nh : Ne v w\nâŠ¢ Eq (Fintype.card â†‘(Top.top.commonNeighbors v w)) (HSub.hSub (Fintype.card V) 2)","decl":"theorem card_commonNeighbors_top [DecidableEq V] {v w : V} (h : v â‰  w) :\n    Fintype.card ((âŠ¤ : SimpleGraph V).commonNeighbors v w) = Fintype.card V - 2 := by\n  simp only [commonNeighbors_top_eq, â† Set.toFinset_card, Set.toFinset_diff]\n  rw [Finset.card_sdiff]\n  Â· simp [Finset.card_univ, h]\n  Â· simp only [Set.toFinset_subset_toFinset, Set.subset_univ]\n\n"}
