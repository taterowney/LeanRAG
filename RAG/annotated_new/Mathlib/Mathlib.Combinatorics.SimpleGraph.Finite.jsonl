{"name":"SimpleGraph.coe_edgeFinset","module":"Mathlib.Combinatorics.SimpleGraph.Finite","initialProofState":"V : Type u_1\nG : SimpleGraph V\ninst✝ : Fintype ↑G.edgeSet\n⊢ Eq (↑G.edgeFinset) G.edgeSet","decl":"@[norm_cast]\ntheorem coe_edgeFinset : (G.edgeFinset : Set (Sym2 V)) = G.edgeSet :=\n  Set.coe_toFinset _\n\n"}
{"name":"SimpleGraph.mem_edgeFinset","module":"Mathlib.Combinatorics.SimpleGraph.Finite","initialProofState":"V : Type u_1\nG : SimpleGraph V\ne : Sym2 V\ninst✝ : Fintype ↑G.edgeSet\n⊢ Iff (Membership.mem G.edgeFinset e) (Membership.mem G.edgeSet e)","decl":"theorem mem_edgeFinset : e ∈ G.edgeFinset ↔ e ∈ G.edgeSet :=\n  Set.mem_toFinset\n\n"}
{"name":"SimpleGraph.not_isDiag_of_mem_edgeFinset","module":"Mathlib.Combinatorics.SimpleGraph.Finite","initialProofState":"V : Type u_1\nG : SimpleGraph V\ne : Sym2 V\ninst✝ : Fintype ↑G.edgeSet\na✝ : Membership.mem G.edgeFinset e\n⊢ Not e.IsDiag","decl":"theorem not_isDiag_of_mem_edgeFinset : e ∈ G.edgeFinset → ¬e.IsDiag :=\n  not_isDiag_of_mem_edgeSet _ ∘ mem_edgeFinset.1\n\n"}
{"name":"SimpleGraph.edgeFinset_inj","module":"Mathlib.Combinatorics.SimpleGraph.Finite","initialProofState":"V : Type u_1\nG₁ G₂ : SimpleGraph V\ninst✝¹ : Fintype ↑G₁.edgeSet\ninst✝ : Fintype ↑G₂.edgeSet\n⊢ Iff (Eq G₁.edgeFinset G₂.edgeFinset) (Eq G₁ G₂)","decl":"theorem edgeFinset_inj : G₁.edgeFinset = G₂.edgeFinset ↔ G₁ = G₂ := by simp\n\n"}
{"name":"SimpleGraph.edgeFinset_subset_edgeFinset","module":"Mathlib.Combinatorics.SimpleGraph.Finite","initialProofState":"V : Type u_1\nG₁ G₂ : SimpleGraph V\ninst✝¹ : Fintype ↑G₁.edgeSet\ninst✝ : Fintype ↑G₂.edgeSet\n⊢ Iff (HasSubset.Subset G₁.edgeFinset G₂.edgeFinset) (LE.le G₁ G₂)","decl":"theorem edgeFinset_subset_edgeFinset : G₁.edgeFinset ⊆ G₂.edgeFinset ↔ G₁ ≤ G₂ := by simp\n\n"}
{"name":"SimpleGraph.edgeFinset_ssubset_edgeFinset","module":"Mathlib.Combinatorics.SimpleGraph.Finite","initialProofState":"V : Type u_1\nG₁ G₂ : SimpleGraph V\ninst✝¹ : Fintype ↑G₁.edgeSet\ninst✝ : Fintype ↑G₂.edgeSet\n⊢ Iff (HasSSubset.SSubset G₁.edgeFinset G₂.edgeFinset) (LT.lt G₁ G₂)","decl":"theorem edgeFinset_ssubset_edgeFinset : G₁.edgeFinset ⊂ G₂.edgeFinset ↔ G₁ < G₂ := by simp\n\n"}
{"name":"SimpleGraph.edgeFinset_mono","module":"Mathlib.Combinatorics.SimpleGraph.Finite","initialProofState":"V : Type u_1\nG₁ G₂ : SimpleGraph V\ninst✝¹ : Fintype ↑G₁.edgeSet\ninst✝ : Fintype ↑G₂.edgeSet\na✝ : LE.le G₁ G₂\n⊢ HasSubset.Subset G₁.edgeFinset G₂.edgeFinset","decl":"@[gcongr] alias ⟨_, edgeFinset_mono⟩ := edgeFinset_subset_edgeFinset\n\n"}
{"name":"SimpleGraph.edgeFinset_strict_mono","module":"Mathlib.Combinatorics.SimpleGraph.Finite","initialProofState":"V : Type u_1\nG₁ G₂ : SimpleGraph V\ninst✝¹ : Fintype ↑G₁.edgeSet\ninst✝ : Fintype ↑G₂.edgeSet\na✝ : LT.lt G₁ G₂\n⊢ HasSSubset.SSubset G₁.edgeFinset G₂.edgeFinset","decl":"alias ⟨_, edgeFinset_strict_mono⟩ := edgeFinset_ssubset_edgeFinset\n\n"}
{"name":"SimpleGraph.edgeFinset_bot","module":"Mathlib.Combinatorics.SimpleGraph.Finite","initialProofState":"V : Type u_1\n⊢ Eq Bot.bot.edgeFinset EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem edgeFinset_bot : (⊥ : SimpleGraph V).edgeFinset = ∅ := by simp [edgeFinset]\n\n"}
{"name":"SimpleGraph.edgeFinset_sup","module":"Mathlib.Combinatorics.SimpleGraph.Finite","initialProofState":"V : Type u_1\nG₁ G₂ : SimpleGraph V\ninst✝³ : Fintype ↑G₁.edgeSet\ninst✝² : Fintype ↑G₂.edgeSet\ninst✝¹ : Fintype ↑(Max.max G₁ G₂).edgeSet\ninst✝ : DecidableEq V\n⊢ Eq (Max.max G₁ G₂).edgeFinset (Union.union G₁.edgeFinset G₂.edgeFinset)","decl":"@[simp]\ntheorem edgeFinset_sup [Fintype (edgeSet (G₁ ⊔ G₂))] [DecidableEq V] :\n    (G₁ ⊔ G₂).edgeFinset = G₁.edgeFinset ∪ G₂.edgeFinset := by simp [edgeFinset]\n\n"}
{"name":"SimpleGraph.edgeFinset_inf","module":"Mathlib.Combinatorics.SimpleGraph.Finite","initialProofState":"V : Type u_1\nG₁ G₂ : SimpleGraph V\ninst✝² : Fintype ↑G₁.edgeSet\ninst✝¹ : Fintype ↑G₂.edgeSet\ninst✝ : DecidableEq V\n⊢ Eq (Min.min G₁ G₂).edgeFinset (Inter.inter G₁.edgeFinset G₂.edgeFinset)","decl":"@[simp]\ntheorem edgeFinset_inf [DecidableEq V] : (G₁ ⊓ G₂).edgeFinset = G₁.edgeFinset ∩ G₂.edgeFinset := by\n  simp [edgeFinset]\n\n"}
{"name":"SimpleGraph.edgeFinset_sdiff","module":"Mathlib.Combinatorics.SimpleGraph.Finite","initialProofState":"V : Type u_1\nG₁ G₂ : SimpleGraph V\ninst✝² : Fintype ↑G₁.edgeSet\ninst✝¹ : Fintype ↑G₂.edgeSet\ninst✝ : DecidableEq V\n⊢ Eq (SDiff.sdiff G₁ G₂).edgeFinset (SDiff.sdiff G₁.edgeFinset G₂.edgeFinset)","decl":"@[simp]\ntheorem edgeFinset_sdiff [DecidableEq V] :\n    (G₁ \\ G₂).edgeFinset = G₁.edgeFinset \\ G₂.edgeFinset := by simp [edgeFinset]\n\n"}
{"name":"SimpleGraph.disjoint_edgeFinset","module":"Mathlib.Combinatorics.SimpleGraph.Finite","initialProofState":"V : Type u_1\nG₁ G₂ : SimpleGraph V\ninst✝¹ : Fintype ↑G₁.edgeSet\ninst✝ : Fintype ↑G₂.edgeSet\n⊢ Iff (Disjoint G₁.edgeFinset G₂.edgeFinset) (Disjoint G₁ G₂)","decl":"lemma disjoint_edgeFinset : Disjoint G₁.edgeFinset G₂.edgeFinset ↔ Disjoint G₁ G₂ := by\n  simp_rw [← Finset.disjoint_coe, coe_edgeFinset, disjoint_edgeSet]\n\n"}
{"name":"SimpleGraph.edgeFinset_eq_empty","module":"Mathlib.Combinatorics.SimpleGraph.Finite","initialProofState":"V : Type u_1\nG : SimpleGraph V\ninst✝ : Fintype ↑G.edgeSet\n⊢ Iff (Eq G.edgeFinset EmptyCollection.emptyCollection) (Eq G Bot.bot)","decl":"lemma edgeFinset_eq_empty : G.edgeFinset = ∅ ↔ G = ⊥ := by\n  rw [← edgeFinset_bot, edgeFinset_inj]\n\n"}
{"name":"SimpleGraph.edgeFinset_nonempty","module":"Mathlib.Combinatorics.SimpleGraph.Finite","initialProofState":"V : Type u_1\nG : SimpleGraph V\ninst✝ : Fintype ↑G.edgeSet\n⊢ Iff G.edgeFinset.Nonempty (Ne G Bot.bot)","decl":"lemma edgeFinset_nonempty : G.edgeFinset.Nonempty ↔ G ≠ ⊥ := by\n  rw [Finset.nonempty_iff_ne_empty, edgeFinset_eq_empty.ne]\n\n"}
{"name":"SimpleGraph.edgeFinset_card","module":"Mathlib.Combinatorics.SimpleGraph.Finite","initialProofState":"V : Type u_1\nG : SimpleGraph V\ninst✝ : Fintype ↑G.edgeSet\n⊢ Eq G.edgeFinset.card (Fintype.card ↑G.edgeSet)","decl":"theorem edgeFinset_card : #G.edgeFinset = Fintype.card G.edgeSet :=\n  Set.toFinset_card _\n\n"}
{"name":"SimpleGraph.edgeSet_univ_card","module":"Mathlib.Combinatorics.SimpleGraph.Finite","initialProofState":"V : Type u_1\nG : SimpleGraph V\ninst✝ : Fintype ↑G.edgeSet\n⊢ Eq Finset.univ.card G.edgeFinset.card","decl":"@[simp]\ntheorem edgeSet_univ_card : #(univ : Finset G.edgeSet) = #G.edgeFinset :=\n  Fintype.card_of_subtype G.edgeFinset fun _ => mem_edgeFinset\n\n"}
{"name":"SimpleGraph.edgeFinset_top","module":"Mathlib.Combinatorics.SimpleGraph.Finite","initialProofState":"V : Type u_1\ninst✝¹ : Fintype V\ninst✝ : DecidableEq V\n⊢ Eq Top.top.edgeFinset (Finset.filter (fun e => Not e.IsDiag) Finset.univ)","decl":"@[simp]\ntheorem edgeFinset_top [DecidableEq V] :\n    (⊤ : SimpleGraph V).edgeFinset = ({e | ¬e.IsDiag} : Finset _) := by simp [← coe_inj]\n\n"}
{"name":"SimpleGraph.card_edgeFinset_top_eq_card_choose_two","module":"Mathlib.Combinatorics.SimpleGraph.Finite","initialProofState":"V : Type u_1\ninst✝¹ : Fintype V\ninst✝ : DecidableEq V\n⊢ Eq Top.top.edgeFinset.card ((Fintype.card V).choose 2)","decl":"/-- The complete graph on `n` vertices has `n.choose 2` edges. -/\ntheorem card_edgeFinset_top_eq_card_choose_two [DecidableEq V] :\n    #(⊤ : SimpleGraph V).edgeFinset = (Fintype.card V).choose 2 := by\n  simp_rw [Set.toFinset_card, edgeSet_top, Set.coe_setOf, ← Sym2.card_subtype_not_diag]\n\n"}
{"name":"SimpleGraph.card_edgeFinset_le_card_choose_two","module":"Mathlib.Combinatorics.SimpleGraph.Finite","initialProofState":"V : Type u_1\nG : SimpleGraph V\ninst✝¹ : Fintype ↑G.edgeSet\ninst✝ : Fintype V\n⊢ LE.le G.edgeFinset.card ((Fintype.card V).choose 2)","decl":"/-- Any graph on `n` vertices has at most `n.choose 2` edges. -/\ntheorem card_edgeFinset_le_card_choose_two : #G.edgeFinset ≤ (Fintype.card V).choose 2 := by\n  classical\n  rw [← card_edgeFinset_top_eq_card_choose_two]\n  exact card_le_card (edgeFinset_mono le_top)\n\n"}
{"name":"SimpleGraph.edgeFinset_deleteEdges","module":"Mathlib.Combinatorics.SimpleGraph.Finite","initialProofState":"V : Type u_1\nG : SimpleGraph V\ninst✝² : DecidableEq V\ninst✝¹ : Fintype ↑G.edgeSet\ns : Finset (Sym2 V)\ninst✝ : Fintype ↑(G.deleteEdges ↑s).edgeSet\n⊢ Eq (G.deleteEdges ↑s).edgeFinset (SDiff.sdiff G.edgeFinset s)","decl":"theorem edgeFinset_deleteEdges [DecidableEq V] [Fintype G.edgeSet] (s : Finset (Sym2 V))\n    [Fintype (G.deleteEdges s).edgeSet] :\n    (G.deleteEdges s).edgeFinset = G.edgeFinset \\ s := by\n  ext e\n  simp [edgeSet_deleteEdges]\n\n"}
{"name":"SimpleGraph.deleteFar_iff","module":"Mathlib.Combinatorics.SimpleGraph.Finite","initialProofState":"V : Type u_1\nG : SimpleGraph V\n𝕜 : Type u_2\ninst✝² : OrderedRing 𝕜\ninst✝¹ : Fintype ↑G.edgeSet\np : SimpleGraph V → Prop\nr : 𝕜\ninst✝ : Fintype (Sym2 V)\n⊢ Iff (G.DeleteFar p r) (∀ ⦃H : SimpleGraph V⦄ [inst : DecidableRel H.Adj], LE.le H G → p H → LE.le r (HSub.hSub ↑G.edgeFinset.card ↑H.edgeFinset.card))","decl":"theorem deleteFar_iff [Fintype (Sym2 V)] :\n    G.DeleteFar p r ↔ ∀ ⦃H : SimpleGraph _⦄ [DecidableRel H.Adj],\n      H ≤ G → p H → r ≤ #G.edgeFinset - #H.edgeFinset := by\n  classical\n  refine ⟨fun h H _ hHG hH ↦ ?_, fun h s hs hG ↦ ?_⟩\n  · have := h (sdiff_subset (t := H.edgeFinset))\n    simp only [deleteEdges_sdiff_eq_of_le hHG, edgeFinset_mono hHG, card_sdiff,\n      card_le_card, coe_sdiff, coe_edgeFinset, Nat.cast_sub] at this\n    exact this hH\n  · classical\n    simpa [card_sdiff hs, edgeFinset_deleteEdges, -Set.toFinset_card, Nat.cast_sub,\n      card_le_card hs] using h (G.deleteEdges_le s) hG\n\n"}
{"name":"SimpleGraph.DeleteFar.le_card_sub_card","module":"Mathlib.Combinatorics.SimpleGraph.Finite","initialProofState":"V : Type u_1\nG : SimpleGraph V\n𝕜 : Type u_2\ninst✝³ : OrderedRing 𝕜\ninst✝² : Fintype ↑G.edgeSet\np : SimpleGraph V → Prop\nr : 𝕜\ninst✝¹ : Fintype (Sym2 V)\na✝² : G.DeleteFar p r\nH : SimpleGraph V\ninst✝ : DecidableRel H.Adj\na✝¹ : LE.le H G\na✝ : p H\n⊢ LE.le r (HSub.hSub ↑G.edgeFinset.card ↑H.edgeFinset.card)","decl":"alias ⟨DeleteFar.le_card_sub_card, _⟩ := deleteFar_iff\n\n"}
{"name":"SimpleGraph.DeleteFar.mono","module":"Mathlib.Combinatorics.SimpleGraph.Finite","initialProofState":"V : Type u_1\nG : SimpleGraph V\n𝕜 : Type u_2\ninst✝¹ : OrderedRing 𝕜\ninst✝ : Fintype ↑G.edgeSet\np : SimpleGraph V → Prop\nr₁ r₂ : 𝕜\nh : G.DeleteFar p r₂\nhr : LE.le r₁ r₂\n⊢ G.DeleteFar p r₁","decl":"theorem DeleteFar.mono (h : G.DeleteFar p r₂) (hr : r₁ ≤ r₂) : G.DeleteFar p r₁ := fun _ hs hG =>\n  hr.trans <| h hs hG\n\n"}
{"name":"SimpleGraph.neighborFinset_def","module":"Mathlib.Combinatorics.SimpleGraph.Finite","initialProofState":"V : Type u_1\nG : SimpleGraph V\nv : V\ninst✝ : Fintype ↑(G.neighborSet v)\n⊢ Eq (G.neighborFinset v) (G.neighborSet v).toFinset","decl":"theorem neighborFinset_def : G.neighborFinset v = (G.neighborSet v).toFinset :=\n  rfl\n\n"}
{"name":"SimpleGraph.mem_neighborFinset","module":"Mathlib.Combinatorics.SimpleGraph.Finite","initialProofState":"V : Type u_1\nG : SimpleGraph V\nv : V\ninst✝ : Fintype ↑(G.neighborSet v)\nw : V\n⊢ Iff (Membership.mem (G.neighborFinset v) w) (G.Adj v w)","decl":"@[simp]\ntheorem mem_neighborFinset (w : V) : w ∈ G.neighborFinset v ↔ G.Adj v w :=\n  Set.mem_toFinset\n\n"}
{"name":"SimpleGraph.not_mem_neighborFinset_self","module":"Mathlib.Combinatorics.SimpleGraph.Finite","initialProofState":"V : Type u_1\nG : SimpleGraph V\nv : V\ninst✝ : Fintype ↑(G.neighborSet v)\n⊢ Not (Membership.mem (G.neighborFinset v) v)","decl":"theorem not_mem_neighborFinset_self : v ∉ G.neighborFinset v := by simp\n\n"}
{"name":"SimpleGraph.neighborFinset_disjoint_singleton","module":"Mathlib.Combinatorics.SimpleGraph.Finite","initialProofState":"V : Type u_1\nG : SimpleGraph V\nv : V\ninst✝ : Fintype ↑(G.neighborSet v)\n⊢ Disjoint (G.neighborFinset v) (Singleton.singleton v)","decl":"theorem neighborFinset_disjoint_singleton : Disjoint (G.neighborFinset v) {v} :=\n  Finset.disjoint_singleton_right.mpr <| not_mem_neighborFinset_self _ _\n\n"}
{"name":"SimpleGraph.singleton_disjoint_neighborFinset","module":"Mathlib.Combinatorics.SimpleGraph.Finite","initialProofState":"V : Type u_1\nG : SimpleGraph V\nv : V\ninst✝ : Fintype ↑(G.neighborSet v)\n⊢ Disjoint (Singleton.singleton v) (G.neighborFinset v)","decl":"theorem singleton_disjoint_neighborFinset : Disjoint {v} (G.neighborFinset v) :=\n  Finset.disjoint_singleton_left.mpr <| not_mem_neighborFinset_self _ _\n\n"}
{"name":"SimpleGraph.card_neighborFinset_eq_degree","module":"Mathlib.Combinatorics.SimpleGraph.Finite","initialProofState":"V : Type u_1\nG : SimpleGraph V\nv : V\ninst✝ : Fintype ↑(G.neighborSet v)\n⊢ Eq (G.neighborFinset v).card (G.degree v)","decl":"@[simp]\ntheorem card_neighborFinset_eq_degree : #(G.neighborFinset v) = G.degree v := rfl\n\n"}
{"name":"SimpleGraph.card_neighborSet_eq_degree","module":"Mathlib.Combinatorics.SimpleGraph.Finite","initialProofState":"V : Type u_1\nG : SimpleGraph V\nv : V\ninst✝ : Fintype ↑(G.neighborSet v)\n⊢ Eq (Fintype.card ↑(G.neighborSet v)) (G.degree v)","decl":"@[simp]\ntheorem card_neighborSet_eq_degree : Fintype.card (G.neighborSet v) = G.degree v :=\n  (Set.toFinset_card _).symm\n\n"}
{"name":"SimpleGraph.degree_pos_iff_exists_adj","module":"Mathlib.Combinatorics.SimpleGraph.Finite","initialProofState":"V : Type u_1\nG : SimpleGraph V\nv : V\ninst✝ : Fintype ↑(G.neighborSet v)\n⊢ Iff (LT.lt 0 (G.degree v)) (Exists fun w => G.Adj v w)","decl":"theorem degree_pos_iff_exists_adj : 0 < G.degree v ↔ ∃ w, G.Adj v w := by\n  simp only [degree, card_pos, Finset.Nonempty, mem_neighborFinset]\n\n"}
{"name":"SimpleGraph.degree_compl","module":"Mathlib.Combinatorics.SimpleGraph.Finite","initialProofState":"V : Type u_1\nG : SimpleGraph V\nv : V\ninst✝² : Fintype ↑(G.neighborSet v)\ninst✝¹ : Fintype ↑((HasCompl.compl G).neighborSet v)\ninst✝ : Fintype V\n⊢ Eq ((HasCompl.compl G).degree v) (HSub.hSub (HSub.hSub (Fintype.card V) 1) (G.degree v))","decl":"theorem degree_compl [Fintype (Gᶜ.neighborSet v)] [Fintype V] :\n    Gᶜ.degree v = Fintype.card V - 1 - G.degree v := by\n  classical\n    rw [← card_neighborSet_union_compl_neighborSet G v, Set.toFinset_union]\n    simp [card_union_of_disjoint (Set.disjoint_toFinset.mpr (compl_neighborSet_disjoint G v))]\n\n"}
{"name":"SimpleGraph.card_incidenceSet_eq_degree","module":"Mathlib.Combinatorics.SimpleGraph.Finite","initialProofState":"V : Type u_1\nG : SimpleGraph V\nv : V\ninst✝¹ : Fintype ↑(G.neighborSet v)\ninst✝ : DecidableEq V\n⊢ Eq (Fintype.card ↑(G.incidenceSet v)) (G.degree v)","decl":"@[simp]\ntheorem card_incidenceSet_eq_degree [DecidableEq V] :\n    Fintype.card (G.incidenceSet v) = G.degree v := by\n  rw [Fintype.card_congr (G.incidenceSetEquivNeighborSet v)]\n  simp\n\n"}
{"name":"SimpleGraph.card_incidenceFinset_eq_degree","module":"Mathlib.Combinatorics.SimpleGraph.Finite","initialProofState":"V : Type u_1\nG : SimpleGraph V\nv : V\ninst✝¹ : Fintype ↑(G.neighborSet v)\ninst✝ : DecidableEq V\n⊢ Eq (G.incidenceFinset v).card (G.degree v)","decl":"@[simp]\ntheorem card_incidenceFinset_eq_degree [DecidableEq V] : #(G.incidenceFinset v) = G.degree v := by\n  rw [← G.card_incidenceSet_eq_degree]\n  apply Set.toFinset_card\n\n"}
{"name":"SimpleGraph.mem_incidenceFinset","module":"Mathlib.Combinatorics.SimpleGraph.Finite","initialProofState":"V : Type u_1\nG : SimpleGraph V\nv : V\ninst✝¹ : Fintype ↑(G.neighborSet v)\ninst✝ : DecidableEq V\ne : Sym2 V\n⊢ Iff (Membership.mem (G.incidenceFinset v) e) (Membership.mem (G.incidenceSet v) e)","decl":"@[simp]\ntheorem mem_incidenceFinset [DecidableEq V] (e : Sym2 V) :\n    e ∈ G.incidenceFinset v ↔ e ∈ G.incidenceSet v :=\n  Set.mem_toFinset\n\n"}
{"name":"SimpleGraph.incidenceFinset_eq_filter","module":"Mathlib.Combinatorics.SimpleGraph.Finite","initialProofState":"V : Type u_1\nG : SimpleGraph V\nv : V\ninst✝² : Fintype ↑(G.neighborSet v)\ninst✝¹ : DecidableEq V\ninst✝ : Fintype ↑G.edgeSet\n⊢ Eq (G.incidenceFinset v) (Finset.filter (fun e => Membership.mem e v) G.edgeFinset)","decl":"theorem incidenceFinset_eq_filter [DecidableEq V] [Fintype G.edgeSet] :\n    G.incidenceFinset v = {e ∈ G.edgeFinset | v ∈ e} := by\n  ext e\n  induction e\n  simp [mk'_mem_incidenceSet_iff]\n\n"}
{"name":"SimpleGraph.IsRegularOfDegree.degree_eq","module":"Mathlib.Combinatorics.SimpleGraph.Finite","initialProofState":"V : Type u_1\nG : SimpleGraph V\ninst✝ : G.LocallyFinite\nd : Nat\nh : G.IsRegularOfDegree d\nv : V\n⊢ Eq (G.degree v) d","decl":"theorem IsRegularOfDegree.degree_eq {d : ℕ} (h : G.IsRegularOfDegree d) (v : V) : G.degree v = d :=\n  h v\n\n"}
{"name":"SimpleGraph.IsRegularOfDegree.compl","module":"Mathlib.Combinatorics.SimpleGraph.Finite","initialProofState":"V : Type u_1\ninst✝² : Fintype V\ninst✝¹ : DecidableEq V\nG : SimpleGraph V\ninst✝ : DecidableRel G.Adj\nk : Nat\nh : G.IsRegularOfDegree k\n⊢ (HasCompl.compl G).IsRegularOfDegree (HSub.hSub (HSub.hSub (Fintype.card V) 1) k)","decl":"theorem IsRegularOfDegree.compl [Fintype V] [DecidableEq V] {G : SimpleGraph V} [DecidableRel G.Adj]\n    {k : ℕ} (h : G.IsRegularOfDegree k) : Gᶜ.IsRegularOfDegree (Fintype.card V - 1 - k) := by\n  intro v\n  rw [degree_compl, h v]\n\n"}
{"name":"SimpleGraph.neighborFinset_eq_filter","module":"Mathlib.Combinatorics.SimpleGraph.Finite","initialProofState":"V : Type u_1\nG : SimpleGraph V\ninst✝¹ : Fintype V\nv : V\ninst✝ : DecidableRel G.Adj\n⊢ Eq (G.neighborFinset v) (Finset.filter (fun w => G.Adj v w) Finset.univ)","decl":"theorem neighborFinset_eq_filter {v : V} [DecidableRel G.Adj] :\n    G.neighborFinset v = ({w | G.Adj v w} : Finset _) := by ext; simp\n\n"}
{"name":"SimpleGraph.neighborFinset_compl","module":"Mathlib.Combinatorics.SimpleGraph.Finite","initialProofState":"V : Type u_1\nG : SimpleGraph V\ninst✝² : Fintype V\ninst✝¹ : DecidableEq V\ninst✝ : DecidableRel G.Adj\nv : V\n⊢ Eq ((HasCompl.compl G).neighborFinset v) (SDiff.sdiff (HasCompl.compl (G.neighborFinset v)) (Singleton.singleton v))","decl":"theorem neighborFinset_compl [DecidableEq V] [DecidableRel G.Adj] (v : V) :\n    Gᶜ.neighborFinset v = (G.neighborFinset v)ᶜ \\ {v} := by\n  simp only [neighborFinset, neighborSet_compl, Set.toFinset_diff, Set.toFinset_compl,\n    Set.toFinset_singleton]\n\n"}
{"name":"SimpleGraph.complete_graph_degree","module":"Mathlib.Combinatorics.SimpleGraph.Finite","initialProofState":"V : Type u_1\ninst✝¹ : Fintype V\ninst✝ : DecidableEq V\nv : V\n⊢ Eq (Top.top.degree v) (HSub.hSub (Fintype.card V) 1)","decl":"@[simp]\ntheorem complete_graph_degree [DecidableEq V] (v : V) :\n    (⊤ : SimpleGraph V).degree v = Fintype.card V - 1 := by\n  erw [degree, neighborFinset_eq_filter, filter_ne, card_erase_of_mem (mem_univ v), card_univ]\n\n"}
{"name":"SimpleGraph.bot_degree","module":"Mathlib.Combinatorics.SimpleGraph.Finite","initialProofState":"V : Type u_1\ninst✝ : Fintype V\nv : V\n⊢ Eq (Bot.bot.degree v) 0","decl":"theorem bot_degree (v : V) : (⊥ : SimpleGraph V).degree v = 0 := by\n  erw [degree, neighborFinset_eq_filter, filter_False]\n  exact Finset.card_empty\n\n"}
{"name":"SimpleGraph.IsRegularOfDegree.top","module":"Mathlib.Combinatorics.SimpleGraph.Finite","initialProofState":"V : Type u_1\ninst✝¹ : Fintype V\ninst✝ : DecidableEq V\n⊢ Top.top.IsRegularOfDegree (HSub.hSub (Fintype.card V) 1)","decl":"theorem IsRegularOfDegree.top [DecidableEq V] :\n    (⊤ : SimpleGraph V).IsRegularOfDegree (Fintype.card V - 1) := by\n  intro v\n  simp\n\n"}
{"name":"SimpleGraph.exists_minimal_degree_vertex","module":"Mathlib.Combinatorics.SimpleGraph.Finite","initialProofState":"V : Type u_1\nG : SimpleGraph V\ninst✝² : Fintype V\ninst✝¹ : DecidableRel G.Adj\ninst✝ : Nonempty V\n⊢ Exists fun v => Eq G.minDegree (G.degree v)","decl":"/-- There exists a vertex of minimal degree. Note the assumption of being nonempty is necessary, as\nthe lemma implies there exists a vertex. -/\ntheorem exists_minimal_degree_vertex [DecidableRel G.Adj] [Nonempty V] :\n    ∃ v, G.minDegree = G.degree v := by\n  obtain ⟨t, ht : _ = _⟩ := min_of_nonempty (univ_nonempty.image fun v => G.degree v)\n  obtain ⟨v, _, rfl⟩ := mem_image.mp (mem_of_min ht)\n  exact ⟨v, by simp [minDegree, ht]⟩\n\n"}
{"name":"SimpleGraph.minDegree_le_degree","module":"Mathlib.Combinatorics.SimpleGraph.Finite","initialProofState":"V : Type u_1\nG : SimpleGraph V\ninst✝¹ : Fintype V\ninst✝ : DecidableRel G.Adj\nv : V\n⊢ LE.le G.minDegree (G.degree v)","decl":"/-- The minimum degree in the graph is at most the degree of any particular vertex. -/\ntheorem minDegree_le_degree [DecidableRel G.Adj] (v : V) : G.minDegree ≤ G.degree v := by\n  obtain ⟨t, ht⟩ := Finset.min_of_mem (mem_image_of_mem (fun v => G.degree v) (mem_univ v))\n  have := Finset.min_le_of_eq (mem_image_of_mem _ (mem_univ v)) ht\n  rwa [minDegree, ht]\n\n"}
{"name":"SimpleGraph.le_minDegree_of_forall_le_degree","module":"Mathlib.Combinatorics.SimpleGraph.Finite","initialProofState":"V : Type u_1\nG : SimpleGraph V\ninst✝² : Fintype V\ninst✝¹ : DecidableRel G.Adj\ninst✝ : Nonempty V\nk : Nat\nh : ∀ (v : V), LE.le k (G.degree v)\n⊢ LE.le k G.minDegree","decl":"/-- In a nonempty graph, if `k` is at most the degree of every vertex, it is at most the minimum\ndegree. Note the assumption that the graph is nonempty is necessary as long as `G.minDegree` is\ndefined to be a natural. -/\ntheorem le_minDegree_of_forall_le_degree [DecidableRel G.Adj] [Nonempty V] (k : ℕ)\n    (h : ∀ v, k ≤ G.degree v) : k ≤ G.minDegree := by\n  rcases G.exists_minimal_degree_vertex with ⟨v, hv⟩\n  rw [hv]\n  apply h\n\n"}
{"name":"SimpleGraph.exists_maximal_degree_vertex","module":"Mathlib.Combinatorics.SimpleGraph.Finite","initialProofState":"V : Type u_1\nG : SimpleGraph V\ninst✝² : Fintype V\ninst✝¹ : DecidableRel G.Adj\ninst✝ : Nonempty V\n⊢ Exists fun v => Eq G.maxDegree (G.degree v)","decl":"/-- There exists a vertex of maximal degree. Note the assumption of being nonempty is necessary, as\nthe lemma implies there exists a vertex. -/\ntheorem exists_maximal_degree_vertex [DecidableRel G.Adj] [Nonempty V] :\n    ∃ v, G.maxDegree = G.degree v := by\n  obtain ⟨t, ht⟩ := max_of_nonempty (univ_nonempty.image fun v => G.degree v)\n  have ht₂ := mem_of_max ht\n  simp only [mem_image, mem_univ, exists_prop_of_true] at ht₂\n  rcases ht₂ with ⟨v, _, rfl⟩\n  refine ⟨v, ?_⟩\n  rw [maxDegree, ht]\n  rfl\n\n"}
{"name":"SimpleGraph.degree_le_maxDegree","module":"Mathlib.Combinatorics.SimpleGraph.Finite","initialProofState":"V : Type u_1\nG : SimpleGraph V\ninst✝¹ : Fintype V\ninst✝ : DecidableRel G.Adj\nv : V\n⊢ LE.le (G.degree v) G.maxDegree","decl":"/-- The maximum degree in the graph is at least the degree of any particular vertex. -/\ntheorem degree_le_maxDegree [DecidableRel G.Adj] (v : V) : G.degree v ≤ G.maxDegree := by\n  obtain ⟨t, ht : _ = _⟩ := Finset.max_of_mem (mem_image_of_mem (fun v => G.degree v) (mem_univ v))\n  have := Finset.le_max_of_eq (mem_image_of_mem _ (mem_univ v)) ht\n  rwa [maxDegree, ht]\n\n"}
{"name":"SimpleGraph.maxDegree_le_of_forall_degree_le","module":"Mathlib.Combinatorics.SimpleGraph.Finite","initialProofState":"V : Type u_1\nG : SimpleGraph V\ninst✝¹ : Fintype V\ninst✝ : DecidableRel G.Adj\nk : Nat\nh : ∀ (v : V), LE.le (G.degree v) k\n⊢ LE.le G.maxDegree k","decl":"/-- In a graph, if `k` is at least the degree of every vertex, then it is at least the maximum\ndegree. -/\ntheorem maxDegree_le_of_forall_degree_le [DecidableRel G.Adj] (k : ℕ) (h : ∀ v, G.degree v ≤ k) :\n    G.maxDegree ≤ k := by\n  by_cases hV : (univ : Finset V).Nonempty\n  · haveI : Nonempty V := univ_nonempty_iff.mp hV\n    obtain ⟨v, hv⟩ := G.exists_maximal_degree_vertex\n    rw [hv]\n    apply h\n  · rw [not_nonempty_iff_eq_empty] at hV\n    rw [maxDegree, hV, image_empty]\n    exact k.zero_le\n\n"}
{"name":"SimpleGraph.degree_lt_card_verts","module":"Mathlib.Combinatorics.SimpleGraph.Finite","initialProofState":"V : Type u_1\nG : SimpleGraph V\ninst✝¹ : Fintype V\ninst✝ : DecidableRel G.Adj\nv : V\n⊢ LT.lt (G.degree v) (Fintype.card V)","decl":"theorem degree_lt_card_verts [DecidableRel G.Adj] (v : V) : G.degree v < Fintype.card V := by\n  classical\n  apply Finset.card_lt_card\n  rw [Finset.ssubset_iff]\n  exact ⟨v, by simp, Finset.subset_univ _⟩\n\n"}
{"name":"SimpleGraph.maxDegree_lt_card_verts","module":"Mathlib.Combinatorics.SimpleGraph.Finite","initialProofState":"V : Type u_1\nG : SimpleGraph V\ninst✝² : Fintype V\ninst✝¹ : DecidableRel G.Adj\ninst✝ : Nonempty V\n⊢ LT.lt G.maxDegree (Fintype.card V)","decl":"/--\nThe maximum degree of a nonempty graph is less than the number of vertices. Note that the assumption\nthat `V` is nonempty is necessary, as otherwise this would assert the existence of a\nnatural number less than zero. -/\ntheorem maxDegree_lt_card_verts [DecidableRel G.Adj] [Nonempty V] :\n    G.maxDegree < Fintype.card V := by\n  cases' G.exists_maximal_degree_vertex with v hv\n  rw [hv]\n  apply G.degree_lt_card_verts v\n\n"}
{"name":"SimpleGraph.card_commonNeighbors_le_degree_left","module":"Mathlib.Combinatorics.SimpleGraph.Finite","initialProofState":"V : Type u_1\nG : SimpleGraph V\ninst✝¹ : Fintype V\ninst✝ : DecidableRel G.Adj\nv w : V\n⊢ LE.le (Fintype.card ↑(G.commonNeighbors v w)) (G.degree v)","decl":"theorem card_commonNeighbors_le_degree_left [DecidableRel G.Adj] (v w : V) :\n    Fintype.card (G.commonNeighbors v w) ≤ G.degree v := by\n  rw [← card_neighborSet_eq_degree]\n  exact Set.card_le_card Set.inter_subset_left\n\n"}
{"name":"SimpleGraph.card_commonNeighbors_le_degree_right","module":"Mathlib.Combinatorics.SimpleGraph.Finite","initialProofState":"V : Type u_1\nG : SimpleGraph V\ninst✝¹ : Fintype V\ninst✝ : DecidableRel G.Adj\nv w : V\n⊢ LE.le (Fintype.card ↑(G.commonNeighbors v w)) (G.degree w)","decl":"theorem card_commonNeighbors_le_degree_right [DecidableRel G.Adj] (v w : V) :\n    Fintype.card (G.commonNeighbors v w) ≤ G.degree w := by\n  simp_rw [commonNeighbors_symm _ v w, card_commonNeighbors_le_degree_left]\n\n"}
{"name":"SimpleGraph.card_commonNeighbors_lt_card_verts","module":"Mathlib.Combinatorics.SimpleGraph.Finite","initialProofState":"V : Type u_1\nG : SimpleGraph V\ninst✝¹ : Fintype V\ninst✝ : DecidableRel G.Adj\nv w : V\n⊢ LT.lt (Fintype.card ↑(G.commonNeighbors v w)) (Fintype.card V)","decl":"theorem card_commonNeighbors_lt_card_verts [DecidableRel G.Adj] (v w : V) :\n    Fintype.card (G.commonNeighbors v w) < Fintype.card V :=\n  Nat.lt_of_le_of_lt (G.card_commonNeighbors_le_degree_left _ _) (G.degree_lt_card_verts v)\n\n"}
{"name":"SimpleGraph.Adj.card_commonNeighbors_lt_degree","module":"Mathlib.Combinatorics.SimpleGraph.Finite","initialProofState":"V : Type u_1\ninst✝¹ : Fintype V\nG : SimpleGraph V\ninst✝ : DecidableRel G.Adj\nv w : V\nh : G.Adj v w\n⊢ LT.lt (Fintype.card ↑(G.commonNeighbors v w)) (G.degree v)","decl":"/-- If the condition `G.Adj v w` fails, then `card_commonNeighbors_le_degree` is\nthe best we can do in general. -/\ntheorem Adj.card_commonNeighbors_lt_degree {G : SimpleGraph V} [DecidableRel G.Adj] {v w : V}\n    (h : G.Adj v w) : Fintype.card (G.commonNeighbors v w) < G.degree v := by\n  classical\n  rw [← Set.toFinset_card]\n  apply Finset.card_lt_card\n  rw [Finset.ssubset_iff]\n  use w\n  constructor\n  · rw [Set.mem_toFinset]\n    apply not_mem_commonNeighbors_right\n  · rw [Finset.insert_subset_iff]\n    constructor\n    · simpa\n    · rw [neighborFinset, Set.toFinset_subset_toFinset]\n      exact G.commonNeighbors_subset_neighborSet_left _ _\n\n"}
{"name":"SimpleGraph.card_commonNeighbors_top","module":"Mathlib.Combinatorics.SimpleGraph.Finite","initialProofState":"V : Type u_1\ninst✝¹ : Fintype V\ninst✝ : DecidableEq V\nv w : V\nh : Ne v w\n⊢ Eq (Fintype.card ↑(Top.top.commonNeighbors v w)) (HSub.hSub (Fintype.card V) 2)","decl":"theorem card_commonNeighbors_top [DecidableEq V] {v w : V} (h : v ≠ w) :\n    Fintype.card ((⊤ : SimpleGraph V).commonNeighbors v w) = Fintype.card V - 2 := by\n  simp only [commonNeighbors_top_eq, ← Set.toFinset_card, Set.toFinset_diff]\n  rw [Finset.card_sdiff]\n  · simp [Finset.card_univ, h]\n  · simp only [Set.toFinset_subset_toFinset, Set.subset_univ]\n\n"}
