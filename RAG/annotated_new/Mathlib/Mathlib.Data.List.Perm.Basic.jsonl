{"name":"List.perm_rfl","module":"Mathlib.Data.List.Perm.Basic","initialProofState":"α : Type u_1\nl : List α\n⊢ l.Perm l","decl":"lemma perm_rfl : l ~ l := Perm.refl _\n\n"}
{"name":"List.Perm.subset_congr_left","module":"Mathlib.Data.List.Perm.Basic","initialProofState":"α : Type u_1\nl₁ l₂ l₃ : List α\nh : l₁.Perm l₂\n⊢ Iff (HasSubset.Subset l₁ l₃) (HasSubset.Subset l₂ l₃)","decl":"theorem Perm.subset_congr_left {l₁ l₂ l₃ : List α} (h : l₁ ~ l₂) : l₁ ⊆ l₃ ↔ l₂ ⊆ l₃ :=\n  ⟨h.symm.subset.trans, h.subset.trans⟩\n\n"}
{"name":"List.Perm.subset_congr_right","module":"Mathlib.Data.List.Perm.Basic","initialProofState":"α : Type u_1\nl₁ l₂ l₃ : List α\nh : l₁.Perm l₂\n⊢ Iff (HasSubset.Subset l₃ l₁) (HasSubset.Subset l₃ l₂)","decl":"theorem Perm.subset_congr_right {l₁ l₂ l₃ : List α} (h : l₁ ~ l₂) : l₃ ⊆ l₁ ↔ l₃ ⊆ l₂ :=\n  ⟨fun h' => h'.trans h.subset, fun h' => h'.trans h.symm.subset⟩\n\n"}
{"name":"List.perm_comp_perm","module":"Mathlib.Data.List.Perm.Basic","initialProofState":"α : Type u_1\n⊢ Eq (Relation.Comp List.Perm List.Perm) List.Perm","decl":"theorem perm_comp_perm : (Perm ∘r Perm : List α → List α → Prop) = Perm := by\n  funext a c; apply propext\n  constructor\n  · exact fun ⟨b, hab, hba⟩ => Perm.trans hab hba\n  · exact fun h => ⟨a, Perm.refl a, h⟩\n\n"}
{"name":"List.perm_comp_forall₂","module":"Mathlib.Data.List.Perm.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → β → Prop\nl u : List α\nv : List β\nhlu : l.Perm u\nhuv : List.Forall₂ r u v\n⊢ Relation.Comp (List.Forall₂ r) List.Perm l v","decl":"theorem perm_comp_forall₂ {l u v} (hlu : Perm l u) (huv : Forall₂ r u v) :\n    (Forall₂ r ∘r Perm) l v := by\n  induction hlu generalizing v with\n  | nil => cases huv; exact ⟨[], Forall₂.nil, Perm.nil⟩\n  | cons u _hlu ih =>\n    cases' huv with _ b _ v hab huv'\n    rcases ih huv' with ⟨l₂, h₁₂, h₂₃⟩\n    exact ⟨b :: l₂, Forall₂.cons hab h₁₂, h₂₃.cons _⟩\n  | swap a₁ a₂ h₂₃ =>\n    cases' huv with _ b₁ _ l₂ h₁ hr₂₃\n    cases' hr₂₃ with _ b₂ _ l₂ h₂ h₁₂\n    exact ⟨b₂ :: b₁ :: l₂, Forall₂.cons h₂ (Forall₂.cons h₁ h₁₂), Perm.swap _ _ _⟩\n  | trans _ _ ih₁ ih₂ =>\n    rcases ih₂ huv with ⟨lb₂, hab₂, h₂₃⟩\n    rcases ih₁ hab₂ with ⟨lb₁, hab₁, h₁₂⟩\n    exact ⟨lb₁, hab₁, Perm.trans h₁₂ h₂₃⟩\n\n"}
{"name":"List.forall₂_comp_perm_eq_perm_comp_forall₂","module":"Mathlib.Data.List.Perm.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → β → Prop\n⊢ Eq (Relation.Comp (List.Forall₂ r) List.Perm) (Relation.Comp List.Perm (List.Forall₂ r))","decl":"theorem forall₂_comp_perm_eq_perm_comp_forall₂ : Forall₂ r ∘r Perm = Perm ∘r Forall₂ r := by\n  funext l₁ l₃; apply propext\n  constructor\n  · intro h\n    rcases h with ⟨l₂, h₁₂, h₂₃⟩\n    have : Forall₂ (flip r) l₂ l₁ := h₁₂.flip\n    rcases perm_comp_forall₂ h₂₃.symm this with ⟨l', h₁, h₂⟩\n    exact ⟨l', h₂.symm, h₁.flip⟩\n  · exact fun ⟨l₂, h₁₂, h₂₃⟩ => perm_comp_forall₂ h₁₂ h₂₃\n\n"}
{"name":"List.rel_perm_imp","module":"Mathlib.Data.List.Perm.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → β → Prop\nhr : Relator.RightUnique r\n⊢ Relator.LiftFun (List.Forall₂ r) (Relator.LiftFun (List.Forall₂ r) fun x1 x2 => x1 → x2) List.Perm List.Perm","decl":"theorem rel_perm_imp (hr : RightUnique r) : (Forall₂ r ⇒ Forall₂ r ⇒ (· → ·)) Perm Perm :=\n  fun a b h₁ c d h₂ h =>\n  have : (flip (Forall₂ r) ∘r Perm ∘r Forall₂ r) b d := ⟨a, h₁, c, h, h₂⟩\n  have : ((flip (Forall₂ r) ∘r Forall₂ r) ∘r Perm) b d := by\n    rwa [← forall₂_comp_perm_eq_perm_comp_forall₂, ← Relation.comp_assoc] at this\n  let ⟨b', ⟨_, hbc, hcb⟩, hbd⟩ := this\n  have : b' = b := right_unique_forall₂' hr hcb hbc\n  this ▸ hbd\n\n"}
{"name":"List.rel_perm","module":"Mathlib.Data.List.Perm.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → β → Prop\nhr : Relator.BiUnique r\n⊢ Relator.LiftFun (List.Forall₂ r) (Relator.LiftFun (List.Forall₂ r) fun x1 x2 => Iff x1 x2) List.Perm List.Perm","decl":"theorem rel_perm (hr : BiUnique r) : (Forall₂ r ⇒ Forall₂ r ⇒ (· ↔ ·)) Perm Perm :=\n  fun _a _b hab _c _d hcd =>\n  Iff.intro (rel_perm_imp hr.2 hab hcd) (rel_perm_imp hr.left.flip hab.flip hcd.flip)\n\n"}
{"name":"List.count_eq_count_filter_add","module":"Mathlib.Data.List.Perm.Basic","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\nP : α → Prop\ninst✝ : DecidablePred P\nl : List α\na : α\n⊢ Eq (List.count a l) (HAdd.hAdd (List.count a (List.filter (fun b => Decidable.decide (P b)) l)) (List.count a (List.filter (fun x => Decidable.decide (Not (P x))) l)))","decl":"lemma count_eq_count_filter_add [DecidableEq α] (P : α → Prop) [DecidablePred P]\n    (l : List α) (a : α) :\n    count a l = count a (l.filter P) + count a (l.filter (¬ P ·)) := by\n  convert countP_eq_countP_filter_add l _ P\n  simp only [decide_not]\n\n"}
{"name":"List.Perm.foldl_eq","module":"Mathlib.Data.List.Perm.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : β → α → β\nl₁ l₂ : List α\nrcomm : RightCommutative f\np : l₁.Perm l₂\nb : β\n⊢ Eq (List.foldl f b l₁) (List.foldl f b l₂)","decl":"theorem Perm.foldl_eq {f : β → α → β} {l₁ l₂ : List α} [rcomm : RightCommutative f] (p : l₁ ~ l₂) :\n    ∀ b, foldl f b l₁ = foldl f b l₂ :=\n  p.foldl_eq' fun x _hx y _hy z => rcomm.right_comm z x y\n\n"}
{"name":"List.Perm.foldr_eq","module":"Mathlib.Data.List.Perm.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β → β\nl₁ l₂ : List α\nlcomm : LeftCommutative f\np : l₁.Perm l₂\nb : β\n⊢ Eq (List.foldr f b l₁) (List.foldr f b l₂)","decl":"theorem Perm.foldr_eq {f : α → β → β} {l₁ l₂ : List α} [lcomm : LeftCommutative f] (p : l₁ ~ l₂) :\n    ∀ b, foldr f b l₁ = foldr f b l₂ := by\n  intro b\n  induction p using Perm.recOnSwap' generalizing b with\n  | nil => rfl\n  | cons _ _ r  => simp [r b]\n  | swap' _ _ _ r => simp only [foldr_cons]; rw [lcomm.left_comm, r b]\n  | trans _ _ r₁ r₂ => exact Eq.trans (r₁ b) (r₂ b)\n\n"}
{"name":"List.Perm.foldl_op_eq","module":"Mathlib.Data.List.Perm.Basic","initialProofState":"α : Type u_1\nop : α → α → α\nIA : Std.Associative op\nIC : Std.Commutative op\nl₁ l₂ : List α\na : α\nh : l₁.Perm l₂\n⊢ Eq (List.foldl op a l₁) (List.foldl op a l₂)","decl":"theorem Perm.foldl_op_eq {l₁ l₂ : List α} {a : α} (h : l₁ ~ l₂) : (l₁ <*> a) = l₂ <*> a :=\n  h.foldl_eq _\n\n"}
{"name":"List.Perm.foldr_op_eq","module":"Mathlib.Data.List.Perm.Basic","initialProofState":"α : Type u_1\nop : α → α → α\nIA : Std.Associative op\nIC : Std.Commutative op\nl₁ l₂ : List α\na : α\nh : l₁.Perm l₂\n⊢ Eq (List.foldr op a l₁) (List.foldr op a l₂)","decl":"theorem Perm.foldr_op_eq {l₁ l₂ : List α} {a : α} (h : l₁ ~ l₂) : l₁.foldr op a = l₂.foldr op a :=\n  h.foldr_eq _\n\n"}
{"name":"List.Perm.fold_op_eq","module":"Mathlib.Data.List.Perm.Basic","initialProofState":"α : Type u_1\nop : α → α → α\nIA : Std.Associative op\nIC : Std.Commutative op\nl₁ l₂ : List α\na : α\nh : l₁.Perm l₂\n⊢ Eq (List.foldl op a l₁) (List.foldl op a l₂)","decl":"@[deprecated (since := \"2024-09-28\")] alias Perm.fold_op_eq := Perm.foldl_op_eq\n\n"}
{"name":"List.perm_option_toList","module":"Mathlib.Data.List.Perm.Basic","initialProofState":"α : Type u_1\no₁ o₂ : Option α\n⊢ Iff (o₁.toList.Perm o₂.toList) (Eq o₁ o₂)","decl":"theorem perm_option_toList {o₁ o₂ : Option α} : o₁.toList ~ o₂.toList ↔ o₁ = o₂ := by\n  refine ⟨fun p => ?_, fun e => e ▸ Perm.refl _⟩\n  cases' o₁ with a <;> cases' o₂ with b; · rfl\n  · cases p.length_eq\n  · cases p.length_eq\n  · exact Option.mem_toList.1 (p.symm.subset <| by simp)\n\n"}
{"name":"List.perm_option_to_list","module":"Mathlib.Data.List.Perm.Basic","initialProofState":"α : Type u_1\no₁ o₂ : Option α\n⊢ Iff (o₁.toList.Perm o₂.toList) (Eq o₁ o₂)","decl":"@[deprecated (since := \"2024-10-16\")] alias perm_option_to_list := perm_option_toList\n\n"}
{"name":"List.perm_replicate_append_replicate","module":"Mathlib.Data.List.Perm.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl : List α\na b : α\nm n : Nat\nh : Ne a b\n⊢ Iff (l.Perm (HAppend.hAppend (List.replicate m a) (List.replicate n b))) (And (Eq (List.count a l) m) (And (Eq (List.count b l) n) (HasSubset.Subset l (List.cons a (List.cons b List.nil)))))","decl":"theorem perm_replicate_append_replicate\n    [DecidableEq α] {l : List α} {a b : α} {m n : ℕ} (h : a ≠ b) :\n    l ~ replicate m a ++ replicate n b ↔ count a l = m ∧ count b l = n ∧ l ⊆ [a, b] := by\n  rw [perm_iff_count, ← Decidable.and_forall_ne a, ← Decidable.and_forall_ne b]\n  suffices l ⊆ [a, b] ↔ ∀ c, c ≠ b → c ≠ a → c ∉ l by\n    simp +contextual [count_replicate, h, this, count_eq_zero, Ne.symm]\n  trans ∀ c, c ∈ l → c = b ∨ c = a\n  · simp [subset_def, or_comm]\n  · exact forall_congr' fun _ => by rw [← and_imp, ← not_or, not_imp_not]\n\n"}
{"name":"List.Perm.flatMap_left","module":"Mathlib.Data.List.Perm.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nl : List α\nf g : α → List β\nh : ∀ (a : α), Membership.mem l a → (f a).Perm (g a)\n⊢ (l.flatMap f).Perm (l.flatMap g)","decl":"theorem Perm.flatMap_left (l : List α) {f g : α → List β} (h : ∀ a ∈ l, f a ~ g a) :\n    l.flatMap f ~ l.flatMap g :=\n  Perm.flatten_congr <| by\n    rwa [List.forall₂_map_right_iff, List.forall₂_map_left_iff, List.forall₂_same]\n\n"}
{"name":"List.Perm.bind_left","module":"Mathlib.Data.List.Perm.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nl : List α\nf g : α → List β\nh : ∀ (a : α), Membership.mem l a → (f a).Perm (g a)\n⊢ (l.flatMap f).Perm (l.flatMap g)","decl":"@[deprecated (since := \"2024-10-16\")] alias Perm.bind_left := Perm.flatMap_left\n\n"}
{"name":"List.flatMap_append_perm","module":"Mathlib.Data.List.Perm.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nl : List α\nf g : α → List β\n⊢ (HAppend.hAppend (l.flatMap f) (l.flatMap g)).Perm (l.flatMap fun x => HAppend.hAppend (f x) (g x))","decl":"theorem flatMap_append_perm (l : List α) (f g : α → List β) :\n    l.flatMap f ++ l.flatMap g ~ l.flatMap fun x => f x ++ g x := by\n  induction' l with a l IH\n  · simp\n  simp only [flatMap_cons, append_assoc]\n  refine (Perm.trans ?_ (IH.append_left _)).append_left _\n  rw [← append_assoc, ← append_assoc]\n  exact perm_append_comm.append_right _\n\n"}
{"name":"List.bind_append_perm","module":"Mathlib.Data.List.Perm.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nl : List α\nf g : α → List β\n⊢ (HAppend.hAppend (l.flatMap f) (l.flatMap g)).Perm (l.flatMap fun x => HAppend.hAppend (f x) (g x))","decl":"@[deprecated (since := \"2024-10-16\")] alias bind_append_perm := flatMap_append_perm\n\n"}
{"name":"List.map_append_flatMap_perm","module":"Mathlib.Data.List.Perm.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nl : List α\nf : α → β\ng : α → List β\n⊢ (HAppend.hAppend (List.map f l) (l.flatMap g)).Perm (l.flatMap fun x => List.cons (f x) (g x))","decl":"theorem map_append_flatMap_perm (l : List α) (f : α → β) (g : α → List β) :\n    l.map f ++ l.flatMap g ~ l.flatMap fun x => f x :: g x := by\n  simpa [← map_eq_flatMap] using flatMap_append_perm l (fun x => [f x]) g\n\n"}
{"name":"List.map_append_bind_perm","module":"Mathlib.Data.List.Perm.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nl : List α\nf : α → β\ng : α → List β\n⊢ (HAppend.hAppend (List.map f l) (l.flatMap g)).Perm (l.flatMap fun x => List.cons (f x) (g x))","decl":"@[deprecated (since := \"2024-10-16\")] alias map_append_bind_perm := map_append_flatMap_perm\n\n"}
{"name":"List.Perm.product_right","module":"Mathlib.Data.List.Perm.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nl₁ l₂ : List α\nt₁ : List β\np : l₁.Perm l₂\n⊢ (l₁.product t₁).Perm (l₂.product t₁)","decl":"theorem Perm.product_right {l₁ l₂ : List α} (t₁ : List β) (p : l₁ ~ l₂) :\n    product l₁ t₁ ~ product l₂ t₁ :=\n  p.flatMap_right _\n\n"}
{"name":"List.Perm.product_left","module":"Mathlib.Data.List.Perm.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nl : List α\nt₁ t₂ : List β\np : t₁.Perm t₂\n⊢ (l.product t₁).Perm (l.product t₂)","decl":"theorem Perm.product_left (l : List α) {t₁ t₂ : List β} (p : t₁ ~ t₂) :\n    product l t₁ ~ product l t₂ :=\n  (Perm.flatMap_left _) fun _ _ => p.map _\n\n"}
{"name":"List.Perm.product","module":"Mathlib.Data.List.Perm.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nl₁ l₂ : List α\nt₁ t₂ : List β\np₁ : l₁.Perm l₂\np₂ : t₁.Perm t₂\n⊢ (l₁.product t₁).Perm (l₂.product t₂)","decl":"theorem Perm.product {l₁ l₂ : List α} {t₁ t₂ : List β} (p₁ : l₁ ~ l₂) (p₂ : t₁ ~ t₂) :\n    product l₁ t₁ ~ product l₂ t₂ :=\n  (p₁.product_right t₁).trans (p₂.product_left l₂)\n\n"}
{"name":"List.perm_lookmap","module":"Mathlib.Data.List.Perm.Basic","initialProofState":"α : Type u_1\nf : α → Option α\nl₁ l₂ : List α\nH : List.Pairwise (fun a b => ∀ (c : α), Membership.mem (f a) c → ∀ (d : α), Membership.mem (f b) d → And (Eq a b) (Eq c d)) l₁\np : l₁.Perm l₂\n⊢ (List.lookmap f l₁).Perm (List.lookmap f l₂)","decl":"theorem perm_lookmap (f : α → Option α) {l₁ l₂ : List α}\n    (H : Pairwise (fun a b => ∀ c ∈ f a, ∀ d ∈ f b, a = b ∧ c = d) l₁) (p : l₁ ~ l₂) :\n    lookmap f l₁ ~ lookmap f l₂ := by\n  induction' p with a l₁ l₂ p IH a b l l₁ l₂ l₃ p₁ _ IH₁ IH₂; · simp\n  · cases h : f a\n    · simpa [h] using IH (pairwise_cons.1 H).2\n    · simp [lookmap_cons_some _ _ h, p]\n  · cases' h₁ : f a with c <;> cases' h₂ : f b with d\n    · simpa [h₁, h₂] using swap _ _ _\n    · simpa [h₁, lookmap_cons_some _ _ h₂] using swap _ _ _\n    · simpa [lookmap_cons_some _ _ h₁, h₂] using swap _ _ _\n    · rcases (pairwise_cons.1 H).1 _ (mem_cons.2 (Or.inl rfl)) _ h₂ _ h₁ with ⟨rfl, rfl⟩\n      exact Perm.refl _\n  · refine (IH₁ H).trans (IH₂ ((p₁.pairwise_iff ?_).1 H))\n    intro x y h c hc d hd\n    rw [@eq_comm _ y, @eq_comm _ c]\n    apply h d hd c hc\n\n"}
