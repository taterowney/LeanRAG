{"name":"Polynomial.eval₂_eq_sum_range","module":"Mathlib.Algebra.Polynomial.Eval.Degree","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Semiring R\np : Polynomial R\ninst✝ : Semiring S\nf : RingHom R S\nx : S\n⊢ Eq (Polynomial.eval₂ f x p) ((Finset.range (HAdd.hAdd p.natDegree 1)).sum fun i => HMul.hMul (f (p.coeff i)) (HPow.hPow x i))","decl":"theorem eval₂_eq_sum_range :\n    p.eval₂ f x = ∑ i ∈ Finset.range (p.natDegree + 1), f (p.coeff i) * x ^ i :=\n  _root_.trans (congr_arg _ p.as_sum_range)\n    (_root_.trans (eval₂_finset_sum f _ _ x) (congr_arg _ (by simp)))\n\n"}
{"name":"Polynomial.eval₂_eq_sum_range'","module":"Mathlib.Algebra.Polynomial.Eval.Degree","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Semiring R\ninst✝ : Semiring S\nf : RingHom R S\np : Polynomial R\nn : Nat\nhn : LT.lt p.natDegree n\nx : S\n⊢ Eq (Polynomial.eval₂ f x p) ((Finset.range n).sum fun i => HMul.hMul (f (p.coeff i)) (HPow.hPow x i))","decl":"theorem eval₂_eq_sum_range' (f : R →+* S) {p : R[X]} {n : ℕ} (hn : p.natDegree < n) (x : S) :\n    eval₂ f x p = ∑ i ∈ Finset.range n, f (p.coeff i) * x ^ i := by\n  rw [eval₂_eq_sum, p.sum_over_range' _ _ hn]\n  intro i\n  rw [f.map_zero, zero_mul]\n\n"}
{"name":"Polynomial.eval_eq_sum_range","module":"Mathlib.Algebra.Polynomial.Eval.Degree","initialProofState":"R : Type u\ninst✝ : Semiring R\np : Polynomial R\nx : R\n⊢ Eq (Polynomial.eval x p) ((Finset.range (HAdd.hAdd p.natDegree 1)).sum fun i => HMul.hMul (p.coeff i) (HPow.hPow x i))","decl":"theorem eval_eq_sum_range {p : R[X]} (x : R) :\n    p.eval x = ∑ i ∈ Finset.range (p.natDegree + 1), p.coeff i * x ^ i := by\n  rw [eval_eq_sum, sum_over_range]; simp\n\n"}
{"name":"Polynomial.eval_eq_sum_range'","module":"Mathlib.Algebra.Polynomial.Eval.Degree","initialProofState":"R : Type u\ninst✝ : Semiring R\np : Polynomial R\nn : Nat\nhn : LT.lt p.natDegree n\nx : R\n⊢ Eq (Polynomial.eval x p) ((Finset.range n).sum fun i => HMul.hMul (p.coeff i) (HPow.hPow x i))","decl":"theorem eval_eq_sum_range' {p : R[X]} {n : ℕ} (hn : p.natDegree < n) (x : R) :\n    p.eval x = ∑ i ∈ Finset.range n, p.coeff i * x ^ i := by\n  rw [eval_eq_sum, p.sum_over_range' _ _ hn]; simp\n\n"}
{"name":"Polynomial.eval_monomial_one_add_sub","module":"Mathlib.Algebra.Polynomial.Eval.Degree","initialProofState":"S : Type v\ninst✝ : CommRing S\nd : Nat\ny : S\n⊢ Eq (HSub.hSub (Polynomial.eval (HAdd.hAdd 1 y) ((Polynomial.monomial d) (HAdd.hAdd (↑d) 1))) (Polynomial.eval y ((Polynomial.monomial d) (HAdd.hAdd (↑d) 1)))) ((Finset.range (HAdd.hAdd d 1)).sum fun x_1 => HMul.hMul (↑((HAdd.hAdd d 1).choose x_1)) (HMul.hMul (↑x_1) (HPow.hPow y (HSub.hSub x_1 1))))","decl":"/-- A reformulation of the expansion of (1 + y)^d:\n$$(d + 1) (1 + y)^d - (d + 1)y^d = \\sum_{i = 0}^d {d + 1 \\choose i} \\cdot i \\cdot y^{i - 1}.$$\n-/\ntheorem eval_monomial_one_add_sub [CommRing S] (d : ℕ) (y : S) :\n    eval (1 + y) (monomial d (d + 1 : S)) - eval y (monomial d (d + 1 : S)) =\n      ∑ x_1 ∈ range (d + 1), ↑((d + 1).choose x_1) * (↑x_1 * y ^ (x_1 - 1)) := by\n  have cast_succ : (d + 1 : S) = ((d.succ : ℕ) : S) := by simp only [Nat.cast_succ]\n  rw [cast_succ, eval_monomial, eval_monomial, add_comm, add_pow]\n  -- Porting note: `apply_congr` hadn't been ported yet, so `congr` & `ext` is used.\n  conv_lhs =>\n    congr\n    · congr\n      · skip\n      · congr\n        · skip\n        · ext\n          rw [one_pow, mul_one, mul_comm]\n  rw [sum_range_succ, mul_add, Nat.choose_self, Nat.cast_one, one_mul, add_sub_cancel_right,\n    mul_sum, sum_range_succ', Nat.cast_zero, zero_mul, mul_zero, add_zero]\n  refine sum_congr rfl fun y _hy => ?_\n  rw [← mul_assoc, ← mul_assoc, ← Nat.cast_mul, Nat.succ_mul_choose_eq, Nat.cast_mul,\n    Nat.add_sub_cancel]\n\n"}
{"name":"Polynomial.coeff_comp_degree_mul_degree","module":"Mathlib.Algebra.Polynomial.Eval.Degree","initialProofState":"R : Type u\ninst✝ : Semiring R\np q : Polynomial R\nhqd0 : Ne q.natDegree 0\n⊢ Eq ((p.comp q).coeff (HMul.hMul p.natDegree q.natDegree)) (HMul.hMul p.leadingCoeff (HPow.hPow q.leadingCoeff p.natDegree))","decl":"theorem coeff_comp_degree_mul_degree (hqd0 : natDegree q ≠ 0) :\n    coeff (p.comp q) (natDegree p * natDegree q) =\n    leadingCoeff p * leadingCoeff q ^ natDegree p := by\n  rw [comp, eval₂_def, coeff_sum]\n  -- Porting note: `convert` → `refine`\n  refine Eq.trans (Finset.sum_eq_single p.natDegree ?h₀ ?h₁) ?h₂\n  case h₂ =>\n    simp only [coeff_natDegree, coeff_C_mul, coeff_pow_mul_natDegree]\n  case h₀ =>\n    intro b hbs hbp\n    refine coeff_eq_zero_of_natDegree_lt (natDegree_mul_le.trans_lt ?_)\n    rw [natDegree_C, zero_add]\n    refine natDegree_pow_le.trans_lt ((mul_lt_mul_right (pos_iff_ne_zero.mpr hqd0)).mpr ?_)\n    exact lt_of_le_of_ne (le_natDegree_of_mem_supp _ hbs) hbp\n  case h₁ =>\n    simp +contextual\n\n"}
{"name":"Polynomial.comp_C_mul_X_coeff","module":"Mathlib.Algebra.Polynomial.Eval.Degree","initialProofState":"R : Type u\ninst✝ : Semiring R\np : Polynomial R\nr : R\nn : Nat\n⊢ Eq ((p.comp (HMul.hMul (Polynomial.C r) Polynomial.X)).coeff n) (HMul.hMul (p.coeff n) (HPow.hPow r n))","decl":"@[simp] lemma comp_C_mul_X_coeff {r : R} {n : ℕ} :\n    (p.comp <| C r * X).coeff n = p.coeff n * r ^ n := by\n  simp_rw [comp, eval₂_eq_sum_range, (commute_X _).symm.mul_pow,\n    ← C_pow, finset_sum_coeff, coeff_C_mul, coeff_X_pow]\n  rw [Finset.sum_eq_single n _ fun h ↦ ?_, if_pos rfl, mul_one]\n  · intro b _ h; simp_rw [if_neg h.symm, mul_zero]\n  · rw [coeff_eq_zero_of_natDegree_lt, zero_mul]\n    rwa [Finset.mem_range_succ_iff, not_le] at h\n\n"}
{"name":"Polynomial.comp_C_mul_X_eq_zero_iff","module":"Mathlib.Algebra.Polynomial.Eval.Degree","initialProofState":"R : Type u\ninst✝ : Semiring R\np : Polynomial R\nr : R\nhr : Membership.mem (nonZeroDivisors R) r\n⊢ Iff (Eq (p.comp (HMul.hMul (Polynomial.C r) Polynomial.X)) 0) (Eq p 0)","decl":"lemma comp_C_mul_X_eq_zero_iff {r : R} (hr : r ∈ nonZeroDivisors R) :\n    p.comp (C r * X) = 0 ↔ p = 0 := by\n  simp_rw [ext_iff]\n  refine forall_congr' fun n ↦ ?_\n  rw [comp_C_mul_X_coeff, coeff_zero, mul_right_mem_nonZeroDivisors_eq_zero_iff (pow_mem hr _)]\n\n"}
{"name":"Polynomial.mapEquiv_apply","module":"Mathlib.Algebra.Polynomial.Eval.Degree","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Semiring R\ninst✝ : Semiring S\ne : RingEquiv R S\na : Polynomial R\n⊢ Eq ((Polynomial.mapEquiv e) a) (Polynomial.map (↑e) a)","decl":"variable (f) in\n/-- If `R` and `S` are isomorphic, then so are their polynomial rings. -/\n@[simps!]\ndef mapEquiv (e : R ≃+* S) : R[X] ≃+* S[X] :=\n  RingEquiv.ofHomInv (mapRingHom (e : R →+* S)) (mapRingHom (e.symm : S →+* R)) (by ext; simp)\n    (by ext; simp)\n\n"}
{"name":"Polynomial.mapEquiv_symm_apply","module":"Mathlib.Algebra.Polynomial.Eval.Degree","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Semiring R\ninst✝ : Semiring S\ne : RingEquiv R S\na : Polynomial S\n⊢ Eq ((Polynomial.mapEquiv e).symm a) (Polynomial.map (↑e.symm) a)","decl":"variable (f) in\n/-- If `R` and `S` are isomorphic, then so are their polynomial rings. -/\n@[simps!]\ndef mapEquiv (e : R ≃+* S) : R[X] ≃+* S[X] :=\n  RingEquiv.ofHomInv (mapRingHom (e : R →+* S)) (mapRingHom (e.symm : S →+* R)) (by ext; simp)\n    (by ext; simp)\n\n"}
{"name":"Polynomial.map_monic_eq_zero_iff","module":"Mathlib.Algebra.Polynomial.Eval.Degree","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Semiring R\ninst✝ : Semiring S\nf : RingHom R S\np : Polynomial R\nhp : p.Monic\n⊢ Iff (Eq (Polynomial.map f p) 0) (∀ (x : R), Eq (f x) 0)","decl":"theorem map_monic_eq_zero_iff (hp : p.Monic) : p.map f = 0 ↔ ∀ x, f x = 0 :=\n  ⟨fun hfp x =>\n    calc\n      f x = f x * f p.leadingCoeff := by simp only [mul_one, hp.leadingCoeff, f.map_one]\n      _ = f x * (p.map f).coeff p.natDegree := congr_arg _ (coeff_map _ _).symm\n      _ = 0 := by simp only [hfp, mul_zero, coeff_zero]\n      ,\n    fun h => ext fun n => by simp only [h, coeff_map, coeff_zero]⟩\n\n"}
{"name":"Polynomial.map_monic_ne_zero","module":"Mathlib.Algebra.Polynomial.Eval.Degree","initialProofState":"R : Type u\nS : Type v\ninst✝² : Semiring R\ninst✝¹ : Semiring S\nf : RingHom R S\np : Polynomial R\nhp : p.Monic\ninst✝ : Nontrivial S\n⊢ Ne (Polynomial.map f p) 0","decl":"theorem map_monic_ne_zero (hp : p.Monic) [Nontrivial S] : p.map f ≠ 0 := fun h =>\n  f.map_one_ne_zero ((map_monic_eq_zero_iff hp).mp h _)\n\n"}
{"name":"Polynomial.degree_map_le","module":"Mathlib.Algebra.Polynomial.Eval.Degree","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Semiring R\ninst✝ : Semiring S\nf : RingHom R S\np : Polynomial R\n⊢ LE.le (Polynomial.map f p).degree p.degree","decl":"lemma degree_map_le : degree (p.map f) ≤ degree p := by\n  refine (degree_le_iff_coeff_zero _ _).2 fun m hm => ?_\n  rw [degree_lt_iff_coeff_zero] at hm\n  simp [hm m le_rfl]\n\n"}
{"name":"Polynomial.natDegree_map_le","module":"Mathlib.Algebra.Polynomial.Eval.Degree","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Semiring R\ninst✝ : Semiring S\nf : RingHom R S\np : Polynomial R\n⊢ LE.le (Polynomial.map f p).natDegree p.natDegree","decl":"lemma natDegree_map_le : natDegree (p.map f) ≤ natDegree p := natDegree_le_natDegree degree_map_le\n\n"}
{"name":"Polynomial.degree_map_lt","module":"Mathlib.Algebra.Polynomial.Eval.Degree","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Semiring R\ninst✝ : Semiring S\nf : RingHom R S\np : Polynomial R\nhp : Eq (f p.leadingCoeff) 0\nhp₀ : Ne p 0\n⊢ LT.lt (Polynomial.map f p).degree p.degree","decl":"lemma degree_map_lt (hp : f p.leadingCoeff = 0) (hp₀ : p ≠ 0) : (p.map f).degree < p.degree := by\n  refine degree_map_le.lt_of_ne fun hpq ↦ hp₀ ?_\n  rw [leadingCoeff, ← coeff_map, ← natDegree_eq_natDegree hpq, ← leadingCoeff, leadingCoeff_eq_zero]\n    at hp\n  rw [← degree_eq_bot, ← hpq, hp, degree_zero]\n\n"}
{"name":"Polynomial.natDegree_map_lt","module":"Mathlib.Algebra.Polynomial.Eval.Degree","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Semiring R\ninst✝ : Semiring S\nf : RingHom R S\np : Polynomial R\nhp : Eq (f p.leadingCoeff) 0\nhp₀ : Ne (Polynomial.map f p) 0\n⊢ LT.lt (Polynomial.map f p).natDegree p.natDegree","decl":"lemma natDegree_map_lt (hp : f p.leadingCoeff = 0) (hp₀ : map f p ≠ 0) :\n    (p.map f).natDegree < p.natDegree :=\n  natDegree_lt_natDegree hp₀ <| degree_map_lt hp <| by rintro rfl; simp at hp₀\n\n"}
{"name":"Polynomial.natDegree_map_lt'","module":"Mathlib.Algebra.Polynomial.Eval.Degree","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Semiring R\ninst✝ : Semiring S\nf : RingHom R S\np : Polynomial R\nhp : Eq (f p.leadingCoeff) 0\nhp₀ : LT.lt 0 p.natDegree\n⊢ LT.lt (Polynomial.map f p).natDegree p.natDegree","decl":"/-- Variant of `natDegree_map_lt` that assumes `0 < natDegree p` instead of `map f p ≠ 0`. -/\nlemma natDegree_map_lt' (hp : f p.leadingCoeff = 0) (hp₀ : 0 < natDegree p) :\n    (p.map f).natDegree < p.natDegree := by\n  by_cases H : map f p = 0\n  · rwa [H, natDegree_zero]\n  · exact natDegree_map_lt hp H\n\n"}
{"name":"Polynomial.degree_map_eq_of_leadingCoeff_ne_zero","module":"Mathlib.Algebra.Polynomial.Eval.Degree","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Semiring R\ninst✝ : Semiring S\np : Polynomial R\nf : RingHom R S\nhf : Ne (f p.leadingCoeff) 0\n⊢ Eq (Polynomial.map f p).degree p.degree","decl":"theorem degree_map_eq_of_leadingCoeff_ne_zero (f : R →+* S) (hf : f (leadingCoeff p) ≠ 0) :\n    degree (p.map f) = degree p := by\n  refine degree_map_le.antisymm ?_\n  have hp0 : p ≠ 0 :=\n    leadingCoeff_ne_zero.mp fun hp0 => hf (_root_.trans (congr_arg _ hp0) f.map_zero)\n  rw [degree_eq_natDegree hp0]\n  refine le_degree_of_ne_zero ?_\n  rw [coeff_map]\n  exact hf\n\n"}
{"name":"Polynomial.natDegree_map_of_leadingCoeff_ne_zero","module":"Mathlib.Algebra.Polynomial.Eval.Degree","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Semiring R\ninst✝ : Semiring S\np : Polynomial R\nf : RingHom R S\nhf : Ne (f p.leadingCoeff) 0\n⊢ Eq (Polynomial.map f p).natDegree p.natDegree","decl":"theorem natDegree_map_of_leadingCoeff_ne_zero (f : R →+* S) (hf : f (leadingCoeff p) ≠ 0) :\n    natDegree (p.map f) = natDegree p :=\n  natDegree_eq_of_degree_eq (degree_map_eq_of_leadingCoeff_ne_zero f hf)\n\n"}
{"name":"Polynomial.leadingCoeff_map_of_leadingCoeff_ne_zero","module":"Mathlib.Algebra.Polynomial.Eval.Degree","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Semiring R\ninst✝ : Semiring S\np : Polynomial R\nf : RingHom R S\nhf : Ne (f p.leadingCoeff) 0\n⊢ Eq (Polynomial.map f p).leadingCoeff (f p.leadingCoeff)","decl":"theorem leadingCoeff_map_of_leadingCoeff_ne_zero (f : R →+* S) (hf : f (leadingCoeff p) ≠ 0) :\n    leadingCoeff (p.map f) = f (leadingCoeff p) := by\n  unfold leadingCoeff\n  rw [coeff_map, natDegree_map_of_leadingCoeff_ne_zero f hf]\n\n"}
{"name":"Polynomial.eval₂_comp","module":"Mathlib.Algebra.Polynomial.Eval.Degree","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Semiring R\np q : Polynomial R\ninst✝ : CommSemiring S\nf : RingHom R S\nx : S\n⊢ Eq (Polynomial.eval₂ f x (p.comp q)) (Polynomial.eval₂ f (Polynomial.eval₂ f x q) p)","decl":"theorem eval₂_comp {x : S} : eval₂ f x (p.comp q) = eval₂ f (eval₂ f x q) p := by\n  rw [comp, p.as_sum_range]; simp [eval₂_finset_sum, eval₂_pow]\n\n"}
{"name":"Polynomial.iterate_comp_eval₂","module":"Mathlib.Algebra.Polynomial.Eval.Degree","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Semiring R\np q : Polynomial R\ninst✝ : CommSemiring S\nf : RingHom R S\nk : Nat\nt : S\n⊢ Eq (Polynomial.eval₂ f t (Nat.iterate p.comp k q)) (Nat.iterate (fun x => Polynomial.eval₂ f x p) k (Polynomial.eval₂ f t q))","decl":"@[simp]\ntheorem iterate_comp_eval₂ (k : ℕ) (t : S) :\n    eval₂ f t (p.comp^[k] q) = (fun x => eval₂ f x p)^[k] (eval₂ f t q) := by\n  induction k with\n  | zero => simp\n  | succ k IH => rw [Function.iterate_succ_apply', Function.iterate_succ_apply', eval₂_comp, IH]\n\n"}
{"name":"Polynomial.iterate_comp_eval","module":"Mathlib.Algebra.Polynomial.Eval.Degree","initialProofState":"R : Type u\ninst✝ : CommSemiring R\np q : Polynomial R\nk : Nat\nt : R\n⊢ Eq (Polynomial.eval t (Nat.iterate p.comp k q)) (Nat.iterate (fun x => Polynomial.eval x p) k (Polynomial.eval t q))","decl":"@[simp]\ntheorem iterate_comp_eval :\n    ∀ (k : ℕ) (t : R), (p.comp^[k] q).eval t = (fun x => p.eval x)^[k] (q.eval t) :=\n  iterate_comp_eval₂ _\n\n"}
{"name":"Polynomial.isUnit_of_isUnit_leadingCoeff_of_isUnit_map","module":"Mathlib.Algebra.Polynomial.Eval.Degree","initialProofState":"R : Type u\nS : Type v\ninst✝² : Semiring R\ninst✝¹ : CommRing S\ninst✝ : IsDomain S\nφ : RingHom R S\nf : Polynomial R\nhf : IsUnit f.leadingCoeff\nH : IsUnit (Polynomial.map φ f)\n⊢ IsUnit f","decl":"lemma isUnit_of_isUnit_leadingCoeff_of_isUnit_map (hf : IsUnit f.leadingCoeff)\n    (H : IsUnit (map φ f)) : IsUnit f := by\n  have dz := degree_eq_zero_of_isUnit H\n  rw [degree_map_eq_of_leadingCoeff_ne_zero] at dz\n  · rw [eq_C_of_degree_eq_zero dz]\n    refine IsUnit.map C ?_\n    convert hf\n    change coeff f 0 = coeff f (natDegree f)\n    rw [(degree_eq_iff_natDegree_eq _).1 dz]\n    · rfl\n    rintro rfl\n    simp at H\n  · intro h\n    have u : IsUnit (φ f.leadingCoeff) := IsUnit.map φ hf\n    rw [h] at u\n    simp at u\n\n"}
