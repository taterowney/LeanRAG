{"name":"derivationOfSectionOfKerSqZero_apply_coe","module":"Mathlib.RingTheory.Smooth.Kaehler","initialProofState":"R P S : Type u\ninst✝⁴ : CommRing R\ninst✝³ : CommRing P\ninst✝² : CommRing S\ninst✝¹ : Algebra R P\ninst✝ : Algebra R S\nf : AlgHom R P S\nhf' : Eq (HPow.hPow (RingHom.ker f) 2) Bot.bot\ng : AlgHom R S P\nhg : Eq (f.comp g) (AlgHom.id R S)\nx : P\n⊢ Eq (↑((derivationOfSectionOfKerSqZero f hf' g hg) x)) (HSub.hSub x (g (f x)))","decl":"/--\nGiven a surjective algebra homomorphism `f : P →ₐ[R] S` with square-zero kernel `I`,\nand a section `g : S →ₐ[R] P` (as an algebra homomorphism),\nwe get an `R`-derivation `P → I` via `x ↦ x - g (f x)`.\n-/\n@[simps]\ndef derivationOfSectionOfKerSqZero (f : P →ₐ[R] S) (hf' : (RingHom.ker f) ^ 2 = ⊥) (g : S →ₐ[R] P)\n    (hg : f.comp g = AlgHom.id R S) : Derivation R P (RingHom.ker f) where\n  toFun x := ⟨x - g (f x), by\n    simpa [RingHom.mem_ker, sub_eq_zero] using AlgHom.congr_fun hg.symm (f x)⟩\n  map_add' x y := by simp only [map_add, AddMemClass.mk_add_mk, Subtype.mk.injEq]; ring\n  map_smul' x y := by\n    ext\n    simp only [Algebra.smul_def, map_mul, ← IsScalarTower.algebraMap_apply, AlgHom.commutes,\n      RingHom.id_apply, Submodule.coe_smul_of_tower]\n    ring\n  map_one_eq_zero' := by simp only [LinearMap.coe_mk, AddHom.coe_mk, map_one, sub_self,\n    Submodule.mk_eq_zero]\n  leibniz' a b := by\n    have : (a - g (f a)) * (b - g (f b)) = 0 := by\n      rw [← Ideal.mem_bot, ← hf', pow_two]\n      apply Ideal.mul_mem_mul\n      · simpa [RingHom.mem_ker, sub_eq_zero] using AlgHom.congr_fun hg.symm (f a)\n      · simpa [RingHom.mem_ker, sub_eq_zero] using AlgHom.congr_fun hg.symm (f b)\n    ext\n    rw [← sub_eq_zero]\n    conv_rhs => rw [← neg_zero, ← this]\n    simp only [LinearMap.coe_mk, AddHom.coe_mk, map_mul, SetLike.mk_smul_mk, smul_eq_mul, mul_sub,\n      AddMemClass.mk_add_mk, sub_mul, neg_sub]\n    ring\n\n"}
{"name":"isScalarTower_of_section_of_ker_sqZero","module":"Mathlib.RingTheory.Smooth.Kaehler","initialProofState":"R P S : Type u\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing P\ninst✝⁴ : CommRing S\ninst✝³ : Algebra R P\ninst✝² : Algebra P S\ninst✝¹ : Algebra R S\ninst✝ : IsScalarTower R P S\ng : AlgHom R S P\nhf' : Eq (HPow.hPow (RingHom.ker (algebraMap P S)) 2) Bot.bot\nhg : Eq ((IsScalarTower.toAlgHom R P S).comp g) (AlgHom.id R S)\n⊢ IsScalarTower P S (Subtype fun x => Membership.mem (RingHom.ker (algebraMap P S)) x)","decl":"lemma isScalarTower_of_section_of_ker_sqZero :\n    letI := g.toRingHom.toAlgebra; IsScalarTower P S (RingHom.ker (algebraMap P S)) := by\n  letI := g.toRingHom.toAlgebra\n  constructor\n  intro p s m\n  ext\n  show g (p • s) * m = p * (g s * m)\n  simp only [Algebra.smul_def, map_mul, mul_assoc, mul_left_comm _ (g s)]\n  congr 1\n  rw [← sub_eq_zero, ← Ideal.mem_bot, ← hf', pow_two, ← sub_mul]\n  refine Ideal.mul_mem_mul ?_ m.2\n  simpa [RingHom.mem_ker, sub_eq_zero] using AlgHom.congr_fun hg (algebraMap P S p)\n\n"}
{"name":"retractionOfSectionOfKerSqZero_tmul_D","module":"Mathlib.RingTheory.Smooth.Kaehler","initialProofState":"R P S : Type u\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing P\ninst✝⁴ : CommRing S\ninst✝³ : Algebra R P\ninst✝² : Algebra P S\ninst✝¹ : Algebra R S\ninst✝ : IsScalarTower R P S\ng : AlgHom R S P\nhf' : Eq (HPow.hPow (RingHom.ker (algebraMap P S)) 2) Bot.bot\nhg : Eq ((IsScalarTower.toAlgHom R P S).comp g) (AlgHom.id R S)\ns : S\nt : P\n⊢ Eq (↑((retractionOfSectionOfKerSqZero g hf' hg) (TensorProduct.tmul P s ((KaehlerDifferential.D R P) t)))) (HSub.hSub (HMul.hMul (g s) t) (HMul.hMul (g s) (g ((algebraMap P S) t))))","decl":"@[simp]\nlemma retractionOfSectionOfKerSqZero_tmul_D (s : S) (t : P) :\n    retractionOfSectionOfKerSqZero g hf' hg (s ⊗ₜ .D _ _ t) =\n      g s * t - g s * g (algebraMap _ _ t) := by\n  letI := g.toRingHom.toAlgebra\n  haveI := isScalarTower_of_section_of_ker_sqZero g hf' hg\n  simp only [retractionOfSectionOfKerSqZero, AlgHom.toRingHom_eq_coe, LinearMap.coe_restrictScalars,\n    LinearMap.liftBaseChange_tmul, SetLike.val_smul_of_tower]\n  erw [Derivation.liftKaehlerDifferential_comp_D]\n  exact mul_sub (g s) t (g (algebraMap P S t))\n\n"}
{"name":"retractionOfSectionOfKerSqZero_comp_kerToTensor","module":"Mathlib.RingTheory.Smooth.Kaehler","initialProofState":"R P S : Type u\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing P\ninst✝⁴ : CommRing S\ninst✝³ : Algebra R P\ninst✝² : Algebra P S\ninst✝¹ : Algebra R S\ninst✝ : IsScalarTower R P S\ng : AlgHom R S P\nhf' : Eq (HPow.hPow (RingHom.ker (algebraMap P S)) 2) Bot.bot\nhg : Eq ((IsScalarTower.toAlgHom R P S).comp g) (AlgHom.id R S)\n⊢ Eq ((retractionOfSectionOfKerSqZero g hf' hg).comp (KaehlerDifferential.kerToTensor R P S)) LinearMap.id","decl":"lemma retractionOfSectionOfKerSqZero_comp_kerToTensor :\n    (retractionOfSectionOfKerSqZero g hf' hg).comp (kerToTensor R P S) = LinearMap.id := by\n  ext x; simp [RingHom.mem_ker.mp x.2]\n\n"}
{"name":"sectionOfRetractionKerToTensorAux_prop","module":"Mathlib.RingTheory.Smooth.Kaehler","initialProofState":"R P S : Type u\ninst✝⁴ : CommRing R\ninst✝³ : CommRing P\ninst✝² : CommRing S\ninst✝¹ : Algebra R P\ninst✝ : Algebra P S\nl : LinearMap (RingHom.id P) (TensorProduct P S (KaehlerDifferential R P)) (Subtype fun x => Membership.mem (RingHom.ker (algebraMap P S)) x)\nhl : Eq (l.comp (KaehlerDifferential.kerToTensor R P S)) LinearMap.id\nx y : P\nh : Eq ((algebraMap P S) x) ((algebraMap P S) y)\n⊢ Eq (HSub.hSub x ↑(l (TensorProduct.tmul P 1 ((KaehlerDifferential.D R P) x)))) (HSub.hSub y ↑(l (TensorProduct.tmul P 1 ((KaehlerDifferential.D R P) y))))","decl":"lemma sectionOfRetractionKerToTensorAux_prop (x y) (h : algebraMap P S x = algebraMap P S y) :\n    x - l (1 ⊗ₜ .D _ _ x) = y - l (1 ⊗ₜ .D _ _ y) := by\n  rw [sub_eq_iff_eq_add, sub_add_comm, ← sub_eq_iff_eq_add, ← Submodule.coe_sub,\n    ← map_sub, ← tmul_sub, ← map_sub]\n  exact congr_arg Subtype.val (LinearMap.congr_fun hl.symm ⟨x - y, by simp [RingHom.mem_ker, h]⟩)\n\n"}
{"name":"sectionOfRetractionKerToTensorAux_algebraMap","module":"Mathlib.RingTheory.Smooth.Kaehler","initialProofState":"R P S : Type u\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing P\ninst✝⁴ : CommRing S\ninst✝³ : Algebra R P\ninst✝² : Algebra P S\nl : LinearMap (RingHom.id P) (TensorProduct P S (KaehlerDifferential R P)) (Subtype fun x => Membership.mem (RingHom.ker (algebraMap P S)) x)\nhl : Eq (l.comp (KaehlerDifferential.kerToTensor R P S)) LinearMap.id\ninst✝¹ : Algebra R S\ninst✝ : IsScalarTower R P S\nhf' : Eq (HPow.hPow (RingHom.ker (algebraMap P S)) 2) Bot.bot\nx : P\n⊢ Eq (sorryAx (Unit → P) Bool.true (Function.const Lean.Name Unit.unit ((((((((((Lean.Name.anonymous.num 188).num 4).num 188).num 70).num 4).num 70).str \"_sorry\").str \"_@\").str \"_hyg\").num 1482))) (HSub.hSub x ↑(l (TensorProduct.tmul P 1 ((KaehlerDifferential.D R P) x))))","decl":"lemma sectionOfRetractionKerToTensorAux_algebraMap (x : P) :\n    sectionOfRetractionKerToTensorAux l hl σ hσ hf' (algebraMap P S x) = x - l (1 ⊗ₜ .D _ _ x) :=\n  sectionOfRetractionKerToTensorAux_prop l hl _ x (by simp [hσ])\n\n"}
{"name":"toAlgHom_comp_sectionOfRetractionKerToTensorAux","module":"Mathlib.RingTheory.Smooth.Kaehler","initialProofState":"R P S : Type u\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing P\ninst✝⁴ : CommRing S\ninst✝³ : Algebra R P\ninst✝² : Algebra P S\nl : LinearMap (RingHom.id P) (TensorProduct P S (KaehlerDifferential R P)) (Subtype fun x => Membership.mem (RingHom.ker (algebraMap P S)) x)\nhl : Eq (l.comp (KaehlerDifferential.kerToTensor R P S)) LinearMap.id\ninst✝¹ : Algebra R S\ninst✝ : IsScalarTower R P S\nhf' : Eq (HPow.hPow (RingHom.ker (algebraMap P S)) 2) Bot.bot\nhf : Function.Surjective ⇑(algebraMap P S)\n⊢ Eq ((IsScalarTower.toAlgHom R P S).comp (sorryAx (Unit → AlgHom R S P) Bool.true (Function.const Lean.Name Unit.unit ((((((((((Lean.Name.anonymous.num 196).num 7).num 196).num 54).num 7).num 54).str \"_sorry\").str \"_@\").str \"_hyg\").num 1740)))) (AlgHom.id R S)","decl":"lemma toAlgHom_comp_sectionOfRetractionKerToTensorAux :\n    (IsScalarTower.toAlgHom R P S).comp\n      (sectionOfRetractionKerToTensorAux l hl σ hσ hf') = AlgHom.id _ _ := by\n  ext x\n  obtain ⟨x, rfl⟩ := hf x\n  simp [sectionOfRetractionKerToTensorAux_algebraMap, RingHom.mem_ker.mp]\n\n"}
{"name":"sectionOfRetractionKerToTensor_algebraMap","module":"Mathlib.RingTheory.Smooth.Kaehler","initialProofState":"R P S : Type u\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing P\ninst✝⁴ : CommRing S\ninst✝³ : Algebra R P\ninst✝² : Algebra P S\nl : LinearMap (RingHom.id P) (TensorProduct P S (KaehlerDifferential R P)) (Subtype fun x => Membership.mem (RingHom.ker (algebraMap P S)) x)\nhl : Eq (l.comp (KaehlerDifferential.kerToTensor R P S)) LinearMap.id\ninst✝¹ : Algebra R S\ninst✝ : IsScalarTower R P S\nhf' : Eq (HPow.hPow (RingHom.ker (algebraMap P S)) 2) Bot.bot\nhf : Function.Surjective ⇑(algebraMap P S)\nx : P\n⊢ Eq (sorryAx (Unit → P) Bool.true (Function.const Lean.Name Unit.unit ((((((((((Lean.Name.anonymous.num 212).num 4).num 212).num 65).num 4).num 65).str \"_sorry\").str \"_@\").str \"_hyg\").num 1977))) (HSub.hSub x ↑(l (TensorProduct.tmul P 1 ((KaehlerDifferential.D R P) x))))","decl":"@[simp]\nlemma sectionOfRetractionKerToTensor_algebraMap (x : P) :\n    sectionOfRetractionKerToTensor l hl hf' hf (algebraMap P S x) = x - l (1 ⊗ₜ .D _ _ x) :=\n  sectionOfRetractionKerToTensorAux_algebraMap l hl _ _ hf' x\n\n"}
{"name":"toAlgHom_comp_sectionOfRetractionKerToTensor","module":"Mathlib.RingTheory.Smooth.Kaehler","initialProofState":"R P S : Type u\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing P\ninst✝⁴ : CommRing S\ninst✝³ : Algebra R P\ninst✝² : Algebra P S\nl : LinearMap (RingHom.id P) (TensorProduct P S (KaehlerDifferential R P)) (Subtype fun x => Membership.mem (RingHom.ker (algebraMap P S)) x)\nhl : Eq (l.comp (KaehlerDifferential.kerToTensor R P S)) LinearMap.id\ninst✝¹ : Algebra R S\ninst✝ : IsScalarTower R P S\nhf' : Eq (HPow.hPow (RingHom.ker (algebraMap P S)) 2) Bot.bot\nhf : Function.Surjective ⇑(algebraMap P S)\n⊢ Eq ((IsScalarTower.toAlgHom R P S).comp (sorryAx (Unit → AlgHom R S P) Bool.true (Function.const Lean.Name Unit.unit ((((((((((Lean.Name.anonymous.num 218).num 7).num 218).num 49).num 7).num 49).str \"_sorry\").str \"_@\").str \"_hyg\").num 2123)))) (AlgHom.id R S)","decl":"@[simp]\nlemma toAlgHom_comp_sectionOfRetractionKerToTensor :\n    (IsScalarTower.toAlgHom R P S).comp\n      (sectionOfRetractionKerToTensor l hl hf' hf) = AlgHom.id _ _ :=\n  toAlgHom_comp_sectionOfRetractionKerToTensorAux (hf := hf) ..\n\n"}
{"name":"derivationQuotKerSq_mk","module":"Mathlib.RingTheory.Smooth.Kaehler","initialProofState":"R P S : Type u\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing P\ninst✝⁴ : CommRing S\ninst✝³ : Algebra R P\ninst✝² : Algebra P S\ninst✝¹ : Algebra R S\ninst✝ : IsScalarTower R P S\nx : P\n⊢ Eq ((derivationQuotKerSq R P S) ((Ideal.Quotient.mk (HPow.hPow (RingHom.ker (algebraMap P S)) 2)) x)) (TensorProduct.tmul P 1 ((KaehlerDifferential.D R P) x))","decl":"@[simp]\nlemma derivationQuotKerSq_mk (x : P) :\n    derivationQuotKerSq R P S x = 1 ⊗ₜ .D R P x := rfl\n\n"}
{"name":"tensorKaehlerQuotKerSqEquiv_tmul_D","module":"Mathlib.RingTheory.Smooth.Kaehler","initialProofState":"R P S : Type u\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing P\ninst✝⁴ : CommRing S\ninst✝³ : Algebra R P\ninst✝² : Algebra P S\ninst✝¹ : Algebra R S\ninst✝ : IsScalarTower R P S\ns : S\nt : P\n⊢ Eq ((tensorKaehlerQuotKerSqEquiv R P S) (TensorProduct.tmul (HasQuotient.Quotient P (HPow.hPow (RingHom.ker (algebraMap P S)) 2)) s ((KaehlerDifferential.D R (HasQuotient.Quotient P (HPow.hPow (RingHom.ker (algebraMap P S)) 2))) ((Ideal.Quotient.mk (HPow.hPow (RingHom.ker (algebraMap P S)) 2)) t)))) (TensorProduct.tmul P s ((KaehlerDifferential.D R P) t))","decl":"@[simp]\nlemma tensorKaehlerQuotKerSqEquiv_tmul_D (s t) :\n    tensorKaehlerQuotKerSqEquiv R P S (s ⊗ₜ .D _ _ (Ideal.Quotient.mk _ t)) = s ⊗ₜ .D _ _ t := by\n  show s • (derivationQuotKerSq R P S).liftKaehlerDifferential (.D _ _ (Ideal.Quotient.mk _ t)) = _\n  simp [smul_tmul']\n\n"}
{"name":"tensorKaehlerQuotKerSqEquiv_symm_tmul_D","module":"Mathlib.RingTheory.Smooth.Kaehler","initialProofState":"R P S : Type u\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing P\ninst✝⁴ : CommRing S\ninst✝³ : Algebra R P\ninst✝² : Algebra P S\ninst✝¹ : Algebra R S\ninst✝ : IsScalarTower R P S\ns : S\nt : P\n⊢ Eq ((tensorKaehlerQuotKerSqEquiv R P S).symm (TensorProduct.tmul P s ((KaehlerDifferential.D R P) t))) (TensorProduct.tmul (HasQuotient.Quotient P (HPow.hPow (RingHom.ker (algebraMap P S)) 2)) s ((KaehlerDifferential.D R (HasQuotient.Quotient P (HPow.hPow (RingHom.ker (algebraMap P S)) 2))) ((Ideal.Quotient.mk (HPow.hPow (RingHom.ker (algebraMap P S)) 2)) t)))","decl":"@[simp]\nlemma tensorKaehlerQuotKerSqEquiv_symm_tmul_D (s t) :\n    (tensorKaehlerQuotKerSqEquiv R P S).symm (s ⊗ₜ .D _ _ t) =\n      s ⊗ₜ .D _ _ (Ideal.Quotient.mk _ t) := by\n  apply (tensorKaehlerQuotKerSqEquiv R P S).injective\n  simp\n\n"}
{"name":"Algebra.FormallySmooth.iff_split_injection","module":"Mathlib.RingTheory.Smooth.Kaehler","initialProofState":"R P S : Type u\ninst✝⁷ : CommRing R\ninst✝⁶ : CommRing P\ninst✝⁵ : CommRing S\ninst✝⁴ : Algebra R P\ninst✝³ : Algebra P S\ninst✝² : Algebra R S\ninst✝¹ : IsScalarTower R P S\nhf : Function.Surjective ⇑(algebraMap P S)\ninst✝ : Algebra.FormallySmooth R P\n⊢ Iff (Algebra.FormallySmooth R S) (Exists fun l => Eq (l.comp (KaehlerDifferential.kerCotangentToTensor R P S)) LinearMap.id)","decl":"include hf in\n/--\nGiven a formally smooth `R`-algebra `P` and a surjective algebra homomorphism `f : P →ₐ[R] S`\nwith kernel `I` (typically a presentation `R[X] → S`),\n`S` is formally smooth iff the `P`-linear map `I/I² → S ⊗[P] Ω[P⁄R]` is split injective.\nAlso see `Algebra.Extension.formallySmooth_iff_split_injection`\nfor the version in terms of `Extension`.\n-/\n@[stacks 031I]\ntheorem Algebra.FormallySmooth.iff_split_injection :\n    Algebra.FormallySmooth R S ↔ ∃ l, l ∘ₗ (kerCotangentToTensor R P S) = LinearMap.id := by\n  have := (retractionKerCotangentToTensorEquivSection (R := R) hf).nonempty_congr\n  simp only [nonempty_subtype] at this\n  rw [this, ← Algebra.FormallySmooth.iff_split_surjection _ hf]\n\n"}
{"name":"Algebra.Extension.formallySmooth_iff_split_injection","module":"Mathlib.RingTheory.Smooth.Kaehler","initialProofState":"R S : Type u\ninst✝³ : CommRing R\ninst✝² : CommRing S\ninst✝¹ : Algebra R S\nP : Algebra.Extension R S\ninst✝ : Algebra.FormallySmooth R P.Ring\n⊢ Iff (Algebra.FormallySmooth R S) (Exists fun l => Eq (l.comp P.cotangentComplex) LinearMap.id)","decl":"/--\nGiven a formally smooth `R`-algebra `P` and a surjective algebra homomorphism `f : P →ₐ[R] S`\nwith kernel `I` (typically a presentation `R[X] → S`),\n`S` is formally smooth iff the `P`-linear map `I/I² → S ⊗[P] Ω[P⁄R]` is split injective.\n-/\n@[stacks 031I]\ntheorem Algebra.Extension.formallySmooth_iff_split_injection\n    (P : Algebra.Extension.{u} R S) [FormallySmooth R P.Ring] :\n    Algebra.FormallySmooth R S ↔ ∃ l, l ∘ₗ P.cotangentComplex = LinearMap.id := by\n  refine (Algebra.FormallySmooth.iff_split_injection P.algebraMap_surjective).trans ?_\n  let e : P.ker.Cotangent ≃ₗ[P.Ring] P.Cotangent :=\n    { __ := AddEquiv.refl _, map_smul' r m := by ext1; simp; rfl }\n  constructor\n  · intro ⟨l, hl⟩\n    exact ⟨(e.comp l).extendScalarsOfSurjective P.algebraMap_surjective,\n      LinearMap.ext (DFunLike.congr_fun hl : _)⟩\n  · intro ⟨l, hl⟩\n    exact ⟨e.symm.toLinearMap ∘ₗ l.restrictScalars P.Ring,\n      LinearMap.ext (DFunLike.congr_fun hl : _)⟩\n\n"}
{"name":"Algebra.FormallySmooth.iff_injective_and_split","module":"Mathlib.RingTheory.Smooth.Kaehler","initialProofState":"R P S : Type u\ninst✝⁷ : CommRing R\ninst✝⁶ : CommRing P\ninst✝⁵ : CommRing S\ninst✝⁴ : Algebra R P\ninst✝³ : Algebra P S\ninst✝² : Algebra R S\ninst✝¹ : IsScalarTower R P S\nhf : Function.Surjective ⇑(algebraMap P S)\ninst✝ : Algebra.FormallySmooth R P\n⊢ Iff (Algebra.FormallySmooth R S) (And (Function.Injective ⇑(KaehlerDifferential.kerCotangentToTensor R P S)) (Exists fun l => Eq ((KaehlerDifferential.mapBaseChange R P S).comp l) LinearMap.id))","decl":"include hf in\n/--\nGiven a formally smooth `R`-algebra `P` and a surjective algebra homomorphism `f : P →ₐ[R] S`\nwith kernel `I` (typically a presentation `R[X] → S`),\nthen `S` is formally smooth iff `I/I² → S ⊗[P] Ω[S⁄R]` is injective and\n`S ⊗[P] Ω[P⁄R] → Ω[S⁄R]` is split surjective.\n-/\ntheorem Algebra.FormallySmooth.iff_injective_and_split :\n    Algebra.FormallySmooth R S ↔ Function.Injective (kerCotangentToTensor R P S) ∧\n      ∃ l, (KaehlerDifferential.mapBaseChange R P S) ∘ₗ l = LinearMap.id := by\n  rw [Algebra.FormallySmooth.iff_split_injection hf]\n  refine (and_iff_right (KaehlerDifferential.mapBaseChange_surjective R _ _ hf)).symm.trans ?_\n  refine Iff.trans (((exact_kerCotangentToTensor_mapBaseChange R _ _ hf).split_tfae'\n    (g := (KaehlerDifferential.mapBaseChange R P S).restrictScalars P)).out 1 0)\n    (and_congr Iff.rfl ?_)\n  rw [(LinearMap.extendScalarsOfSurjectiveEquiv hf).surjective.exists]\n  simp only [LinearMap.ext_iff, LinearMap.coe_comp, LinearMap.coe_restrictScalars,\n    Function.comp_apply, LinearMap.extendScalarsOfSurjective_apply, LinearMap.id_coe, id_eq]\n\n"}
{"name":"instProjectiveKaehlerDifferential","module":"Mathlib.RingTheory.Smooth.Kaehler","initialProofState":"R P : Type u\ninst✝³ : CommRing R\ninst✝² : CommRing P\ninst✝¹ : Algebra R P\ninst✝ : Algebra.FormallySmooth R P\n⊢ Module.Projective P (KaehlerDifferential R P)","decl":"instance : Module.Projective P (Ω[P⁄R]) :=\n  (Algebra.FormallySmooth.iff_injective_and_projective'.mp ‹_›).2\n\n"}
{"name":"Algebra.FormallySmooth.iff_injective_and_projective","module":"Mathlib.RingTheory.Smooth.Kaehler","initialProofState":"R P S : Type u\ninst✝⁷ : CommRing R\ninst✝⁶ : CommRing P\ninst✝⁵ : CommRing S\ninst✝⁴ : Algebra R P\ninst✝³ : Algebra P S\ninst✝² : Algebra R S\ninst✝¹ : IsScalarTower R P S\nhf : Function.Surjective ⇑(algebraMap P S)\ninst✝ : Algebra.FormallySmooth R P\n⊢ Iff (Algebra.FormallySmooth R S) (And (Function.Injective ⇑(KaehlerDifferential.kerCotangentToTensor R P S)) (Module.Projective S (KaehlerDifferential R S)))","decl":"include hf in\n/--\nGiven a formally smooth `R`-algebra `P` and a surjective algebra homomorphism `f : P →ₐ[R] S`\nwith kernel `I` (typically a presentation `R[X] → S`),\nthen `S` is formally smooth iff `I/I² → S ⊗[P] Ω[P⁄R]` is injective and `Ω[S/R]` is projective.\n-/\ntheorem Algebra.FormallySmooth.iff_injective_and_projective :\n    Algebra.FormallySmooth R S ↔\n        Function.Injective (kerCotangentToTensor R P S) ∧ Module.Projective S (Ω[S⁄R]) := by\n  rw [Algebra.FormallySmooth.iff_injective_and_split hf,\n    ← Module.Projective.iff_split_of_projective]\n  exact KaehlerDifferential.mapBaseChange_surjective _ _ _ hf\n\n"}
{"name":"Algebra.FormallySmooth.iff_subsingleton_and_projective","module":"Mathlib.RingTheory.Smooth.Kaehler","initialProofState":"R S : Type u\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\n⊢ Iff (Algebra.FormallySmooth R S) (And (Subsingleton (Algebra.H1Cotangent R S)) (Module.Projective S (KaehlerDifferential R S)))","decl":"/--\nAn algebra is formally smooth if and only if `H¹(L_{R/S}) = 0` and `Ω_{S/R}` is projective.\n-/\n@[stacks 031J]\ntheorem Algebra.FormallySmooth.iff_subsingleton_and_projective :\n    Algebra.FormallySmooth R S ↔\n        Subsingleton (Algebra.H1Cotangent R S) ∧ Module.Projective S (Ω[S⁄R]) := by\n  refine (Algebra.FormallySmooth.iff_injective_and_projective\n    (Generators.self R S).algebraMap_surjective).trans (and_congr ?_ Iff.rfl)\n  show Function.Injective (Generators.self R S).toExtension.cotangentComplex ↔ _\n  rw [← LinearMap.ker_eq_bot, ← Submodule.subsingleton_iff_eq_bot]\n  rfl\n\n"}
{"name":"instSubsingletonH1CotangentOfFormallySmooth","module":"Mathlib.RingTheory.Smooth.Kaehler","initialProofState":"R S : Type u\ninst✝³ : CommRing R\ninst✝² : CommRing S\ninst✝¹ : Algebra R S\ninst✝ : Algebra.FormallySmooth R S\n⊢ Subsingleton (Algebra.H1Cotangent R S)","decl":"instance [Algebra.FormallySmooth R S] : Subsingleton (Algebra.H1Cotangent R S) :=\n  (Algebra.FormallySmooth.iff_subsingleton_and_projective.mp ‹_›).1\n\n"}
{"name":"Algebra.Extension.CotangentSpace.map_toInfinitesimal_bijective","module":"Mathlib.RingTheory.Smooth.Kaehler","initialProofState":"R S : Type u\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nP : Algebra.Extension R S\n⊢ Function.Bijective ⇑(Algebra.Extension.CotangentSpace.map P.toInfinitesimal)","decl":"lemma CotangentSpace.map_toInfinitesimal_bijective (P : Extension.{u} R S) :\n    Function.Bijective (CotangentSpace.map P.toInfinitesimal) := by\n  suffices CotangentSpace.map P.toInfinitesimal =\n      (tensorKaehlerQuotKerSqEquiv _ _ _).symm.toLinearMap by\n    rw [this]; exact(tensorKaehlerQuotKerSqEquiv _ _ _).symm.bijective\n  letI : Algebra P.Ring P.infinitesimal.Ring := inferInstanceAs (Algebra P.Ring (P.Ring ⧸ _))\n  have : IsScalarTower P.Ring P.infinitesimal.Ring S := .of_algebraMap_eq' rfl\n  apply LinearMap.restrictScalars_injective P.Ring\n  ext x a\n  dsimp\n  simp only [map_tmul, id.map_eq_id, RingHom.id_apply, Hom.toAlgHom_apply]\n  exact (tensorKaehlerQuotKerSqEquiv_symm_tmul_D _ _).symm\n\n"}
{"name":"Algebra.Extension.Cotangent.map_toInfinitesimal_bijective","module":"Mathlib.RingTheory.Smooth.Kaehler","initialProofState":"R S : Type u\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nP : Algebra.Extension R S\n⊢ Function.Bijective ⇑(Algebra.Extension.Cotangent.map P.toInfinitesimal)","decl":"lemma Cotangent.map_toInfinitesimal_bijective (P : Extension.{u} R S) :\n    Function.Bijective (Cotangent.map P.toInfinitesimal) := by\n  constructor\n  · rw [injective_iff_map_eq_zero]\n    intro x hx\n    obtain ⟨x, rfl⟩ := Cotangent.mk_surjective x\n    have hx : x.1 ∈ P.ker ^ 2 := by\n      apply_fun Cotangent.val at hx\n      simp only [map_mk, Hom.toAlgHom_apply, val_mk, val_zero, Ideal.toCotangent_eq_zero,\n        Extension.ker_infinitesimal] at hx\n      rw [Ideal.cotangentIdeal_square] at hx\n      simpa only [toInfinitesimal, Ideal.mem_bot, infinitesimal,\n        Ideal.Quotient.eq_zero_iff_mem] using hx\n    ext\n    simpa [Ideal.toCotangent_eq_zero]\n  · intro x\n    obtain ⟨⟨x, hx⟩, rfl⟩ := Cotangent.mk_surjective x\n    obtain ⟨x, rfl⟩ := Ideal.Quotient.mk_surjective x\n    rw [ker_infinitesimal, Ideal.mk_mem_cotangentIdeal] at hx\n    exact ⟨.mk ⟨x, hx⟩, rfl⟩\n\n"}
{"name":"Algebra.Extension.H1Cotangent.map_toInfinitesimal_bijective","module":"Mathlib.RingTheory.Smooth.Kaehler","initialProofState":"R S : Type u\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nP : Algebra.Extension R S\n⊢ Function.Bijective ⇑(Algebra.Extension.H1Cotangent.map P.toInfinitesimal)","decl":"lemma H1Cotangent.map_toInfinitesimal_bijective (P : Extension.{u} R S) :\n    Function.Bijective (H1Cotangent.map P.toInfinitesimal) := by\n  constructor\n  · intro x y e\n    ext1\n    exact (Cotangent.map_toInfinitesimal_bijective P).1 (congr_arg Subtype.val e)\n  · intro ⟨x, hx⟩\n    obtain ⟨x, rfl⟩ := (Cotangent.map_toInfinitesimal_bijective P).2 x\n    refine ⟨⟨x, ?_⟩, rfl⟩\n    simpa [← CotangentSpace.map_cotangentComplex,\n      map_eq_zero_iff _ (CotangentSpace.map_toInfinitesimal_bijective P).injective] using hx\n\n"}
{"name":"Algebra.Extension.H1Cotangent.equivOfFormallySmooth_toLinearMap","module":"Mathlib.RingTheory.Smooth.Kaehler","initialProofState":"R S : Type u\ninst✝⁴ : CommRing R\ninst✝³ : CommRing S\ninst✝² : Algebra R S\nP₁ P₂ : Algebra.Extension R S\nf : P₁.Hom P₂\ninst✝¹ : Algebra.FormallySmooth R P₁.Ring\ninst✝ : Algebra.FormallySmooth R P₂.Ring\n⊢ Eq (↑(Algebra.Extension.H1Cotangent.equivOfFormallySmooth P₁ P₂)) (Algebra.Extension.H1Cotangent.map f)","decl":"lemma H1Cotangent.equivOfFormallySmooth_toLinearMap {P₁ P₂ : Extension R S} (f : P₁.Hom P₂)\n    [FormallySmooth R P₁.Ring] [FormallySmooth R P₂.Ring] :\n    (H1Cotangent.equivOfFormallySmooth P₁ P₂).toLinearMap = map f := by\n  ext1 x\n  refine (LinearEquiv.symm_apply_eq _).mpr ?_\n  show ((map (P₁.homInfinitesimal P₂)).restrictScalars S ∘ₗ map P₁.toInfinitesimal) x =\n    ((map P₂.toInfinitesimal).restrictScalars S ∘ₗ map f) x\n  rw [← map_comp, ← map_comp, map_eq]\n\n"}
{"name":"Algebra.Extension.H1Cotangent.equivOfFormallySmooth_apply","module":"Mathlib.RingTheory.Smooth.Kaehler","initialProofState":"R S : Type u\ninst✝⁴ : CommRing R\ninst✝³ : CommRing S\ninst✝² : Algebra R S\nP₁ P₂ : Algebra.Extension R S\nf : P₁.Hom P₂\ninst✝¹ : Algebra.FormallySmooth R P₁.Ring\ninst✝ : Algebra.FormallySmooth R P₂.Ring\nx : P₁.H1Cotangent\n⊢ Eq ((Algebra.Extension.H1Cotangent.equivOfFormallySmooth P₁ P₂) x) ((Algebra.Extension.H1Cotangent.map f) x)","decl":"lemma H1Cotangent.equivOfFormallySmooth_apply {P₁ P₂ : Extension R S} (f : P₁.Hom P₂)\n    [FormallySmooth R P₁.Ring] [FormallySmooth R P₂.Ring] (x) :\n    H1Cotangent.equivOfFormallySmooth P₁ P₂ x = map f x := by\n  rw [← equivOfFormallySmooth_toLinearMap]; rfl\n\n"}
{"name":"Algebra.Extension.H1Cotangent.equivOfFormallySmooth_symm","module":"Mathlib.RingTheory.Smooth.Kaehler","initialProofState":"R S : Type u\ninst✝⁴ : CommRing R\ninst✝³ : CommRing S\ninst✝² : Algebra R S\nP₁ P₂ : Algebra.Extension R S\ninst✝¹ : Algebra.FormallySmooth R P₁.Ring\ninst✝ : Algebra.FormallySmooth R P₂.Ring\n⊢ Eq (Algebra.Extension.H1Cotangent.equivOfFormallySmooth P₁ P₂).symm (Algebra.Extension.H1Cotangent.equivOfFormallySmooth P₂ P₁)","decl":"lemma H1Cotangent.equivOfFormallySmooth_symm (P₁ P₂ : Extension R S)\n    [FormallySmooth R P₁.Ring] [FormallySmooth R P₂.Ring] :\n    (equivOfFormallySmooth P₁ P₂).symm = equivOfFormallySmooth P₂ P₁ := rfl\n\n"}
