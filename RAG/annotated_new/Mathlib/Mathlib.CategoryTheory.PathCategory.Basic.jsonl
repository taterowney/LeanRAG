{"name":"CategoryTheory.Paths.of_map","module":"Mathlib.CategoryTheory.PathCategory.Basic","initialProofState":"V : Type u‚ÇÅ\ninst‚úù : Quiver V\nX‚úù Y‚úù : V\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (CategoryTheory.Paths.of.map f) f.toPath","decl":"/-- The inclusion of a quiver `V` into its path category, as a prefunctor.\n-/\n@[simps]\ndef of : V ‚•§q Paths V where\n  obj X := X\n  map f := f.toPath\n\n"}
{"name":"CategoryTheory.Paths.of_obj","module":"Mathlib.CategoryTheory.PathCategory.Basic","initialProofState":"V : Type u‚ÇÅ\ninst‚úù : Quiver V\nX : V\n‚ä¢ Eq (CategoryTheory.Paths.of.obj X) X","decl":"/-- The inclusion of a quiver `V` into its path category, as a prefunctor.\n-/\n@[simps]\ndef of : V ‚•§q Paths V where\n  obj X := X\n  map f := f.toPath\n\n"}
{"name":"CategoryTheory.Paths.induction_fixed_source","module":"Mathlib.CategoryTheory.PathCategory.Basic","initialProofState":"V : Type u‚ÇÅ\ninst‚úù : Quiver V\na : CategoryTheory.Paths V\nP : {b : CategoryTheory.Paths V} ‚Üí Quiver.Hom a b ‚Üí Prop\nid : P (CategoryTheory.CategoryStruct.id a)\ncomp : ‚àÄ {u v : V} (p : Quiver.Hom a (CategoryTheory.Paths.of.obj u)) (q : Quiver.Hom u v), P p ‚Üí P (CategoryTheory.CategoryStruct.comp p (CategoryTheory.Paths.of.map q))\nb : CategoryTheory.Paths V\nf : Quiver.Hom a b\n‚ä¢ P f","decl":"/-- To prove a property on morphisms of a path category with given source `a`, it suffices to\nprove it for the identity and prove that the property is preserved under composition on the right\nwith length 1 paths. -/\nlemma induction_fixed_source {a : Paths V} (P : ‚àÄ {b : Paths V}, (a ‚ü∂ b) ‚Üí Prop)\n    (id : P (ùüô a))\n    (comp : ‚àÄ {u v : V} (p : a ‚ü∂ of.obj u) (q : u ‚ü∂ v), P p ‚Üí P (p ‚â´ of.map q)) :\n    ‚àÄ {b : Paths V} (f : a ‚ü∂ b), P f := by\n  intro _ f\n  induction f with\n  | nil => exact id\n  | cons _ w h => exact comp _ w h\n\n"}
{"name":"CategoryTheory.Paths.induction_fixed_target","module":"Mathlib.CategoryTheory.PathCategory.Basic","initialProofState":"V : Type u‚ÇÅ\ninst‚úù : Quiver V\nb : CategoryTheory.Paths V\nP : {a : CategoryTheory.Paths V} ‚Üí Quiver.Hom a b ‚Üí Prop\nid : P (CategoryTheory.CategoryStruct.id b)\ncomp : ‚àÄ {u v : V} (p : Quiver.Hom (CategoryTheory.Paths.of.obj v) b) (q : Quiver.Hom u v), P p ‚Üí P (CategoryTheory.CategoryStruct.comp (CategoryTheory.Paths.of.map q) p)\na : CategoryTheory.Paths V\nf : Quiver.Hom a b\n‚ä¢ P f","decl":"/-- To prove a property on morphisms of a path category with given target `b`, it suffices to prove\nit for the identity and prove that the property is preserved under composition on the left\nwith length 1 paths. -/\nlemma induction_fixed_target {b : Paths V} (P : ‚àÄ {a : Paths V}, (a ‚ü∂ b) ‚Üí Prop)\n    (id : P (ùüô b))\n    (comp : ‚àÄ {u v : V} (p : of.obj v ‚ü∂ b) (q : u ‚ü∂ v), P p ‚Üí P (of.map q ‚â´ p)) :\n    ‚àÄ {a : Paths V} (f : a ‚ü∂ b), P f := by\n  intro a f\n  generalize h : f.length = k\n  induction k generalizing f a with\n  | zero => cases f with\n    | nil => exact id\n    | cons _ _ => simp at h\n  | succ k h' =>\n    obtain ‚ü®c, f, q, hq, rfl‚ü© := f.eq_toPath_comp_of_length_eq_succ h\n    exact comp _ _ (h' _ hq)\n\n"}
{"name":"CategoryTheory.Paths.induction","module":"Mathlib.CategoryTheory.PathCategory.Basic","initialProofState":"V : Type u‚ÇÅ\ninst‚úù : Quiver V\nP : {a b : CategoryTheory.Paths V} ‚Üí Quiver.Hom a b ‚Üí Prop\nid : ‚àÄ {v : V}, P (CategoryTheory.CategoryStruct.id (CategoryTheory.Paths.of.obj v))\ncomp : ‚àÄ {u v w : V} (p : Quiver.Hom (CategoryTheory.Paths.of.obj u) (CategoryTheory.Paths.of.obj v)) (q : Quiver.Hom v w), P p ‚Üí P (CategoryTheory.CategoryStruct.comp p (CategoryTheory.Paths.of.map q))\na b : CategoryTheory.Paths V\nf : Quiver.Hom a b\n‚ä¢ P f","decl":"/-- To prove a property on morphisms of a path category, it suffices to prove it for the identity\nand prove that the property is preserved under composition on the right with length 1 paths. -/\nlemma induction (P : ‚àÄ {a b : Paths V}, (a ‚ü∂ b) ‚Üí Prop)\n    (id : ‚àÄ {v : V}, P (ùüô (of.obj v)))\n    (comp : ‚àÄ {u v w : V} (p : of.obj u ‚ü∂ of.obj v) (q : v ‚ü∂ w), P p ‚Üí P (p ‚â´ of.map q)) :\n    ‚àÄ {a b : Paths V} (f : a ‚ü∂ b), P f :=\n  fun {_} ‚Ü¶ induction_fixed_source _ id comp\n\n"}
{"name":"CategoryTheory.Paths.induction'","module":"Mathlib.CategoryTheory.PathCategory.Basic","initialProofState":"V : Type u‚ÇÅ\ninst‚úù : Quiver V\nP : {a b : CategoryTheory.Paths V} ‚Üí Quiver.Hom a b ‚Üí Prop\nid : ‚àÄ {v : V}, P (CategoryTheory.CategoryStruct.id (CategoryTheory.Paths.of.obj v))\ncomp : ‚àÄ {u v w : V} (p : Quiver.Hom u v) (q : Quiver.Hom (CategoryTheory.Paths.of.obj v) (CategoryTheory.Paths.of.obj w)), P q ‚Üí P (CategoryTheory.CategoryStruct.comp (CategoryTheory.Paths.of.map p) q)\na b : CategoryTheory.Paths V\nf : Quiver.Hom a b\n‚ä¢ P f","decl":"/-- To prove a property on morphisms of a path category, it suffices to prove it for the identity\nand prove that the property is preserved under composition on the left with length 1 paths. -/\nlemma induction' (P : ‚àÄ {a b : Paths V}, (a ‚ü∂ b) ‚Üí Prop)\n    (id : ‚àÄ {v : V}, P (ùüô (of.obj v)))\n    (comp : ‚àÄ {u v w : V} (p : u ‚ü∂ v) (q : of.obj v ‚ü∂ of.obj w), P q ‚Üí P (of.map p ‚â´ q)) :\n    ‚àÄ {a b : Paths V} (f : a ‚ü∂ b), P f := by\n  intro a b\n  revert a\n  exact induction_fixed_target (P := fun f ‚Ü¶ P f) id (fun _ _ ‚Ü¶ comp _ _)\n\n"}
{"name":"CategoryTheory.Paths.lift_nil","module":"Mathlib.CategoryTheory.PathCategory.Basic","initialProofState":"V : Type u‚ÇÅ\ninst‚úù¬π : Quiver V\nC : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nœÜ : Prefunctor V C\nX : V\n‚ä¢ Eq ((CategoryTheory.Paths.lift œÜ).map Quiver.Path.nil) (CategoryTheory.CategoryStruct.id (œÜ.obj X))","decl":"@[simp]\ntheorem lift_nil {C} [Category C] (œÜ : V ‚•§q C) (X : V) :\n    (lift œÜ).map Quiver.Path.nil = ùüô (œÜ.obj X) := rfl\n\n"}
{"name":"CategoryTheory.Paths.lift_cons","module":"Mathlib.CategoryTheory.PathCategory.Basic","initialProofState":"V : Type u‚ÇÅ\ninst‚úù¬π : Quiver V\nC : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nœÜ : Prefunctor V C\nX Y Z : V\np : Quiver.Path X Y\nf : Quiver.Hom Y Z\n‚ä¢ Eq ((CategoryTheory.Paths.lift œÜ).map (p.cons f)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Paths.lift œÜ).map p) (œÜ.map f))","decl":"@[simp]\ntheorem lift_cons {C} [Category C] (œÜ : V ‚•§q C) {X Y Z : V} (p : Quiver.Path X Y) (f : Y ‚ü∂ Z) :\n    (lift œÜ).map (p.cons f) = (lift œÜ).map p ‚â´ œÜ.map f := rfl\n\n"}
{"name":"CategoryTheory.Paths.lift_toPath","module":"Mathlib.CategoryTheory.PathCategory.Basic","initialProofState":"V : Type u‚ÇÅ\ninst‚úù¬π : Quiver V\nC : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nœÜ : Prefunctor V C\nX Y : V\nf : Quiver.Hom X Y\n‚ä¢ Eq ((CategoryTheory.Paths.lift œÜ).map f.toPath) (œÜ.map f)","decl":"@[simp]\ntheorem lift_toPath {C} [Category C] (œÜ : V ‚•§q C) {X Y : V} (f : X ‚ü∂ Y) :\n    (lift œÜ).map f.toPath = œÜ.map f := by\n  dsimp [Quiver.Hom.toPath, lift]\n  simp\n\n"}
{"name":"CategoryTheory.Paths.lift_spec","module":"Mathlib.CategoryTheory.PathCategory.Basic","initialProofState":"V : Type u‚ÇÅ\ninst‚úù¬π : Quiver V\nC : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nœÜ : Prefunctor V C\n‚ä¢ Eq (CategoryTheory.Paths.of.comp (CategoryTheory.Paths.lift œÜ).toPrefunctor) œÜ","decl":"theorem lift_spec {C} [Category C] (œÜ : V ‚•§q C) : of ‚ãôq (lift œÜ).toPrefunctor = œÜ := by\n  fapply Prefunctor.ext\n  ¬∑ rintro X\n    rfl\n  ¬∑ rintro X Y f\n    rcases œÜ with ‚ü®œÜo, œÜm‚ü©\n    dsimp [lift, Quiver.Hom.toPath]\n    simp only [Category.id_comp]\n\n"}
{"name":"CategoryTheory.Paths.lift_unique","module":"Mathlib.CategoryTheory.PathCategory.Basic","initialProofState":"V : Type u‚ÇÅ\ninst‚úù¬π : Quiver V\nC : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nœÜ : Prefunctor V C\nŒ¶ : CategoryTheory.Functor (CategoryTheory.Paths V) C\nhŒ¶ : Eq (CategoryTheory.Paths.of.comp Œ¶.toPrefunctor) œÜ\n‚ä¢ Eq Œ¶ (CategoryTheory.Paths.lift œÜ)","decl":"theorem lift_unique {C} [Category C] (œÜ : V ‚•§q C) (Œ¶ : Paths V ‚•§ C)\n    (hŒ¶ : of ‚ãôq Œ¶.toPrefunctor = œÜ) : Œ¶ = lift œÜ := by\n  subst_vars\n  fapply Functor.ext\n  ¬∑ rintro X\n    rfl\n  ¬∑ rintro X Y f\n    dsimp [lift]\n    induction f with\n    | nil =>\n      simp only [Category.comp_id]\n      apply Functor.map_id\n    | cons p f' ih =>\n      simp only [Category.comp_id, Category.id_comp] at ih ‚ä¢\n      -- Porting note: Had to do substitute `p.cons f'` and `f'.toPath` by their fully qualified\n      -- versions in this `have` clause (elsewhere too).\n      have : Œ¶.map (Quiver.Path.cons p f') = Œ¶.map p ‚â´ Œ¶.map (Quiver.Hom.toPath f') := by\n        convert Functor.map_comp Œ¶ p (Quiver.Hom.toPath f')\n      rw [this, ih]\n\n"}
{"name":"CategoryTheory.Paths.ext_functor","module":"Mathlib.CategoryTheory.PathCategory.Basic","initialProofState":"V : Type u‚ÇÅ\ninst‚úù¬π : Quiver V\nC : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nF G : CategoryTheory.Functor (CategoryTheory.Paths V) C\nh_obj : Eq F.obj G.obj\nh : ‚àÄ (a b : V) (e : Quiver.Hom a b), Eq (F.map e.toPath) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ‚ãØ) (CategoryTheory.CategoryStruct.comp (G.map e.toPath) (CategoryTheory.eqToHom ‚ãØ)))\n‚ä¢ Eq F G","decl":"/-- Two functors out of a path category are equal when they agree on singleton paths. -/\n@[ext (iff := false)]\ntheorem ext_functor {C} [Category C] {F G : Paths V ‚•§ C} (h_obj : F.obj = G.obj)\n    (h : ‚àÄ (a b : V) (e : a ‚ü∂ b), F.map e.toPath =\n        eqToHom (congr_fun h_obj a) ‚â´ G.map e.toPath ‚â´ eqToHom (congr_fun h_obj.symm b)) :\n    F = G := by\n  fapply Functor.ext\n  ¬∑ intro X\n    rw [h_obj]\n  ¬∑ intro X Y f\n    induction' f with Y' Z' g e ih\n    ¬∑ erw [F.map_id, G.map_id, Category.id_comp, eqToHom_trans, eqToHom_refl]\n    ¬∑ erw [F.map_comp g (Quiver.Hom.toPath e), G.map_comp g (Quiver.Hom.toPath e), ih, h]\n      simp only [Category.id_comp, eqToHom_refl, eqToHom_trans_assoc, Category.assoc]\n\n"}
{"name":"CategoryTheory.Prefunctor.mapPath_comp'","module":"Mathlib.CategoryTheory.PathCategory.Basic","initialProofState":"V : Type u‚ÇÅ\ninst‚úù¬π : Quiver V\nW : Type u‚ÇÇ\ninst‚úù : Quiver W\nF : Prefunctor V W\nX Y Z : CategoryTheory.Paths V\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\n‚ä¢ Eq (F.mapPath (CategoryTheory.CategoryStruct.comp f g)) ((F.mapPath f).comp (F.mapPath g))","decl":"@[simp]\ntheorem Prefunctor.mapPath_comp' (F : V ‚•§q W) {X Y Z : Paths V} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) :\n    F.mapPath (f ‚â´ g) = (F.mapPath f).comp (F.mapPath g) :=\n  Prefunctor.mapPath_comp _ _ _\n\n"}
{"name":"CategoryTheory.composePath_nil","module":"Mathlib.CategoryTheory.PathCategory.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : C\n‚ä¢ Eq (CategoryTheory.composePath Quiver.Path.nil) (CategoryTheory.CategoryStruct.id X)","decl":"@[simp] lemma composePath_nil {X : C} : composePath (Path.nil : Path X X) = ùüô X := rfl\n\n"}
{"name":"CategoryTheory.composePath_cons","module":"Mathlib.CategoryTheory.PathCategory.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y Z : C\np : Quiver.Path X Y\ne : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.composePath (p.cons e)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.composePath p) e)","decl":"@[simp] lemma composePath_cons {X Y Z : C} (p : Path X Y) (e : Y ‚ü∂ Z) :\n  composePath (p.cons e) = composePath p ‚â´ e := rfl\n\n"}
{"name":"CategoryTheory.composePath_toPath","module":"Mathlib.CategoryTheory.PathCategory.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nf : Quiver.Hom X Y\n‚ä¢ Eq (CategoryTheory.composePath f.toPath) f","decl":"@[simp]\ntheorem composePath_toPath {X Y : C} (f : X ‚ü∂ Y) : composePath f.toPath = f := Category.id_comp _\n\n"}
{"name":"CategoryTheory.composePath_comp","module":"Mathlib.CategoryTheory.PathCategory.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y Z : C\nf : Quiver.Path X Y\ng : Quiver.Path Y Z\n‚ä¢ Eq (CategoryTheory.composePath (f.comp g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.composePath f) (CategoryTheory.composePath g))","decl":"@[simp]\ntheorem composePath_comp {X Y Z : C} (f : Path X Y) (g : Path Y Z) :\n    composePath (f.comp g) = composePath f ‚â´ composePath g := by\n  induction' g with Y' Z' g e ih\n  ¬∑ simp\n  ¬∑ simp [ih]\n\n"}
{"name":"CategoryTheory.composePath_id","module":"Mathlib.CategoryTheory.PathCategory.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : CategoryTheory.Paths C\n‚ä¢ Eq (CategoryTheory.composePath (CategoryTheory.CategoryStruct.id X)) (CategoryTheory.CategoryStruct.id (id X))","decl":"@[simp]\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO get rid of `(id X : C)` somehow?\ntheorem composePath_id {X : Paths C} : composePath (ùüô X) = ùüô (id X : C) := rfl\n\n"}
{"name":"CategoryTheory.composePath_comp'","module":"Mathlib.CategoryTheory.PathCategory.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y Z : CategoryTheory.Paths C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.composePath (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.composePath f) (CategoryTheory.composePath g))","decl":"@[simp]\ntheorem composePath_comp' {X Y Z : Paths C} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) :\n    composePath (f ‚â´ g) = composePath f ‚â´ composePath g :=\n  composePath_comp f g\n\n"}
{"name":"CategoryTheory.pathComposition_obj","module":"Mathlib.CategoryTheory.PathCategory.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : CategoryTheory.Paths C\n‚ä¢ Eq ((CategoryTheory.pathComposition C).obj X) X","decl":"/-- Composition of paths as functor from the path category of a category to the category. -/\n@[simps]\ndef pathComposition : Paths C ‚•§ C where\n  obj X := X\n  map f := composePath f\n\n-- TODO: This, and what follows, should be generalized to\n-- the `HomRel` for the kernel of any functor.\n-- Indeed, this should be part of an equivalence between congruence relations on a category `C`\n-- and full, essentially surjective functors out of `C`.\n"}
{"name":"CategoryTheory.pathComposition_map","module":"Mathlib.CategoryTheory.PathCategory.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX‚úù Y‚úù : CategoryTheory.Paths C\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.pathComposition C).map f) (CategoryTheory.composePath f)","decl":"/-- Composition of paths as functor from the path category of a category to the category. -/\n@[simps]\ndef pathComposition : Paths C ‚•§ C where\n  obj X := X\n  map f := composePath f\n\n-- TODO: This, and what follows, should be generalized to\n-- the `HomRel` for the kernel of any functor.\n-- Indeed, this should be part of an equivalence between congruence relations on a category `C`\n-- and full, essentially surjective functors out of `C`.\n"}
{"name":"CategoryTheory.toQuotientPaths_obj_as","module":"Mathlib.CategoryTheory.PathCategory.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : C\n‚ä¢ Eq ((CategoryTheory.toQuotientPaths C).obj X).as X","decl":"/-- The functor from a category to the canonical quotient of its path category. -/\n@[simps]\ndef toQuotientPaths : C ‚•§ Quotient (pathsHomRel C) where\n  obj X := Quotient.mk X\n  map f := Quot.mk _ f.toPath\n  map_id X := Quot.sound (Quotient.CompClosure.of _ _ _ (by simp))\n  map_comp f g := Quot.sound (Quotient.CompClosure.of _ _ _ (by simp))\n\n"}
{"name":"CategoryTheory.toQuotientPaths_map","module":"Mathlib.CategoryTheory.PathCategory.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX‚úù Y‚úù : C\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.toQuotientPaths C).map f) (Quot.mk (CategoryTheory.Quotient.CompClosure (CategoryTheory.pathsHomRel C)) f.toPath)","decl":"/-- The functor from a category to the canonical quotient of its path category. -/\n@[simps]\ndef toQuotientPaths : C ‚•§ Quotient (pathsHomRel C) where\n  obj X := Quotient.mk X\n  map f := Quot.mk _ f.toPath\n  map_id X := Quot.sound (Quotient.CompClosure.of _ _ _ (by simp))\n  map_comp f g := Quot.sound (Quotient.CompClosure.of _ _ _ (by simp))\n\n"}
{"name":"CategoryTheory.quotientPathsTo_map","module":"Mathlib.CategoryTheory.PathCategory.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\na b : CategoryTheory.Quotient (CategoryTheory.pathsHomRel C)\nhf : Quiver.Hom a b\n‚ä¢ Eq ((CategoryTheory.quotientPathsTo C).map hf) (Quot.liftOn hf (fun f => CategoryTheory.composePath f) ‚ãØ)","decl":"/-- The functor from the canonical quotient of a path category of a category\nto the original category. -/\n@[simps!]\ndef quotientPathsTo : Quotient (pathsHomRel C) ‚•§ C :=\n  Quotient.lift _ (pathComposition C) fun _ _ _ _ w => w\n\n"}
{"name":"CategoryTheory.quotientPathsTo_obj","module":"Mathlib.CategoryTheory.PathCategory.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\na : CategoryTheory.Quotient (CategoryTheory.pathsHomRel C)\n‚ä¢ Eq ((CategoryTheory.quotientPathsTo C).obj a) a.as","decl":"/-- The functor from the canonical quotient of a path category of a category\nto the original category. -/\n@[simps!]\ndef quotientPathsTo : Quotient (pathsHomRel C) ‚•§ C :=\n  Quotient.lift _ (pathComposition C) fun _ _ _ _ w => w\n\n"}
