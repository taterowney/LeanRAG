{"name":"instInfiniteFreeMonoidOfNonempty","module":"Mathlib.SetTheory.Cardinal.Free","initialProofState":"α : Type u\ninst✝ : Nonempty α\n⊢ Infinite (FreeMonoid α)","decl":"@[to_additive]\ninstance [Nonempty α] : Infinite (FreeMonoid α) := inferInstanceAs <| Infinite (List α)\n\n"}
{"name":"instInfiniteFreeAddMonoidOfNonempty","module":"Mathlib.SetTheory.Cardinal.Free","initialProofState":"α : Type u\ninst✝ : Nonempty α\n⊢ Infinite (FreeAddMonoid α)","decl":"@[to_additive]\ninstance [Nonempty α] : Infinite (FreeMonoid α) := inferInstanceAs <| Infinite (List α)\n\n"}
{"name":"instInfiniteFreeGroupOfNonempty","module":"Mathlib.SetTheory.Cardinal.Free","initialProofState":"α : Type u\ninst✝ : Nonempty α\n⊢ Infinite (FreeGroup α)","decl":"@[to_additive]\ninstance [Nonempty α] : Infinite (FreeGroup α) := by\n  classical\n  exact Infinite.of_surjective FreeGroup.norm FreeGroup.norm_surjective\n\n"}
{"name":"instInfiniteFreeAddGroupOfNonempty","module":"Mathlib.SetTheory.Cardinal.Free","initialProofState":"α : Type u\ninst✝ : Nonempty α\n⊢ Infinite (FreeAddGroup α)","decl":"@[to_additive]\ninstance [Nonempty α] : Infinite (FreeGroup α) := by\n  classical\n  exact Infinite.of_surjective FreeGroup.norm FreeGroup.norm_surjective\n\n"}
{"name":"instInfiniteFreeAbelianGroupOfNonempty","module":"Mathlib.SetTheory.Cardinal.Free","initialProofState":"α : Type u\ninst✝ : Nonempty α\n⊢ Infinite (FreeAbelianGroup α)","decl":"instance [Nonempty α] : Infinite (FreeAbelianGroup α) :=\n  (FreeAbelianGroup.equivFinsupp α).toEquiv.infinite_iff.2 inferInstance\n\n"}
{"name":"instInfiniteFreeRing","module":"Mathlib.SetTheory.Cardinal.Free","initialProofState":"α : Type u\n⊢ Infinite (FreeRing α)","decl":"instance : Infinite (FreeRing α) := by unfold FreeRing; infer_instance\n\n"}
{"name":"instInfiniteFreeCommRing","module":"Mathlib.SetTheory.Cardinal.Free","initialProofState":"α : Type u\n⊢ Infinite (FreeCommRing α)","decl":"instance : Infinite (FreeCommRing α) := by unfold FreeCommRing; infer_instance\n\n"}
{"name":"Cardinal.mk_abelianization_le","module":"Mathlib.SetTheory.Cardinal.Free","initialProofState":"G : Type u\ninst✝ : Group G\n⊢ LE.le (Cardinal.mk (Abelianization G)) (Cardinal.mk G)","decl":"theorem mk_abelianization_le (G : Type u) [Group G] :\n    #(Abelianization G) ≤ #G := Cardinal.mk_le_of_surjective Quotient.mk_surjective\n\n"}
{"name":"Cardinal.mk_freeAddMonoid","module":"Mathlib.SetTheory.Cardinal.Free","initialProofState":"α : Type u\ninst✝ : Nonempty α\n⊢ Eq (Cardinal.mk (FreeAddMonoid α)) (Max.max (Cardinal.mk α) Cardinal.aleph0)","decl":"@[to_additive (attr := simp)]\ntheorem mk_freeMonoid [Nonempty α] : #(FreeMonoid α) = max #α ℵ₀ :=\n    Cardinal.mk_list_eq_max_mk_aleph0 _\n\n"}
{"name":"Cardinal.mk_freeMonoid","module":"Mathlib.SetTheory.Cardinal.Free","initialProofState":"α : Type u\ninst✝ : Nonempty α\n⊢ Eq (Cardinal.mk (FreeMonoid α)) (Max.max (Cardinal.mk α) Cardinal.aleph0)","decl":"@[to_additive (attr := simp)]\ntheorem mk_freeMonoid [Nonempty α] : #(FreeMonoid α) = max #α ℵ₀ :=\n    Cardinal.mk_list_eq_max_mk_aleph0 _\n\n"}
{"name":"Cardinal.mk_freeGroup","module":"Mathlib.SetTheory.Cardinal.Free","initialProofState":"α : Type u\ninst✝ : Nonempty α\n⊢ Eq (Cardinal.mk (FreeGroup α)) (Max.max (Cardinal.mk α) Cardinal.aleph0)","decl":"@[to_additive (attr := simp)]\ntheorem mk_freeGroup [Nonempty α] : #(FreeGroup α) = max #α ℵ₀ := by\n  classical\n  apply le_antisymm\n  · apply (mk_le_of_injective (FreeGroup.toWord_injective (α := α))).trans_eq\n    simp [Cardinal.mk_list_eq_max_mk_aleph0]\n    obtain hα | hα := lt_or_le #α ℵ₀\n    · simp only [hα.le, max_eq_right, max_eq_right_iff]\n      exact (mul_lt_aleph0 hα (nat_lt_aleph0 2)).le\n    · rw [max_eq_left hα, max_eq_left (hα.trans <| Cardinal.le_mul_right two_ne_zero),\n        Cardinal.mul_eq_left hα _ (by simp)]\n      exact (nat_lt_aleph0 2).le.trans hα\n  · apply max_le\n    · exact mk_le_of_injective FreeGroup.of_injective\n    · simp\n\n"}
{"name":"Cardinal.mk_freeAddGroup","module":"Mathlib.SetTheory.Cardinal.Free","initialProofState":"α : Type u\ninst✝ : Nonempty α\n⊢ Eq (Cardinal.mk (FreeAddGroup α)) (Max.max (Cardinal.mk α) Cardinal.aleph0)","decl":"@[to_additive (attr := simp)]\ntheorem mk_freeGroup [Nonempty α] : #(FreeGroup α) = max #α ℵ₀ := by\n  classical\n  apply le_antisymm\n  · apply (mk_le_of_injective (FreeGroup.toWord_injective (α := α))).trans_eq\n    simp [Cardinal.mk_list_eq_max_mk_aleph0]\n    obtain hα | hα := lt_or_le #α ℵ₀\n    · simp only [hα.le, max_eq_right, max_eq_right_iff]\n      exact (mul_lt_aleph0 hα (nat_lt_aleph0 2)).le\n    · rw [max_eq_left hα, max_eq_left (hα.trans <| Cardinal.le_mul_right two_ne_zero),\n        Cardinal.mul_eq_left hα _ (by simp)]\n      exact (nat_lt_aleph0 2).le.trans hα\n  · apply max_le\n    · exact mk_le_of_injective FreeGroup.of_injective\n    · simp\n\n"}
{"name":"Cardinal.mk_freeAbelianGroup","module":"Mathlib.SetTheory.Cardinal.Free","initialProofState":"α : Type u\ninst✝ : Nonempty α\n⊢ Eq (Cardinal.mk (FreeAbelianGroup α)) (Max.max (Cardinal.mk α) Cardinal.aleph0)","decl":"@[simp]\ntheorem mk_freeAbelianGroup [Nonempty α] : #(FreeAbelianGroup α) = max #α ℵ₀ := by\n  rw [Cardinal.mk_congr (FreeAbelianGroup.equivFinsupp α).toEquiv]\n  simp\n\n"}
{"name":"Cardinal.mk_freeRing","module":"Mathlib.SetTheory.Cardinal.Free","initialProofState":"α : Type u\n⊢ Eq (Cardinal.mk (FreeRing α)) (Max.max (Cardinal.mk α) Cardinal.aleph0)","decl":"@[simp]\ntheorem mk_freeRing : #(FreeRing α) = max #α ℵ₀ := by\n  cases isEmpty_or_nonempty α <;> simp [FreeRing]\n\n"}
{"name":"Cardinal.mk_freeCommRing","module":"Mathlib.SetTheory.Cardinal.Free","initialProofState":"α : Type u\n⊢ Eq (Cardinal.mk (FreeCommRing α)) (Max.max (Cardinal.mk α) Cardinal.aleph0)","decl":"@[simp]\ntheorem mk_freeCommRing : #(FreeCommRing α) = max #α ℵ₀ := by\n  cases isEmpty_or_nonempty α <;> simp [FreeCommRing]\n\n"}
{"name":"nonempty_commRing","module":"Mathlib.SetTheory.Cardinal.Free","initialProofState":"α : Type u\ninst✝ : Nonempty α\n⊢ Nonempty (CommRing α)","decl":"/-- A commutative ring can be constructed on any non-empty type.\n\nSee also `Infinite.nonempty_field`. -/\ninstance nonempty_commRing [Nonempty α] : Nonempty (CommRing α) := by\n  obtain hR | hR := finite_or_infinite α\n  · obtain ⟨x⟩ := nonempty_fintype α\n    have : NeZero (Fintype.card α) := ⟨by inhabit α; simp⟩\n    classical\n    obtain ⟨e⟩ := Fintype.truncEquivFin α\n    exact ⟨e.commRing⟩\n  · have ⟨e⟩ : Nonempty (α ≃ FreeCommRing α) := by simp [← Cardinal.eq]\n    exact ⟨e.commRing⟩\n\n"}
{"name":"nonempty_commRing_iff","module":"Mathlib.SetTheory.Cardinal.Free","initialProofState":"α : Type u\n⊢ Iff (Nonempty (CommRing α)) (Nonempty α)","decl":"@[simp]\ntheorem nonempty_commRing_iff : Nonempty (CommRing α) ↔ Nonempty α :=\n  ⟨Nonempty.map (·.zero), fun _ => nonempty_commRing _⟩\n\n"}
{"name":"nonempty_ring_iff","module":"Mathlib.SetTheory.Cardinal.Free","initialProofState":"α : Type u\n⊢ Iff (Nonempty (Ring α)) (Nonempty α)","decl":"@[simp]\ntheorem nonempty_ring_iff : Nonempty (Ring α) ↔ Nonempty α :=\n  ⟨Nonempty.map (·.zero), fun _ => (nonempty_commRing _).map (·.toRing)⟩\n\n"}
{"name":"nonempty_commSemiring_iff","module":"Mathlib.SetTheory.Cardinal.Free","initialProofState":"α : Type u\n⊢ Iff (Nonempty (CommSemiring α)) (Nonempty α)","decl":"@[simp]\ntheorem nonempty_commSemiring_iff : Nonempty (CommSemiring α) ↔ Nonempty α :=\n  ⟨Nonempty.map (·.zero), fun _ => (nonempty_commRing _).map (·.toCommSemiring)⟩\n\n"}
{"name":"nonempty_semiring_iff","module":"Mathlib.SetTheory.Cardinal.Free","initialProofState":"α : Type u\n⊢ Iff (Nonempty (Semiring α)) (Nonempty α)","decl":"@[simp]\ntheorem nonempty_semiring_iff : Nonempty (Semiring α) ↔ Nonempty α :=\n  ⟨Nonempty.map (·.zero), fun _ => (nonempty_commRing _).map (·.toSemiring)⟩\n\n"}
