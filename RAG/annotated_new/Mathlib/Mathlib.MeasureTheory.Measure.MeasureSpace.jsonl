{"name":"MeasureTheory.ae_isMeasurablyGenerated","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\n⊢ (MeasureTheory.ae μ).IsMeasurablyGenerated","decl":"instance ae_isMeasurablyGenerated : IsMeasurablyGenerated (ae μ) :=\n  ⟨fun _s hs =>\n    let ⟨t, hst, htm, htμ⟩ := exists_measurable_superset_of_null hs\n    ⟨tᶜ, compl_mem_ae_iff.2 htμ, htm.compl, compl_subset_comm.1 hst⟩⟩\n\n"}
{"name":"MeasureTheory.ae_uIoc_iff","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : LinearOrder α\na b : α\nP : α → Prop\n⊢ Iff (Filter.Eventually (fun x => Membership.mem (Set.uIoc a b) x → P x) (MeasureTheory.ae μ)) (And (Filter.Eventually (fun x => Membership.mem (Set.Ioc a b) x → P x) (MeasureTheory.ae μ)) (Filter.Eventually (fun x => Membership.mem (Set.Ioc b a) x → P x) (MeasureTheory.ae μ)))","decl":"/-- See also `MeasureTheory.ae_restrict_uIoc_iff`. -/\ntheorem ae_uIoc_iff [LinearOrder α] {a b : α} {P : α → Prop} :\n    (∀ᵐ x ∂μ, x ∈ Ι a b → P x) ↔ (∀ᵐ x ∂μ, x ∈ Ioc a b → P x) ∧ ∀ᵐ x ∂μ, x ∈ Ioc b a → P x := by\n  simp only [uIoc_eq_union, mem_union, or_imp, eventually_and]\n\n"}
{"name":"MeasureTheory.measure_union","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns₁ s₂ : Set α\nhd : Disjoint s₁ s₂\nh : MeasurableSet s₂\n⊢ Eq (μ (Union.union s₁ s₂)) (HAdd.hAdd (μ s₁) (μ s₂))","decl":"theorem measure_union (hd : Disjoint s₁ s₂) (h : MeasurableSet s₂) : μ (s₁ ∪ s₂) = μ s₁ + μ s₂ :=\n  measure_union₀ h.nullMeasurableSet hd.aedisjoint\n\n"}
{"name":"MeasureTheory.measure_union'","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns₁ s₂ : Set α\nhd : Disjoint s₁ s₂\nh : MeasurableSet s₁\n⊢ Eq (μ (Union.union s₁ s₂)) (HAdd.hAdd (μ s₁) (μ s₂))","decl":"theorem measure_union' (hd : Disjoint s₁ s₂) (h : MeasurableSet s₁) : μ (s₁ ∪ s₂) = μ s₁ + μ s₂ :=\n  measure_union₀' h.nullMeasurableSet hd.aedisjoint\n\n"}
{"name":"MeasureTheory.measure_inter_add_diff","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nt s : Set α\nht : MeasurableSet t\n⊢ Eq (HAdd.hAdd (μ (Inter.inter s t)) (μ (SDiff.sdiff s t))) (μ s)","decl":"theorem measure_inter_add_diff (s : Set α) (ht : MeasurableSet t) : μ (s ∩ t) + μ (s \\ t) = μ s :=\n  measure_inter_add_diff₀ _ ht.nullMeasurableSet\n\n"}
{"name":"MeasureTheory.measure_diff_add_inter","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nt s : Set α\nht : MeasurableSet t\n⊢ Eq (HAdd.hAdd (μ (SDiff.sdiff s t)) (μ (Inter.inter s t))) (μ s)","decl":"theorem measure_diff_add_inter (s : Set α) (ht : MeasurableSet t) : μ (s \\ t) + μ (s ∩ t) = μ s :=\n  (add_comm _ _).trans (measure_inter_add_diff s ht)\n\n"}
{"name":"MeasureTheory.measure_union_add_inter","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nt s : Set α\nht : MeasurableSet t\n⊢ Eq (HAdd.hAdd (μ (Union.union s t)) (μ (Inter.inter s t))) (HAdd.hAdd (μ s) (μ t))","decl":"theorem measure_union_add_inter (s : Set α) (ht : MeasurableSet t) :\n    μ (s ∪ t) + μ (s ∩ t) = μ s + μ t := by\n  rw [← measure_inter_add_diff (s ∪ t) ht, Set.union_inter_cancel_right, union_diff_right, ←\n    measure_inter_add_diff s ht]\n  ac_rfl\n\n"}
{"name":"MeasureTheory.measure_union_add_inter'","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\nhs : MeasurableSet s\nt : Set α\n⊢ Eq (HAdd.hAdd (μ (Union.union s t)) (μ (Inter.inter s t))) (HAdd.hAdd (μ s) (μ t))","decl":"theorem measure_union_add_inter' (hs : MeasurableSet s) (t : Set α) :\n    μ (s ∪ t) + μ (s ∩ t) = μ s + μ t := by\n  rw [union_comm, inter_comm, measure_union_add_inter t hs, add_comm]\n\n"}
{"name":"MeasureTheory.measure_symmDiff_eq","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns t : Set α\nhs : MeasureTheory.NullMeasurableSet s μ\nht : MeasureTheory.NullMeasurableSet t μ\n⊢ Eq (μ (symmDiff s t)) (HAdd.hAdd (μ (SDiff.sdiff s t)) (μ (SDiff.sdiff t s)))","decl":"lemma measure_symmDiff_eq (hs : NullMeasurableSet s μ) (ht : NullMeasurableSet t μ) :\n    μ (s ∆ t) = μ (s \\ t) + μ (t \\ s) := by\n  simpa only [symmDiff_def, sup_eq_union]\n    using measure_union₀ (ht.diff hs) disjoint_sdiff_sdiff.aedisjoint\n\n"}
{"name":"MeasureTheory.measure_symmDiff_le","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns t u : Set α\n⊢ LE.le (μ (symmDiff s u)) (HAdd.hAdd (μ (symmDiff s t)) (μ (symmDiff t u)))","decl":"lemma measure_symmDiff_le (s t u : Set α) :\n    μ (s ∆ u) ≤ μ (s ∆ t) + μ (t ∆ u) :=\n  le_trans (μ.mono <| symmDiff_triangle s t u) (measure_union_le (s ∆ t) (t ∆ u))\n\n"}
{"name":"MeasureTheory.measure_add_measure_compl","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\nh : MeasurableSet s\n⊢ Eq (HAdd.hAdd (μ s) (μ (HasCompl.compl s))) (μ Set.univ)","decl":"theorem measure_add_measure_compl (h : MeasurableSet s) : μ s + μ sᶜ = μ univ :=\n  measure_add_measure_compl₀ h.nullMeasurableSet\n\n"}
{"name":"MeasureTheory.measure_biUnion₀","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set β\nf : β → Set α\nhs : s.Countable\nhd : s.Pairwise (Function.onFun (MeasureTheory.AEDisjoint μ) f)\nh : ∀ (b : β), Membership.mem s b → MeasureTheory.NullMeasurableSet (f b) μ\n⊢ Eq (μ (Set.iUnion fun b => Set.iUnion fun h => f b)) (tsum fun p => μ (f ↑p))","decl":"theorem measure_biUnion₀ {s : Set β} {f : β → Set α} (hs : s.Countable)\n    (hd : s.Pairwise (AEDisjoint μ on f)) (h : ∀ b ∈ s, NullMeasurableSet (f b) μ) :\n    μ (⋃ b ∈ s, f b) = ∑' p : s, μ (f p) := by\n  haveI := hs.toEncodable\n  rw [biUnion_eq_iUnion]\n  exact measure_iUnion₀ (hd.on_injective Subtype.coe_injective fun x => x.2) fun x => h x x.2\n\n"}
{"name":"MeasureTheory.measure_biUnion","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set β\nf : β → Set α\nhs : s.Countable\nhd : s.PairwiseDisjoint f\nh : ∀ (b : β), Membership.mem s b → MeasurableSet (f b)\n⊢ Eq (μ (Set.iUnion fun b => Set.iUnion fun h => f b)) (tsum fun p => μ (f ↑p))","decl":"theorem measure_biUnion {s : Set β} {f : β → Set α} (hs : s.Countable) (hd : s.PairwiseDisjoint f)\n    (h : ∀ b ∈ s, MeasurableSet (f b)) : μ (⋃ b ∈ s, f b) = ∑' p : s, μ (f p) :=\n  measure_biUnion₀ hs hd.aedisjoint fun b hb => (h b hb).nullMeasurableSet\n\n"}
{"name":"MeasureTheory.measure_sUnion₀","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nS : Set (Set α)\nhs : S.Countable\nhd : S.Pairwise (MeasureTheory.AEDisjoint μ)\nh : ∀ (s : Set α), Membership.mem S s → MeasureTheory.NullMeasurableSet s μ\n⊢ Eq (μ S.sUnion) (tsum fun s => μ ↑s)","decl":"theorem measure_sUnion₀ {S : Set (Set α)} (hs : S.Countable) (hd : S.Pairwise (AEDisjoint μ))\n    (h : ∀ s ∈ S, NullMeasurableSet s μ) : μ (⋃₀ S) = ∑' s : S, μ s := by\n  rw [sUnion_eq_biUnion, measure_biUnion₀ hs hd h]\n\n"}
{"name":"MeasureTheory.measure_sUnion","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nS : Set (Set α)\nhs : S.Countable\nhd : S.Pairwise Disjoint\nh : ∀ (s : Set α), Membership.mem S s → MeasurableSet s\n⊢ Eq (μ S.sUnion) (tsum fun s => μ ↑s)","decl":"theorem measure_sUnion {S : Set (Set α)} (hs : S.Countable) (hd : S.Pairwise Disjoint)\n    (h : ∀ s ∈ S, MeasurableSet s) : μ (⋃₀ S) = ∑' s : S, μ s := by\n  rw [sUnion_eq_biUnion, measure_biUnion hs hd h]\n\n"}
{"name":"MeasureTheory.measure_biUnion_finset₀","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nι : Type u_5\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Finset ι\nf : ι → Set α\nhd : (↑s).Pairwise (Function.onFun (MeasureTheory.AEDisjoint μ) f)\nhm : ∀ (b : ι), Membership.mem s b → MeasureTheory.NullMeasurableSet (f b) μ\n⊢ Eq (μ (Set.iUnion fun b => Set.iUnion fun h => f b)) (s.sum fun p => μ (f p))","decl":"theorem measure_biUnion_finset₀ {s : Finset ι} {f : ι → Set α}\n    (hd : Set.Pairwise (↑s) (AEDisjoint μ on f)) (hm : ∀ b ∈ s, NullMeasurableSet (f b) μ) :\n    μ (⋃ b ∈ s, f b) = ∑ p ∈ s, μ (f p) := by\n  rw [← Finset.sum_attach, Finset.attach_eq_univ, ← tsum_fintype]\n  exact measure_biUnion₀ s.countable_toSet hd hm\n\n"}
{"name":"MeasureTheory.measure_biUnion_finset","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nι : Type u_5\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Finset ι\nf : ι → Set α\nhd : (↑s).PairwiseDisjoint f\nhm : ∀ (b : ι), Membership.mem s b → MeasurableSet (f b)\n⊢ Eq (μ (Set.iUnion fun b => Set.iUnion fun h => f b)) (s.sum fun p => μ (f p))","decl":"theorem measure_biUnion_finset {s : Finset ι} {f : ι → Set α} (hd : PairwiseDisjoint (↑s) f)\n    (hm : ∀ b ∈ s, MeasurableSet (f b)) : μ (⋃ b ∈ s, f b) = ∑ p ∈ s, μ (f p) :=\n  measure_biUnion_finset₀ hd.aedisjoint fun b hb => (hm b hb).nullMeasurableSet\n\n"}
{"name":"MeasureTheory.tsum_meas_le_meas_iUnion_of_disjoint₀","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nι : Type u_8\nx✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\nAs : ι → Set α\nAs_mble : ∀ (i : ι), MeasureTheory.NullMeasurableSet (As i) μ\nAs_disj : Pairwise (Function.onFun (MeasureTheory.AEDisjoint μ) As)\n⊢ LE.le (tsum fun i => μ (As i)) (μ (Set.iUnion fun i => As i))","decl":"/-- The measure of an a.e. disjoint union (even uncountable) of null-measurable sets is at least\nthe sum of the measures of the sets. -/\ntheorem tsum_meas_le_meas_iUnion_of_disjoint₀ {ι : Type*} {_ : MeasurableSpace α} (μ : Measure α)\n    {As : ι → Set α} (As_mble : ∀ i : ι, NullMeasurableSet (As i) μ)\n    (As_disj : Pairwise (AEDisjoint μ on As)) : (∑' i, μ (As i)) ≤ μ (⋃ i, As i) := by\n  rw [ENNReal.tsum_eq_iSup_sum, iSup_le_iff]\n  intro s\n  simp only [← measure_biUnion_finset₀ (fun _i _hi _j _hj hij => As_disj hij) fun i _ => As_mble i]\n  gcongr\n  exact iUnion_subset fun _ ↦ Subset.rfl\n\n"}
{"name":"MeasureTheory.tsum_meas_le_meas_iUnion_of_disjoint","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nι : Type u_8\nx✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\nAs : ι → Set α\nAs_mble : ∀ (i : ι), MeasurableSet (As i)\nAs_disj : Pairwise (Function.onFun Disjoint As)\n⊢ LE.le (tsum fun i => μ (As i)) (μ (Set.iUnion fun i => As i))","decl":"/-- The measure of a disjoint union (even uncountable) of measurable sets is at least the sum of\nthe measures of the sets. -/\ntheorem tsum_meas_le_meas_iUnion_of_disjoint {ι : Type*} {_ : MeasurableSpace α} (μ : Measure α)\n    {As : ι → Set α} (As_mble : ∀ i : ι, MeasurableSet (As i))\n    (As_disj : Pairwise (Disjoint on As)) : (∑' i, μ (As i)) ≤ μ (⋃ i, As i) :=\n  tsum_meas_le_meas_iUnion_of_disjoint₀ μ (fun i ↦ (As_mble i).nullMeasurableSet)\n    (fun _ _ h ↦ Disjoint.aedisjoint (As_disj h))\n\n"}
{"name":"MeasureTheory.tsum_measure_preimage_singleton","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set β\nhs : s.Countable\nf : α → β\nhf : ∀ (y : β), Membership.mem s y → MeasurableSet (Set.preimage f (Singleton.singleton y))\n⊢ Eq (tsum fun b => μ (Set.preimage f (Singleton.singleton ↑b))) (μ (Set.preimage f s))","decl":"/-- If `s` is a countable set, then the measure of its preimage can be found as the sum of measures\nof the fibers `f ⁻¹' {y}`. -/\ntheorem tsum_measure_preimage_singleton {s : Set β} (hs : s.Countable) {f : α → β}\n    (hf : ∀ y ∈ s, MeasurableSet (f ⁻¹' {y})) : (∑' b : s, μ (f ⁻¹' {↑b})) = μ (f ⁻¹' s) := by\n  rw [← Set.biUnion_preimage_singleton, measure_biUnion hs (pairwiseDisjoint_fiber f s) hf]\n\n"}
{"name":"MeasureTheory.measure_preimage_eq_zero_iff_of_countable","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set β\nf : α → β\nhs : s.Countable\n⊢ Iff (Eq (μ (Set.preimage f s)) 0) (∀ (x : β), Membership.mem s x → Eq (μ (Set.preimage f (Singleton.singleton x))) 0)","decl":"lemma measure_preimage_eq_zero_iff_of_countable {s : Set β} {f : α → β} (hs : s.Countable) :\n    μ (f ⁻¹' s) = 0 ↔ ∀ x ∈ s, μ (f ⁻¹' {x}) = 0 := by\n  rw [← biUnion_preimage_singleton, measure_biUnion_null_iff hs]\n\n"}
{"name":"MeasureTheory.sum_measure_preimage_singleton","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Finset β\nf : α → β\nhf : ∀ (y : β), Membership.mem s y → MeasurableSet (Set.preimage f (Singleton.singleton y))\n⊢ Eq (s.sum fun b => μ (Set.preimage f (Singleton.singleton b))) (μ (Set.preimage f ↑s))","decl":"/-- If `s` is a `Finset`, then the measure of its preimage can be found as the sum of measures\nof the fibers `f ⁻¹' {y}`. -/\ntheorem sum_measure_preimage_singleton (s : Finset β) {f : α → β}\n    (hf : ∀ y ∈ s, MeasurableSet (f ⁻¹' {y})) : (∑ b ∈ s, μ (f ⁻¹' {b})) = μ (f ⁻¹' ↑s) := by\n  simp only [← measure_biUnion_finset (pairwiseDisjoint_fiber f s) hf,\n    Finset.set_biUnion_preimage_singleton]\n\n"}
{"name":"MeasureTheory.measure_diff_null'","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns₁ s₂ : Set α\nh : Eq (μ (Inter.inter s₁ s₂)) 0\n⊢ Eq (μ (SDiff.sdiff s₁ s₂)) (μ s₁)","decl":"theorem measure_diff_null' (h : μ (s₁ ∩ s₂) = 0) : μ (s₁ \\ s₂) = μ s₁ :=\n  measure_congr <| diff_ae_eq_self.2 h\n\n"}
{"name":"MeasureTheory.measure_add_diff","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\nhs : MeasureTheory.NullMeasurableSet s μ\nt : Set α\n⊢ Eq (HAdd.hAdd (μ s) (μ (SDiff.sdiff t s))) (μ (Union.union s t))","decl":"theorem measure_add_diff (hs : NullMeasurableSet s μ) (t : Set α) :\n    μ s + μ (t \\ s) = μ (s ∪ t) := by\n  rw [← measure_union₀' hs disjoint_sdiff_right.aedisjoint, union_diff_self]\n\n"}
{"name":"MeasureTheory.measure_diff'","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nt s : Set α\nhm : MeasureTheory.NullMeasurableSet t μ\nh_fin : Ne (μ t) Top.top\n⊢ Eq (μ (SDiff.sdiff s t)) (HSub.hSub (μ (Union.union s t)) (μ t))","decl":"theorem measure_diff' (s : Set α) (hm : NullMeasurableSet t μ) (h_fin : μ t ≠ ∞) :\n    μ (s \\ t) = μ (s ∪ t) - μ t :=\n  ENNReal.eq_sub_of_add_eq h_fin <| by rw [add_comm, measure_add_diff hm, union_comm]\n\n"}
{"name":"MeasureTheory.measure_diff","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns₁ s₂ : Set α\nh : HasSubset.Subset s₂ s₁\nh₂ : MeasureTheory.NullMeasurableSet s₂ μ\nh_fin : Ne (μ s₂) Top.top\n⊢ Eq (μ (SDiff.sdiff s₁ s₂)) (HSub.hSub (μ s₁) (μ s₂))","decl":"theorem measure_diff (h : s₂ ⊆ s₁) (h₂ : NullMeasurableSet s₂ μ) (h_fin : μ s₂ ≠ ∞) :\n    μ (s₁ \\ s₂) = μ s₁ - μ s₂ := by rw [measure_diff' _ h₂ h_fin, union_eq_self_of_subset_right h]\n\n"}
{"name":"MeasureTheory.le_measure_diff","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns₁ s₂ : Set α\n⊢ LE.le (HSub.hSub (μ s₁) (μ s₂)) (μ (SDiff.sdiff s₁ s₂))","decl":"theorem le_measure_diff : μ s₁ - μ s₂ ≤ μ (s₁ \\ s₂) :=\n  tsub_le_iff_left.2 <| (measure_le_inter_add_diff μ s₁ s₂).trans <| by\n    gcongr; apply inter_subset_right\n\n"}
{"name":"MeasureTheory.measure_eq_top_iff_of_symmDiff","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns t : Set α\nhμst : Ne (μ (symmDiff s t)) Top.top\n⊢ Iff (Eq (μ s) Top.top) (Eq (μ t) Top.top)","decl":"/-- If the measure of the symmetric difference of two sets is finite,\nthen one has infinite measure if and only if the other one does. -/\ntheorem measure_eq_top_iff_of_symmDiff (hμst : μ (s ∆ t) ≠ ∞) : μ s = ∞ ↔ μ t = ∞ := by\n  suffices h : ∀ u v, μ (u ∆ v) ≠ ∞ → μ u = ∞ → μ v = ∞\n    from ⟨h s t hμst, h t s (symmDiff_comm s t ▸ hμst)⟩\n  intro u v hμuv hμu\n  by_contra! hμv\n  apply hμuv\n  rw [Set.symmDiff_def, eq_top_iff]\n  calc\n    ∞ = μ u - μ v := by rw [ENNReal.sub_eq_top_iff.2 ⟨hμu, hμv⟩]\n    _ ≤ μ (u \\ v) := le_measure_diff\n    _ ≤ μ (u \\ v ∪ v \\ u) := measure_mono subset_union_left\n\n"}
{"name":"MeasureTheory.measure_ne_top_iff_of_symmDiff","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns t : Set α\nhμst : Ne (μ (symmDiff s t)) Top.top\n⊢ Iff (Ne (μ s) Top.top) (Ne (μ t) Top.top)","decl":"/-- If the measure of the symmetric difference of two sets is finite,\nthen one has finite measure if and only if the other one does. -/\ntheorem measure_ne_top_iff_of_symmDiff (hμst : μ (s ∆ t) ≠ ∞) : μ s ≠ ∞ ↔ μ t ≠ ∞ :=\n    (measure_eq_top_iff_of_symmDiff hμst).ne\n\n"}
{"name":"MeasureTheory.measure_diff_lt_of_lt_add","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns t : Set α\nhs : MeasureTheory.NullMeasurableSet s μ\nhst : HasSubset.Subset s t\nhs' : Ne (μ s) Top.top\nε : ENNReal\nh : LT.lt (μ t) (HAdd.hAdd (μ s) ε)\n⊢ LT.lt (μ (SDiff.sdiff t s)) ε","decl":"theorem measure_diff_lt_of_lt_add (hs : NullMeasurableSet s μ) (hst : s ⊆ t) (hs' : μ s ≠ ∞)\n    {ε : ℝ≥0∞} (h : μ t < μ s + ε) : μ (t \\ s) < ε := by\n  rw [measure_diff hst hs hs']; rw [add_comm] at h\n  exact ENNReal.sub_lt_of_lt_add (measure_mono hst) h\n\n"}
{"name":"MeasureTheory.measure_diff_le_iff_le_add","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns t : Set α\nhs : MeasureTheory.NullMeasurableSet s μ\nhst : HasSubset.Subset s t\nhs' : Ne (μ s) Top.top\nε : ENNReal\n⊢ Iff (LE.le (μ (SDiff.sdiff t s)) ε) (LE.le (μ t) (HAdd.hAdd (μ s) ε))","decl":"theorem measure_diff_le_iff_le_add (hs : NullMeasurableSet s μ) (hst : s ⊆ t) (hs' : μ s ≠ ∞)\n    {ε : ℝ≥0∞} : μ (t \\ s) ≤ ε ↔ μ t ≤ μ s + ε := by\n  rw [measure_diff hst hs hs', tsub_le_iff_left]\n\n"}
{"name":"MeasureTheory.measure_eq_measure_of_null_diff","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns t : Set α\nhst : HasSubset.Subset s t\nh_nulldiff : Eq (μ (SDiff.sdiff t s)) 0\n⊢ Eq (μ s) (μ t)","decl":"theorem measure_eq_measure_of_null_diff {s t : Set α} (hst : s ⊆ t) (h_nulldiff : μ (t \\ s) = 0) :\n    μ s = μ t := measure_congr <|\n      EventuallyLE.antisymm (HasSubset.Subset.eventuallyLE hst) (ae_le_set.mpr h_nulldiff)\n\n"}
{"name":"MeasureTheory.measure_eq_measure_of_between_null_diff","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns₁ s₂ s₃ : Set α\nh12 : HasSubset.Subset s₁ s₂\nh23 : HasSubset.Subset s₂ s₃\nh_nulldiff : Eq (μ (SDiff.sdiff s₃ s₁)) 0\n⊢ And (Eq (μ s₁) (μ s₂)) (Eq (μ s₂) (μ s₃))","decl":"theorem measure_eq_measure_of_between_null_diff {s₁ s₂ s₃ : Set α} (h12 : s₁ ⊆ s₂) (h23 : s₂ ⊆ s₃)\n    (h_nulldiff : μ (s₃ \\ s₁) = 0) : μ s₁ = μ s₂ ∧ μ s₂ = μ s₃ := by\n  have le12 : μ s₁ ≤ μ s₂ := measure_mono h12\n  have le23 : μ s₂ ≤ μ s₃ := measure_mono h23\n  have key : μ s₃ ≤ μ s₁ :=\n    calc\n      μ s₃ = μ (s₃ \\ s₁ ∪ s₁) := by rw [diff_union_of_subset (h12.trans h23)]\n      _ ≤ μ (s₃ \\ s₁) + μ s₁ := measure_union_le _ _\n      _ = μ s₁ := by simp only [h_nulldiff, zero_add]\n  exact ⟨le12.antisymm (le23.trans key), le23.antisymm (key.trans le12)⟩\n\n"}
{"name":"MeasureTheory.measure_eq_measure_smaller_of_between_null_diff","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns₁ s₂ s₃ : Set α\nh12 : HasSubset.Subset s₁ s₂\nh23 : HasSubset.Subset s₂ s₃\nh_nulldiff : Eq (μ (SDiff.sdiff s₃ s₁)) 0\n⊢ Eq (μ s₁) (μ s₂)","decl":"theorem measure_eq_measure_smaller_of_between_null_diff {s₁ s₂ s₃ : Set α} (h12 : s₁ ⊆ s₂)\n    (h23 : s₂ ⊆ s₃) (h_nulldiff : μ (s₃ \\ s₁) = 0) : μ s₁ = μ s₂ :=\n  (measure_eq_measure_of_between_null_diff h12 h23 h_nulldiff).1\n\n"}
{"name":"MeasureTheory.measure_eq_measure_larger_of_between_null_diff","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns₁ s₂ s₃ : Set α\nh12 : HasSubset.Subset s₁ s₂\nh23 : HasSubset.Subset s₂ s₃\nh_nulldiff : Eq (μ (SDiff.sdiff s₃ s₁)) 0\n⊢ Eq (μ s₂) (μ s₃)","decl":"theorem measure_eq_measure_larger_of_between_null_diff {s₁ s₂ s₃ : Set α} (h12 : s₁ ⊆ s₂)\n    (h23 : s₂ ⊆ s₃) (h_nulldiff : μ (s₃ \\ s₁) = 0) : μ s₂ = μ s₃ :=\n  (measure_eq_measure_of_between_null_diff h12 h23 h_nulldiff).2\n\n"}
{"name":"MeasureTheory.measure_compl₀","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\nh : MeasureTheory.NullMeasurableSet s μ\nhs : Ne (μ s) Top.top\n⊢ Eq (μ (HasCompl.compl s)) (HSub.hSub (μ Set.univ) (μ s))","decl":"lemma measure_compl₀ (h : NullMeasurableSet s μ) (hs : μ s ≠ ∞) :\n    μ sᶜ = μ Set.univ - μ s := by\n  rw [← measure_add_measure_compl₀ h, ENNReal.add_sub_cancel_left hs]\n\n"}
{"name":"MeasureTheory.measure_compl","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\nh₁ : MeasurableSet s\nh_fin : Ne (μ s) Top.top\n⊢ Eq (μ (HasCompl.compl s)) (HSub.hSub (μ Set.univ) (μ s))","decl":"theorem measure_compl (h₁ : MeasurableSet s) (h_fin : μ s ≠ ∞) : μ sᶜ = μ univ - μ s :=\n  measure_compl₀ h₁.nullMeasurableSet h_fin\n\n"}
{"name":"MeasureTheory.measure_inter_conull'","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns t : Set α\nht : Eq (μ (SDiff.sdiff s t)) 0\n⊢ Eq (μ (Inter.inter s t)) (μ s)","decl":"lemma measure_inter_conull' (ht : μ (s \\ t) = 0) : μ (s ∩ t) = μ s := by\n  rw [← diff_compl, measure_diff_null']; rwa [← diff_eq]\n\n"}
{"name":"MeasureTheory.measure_inter_conull","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns t : Set α\nht : Eq (μ (HasCompl.compl t)) 0\n⊢ Eq (μ (Inter.inter s t)) (μ s)","decl":"lemma measure_inter_conull (ht : μ tᶜ = 0) : μ (s ∩ t) = μ s := by\n  rw [← diff_compl, measure_diff_null ht]\n\n"}
{"name":"MeasureTheory.union_ae_eq_left_iff_ae_subset","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns t : Set α\n⊢ Iff ((MeasureTheory.ae μ).EventuallyEq (Union.union s t) s) ((MeasureTheory.ae μ).EventuallyLE t s)","decl":"@[simp]\ntheorem union_ae_eq_left_iff_ae_subset : (s ∪ t : Set α) =ᵐ[μ] s ↔ t ≤ᵐ[μ] s := by\n  rw [ae_le_set]\n  refine\n    ⟨fun h => by simpa only [union_diff_left] using (ae_eq_set.mp h).1, fun h =>\n      eventuallyLE_antisymm_iff.mpr\n        ⟨by rwa [ae_le_set, union_diff_left],\n          HasSubset.Subset.eventuallyLE subset_union_left⟩⟩\n\n"}
{"name":"MeasureTheory.union_ae_eq_right_iff_ae_subset","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns t : Set α\n⊢ Iff ((MeasureTheory.ae μ).EventuallyEq (Union.union s t) t) ((MeasureTheory.ae μ).EventuallyLE s t)","decl":"@[simp]\ntheorem union_ae_eq_right_iff_ae_subset : (s ∪ t : Set α) =ᵐ[μ] t ↔ s ≤ᵐ[μ] t := by\n  rw [union_comm, union_ae_eq_left_iff_ae_subset]\n\n"}
{"name":"MeasureTheory.ae_eq_of_ae_subset_of_measure_ge","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns t : Set α\nh₁ : (MeasureTheory.ae μ).EventuallyLE s t\nh₂ : LE.le (μ t) (μ s)\nhsm : MeasureTheory.NullMeasurableSet s μ\nht : Ne (μ t) Top.top\n⊢ (MeasureTheory.ae μ).EventuallyEq s t","decl":"theorem ae_eq_of_ae_subset_of_measure_ge (h₁ : s ≤ᵐ[μ] t) (h₂ : μ t ≤ μ s)\n    (hsm : NullMeasurableSet s μ) (ht : μ t ≠ ∞) : s =ᵐ[μ] t := by\n  refine eventuallyLE_antisymm_iff.mpr ⟨h₁, ae_le_set.mpr ?_⟩\n  replace h₂ : μ t = μ s := h₂.antisymm (measure_mono_ae h₁)\n  replace ht : μ s ≠ ∞ := h₂ ▸ ht\n  rw [measure_diff' t hsm ht, measure_congr (union_ae_eq_left_iff_ae_subset.mpr h₁), h₂, tsub_self]\n\n"}
{"name":"MeasureTheory.ae_eq_of_subset_of_measure_ge","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns t : Set α\nh₁ : HasSubset.Subset s t\nh₂ : LE.le (μ t) (μ s)\nhsm : MeasureTheory.NullMeasurableSet s μ\nht : Ne (μ t) Top.top\n⊢ (MeasureTheory.ae μ).EventuallyEq s t","decl":"/-- If `s ⊆ t`, `μ t ≤ μ s`, `μ t ≠ ∞`, and `s` is measurable, then `s =ᵐ[μ] t`. -/\ntheorem ae_eq_of_subset_of_measure_ge (h₁ : s ⊆ t) (h₂ : μ t ≤ μ s) (hsm : NullMeasurableSet s μ)\n    (ht : μ t ≠ ∞) : s =ᵐ[μ] t :=\n  ae_eq_of_ae_subset_of_measure_ge (HasSubset.Subset.eventuallyLE h₁) h₂ hsm ht\n\n"}
{"name":"MeasureTheory.measure_iUnion_congr_of_subset","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nι : Sort u_8\ninst✝ : Countable ι\ns t : ι → Set α\nhsub : ∀ (i : ι), HasSubset.Subset (s i) (t i)\nh_le : ∀ (i : ι), LE.le (μ (t i)) (μ (s i))\n⊢ Eq (μ (Set.iUnion fun i => s i)) (μ (Set.iUnion fun i => t i))","decl":"theorem measure_iUnion_congr_of_subset {ι : Sort*} [Countable ι] {s : ι → Set α} {t : ι → Set α}\n    (hsub : ∀ i, s i ⊆ t i) (h_le : ∀ i, μ (t i) ≤ μ (s i)) : μ (⋃ i, s i) = μ (⋃ i, t i) := by\n  refine le_antisymm (by gcongr; apply hsub) ?_\n  rcases Classical.em (∃ i, μ (t i) = ∞) with (⟨i, hi⟩ | htop)\n  · calc\n      μ (⋃ i, t i) ≤ ∞ := le_top\n      _ ≤ μ (s i) := hi ▸ h_le i\n      _ ≤ μ (⋃ i, s i) := measure_mono <| subset_iUnion _ _\n  push_neg at htop\n  set M := toMeasurable μ\n  have H : ∀ b, (M (t b) ∩ M (⋃ b, s b) : Set α) =ᵐ[μ] M (t b) := by\n    refine fun b => ae_eq_of_subset_of_measure_ge inter_subset_left ?_ ?_ ?_\n    · calc\n        μ (M (t b)) = μ (t b) := measure_toMeasurable _\n        _ ≤ μ (s b) := h_le b\n        _ ≤ μ (M (t b) ∩ M (⋃ b, s b)) :=\n          measure_mono <|\n            subset_inter ((hsub b).trans <| subset_toMeasurable _ _)\n              ((subset_iUnion _ _).trans <| subset_toMeasurable _ _)\n    · measurability\n    · rw [measure_toMeasurable]\n      exact htop b\n  calc\n    μ (⋃ b, t b) ≤ μ (⋃ b, M (t b)) := measure_mono (iUnion_mono fun b => subset_toMeasurable _ _)\n    _ = μ (⋃ b, M (t b) ∩ M (⋃ b, s b)) := measure_congr (EventuallyEq.countable_iUnion H).symm\n    _ ≤ μ (M (⋃ b, s b)) := measure_mono (iUnion_subset fun b => inter_subset_right)\n    _ = μ (⋃ b, s b) := measure_toMeasurable _\n\n"}
{"name":"MeasureTheory.measure_union_congr_of_subset","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns₁ s₂ t₁ t₂ : Set α\nhs : HasSubset.Subset s₁ s₂\nhsμ : LE.le (μ s₂) (μ s₁)\nht : HasSubset.Subset t₁ t₂\nhtμ : LE.le (μ t₂) (μ t₁)\n⊢ Eq (μ (Union.union s₁ t₁)) (μ (Union.union s₂ t₂))","decl":"theorem measure_union_congr_of_subset {t₁ t₂ : Set α} (hs : s₁ ⊆ s₂) (hsμ : μ s₂ ≤ μ s₁)\n    (ht : t₁ ⊆ t₂) (htμ : μ t₂ ≤ μ t₁) : μ (s₁ ∪ t₁) = μ (s₂ ∪ t₂) := by\n  rw [union_eq_iUnion, union_eq_iUnion]\n  exact measure_iUnion_congr_of_subset (Bool.forall_bool.2 ⟨ht, hs⟩) (Bool.forall_bool.2 ⟨htμ, hsμ⟩)\n\n"}
{"name":"MeasureTheory.measure_iUnion_toMeasurable","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nι : Sort u_8\ninst✝ : Countable ι\ns : ι → Set α\n⊢ Eq (μ (Set.iUnion fun i => MeasureTheory.toMeasurable μ (s i))) (μ (Set.iUnion fun i => s i))","decl":"@[simp]\ntheorem measure_iUnion_toMeasurable {ι : Sort*} [Countable ι] (s : ι → Set α) :\n    μ (⋃ i, toMeasurable μ (s i)) = μ (⋃ i, s i) :=\n  Eq.symm <| measure_iUnion_congr_of_subset (fun _i => subset_toMeasurable _ _) fun _i ↦\n    (measure_toMeasurable _).le\n\n"}
{"name":"MeasureTheory.measure_biUnion_toMeasurable","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nI : Set β\nhc : I.Countable\ns : β → Set α\n⊢ Eq (μ (Set.iUnion fun b => Set.iUnion fun h => MeasureTheory.toMeasurable μ (s b))) (μ (Set.iUnion fun b => Set.iUnion fun h => s b))","decl":"theorem measure_biUnion_toMeasurable {I : Set β} (hc : I.Countable) (s : β → Set α) :\n    μ (⋃ b ∈ I, toMeasurable μ (s b)) = μ (⋃ b ∈ I, s b) := by\n  haveI := hc.toEncodable\n  simp only [biUnion_eq_iUnion, measure_iUnion_toMeasurable]\n\n"}
{"name":"MeasureTheory.measure_toMeasurable_union","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns t : Set α\n⊢ Eq (μ (Union.union (MeasureTheory.toMeasurable μ s) t)) (μ (Union.union s t))","decl":"@[simp]\ntheorem measure_toMeasurable_union : μ (toMeasurable μ s ∪ t) = μ (s ∪ t) :=\n  Eq.symm <|\n    measure_union_congr_of_subset (subset_toMeasurable _ _) (measure_toMeasurable _).le Subset.rfl\n      le_rfl\n\n"}
{"name":"MeasureTheory.measure_union_toMeasurable","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns t : Set α\n⊢ Eq (μ (Union.union s (MeasureTheory.toMeasurable μ t))) (μ (Union.union s t))","decl":"@[simp]\ntheorem measure_union_toMeasurable : μ (s ∪ toMeasurable μ t) = μ (s ∪ t) :=\n  Eq.symm <|\n    measure_union_congr_of_subset Subset.rfl le_rfl (subset_toMeasurable _ _)\n      (measure_toMeasurable _).le\n\n"}
{"name":"MeasureTheory.sum_measure_le_measure_univ","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nι : Type u_5\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Finset ι\nt : ι → Set α\nh : ∀ (i : ι), Membership.mem s i → MeasureTheory.NullMeasurableSet (t i) μ\nH : (↑s).Pairwise (Function.onFun (MeasureTheory.AEDisjoint μ) t)\n⊢ LE.le (s.sum fun i => μ (t i)) (μ Set.univ)","decl":"theorem sum_measure_le_measure_univ {s : Finset ι} {t : ι → Set α}\n    (h : ∀ i ∈ s, NullMeasurableSet (t i) μ) (H : Set.Pairwise s (AEDisjoint μ on t)) :\n    (∑ i ∈ s, μ (t i)) ≤ μ (univ : Set α) := by\n  rw [← measure_biUnion_finset₀ H h]\n  exact measure_mono (subset_univ _)\n\n"}
{"name":"MeasureTheory.tsum_measure_le_measure_univ","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nι : Type u_5\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : ι → Set α\nhs : ∀ (i : ι), MeasureTheory.NullMeasurableSet (s i) μ\nH : Pairwise (Function.onFun (MeasureTheory.AEDisjoint μ) s)\n⊢ LE.le (tsum fun i => μ (s i)) (μ Set.univ)","decl":"theorem tsum_measure_le_measure_univ {s : ι → Set α} (hs : ∀ i, NullMeasurableSet (s i) μ)\n    (H : Pairwise (AEDisjoint μ on s)) : ∑' i, μ (s i) ≤ μ (univ : Set α) := by\n  rw [ENNReal.tsum_eq_iSup_sum]\n  exact iSup_le fun s =>\n    sum_measure_le_measure_univ (fun i _hi => hs i) fun i _hi j _hj hij => H hij\n\n"}
{"name":"MeasureTheory.exists_nonempty_inter_of_measure_univ_lt_tsum_measure","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nι : Type u_5\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : ι → Set α\nhs : ∀ (i : ι), MeasureTheory.NullMeasurableSet (s i) μ\nH : LT.lt (μ Set.univ) (tsum fun i => μ (s i))\n⊢ Exists fun i => Exists fun j => And (Ne i j) (Inter.inter (s i) (s j)).Nonempty","decl":"/-- Pigeonhole principle for measure spaces: if `∑' i, μ (s i) > μ univ`, then\none of the intersections `s i ∩ s j` is not empty. -/\ntheorem exists_nonempty_inter_of_measure_univ_lt_tsum_measure {m : MeasurableSpace α}\n    (μ : Measure α) {s : ι → Set α} (hs : ∀ i, NullMeasurableSet (s i) μ)\n    (H : μ (univ : Set α) < ∑' i, μ (s i)) : ∃ i j, i ≠ j ∧ (s i ∩ s j).Nonempty := by\n  contrapose! H\n  apply tsum_measure_le_measure_univ hs\n  intro i j hij\n  exact (disjoint_iff_inter_eq_empty.mpr (H i j hij)).aedisjoint\n\n"}
{"name":"MeasureTheory.exists_nonempty_inter_of_measure_univ_lt_sum_measure","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nι : Type u_5\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Finset ι\nt : ι → Set α\nh : ∀ (i : ι), Membership.mem s i → MeasureTheory.NullMeasurableSet (t i) μ\nH : LT.lt (μ Set.univ) (s.sum fun i => μ (t i))\n⊢ Exists fun i => And (Membership.mem s i) (Exists fun j => And (Membership.mem s j) (Exists fun _h => (Inter.inter (t i) (t j)).Nonempty))","decl":"/-- Pigeonhole principle for measure spaces: if `s` is a `Finset` and\n`∑ i ∈ s, μ (t i) > μ univ`, then one of the intersections `t i ∩ t j` is not empty. -/\ntheorem exists_nonempty_inter_of_measure_univ_lt_sum_measure {m : MeasurableSpace α} (μ : Measure α)\n    {s : Finset ι} {t : ι → Set α} (h : ∀ i ∈ s, NullMeasurableSet (t i) μ)\n    (H : μ (univ : Set α) < ∑ i ∈ s, μ (t i)) :\n    ∃ i ∈ s, ∃ j ∈ s, ∃ _h : i ≠ j, (t i ∩ t j).Nonempty := by\n  contrapose! H\n  apply sum_measure_le_measure_univ h\n  intro i hi j hj hij\n  exact (disjoint_iff_inter_eq_empty.mpr (H i hi j hj hij)).aedisjoint\n\n"}
{"name":"MeasureTheory.nonempty_inter_of_measure_lt_add","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns t u : Set α\nht : MeasurableSet t\nh's : HasSubset.Subset s u\nh't : HasSubset.Subset t u\nh : LT.lt (μ u) (HAdd.hAdd (μ s) (μ t))\n⊢ (Inter.inter s t).Nonempty","decl":"/-- If two sets `s` and `t` are included in a set `u`, and `μ s + μ t > μ u`,\nthen `s` intersects `t`. Version assuming that `t` is measurable. -/\ntheorem nonempty_inter_of_measure_lt_add {m : MeasurableSpace α} (μ : Measure α) {s t u : Set α}\n    (ht : MeasurableSet t) (h's : s ⊆ u) (h't : t ⊆ u) (h : μ u < μ s + μ t) :\n    (s ∩ t).Nonempty := by\n  rw [← Set.not_disjoint_iff_nonempty_inter]\n  contrapose! h\n  calc\n    μ s + μ t = μ (s ∪ t) := (measure_union h ht).symm\n    _ ≤ μ u := measure_mono (union_subset h's h't)\n\n"}
{"name":"MeasureTheory.nonempty_inter_of_measure_lt_add'","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns t u : Set α\nhs : MeasurableSet s\nh's : HasSubset.Subset s u\nh't : HasSubset.Subset t u\nh : LT.lt (μ u) (HAdd.hAdd (μ s) (μ t))\n⊢ (Inter.inter s t).Nonempty","decl":"/-- If two sets `s` and `t` are included in a set `u`, and `μ s + μ t > μ u`,\nthen `s` intersects `t`. Version assuming that `s` is measurable. -/\ntheorem nonempty_inter_of_measure_lt_add' {m : MeasurableSpace α} (μ : Measure α) {s t u : Set α}\n    (hs : MeasurableSet s) (h's : s ⊆ u) (h't : t ⊆ u) (h : μ u < μ s + μ t) :\n    (s ∩ t).Nonempty := by\n  rw [add_comm] at h\n  rw [inter_comm]\n  exact nonempty_inter_of_measure_lt_add μ hs h't h's h\n\n"}
{"name":"Directed.measure_iUnion","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nι : Type u_5\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : Countable ι\ns : ι → Set α\nhd : Directed (fun x1 x2 => HasSubset.Subset x1 x2) s\n⊢ Eq (μ (Set.iUnion fun i => s i)) (iSup fun i => μ (s i))","decl":"/-- Continuity from below:\nthe measure of the union of a directed sequence of (not necessarily measurable) sets\nis the supremum of the measures. -/\ntheorem _root_.Directed.measure_iUnion [Countable ι] {s : ι → Set α} (hd : Directed (· ⊆ ·) s) :\n    μ (⋃ i, s i) = ⨆ i, μ (s i) := by\n  -- WLOG, `ι = ℕ`\n  rcases Countable.exists_injective_nat ι with ⟨e, he⟩\n  generalize ht : Function.extend e s ⊥ = t\n  replace hd : Directed (· ⊆ ·) t := ht ▸ hd.extend_bot he\n  suffices μ (⋃ n, t n) = ⨆ n, μ (t n) by\n    simp only [← ht, Function.apply_extend μ, ← iSup_eq_iUnion, iSup_extend_bot he,\n      Function.comp_def, Pi.bot_apply, bot_eq_empty, measure_empty] at this\n    exact this.trans (iSup_extend_bot he _)\n  clear! ι\n  -- The `≥` inequality is trivial\n  refine le_antisymm ?_ (iSup_le fun i ↦ measure_mono <| subset_iUnion _ _)\n  -- Choose `T n ⊇ t n` of the same measure, put `Td n = disjointed T`\n  set T : ℕ → Set α := fun n => toMeasurable μ (t n)\n  set Td : ℕ → Set α := disjointed T\n  have hm : ∀ n, MeasurableSet (Td n) := .disjointed fun n ↦ measurableSet_toMeasurable _ _\n  calc\n    μ (⋃ n, t n) = μ (⋃ n, Td n) := by rw [iUnion_disjointed, measure_iUnion_toMeasurable]\n    _ ≤ ∑' n, μ (Td n) := measure_iUnion_le _\n    _ = ⨆ I : Finset ℕ, ∑ n ∈ I, μ (Td n) := ENNReal.tsum_eq_iSup_sum\n    _ ≤ ⨆ n, μ (t n) := iSup_le fun I => by\n      rcases hd.finset_le I with ⟨N, hN⟩\n      calc\n        (∑ n ∈ I, μ (Td n)) = μ (⋃ n ∈ I, Td n) :=\n          (measure_biUnion_finset ((disjoint_disjointed T).set_pairwise I) fun n _ => hm n).symm\n        _ ≤ μ (⋃ n ∈ I, T n) := measure_mono (iUnion₂_mono fun n _hn => disjointed_subset _ _)\n        _ = μ (⋃ n ∈ I, t n) := measure_biUnion_toMeasurable I.countable_toSet _\n        _ ≤ μ (t N) := measure_mono (iUnion₂_subset hN)\n        _ ≤ ⨆ n, μ (t n) := le_iSup (μ ∘ t) N\n\n"}
{"name":"MeasureTheory.measure_iUnion_eq_iSup","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nι : Type u_5\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : Countable ι\ns : ι → Set α\nhd : Directed (fun x1 x2 => HasSubset.Subset x1 x2) s\n⊢ Eq (μ (Set.iUnion fun i => s i)) (iSup fun i => μ (s i))","decl":"@[deprecated (since := \"2024-09-01\")] alias measure_iUnion_eq_iSup := Directed.measure_iUnion\n\n"}
{"name":"Monotone.measure_iUnion","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nι : Type u_5\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝² : Preorder ι\ninst✝¹ : IsDirected ι fun x1 x2 => LE.le x1 x2\ninst✝ : Filter.atTop.IsCountablyGenerated\ns : ι → Set α\nhs : Monotone s\n⊢ Eq (μ (Set.iUnion fun i => s i)) (iSup fun i => μ (s i))","decl":"/-- Continuity from below:\nthe measure of the union of a monotone family of sets is equal to the supremum of their measures.\nThe theorem assumes that the `atTop` filter on the index set is countably generated,\nso it works for a family indexed by a countable type, as well as `ℝ`.  -/\ntheorem _root_.Monotone.measure_iUnion [Preorder ι] [IsDirected ι (· ≤ ·)]\n    [(atTop : Filter ι).IsCountablyGenerated] {s : ι → Set α} (hs : Monotone s) :\n    μ (⋃ i, s i) = ⨆ i, μ (s i) := by\n  cases isEmpty_or_nonempty ι with\n  | inl _ => simp\n  | inr _ =>\n    rcases exists_seq_monotone_tendsto_atTop_atTop ι with ⟨x, hxm, hx⟩\n    rw [← hs.iUnion_comp_tendsto_atTop hx, ← Monotone.iSup_comp_tendsto_atTop _ hx]\n    exacts [(hs.comp hxm).directed_le.measure_iUnion, fun _ _ h ↦ measure_mono (hs h)]\n\n"}
{"name":"Antitone.measure_iUnion","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nι : Type u_5\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝² : Preorder ι\ninst✝¹ : IsDirected ι fun x1 x2 => GE.ge x1 x2\ninst✝ : Filter.atBot.IsCountablyGenerated\ns : ι → Set α\nhs : Antitone s\n⊢ Eq (μ (Set.iUnion fun i => s i)) (iSup fun i => μ (s i))","decl":"theorem _root_.Antitone.measure_iUnion [Preorder ι] [IsDirected ι (· ≥ ·)]\n    [(atBot : Filter ι).IsCountablyGenerated] {s : ι → Set α} (hs : Antitone s) :\n    μ (⋃ i, s i) = ⨆ i, μ (s i) :=\n  hs.dual_left.measure_iUnion\n\n"}
{"name":"MeasureTheory.measure_iUnion_eq_iSup_accumulate","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nι : Type u_5\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝² : Preorder ι\ninst✝¹ : IsDirected ι fun x1 x2 => LE.le x1 x2\ninst✝ : Filter.atTop.IsCountablyGenerated\nf : ι → Set α\n⊢ Eq (μ (Set.iUnion fun i => f i)) (iSup fun i => μ (Set.Accumulate f i))","decl":"/-- Continuity from below: the measure of the union of a sequence of\n(not necessarily measurable) sets is the supremum of the measures of the partial unions. -/\ntheorem measure_iUnion_eq_iSup_accumulate [Preorder ι] [IsDirected ι (· ≤ ·)]\n    [(atTop : Filter ι).IsCountablyGenerated] {f : ι → Set α} :\n    μ (⋃ i, f i) = ⨆ i, μ (Accumulate f i) := by\n  rw [← iUnion_accumulate]\n  exact monotone_accumulate.measure_iUnion\n\n"}
{"name":"MeasureTheory.measure_iUnion_eq_iSup'","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nι : Type u_5\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝² : Preorder ι\ninst✝¹ : IsDirected ι fun x1 x2 => LE.le x1 x2\ninst✝ : Filter.atTop.IsCountablyGenerated\nf : ι → Set α\n⊢ Eq (μ (Set.iUnion fun i => f i)) (iSup fun i => μ (Set.Accumulate f i))","decl":"@[deprecated (since := \"2024-09-01\")]\nalias measure_iUnion_eq_iSup' := measure_iUnion_eq_iSup_accumulate\n\n"}
{"name":"MeasureTheory.measure_biUnion_eq_iSup","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nι : Type u_5\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : ι → Set α\nt : Set ι\nht : t.Countable\nhd : DirectedOn (Function.onFun (fun x1 x2 => HasSubset.Subset x1 x2) s) t\n⊢ Eq (μ (Set.iUnion fun i => Set.iUnion fun h => s i)) (iSup fun i => iSup fun h => μ (s i))","decl":"theorem measure_biUnion_eq_iSup {s : ι → Set α} {t : Set ι} (ht : t.Countable)\n    (hd : DirectedOn ((· ⊆ ·) on s) t) : μ (⋃ i ∈ t, s i) = ⨆ i ∈ t, μ (s i) := by\n  haveI := ht.to_subtype\n  rw [biUnion_eq_iUnion, hd.directed_val.measure_iUnion, ← iSup_subtype'']\n\n"}
{"name":"Directed.measure_iInter","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nι : Type u_5\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : Countable ι\ns : ι → Set α\nh : ∀ (i : ι), MeasureTheory.NullMeasurableSet (s i) μ\nhd : Directed (fun x1 x2 => Superset x1 x2) s\nhfin : Exists fun i => Ne (μ (s i)) Top.top\n⊢ Eq (μ (Set.iInter fun i => s i)) (iInf fun i => μ (s i))","decl":"/-- **Continuity from above**:\nthe measure of the intersection of a directed downwards countable family of measurable sets\nis the infimum of the measures. -/\ntheorem _root_.Directed.measure_iInter [Countable ι] {s : ι → Set α}\n    (h : ∀ i, NullMeasurableSet (s i) μ) (hd : Directed (· ⊇ ·) s) (hfin : ∃ i, μ (s i) ≠ ∞) :\n    μ (⋂ i, s i) = ⨅ i, μ (s i) := by\n  rcases hfin with ⟨k, hk⟩\n  have : ∀ t ⊆ s k, μ t ≠ ∞ := fun t ht => ne_top_of_le_ne_top hk (measure_mono ht)\n  rw [← ENNReal.sub_sub_cancel hk (iInf_le (fun i => μ (s i)) k), ENNReal.sub_iInf, ←\n    ENNReal.sub_sub_cancel hk (measure_mono (iInter_subset _ k)), ←\n    measure_diff (iInter_subset _ k) (.iInter h) (this _ (iInter_subset _ k)),\n    diff_iInter, Directed.measure_iUnion]\n  · congr 1\n    refine le_antisymm (iSup_mono' fun i => ?_) (iSup_mono fun i => le_measure_diff)\n    rcases hd i k with ⟨j, hji, hjk⟩\n    use j\n    rw [← measure_diff hjk (h _) (this _ hjk)]\n    gcongr\n  · exact hd.mono_comp _ fun _ _ => diff_subset_diff_right\n\n"}
{"name":"MeasureTheory.measure_iInter_eq_iInf","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nι : Type u_5\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : Countable ι\ns : ι → Set α\nh : ∀ (i : ι), MeasureTheory.NullMeasurableSet (s i) μ\nhd : Directed (fun x1 x2 => Superset x1 x2) s\nhfin : Exists fun i => Ne (μ (s i)) Top.top\n⊢ Eq (μ (Set.iInter fun i => s i)) (iInf fun i => μ (s i))","decl":"@[deprecated (since := \"2024-09-30\")] alias measure_iInter_eq_iInf := Directed.measure_iInter\n\n"}
{"name":"Monotone.measure_iInter","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nι : Type u_5\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝² : Preorder ι\ninst✝¹ : IsDirected ι fun x1 x2 => GE.ge x1 x2\ninst✝ : Filter.atBot.IsCountablyGenerated\ns : ι → Set α\nhs : Monotone s\nhsm : ∀ (i : ι), MeasureTheory.NullMeasurableSet (s i) μ\nhfin : Exists fun i => Ne (μ (s i)) Top.top\n⊢ Eq (μ (Set.iInter fun i => s i)) (iInf fun i => μ (s i))","decl":"/-- **Continuity from above**:\nthe measure of the intersection of a monotone family of measurable sets\nindexed by a type with countably generated `atBot` filter\nis equal to the infimum of the measures. -/\ntheorem _root_.Monotone.measure_iInter [Preorder ι] [IsDirected ι (· ≥ ·)]\n    [(atBot : Filter ι).IsCountablyGenerated] {s : ι → Set α} (hs : Monotone s)\n    (hsm : ∀ i, NullMeasurableSet (s i) μ) (hfin : ∃ i, μ (s i) ≠ ∞) :\n    μ (⋂ i, s i) = ⨅ i, μ (s i) := by\n  refine le_antisymm (le_iInf fun i ↦ measure_mono <| iInter_subset _ _) ?_\n  have := hfin.nonempty\n  rcases exists_seq_antitone_tendsto_atTop_atBot ι with ⟨x, hxm, hx⟩\n  calc\n    ⨅ i, μ (s i) ≤ ⨅ n, μ (s (x n)) := le_iInf_comp (μ ∘ s) x\n    _ = μ (⋂ n, s (x n)) := by\n      refine .symm <| (hs.comp_antitone hxm).directed_ge.measure_iInter (fun n ↦ hsm _) ?_\n      rcases hfin with ⟨k, hk⟩\n      rcases (hx.eventually_le_atBot k).exists with ⟨n, hn⟩\n      exact ⟨n, ne_top_of_le_ne_top hk <| measure_mono <| hs hn⟩\n    _ ≤ μ (⋂ i, s i) := by\n      refine measure_mono <| iInter_mono' fun i ↦ ?_\n      rcases (hx.eventually_le_atBot i).exists with ⟨n, hn⟩\n      exact ⟨n, hs hn⟩\n\n"}
{"name":"Antitone.measure_iInter","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nι : Type u_5\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝² : Preorder ι\ninst✝¹ : IsDirected ι fun x1 x2 => LE.le x1 x2\ninst✝ : Filter.atTop.IsCountablyGenerated\ns : ι → Set α\nhs : Antitone s\nhsm : ∀ (i : ι), MeasureTheory.NullMeasurableSet (s i) μ\nhfin : Exists fun i => Ne (μ (s i)) Top.top\n⊢ Eq (μ (Set.iInter fun i => s i)) (iInf fun i => μ (s i))","decl":"/-- **Continuity from above**:\nthe measure of the intersection of an antitone family of measurable sets\nindexed by a type with countably generated `atTop` filter\nis equal to the infimum of the measures. -/\ntheorem _root_.Antitone.measure_iInter [Preorder ι] [IsDirected ι (· ≤ ·)]\n    [(atTop : Filter ι).IsCountablyGenerated] {s : ι → Set α} (hs : Antitone s)\n    (hsm : ∀ i, NullMeasurableSet (s i) μ) (hfin : ∃ i, μ (s i) ≠ ∞) :\n    μ (⋂ i, s i) = ⨅ i, μ (s i) :=\n  hs.dual_left.measure_iInter hsm hfin\n\n"}
{"name":"MeasureTheory.measure_iInter_eq_iInf_measure_iInter_le","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_8\nι : Type u_9\nx✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝² : Countable ι\ninst✝¹ : Preorder ι\ninst✝ : IsDirected ι fun x1 x2 => LE.le x1 x2\nf : ι → Set α\nh : ∀ (i : ι), MeasureTheory.NullMeasurableSet (f i) μ\nhfin : Exists fun i => Ne (μ (f i)) Top.top\n⊢ Eq (μ (Set.iInter fun i => f i)) (iInf fun i => μ (Set.iInter fun j => Set.iInter fun h => f j))","decl":"/-- Continuity from above: the measure of the intersection of a sequence of\nmeasurable sets is the infimum of the measures of the partial intersections. -/\ntheorem measure_iInter_eq_iInf_measure_iInter_le {α ι : Type*} {_ : MeasurableSpace α}\n    {μ : Measure α} [Countable ι] [Preorder ι] [IsDirected ι (· ≤ ·)]\n    {f : ι → Set α} (h : ∀ i, NullMeasurableSet (f i) μ) (hfin : ∃ i, μ (f i) ≠ ∞) :\n    μ (⋂ i, f i) = ⨅ i, μ (⋂ j ≤ i, f j) := by\n  rw [← Antitone.measure_iInter]\n  · rw [iInter_comm]\n    exact congrArg μ <| iInter_congr fun i ↦ (biInf_const nonempty_Ici).symm\n  · exact fun i j h ↦ biInter_mono (Iic_subset_Iic.2 h) fun _ _ ↦ Set.Subset.rfl\n  · exact fun i ↦ .biInter (to_countable _) fun _ _ ↦ h _\n  · refine hfin.imp fun k hk ↦ ne_top_of_le_ne_top hk <| measure_mono <| iInter₂_subset k ?_\n    rfl\n\n"}
{"name":"MeasureTheory.measure_iInter_eq_iInf'","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_8\nι : Type u_9\nx✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝² : Countable ι\ninst✝¹ : Preorder ι\ninst✝ : IsDirected ι fun x1 x2 => LE.le x1 x2\nf : ι → Set α\nh : ∀ (i : ι), MeasureTheory.NullMeasurableSet (f i) μ\nhfin : Exists fun i => Ne (μ (f i)) Top.top\n⊢ Eq (μ (Set.iInter fun i => f i)) (iInf fun i => μ (Set.iInter fun j => Set.iInter fun h => f j))","decl":"@[deprecated (since := \"2024-09-30\")]\nalias measure_iInter_eq_iInf' := measure_iInter_eq_iInf_measure_iInter_le\n\n"}
{"name":"MeasureTheory.tendsto_measure_iUnion_atTop","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nι : Type u_5\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝¹ : Preorder ι\ninst✝ : Filter.atTop.IsCountablyGenerated\ns : ι → Set α\nhm : Monotone s\n⊢ Filter.Tendsto (Function.comp (⇑μ) s) Filter.atTop (nhds (μ (Set.iUnion fun n => s n)))","decl":"/-- Continuity from below: the measure of the union of an increasing sequence of (not necessarily\nmeasurable) sets is the limit of the measures. -/\ntheorem tendsto_measure_iUnion_atTop [Preorder ι] [IsCountablyGenerated (atTop : Filter ι)]\n    {s : ι → Set α} (hm : Monotone s) : Tendsto (μ ∘ s) atTop (𝓝 (μ (⋃ n, s n))) := by\n  refine .of_neBot_imp fun h ↦ ?_\n  have := (atTop_neBot_iff.1 h).2\n  rw [hm.measure_iUnion]\n  exact tendsto_atTop_iSup fun n m hnm => measure_mono <| hm hnm\n\n"}
{"name":"MeasureTheory.tendsto_measure_iUnion","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nι : Type u_5\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝¹ : Preorder ι\ninst✝ : Filter.atTop.IsCountablyGenerated\ns : ι → Set α\nhm : Monotone s\n⊢ Filter.Tendsto (Function.comp (⇑μ) s) Filter.atTop (nhds (μ (Set.iUnion fun n => s n)))","decl":"@[deprecated (since := \"2024-09-01\")] alias tendsto_measure_iUnion := tendsto_measure_iUnion_atTop\n\n"}
{"name":"MeasureTheory.tendsto_measure_iUnion_atBot","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nι : Type u_5\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝¹ : Preorder ι\ninst✝ : Filter.atBot.IsCountablyGenerated\ns : ι → Set α\nhm : Antitone s\n⊢ Filter.Tendsto (Function.comp (⇑μ) s) Filter.atBot (nhds (μ (Set.iUnion fun n => s n)))","decl":"theorem tendsto_measure_iUnion_atBot [Preorder ι] [IsCountablyGenerated (atBot : Filter ι)]\n    {s : ι → Set α} (hm : Antitone s) : Tendsto (μ ∘ s) atBot (𝓝 (μ (⋃ n, s n))) :=\n  tendsto_measure_iUnion_atTop (ι := ιᵒᵈ) hm.dual_left\n\n"}
{"name":"MeasureTheory.tendsto_measure_iUnion_accumulate","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_8\nι : Type u_9\ninst✝¹ : Preorder ι\ninst✝ : Filter.atTop.IsCountablyGenerated\nx✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : ι → Set α\n⊢ Filter.Tendsto (fun i => μ (Set.Accumulate f i)) Filter.atTop (nhds (μ (Set.iUnion fun i => f i)))","decl":"/-- Continuity from below: the measure of the union of a sequence of (not necessarily measurable)\nsets is the limit of the measures of the partial unions. -/\ntheorem tendsto_measure_iUnion_accumulate {α ι : Type*}\n    [Preorder ι] [IsCountablyGenerated (atTop : Filter ι)]\n    {_ : MeasurableSpace α} {μ : Measure α} {f : ι → Set α} :\n    Tendsto (fun i ↦ μ (Accumulate f i)) atTop (𝓝 (μ (⋃ i, f i))) := by\n  refine .of_neBot_imp fun h ↦ ?_\n  have := (atTop_neBot_iff.1 h).2\n  rw [measure_iUnion_eq_iSup_accumulate]\n  exact tendsto_atTop_iSup fun i j hij ↦ by gcongr\n\n"}
{"name":"MeasureTheory.tendsto_measure_iUnion'","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_8\nι : Type u_9\ninst✝¹ : Preorder ι\ninst✝ : Filter.atTop.IsCountablyGenerated\nx✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : ι → Set α\n⊢ Filter.Tendsto (fun i => μ (Set.Accumulate f i)) Filter.atTop (nhds (μ (Set.iUnion fun i => f i)))","decl":"@[deprecated (since := \"2024-09-01\")]\nalias tendsto_measure_iUnion' := tendsto_measure_iUnion_accumulate\n\n"}
{"name":"MeasureTheory.tendsto_measure_iInter_atTop","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nι : Type u_5\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝¹ : Preorder ι\ninst✝ : Filter.atTop.IsCountablyGenerated\ns : ι → Set α\nhs : ∀ (i : ι), MeasureTheory.NullMeasurableSet (s i) μ\nhm : Antitone s\nhf : Exists fun i => Ne (μ (s i)) Top.top\n⊢ Filter.Tendsto (Function.comp (⇑μ) s) Filter.atTop (nhds (μ (Set.iInter fun n => s n)))","decl":"/-- Continuity from above: the measure of the intersection of a decreasing sequence of measurable\nsets is the limit of the measures. -/\ntheorem tendsto_measure_iInter_atTop [Preorder ι]\n    [IsCountablyGenerated (atTop : Filter ι)] {s : ι → Set α}\n    (hs : ∀ i, NullMeasurableSet (s i) μ) (hm : Antitone s) (hf : ∃ i, μ (s i) ≠ ∞) :\n    Tendsto (μ ∘ s) atTop (𝓝 (μ (⋂ n, s n))) := by\n  refine .of_neBot_imp fun h ↦ ?_\n  have := (atTop_neBot_iff.1 h).2\n  rw [hm.measure_iInter hs hf]\n  exact tendsto_atTop_iInf fun n m hnm => measure_mono <| hm hnm\n\n"}
{"name":"MeasureTheory.tendsto_measure_iInter","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nι : Type u_5\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝¹ : Preorder ι\ninst✝ : Filter.atTop.IsCountablyGenerated\ns : ι → Set α\nhs : ∀ (i : ι), MeasureTheory.NullMeasurableSet (s i) μ\nhm : Antitone s\nhf : Exists fun i => Ne (μ (s i)) Top.top\n⊢ Filter.Tendsto (Function.comp (⇑μ) s) Filter.atTop (nhds (μ (Set.iInter fun n => s n)))","decl":"@[deprecated (since := \"2024-09-30\")]\nalias tendsto_measure_iInter := tendsto_measure_iInter_atTop\n\n"}
{"name":"MeasureTheory.tendsto_measure_iInter_atBot","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nι : Type u_5\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝¹ : Preorder ι\ninst✝ : Filter.atBot.IsCountablyGenerated\ns : ι → Set α\nhs : ∀ (i : ι), MeasureTheory.NullMeasurableSet (s i) μ\nhm : Monotone s\nhf : Exists fun i => Ne (μ (s i)) Top.top\n⊢ Filter.Tendsto (Function.comp (⇑μ) s) Filter.atBot (nhds (μ (Set.iInter fun n => s n)))","decl":"/-- Continuity from above: the measure of the intersection of an increasing sequence of measurable\nsets is the limit of the measures. -/\ntheorem tendsto_measure_iInter_atBot [Preorder ι] [IsCountablyGenerated (atBot : Filter ι)]\n    {s : ι → Set α} (hs : ∀ i, NullMeasurableSet (s i) μ) (hm : Monotone s)\n    (hf : ∃ i, μ (s i) ≠ ∞) : Tendsto (μ ∘ s) atBot (𝓝 (μ (⋂ n, s n))) :=\n  tendsto_measure_iInter_atTop (ι := ιᵒᵈ) hs hm.dual_left hf\n\n"}
{"name":"MeasureTheory.tendsto_measure_iInter_le","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_8\nι : Type u_9\nx✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝¹ : Countable ι\ninst✝ : Preorder ι\nf : ι → Set α\nhm : ∀ (i : ι), MeasureTheory.NullMeasurableSet (f i) μ\nhf : Exists fun i => Ne (μ (f i)) Top.top\n⊢ Filter.Tendsto (fun i => μ (Set.iInter fun j => Set.iInter fun h => f j)) Filter.atTop (nhds (μ (Set.iInter fun i => f i)))","decl":"/-- Continuity from above: the measure of the intersection of a sequence of measurable\nsets such that one has finite measure is the limit of the measures of the partial intersections. -/\ntheorem tendsto_measure_iInter_le {α ι : Type*} {_ : MeasurableSpace α} {μ : Measure α}\n    [Countable ι] [Preorder ι] {f : ι → Set α} (hm : ∀ i, NullMeasurableSet (f i) μ)\n    (hf : ∃ i, μ (f i) ≠ ∞) :\n    Tendsto (fun i ↦ μ (⋂ j ≤ i, f j)) atTop (𝓝 (μ (⋂ i, f i))) := by\n  refine .of_neBot_imp fun hne ↦ ?_\n  cases' atTop_neBot_iff.mp hne\n  rw [measure_iInter_eq_iInf_measure_iInter_le hm hf]\n  exact tendsto_atTop_iInf\n    fun i j hij ↦ measure_mono <| biInter_subset_biInter_left fun k hki ↦ le_trans hki hij\n\n"}
{"name":"MeasureTheory.exists_measure_iInter_lt","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_8\nι : Type u_9\nx✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝¹ : SemilatticeSup ι\ninst✝ : Countable ι\nf : ι → Set α\nhm : ∀ (i : ι), MeasureTheory.NullMeasurableSet (f i) μ\nε : ENNReal\nhε : LT.lt 0 ε\nhfin : Exists fun i => Ne (μ (f i)) Top.top\nhfem : Eq (Set.iInter fun n => f n) EmptyCollection.emptyCollection\n⊢ Exists fun m => LT.lt (μ (Set.iInter fun n => Set.iInter fun h => f n)) ε","decl":"/-- Some version of continuity of a measure in the emptyset using the intersection along a set of\nsets. -/\ntheorem exists_measure_iInter_lt {α ι : Type*} {_ : MeasurableSpace α} {μ : Measure α}\n    [SemilatticeSup ι] [Countable ι] {f : ι → Set α}\n    (hm : ∀ i, NullMeasurableSet (f i) μ) {ε : ℝ≥0∞} (hε : 0 < ε) (hfin : ∃ i, μ (f i) ≠ ∞)\n    (hfem : ⋂ n, f n = ∅) : ∃ m, μ (⋂ n ≤ m, f n) < ε := by\n  let F m := μ (⋂ n ≤ m, f n)\n  have hFAnti : Antitone F :=\n      fun i j hij => measure_mono (biInter_subset_biInter_left fun k hki => le_trans hki hij)\n  suffices Filter.Tendsto F Filter.atTop (𝓝 0) by\n    rw [@ENNReal.tendsto_atTop_zero_iff_lt_of_antitone\n         _ (nonempty_of_exists hfin) _ _ hFAnti] at this\n    exact this ε hε\n  have hzero : μ (⋂ n, f n) = 0 := by\n    simp only [hfem, measure_empty]\n  rw [← hzero]\n  exact tendsto_measure_iInter_le hm hfin\n\n"}
{"name":"MeasureTheory.tendsto_measure_biInter_gt","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nι : Type u_8\ninst✝⁴ : LinearOrder ι\ninst✝³ : TopologicalSpace ι\ninst✝² : OrderTopology ι\ninst✝¹ : DenselyOrdered ι\ninst✝ : FirstCountableTopology ι\ns : ι → Set α\na : ι\nhs : ∀ (r : ι), GT.gt r a → MeasureTheory.NullMeasurableSet (s r) μ\nhm : ∀ (i j : ι), LT.lt a i → LE.le i j → HasSubset.Subset (s i) (s j)\nhf : Exists fun r => And (GT.gt r a) (Ne (μ (s r)) Top.top)\n⊢ Filter.Tendsto (Function.comp (⇑μ) s) (nhdsWithin a (Set.Ioi a)) (nhds (μ (Set.iInter fun r => Set.iInter fun h => s r)))","decl":"/-- The measure of the intersection of a decreasing sequence of measurable\nsets indexed by a linear order with first countable topology is the limit of the measures. -/\ntheorem tendsto_measure_biInter_gt {ι : Type*} [LinearOrder ι] [TopologicalSpace ι]\n    [OrderTopology ι] [DenselyOrdered ι] [FirstCountableTopology ι] {s : ι → Set α}\n    {a : ι} (hs : ∀ r > a, NullMeasurableSet (s r) μ) (hm : ∀ i j, a < i → i ≤ j → s i ⊆ s j)\n    (hf : ∃ r > a, μ (s r) ≠ ∞) : Tendsto (μ ∘ s) (𝓝[Ioi a] a) (𝓝 (μ (⋂ r > a, s r))) := by\n  have : (atBot : Filter (Ioi a)).IsCountablyGenerated := by\n    rw [← comap_coe_Ioi_nhdsGT]\n    infer_instance\n  simp_rw [← map_coe_Ioi_atBot, tendsto_map'_iff, ← mem_Ioi, biInter_eq_iInter]\n  apply tendsto_measure_iInter_atBot\n  · rwa [Subtype.forall]\n  · exact fun i j h ↦ hm i j i.2 h\n  · simpa only [Subtype.exists, exists_prop]\n\n"}
{"name":"MeasureTheory.measure_if","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nx : β\nt : Set β\ns : Set α\ninst✝ : Decidable (Membership.mem t x)\n⊢ Eq (μ (ite (Membership.mem t x) s EmptyCollection.emptyCollection)) (t.indicator (fun x => μ s) x)","decl":"theorem measure_if {x : β} {t : Set β} {s : Set α} [Decidable (x ∈ t)] :\n    μ (if x ∈ t then s else ∅) = indicator t (fun _ => μ s) x := by split_ifs with h <;> simp [h]\n\n"}
{"name":"MeasureTheory.le_toOuterMeasure_caratheodory","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nms : MeasurableSpace α\nμ : MeasureTheory.Measure α\n⊢ LE.le ms μ.caratheodory","decl":"theorem le_toOuterMeasure_caratheodory (μ : Measure α) : ms ≤ μ.toOuterMeasure.caratheodory :=\n  fun _s hs _t => (measure_inter_add_diff _ hs).symm\n\n"}
{"name":"MeasureTheory.toMeasure_toOuterMeasure","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nms : MeasurableSpace α\nm : MeasureTheory.OuterMeasure α\nh : LE.le ms m.caratheodory\n⊢ Eq (m.toMeasure h).toOuterMeasure m.trim","decl":"@[simp]\ntheorem toMeasure_toOuterMeasure (m : OuterMeasure α) (h : ms ≤ m.caratheodory) :\n    (m.toMeasure h).toOuterMeasure = m.trim :=\n  rfl\n\n"}
{"name":"MeasureTheory.toMeasure_apply","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nms : MeasurableSpace α\nm : MeasureTheory.OuterMeasure α\nh : LE.le ms m.caratheodory\ns : Set α\nhs : MeasurableSet s\n⊢ Eq ((m.toMeasure h) s) (m s)","decl":"@[simp]\ntheorem toMeasure_apply (m : OuterMeasure α) (h : ms ≤ m.caratheodory) {s : Set α}\n    (hs : MeasurableSet s) : m.toMeasure h s = m s :=\n  m.trim_eq hs\n\n"}
{"name":"MeasureTheory.le_toMeasure_apply","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nms : MeasurableSpace α\nm : MeasureTheory.OuterMeasure α\nh : LE.le ms m.caratheodory\ns : Set α\n⊢ LE.le (m s) ((m.toMeasure h) s)","decl":"theorem le_toMeasure_apply (m : OuterMeasure α) (h : ms ≤ m.caratheodory) (s : Set α) :\n    m s ≤ m.toMeasure h s :=\n  m.le_trim s\n\n"}
{"name":"MeasureTheory.toMeasure_apply₀","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nms : MeasurableSpace α\nm : MeasureTheory.OuterMeasure α\nh : LE.le ms m.caratheodory\ns : Set α\nhs : MeasureTheory.NullMeasurableSet s (m.toMeasure h)\n⊢ Eq ((m.toMeasure h) s) (m s)","decl":"theorem toMeasure_apply₀ (m : OuterMeasure α) (h : ms ≤ m.caratheodory) {s : Set α}\n    (hs : NullMeasurableSet s (m.toMeasure h)) : m.toMeasure h s = m s := by\n  refine le_antisymm ?_ (le_toMeasure_apply _ _ _)\n  rcases hs.exists_measurable_subset_ae_eq with ⟨t, hts, htm, heq⟩\n  calc\n    m.toMeasure h s = m.toMeasure h t := measure_congr heq.symm\n    _ = m t := toMeasure_apply m h htm\n    _ ≤ m s := m.mono hts\n\n"}
{"name":"MeasureTheory.toOuterMeasure_toMeasure","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nms : MeasurableSpace α\nμ : MeasureTheory.Measure α\n⊢ Eq (μ.toMeasure ⋯) μ","decl":"@[simp]\ntheorem toOuterMeasure_toMeasure {μ : Measure α} :\n    μ.toOuterMeasure.toMeasure (le_toOuterMeasure_caratheodory _) = μ :=\n  Measure.ext fun _s => μ.toOuterMeasure.trim_eq\n\n"}
{"name":"MeasureTheory.boundedBy_measure","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nms : MeasurableSpace α\nμ : MeasureTheory.Measure α\n⊢ Eq (MeasureTheory.OuterMeasure.boundedBy ⇑μ) μ.toOuterMeasure","decl":"@[simp]\ntheorem boundedBy_measure (μ : Measure α) : OuterMeasure.boundedBy μ = μ.toOuterMeasure :=\n  μ.toOuterMeasure.boundedBy_eq_self\n\n"}
{"name":"MeasureTheory.Measure.measure_inter_eq_of_measure_eq","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns t u : Set α\nhs : MeasurableSet s\nh : Eq (μ t) (μ u)\nhtu : HasSubset.Subset t u\nht_ne_top : Ne (μ t) Top.top\n⊢ Eq (μ (Inter.inter t s)) (μ (Inter.inter u s))","decl":"/-- If `u` is a superset of `t` with the same (finite) measure (both sets possibly non-measurable),\nthen for any measurable set `s` one also has `μ (t ∩ s) = μ (u ∩ s)`. -/\ntheorem measure_inter_eq_of_measure_eq {s t u : Set α} (hs : MeasurableSet s) (h : μ t = μ u)\n    (htu : t ⊆ u) (ht_ne_top : μ t ≠ ∞) : μ (t ∩ s) = μ (u ∩ s) := by\n  rw [h] at ht_ne_top\n  refine le_antisymm (by gcongr) ?_\n  have A : μ (u ∩ s) + μ (u \\ s) ≤ μ (t ∩ s) + μ (u \\ s) :=\n    calc\n      μ (u ∩ s) + μ (u \\ s) = μ u := measure_inter_add_diff _ hs\n      _ = μ t := h.symm\n      _ = μ (t ∩ s) + μ (t \\ s) := (measure_inter_add_diff _ hs).symm\n      _ ≤ μ (t ∩ s) + μ (u \\ s) := by gcongr\n  have B : μ (u \\ s) ≠ ∞ := (lt_of_le_of_lt (measure_mono diff_subset) ht_ne_top.lt_top).ne\n  exact ENNReal.le_of_add_le_add_right B A\n\n"}
{"name":"MeasureTheory.Measure.measure_toMeasurable_inter","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns t : Set α\nhs : MeasurableSet s\nht : Ne (μ t) Top.top\n⊢ Eq (μ (Inter.inter (MeasureTheory.toMeasurable μ t) s)) (μ (Inter.inter t s))","decl":"/-- The measurable superset `toMeasurable μ t` of `t` (which has the same measure as `t`)\nsatisfies, for any measurable set `s`, the equality `μ (toMeasurable μ t ∩ s) = μ (u ∩ s)`.\nHere, we require that the measure of `t` is finite. The conclusion holds without this assumption\nwhen the measure is s-finite (for example when it is σ-finite),\nsee `measure_toMeasurable_inter_of_sFinite`. -/\ntheorem measure_toMeasurable_inter {s t : Set α} (hs : MeasurableSet s) (ht : μ t ≠ ∞) :\n    μ (toMeasurable μ t ∩ s) = μ (t ∩ s) :=\n  (measure_inter_eq_of_measure_eq hs (measure_toMeasurable t).symm (subset_toMeasurable μ t)\n      ht).symm\n\n"}
{"name":"MeasureTheory.Measure.zero_toOuterMeasure","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\n_m : MeasurableSpace α\n⊢ Eq (MeasureTheory.Measure.toOuterMeasure 0) 0","decl":"@[simp]\ntheorem zero_toOuterMeasure {_m : MeasurableSpace α} : (0 : Measure α).toOuterMeasure = 0 :=\n  rfl\n\n"}
{"name":"MeasureTheory.Measure.coe_zero","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\n_m : MeasurableSpace α\n⊢ Eq (⇑0) 0","decl":"@[simp, norm_cast]\ntheorem coe_zero {_m : MeasurableSpace α} : ⇑(0 : Measure α) = 0 :=\n  rfl\n\n"}
{"name":"MeasureTheory.OuterMeasure.toMeasure_zero","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nms : MeasurableSpace α\nh : LE.le ms (MeasureTheory.OuterMeasure.caratheodory 0)\n⊢ Eq (MeasureTheory.OuterMeasure.toMeasure 0 h) 0","decl":"@[simp] lemma _root_.MeasureTheory.OuterMeasure.toMeasure_zero\n    [ms : MeasurableSpace α] (h : ms ≤ (0 : OuterMeasure α).caratheodory) :\n    (0 : OuterMeasure α).toMeasure h = 0 := by\n  ext s hs\n  simp [hs]\n\n"}
{"name":"MeasureTheory.OuterMeasure.toMeasure_eq_zero","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nms : MeasurableSpace α\nμ : MeasureTheory.OuterMeasure α\nh : LE.le ms μ.caratheodory\n⊢ Iff (Eq (μ.toMeasure h) 0) (Eq μ 0)","decl":"@[simp] lemma _root_.MeasureTheory.OuterMeasure.toMeasure_eq_zero {ms : MeasurableSpace α}\n    {μ : OuterMeasure α} (h : ms ≤ μ.caratheodory) : μ.toMeasure h = 0 ↔ μ = 0 where\n  mp hμ := by ext s; exact le_bot_iff.1 <| (le_toMeasure_apply _ _ _).trans_eq congr($hμ s)\n  mpr := by rintro rfl; simp\n\n"}
{"name":"MeasureTheory.Measure.apply_eq_zero_of_isEmpty","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\ninst✝ : IsEmpty α\nx✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\n⊢ Eq (μ s) 0","decl":"@[nontriviality]\nlemma apply_eq_zero_of_isEmpty [IsEmpty α] {_ : MeasurableSpace α} (μ : Measure α) (s : Set α) :\n    μ s = 0 := by\n  rw [eq_empty_of_isEmpty s, measure_empty]\n\n"}
{"name":"MeasureTheory.Measure.instSubsingleton","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\ninst✝ : IsEmpty α\nm : MeasurableSpace α\n⊢ Subsingleton (MeasureTheory.Measure α)","decl":"instance instSubsingleton [IsEmpty α] {m : MeasurableSpace α} : Subsingleton (Measure α) :=\n  ⟨fun μ ν => by ext1 s _; rw [apply_eq_zero_of_isEmpty, apply_eq_zero_of_isEmpty]⟩\n\n"}
{"name":"MeasureTheory.Measure.eq_zero_of_isEmpty","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\ninst✝ : IsEmpty α\n_m : MeasurableSpace α\nμ : MeasureTheory.Measure α\n⊢ Eq μ 0","decl":"theorem eq_zero_of_isEmpty [IsEmpty α] {_m : MeasurableSpace α} (μ : Measure α) : μ = 0 :=\n  Subsingleton.elim μ 0\n\n"}
{"name":"MeasureTheory.Measure.add_toOuterMeasure","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\n_m : MeasurableSpace α\nμ₁ μ₂ : MeasureTheory.Measure α\n⊢ Eq (HAdd.hAdd μ₁ μ₂).toOuterMeasure (HAdd.hAdd μ₁.toOuterMeasure μ₂.toOuterMeasure)","decl":"@[simp]\ntheorem add_toOuterMeasure {_m : MeasurableSpace α} (μ₁ μ₂ : Measure α) :\n    (μ₁ + μ₂).toOuterMeasure = μ₁.toOuterMeasure + μ₂.toOuterMeasure :=\n  rfl\n\n"}
{"name":"MeasureTheory.Measure.coe_add","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\n_m : MeasurableSpace α\nμ₁ μ₂ : MeasureTheory.Measure α\n⊢ Eq (⇑(HAdd.hAdd μ₁ μ₂)) (HAdd.hAdd ⇑μ₁ ⇑μ₂)","decl":"@[simp, norm_cast]\ntheorem coe_add {_m : MeasurableSpace α} (μ₁ μ₂ : Measure α) : ⇑(μ₁ + μ₂) = μ₁ + μ₂ :=\n  rfl\n\n"}
{"name":"MeasureTheory.Measure.add_apply","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\n_m : MeasurableSpace α\nμ₁ μ₂ : MeasureTheory.Measure α\ns : Set α\n⊢ Eq ((HAdd.hAdd μ₁ μ₂) s) (HAdd.hAdd (μ₁ s) (μ₂ s))","decl":"theorem add_apply {_m : MeasurableSpace α} (μ₁ μ₂ : Measure α) (s : Set α) :\n    (μ₁ + μ₂) s = μ₁ s + μ₂ s :=\n  rfl\n\n"}
{"name":"MeasureTheory.Measure.smul_toOuterMeasure","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nR : Type u_6\ninst✝¹ : SMul R ENNReal\ninst✝ : IsScalarTower R ENNReal ENNReal\n_m : MeasurableSpace α\nc : R\nμ : MeasureTheory.Measure α\n⊢ Eq (HSMul.hSMul c μ).toOuterMeasure (HSMul.hSMul c μ.toOuterMeasure)","decl":"@[simp]\ntheorem smul_toOuterMeasure {_m : MeasurableSpace α} (c : R) (μ : Measure α) :\n    (c • μ).toOuterMeasure = c • μ.toOuterMeasure :=\n  rfl\n\n"}
{"name":"MeasureTheory.Measure.coe_smul","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nR : Type u_6\ninst✝¹ : SMul R ENNReal\ninst✝ : IsScalarTower R ENNReal ENNReal\n_m : MeasurableSpace α\nc : R\nμ : MeasureTheory.Measure α\n⊢ Eq (⇑(HSMul.hSMul c μ)) (HSMul.hSMul c ⇑μ)","decl":"@[simp, norm_cast]\ntheorem coe_smul {_m : MeasurableSpace α} (c : R) (μ : Measure α) : ⇑(c • μ) = c • ⇑μ :=\n  rfl\n\n"}
{"name":"MeasureTheory.Measure.smul_apply","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nR : Type u_6\ninst✝¹ : SMul R ENNReal\ninst✝ : IsScalarTower R ENNReal ENNReal\n_m : MeasurableSpace α\nc : R\nμ : MeasureTheory.Measure α\ns : Set α\n⊢ Eq ((HSMul.hSMul c μ) s) (HSMul.hSMul c (μ s))","decl":"@[simp]\ntheorem smul_apply {_m : MeasurableSpace α} (c : R) (μ : Measure α) (s : Set α) :\n    (c • μ) s = c • μ s :=\n  rfl\n\n"}
{"name":"MeasureTheory.Measure.instSMulCommClass","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nR : Type u_6\nR' : Type u_7\ninst✝⁴ : SMul R ENNReal\ninst✝³ : IsScalarTower R ENNReal ENNReal\ninst✝² : SMul R' ENNReal\ninst✝¹ : IsScalarTower R' ENNReal ENNReal\ninst✝ : SMulCommClass R R' ENNReal\nx✝ : MeasurableSpace α\n⊢ SMulCommClass R R' (MeasureTheory.Measure α)","decl":"instance instSMulCommClass [SMulCommClass R R' ℝ≥0∞] {_ : MeasurableSpace α} :\n    SMulCommClass R R' (Measure α) :=\n  ⟨fun _ _ _ => ext fun _ _ => smul_comm _ _ _⟩\n\n"}
{"name":"MeasureTheory.Measure.instIsScalarTower","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nR : Type u_6\nR' : Type u_7\ninst✝⁵ : SMul R ENNReal\ninst✝⁴ : IsScalarTower R ENNReal ENNReal\ninst✝³ : SMul R' ENNReal\ninst✝² : IsScalarTower R' ENNReal ENNReal\ninst✝¹ : SMul R R'\ninst✝ : IsScalarTower R R' ENNReal\nx✝ : MeasurableSpace α\n⊢ IsScalarTower R R' (MeasureTheory.Measure α)","decl":"instance instIsScalarTower [SMul R R'] [IsScalarTower R R' ℝ≥0∞] {_ : MeasurableSpace α} :\n    IsScalarTower R R' (Measure α) :=\n  ⟨fun _ _ _ => ext fun _ _ => smul_assoc _ _ _⟩\n\n"}
{"name":"MeasureTheory.Measure.instIsCentralScalar","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nR : Type u_6\ninst✝³ : SMul R ENNReal\ninst✝² : IsScalarTower R ENNReal ENNReal\ninst✝¹ : SMul (MulOpposite R) ENNReal\ninst✝ : IsCentralScalar R ENNReal\nx✝ : MeasurableSpace α\n⊢ IsCentralScalar R (MeasureTheory.Measure α)","decl":"instance instIsCentralScalar [SMul Rᵐᵒᵖ ℝ≥0∞] [IsCentralScalar R ℝ≥0∞] {_ : MeasurableSpace α} :\n    IsCentralScalar R (Measure α) :=\n  ⟨fun _ _ => ext fun _ _ => op_smul_eq_smul _ _⟩\n\n"}
{"name":"MeasureTheory.Measure.instNoZeroSMulDivisors","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nR : Type u_6\nm0 : MeasurableSpace α\ninst✝³ : Zero R\ninst✝² : SMulWithZero R ENNReal\ninst✝¹ : IsScalarTower R ENNReal ENNReal\ninst✝ : NoZeroSMulDivisors R ENNReal\n⊢ NoZeroSMulDivisors R (MeasureTheory.Measure α)","decl":"instance instNoZeroSMulDivisors [Zero R] [SMulWithZero R ℝ≥0∞] [IsScalarTower R ℝ≥0∞ ℝ≥0∞]\n    [NoZeroSMulDivisors R ℝ≥0∞] : NoZeroSMulDivisors R (Measure α) where\n  eq_zero_or_eq_zero_of_smul_eq_zero h := by simpa [Ne, ext_iff', forall_or_left] using h\n\n"}
{"name":"MeasureTheory.Measure.coe_finset_sum","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nι : Type u_5\n_m : MeasurableSpace α\nI : Finset ι\nμ : ι → MeasureTheory.Measure α\n⊢ Eq (⇑(I.sum fun i => μ i)) (I.sum fun i => ⇑(μ i))","decl":"@[simp]\ntheorem coe_finset_sum {_m : MeasurableSpace α} (I : Finset ι) (μ : ι → Measure α) :\n    ⇑(∑ i ∈ I, μ i) = ∑ i ∈ I, ⇑(μ i) := map_sum coeAddHom μ I\n\n"}
{"name":"MeasureTheory.Measure.finset_sum_apply","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nι : Type u_5\nm : MeasurableSpace α\nI : Finset ι\nμ : ι → MeasureTheory.Measure α\ns : Set α\n⊢ Eq ((I.sum fun i => μ i) s) (I.sum fun i => (μ i) s)","decl":"theorem finset_sum_apply {m : MeasurableSpace α} (I : Finset ι) (μ : ι → Measure α) (s : Set α) :\n    (∑ i ∈ I, μ i) s = ∑ i ∈ I, μ i s := by rw [coe_finset_sum, Finset.sum_apply]\n\n"}
{"name":"MeasureTheory.Measure.coe_nnreal_smul_apply","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\n_m : MeasurableSpace α\nc : NNReal\nμ : MeasureTheory.Measure α\ns : Set α\n⊢ Eq ((HSMul.hSMul c μ) s) (HMul.hMul (↑c) (μ s))","decl":"@[simp]\ntheorem coe_nnreal_smul_apply {_m : MeasurableSpace α} (c : ℝ≥0) (μ : Measure α) (s : Set α) :\n    (c • μ) s = c * μ s :=\n  rfl\n\n"}
{"name":"MeasureTheory.Measure.nnreal_smul_coe_apply","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\n_m : MeasurableSpace α\nc : NNReal\nμ : MeasureTheory.Measure α\ns : Set α\n⊢ Eq (HSMul.hSMul c (μ s)) (HMul.hMul (↑c) (μ s))","decl":"@[simp]\ntheorem nnreal_smul_coe_apply {_m : MeasurableSpace α} (c : ℝ≥0) (μ : Measure α) (s : Set α) :\n    c • μ s = c * μ s := by\n  rfl\n\n"}
{"name":"MeasureTheory.Measure.ae_smul_measure","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nR : Type u_6\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\np : α → Prop\ninst✝¹ : SMul R ENNReal\ninst✝ : IsScalarTower R ENNReal ENNReal\nh : Filter.Eventually (fun x => p x) (MeasureTheory.ae μ)\nc : R\n⊢ Filter.Eventually (fun x => p x) (MeasureTheory.ae (HSMul.hSMul c μ))","decl":"theorem ae_smul_measure {p : α → Prop} [SMul R ℝ≥0∞] [IsScalarTower R ℝ≥0∞ ℝ≥0∞]\n    (h : ∀ᵐ x ∂μ, p x) (c : R) : ∀ᵐ x ∂c • μ, p x :=\n  ae_iff.2 <| by rw [smul_apply, ae_iff.1 h, ← smul_one_smul ℝ≥0∞, smul_zero]\n\n"}
{"name":"MeasureTheory.Measure.ae_smul_measure_le","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nR : Type u_6\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝¹ : SMul R ENNReal\ninst✝ : IsScalarTower R ENNReal ENNReal\nc : R\n⊢ LE.le (MeasureTheory.ae (HSMul.hSMul c μ)) (MeasureTheory.ae μ)","decl":"theorem ae_smul_measure_le [SMul R ℝ≥0∞] [IsScalarTower R ℝ≥0∞ ℝ≥0∞] (c : R) :\n    ae (c • μ) ≤ ae μ := fun _ h ↦ ae_smul_measure h c\n\n"}
{"name":"MeasureTheory.Measure.ae_smul_measure_iff","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nR : Type u_8\ninst✝³ : Zero R\ninst✝² : SMulWithZero R ENNReal\ninst✝¹ : IsScalarTower R ENNReal ENNReal\ninst✝ : NoZeroSMulDivisors R ENNReal\nc : R\np : α → Prop\nhc : Ne c 0\nμ : MeasureTheory.Measure α\n⊢ Iff (Filter.Eventually (fun x => p x) (MeasureTheory.ae (HSMul.hSMul c μ))) (Filter.Eventually (fun x => p x) (MeasureTheory.ae μ))","decl":"lemma ae_smul_measure_iff (hc : c ≠ 0) {μ : Measure α} : (∀ᵐ x ∂c • μ, p x) ↔ ∀ᵐ x ∂μ, p x := by\n  simp [ae_iff, hc]\n\n"}
{"name":"MeasureTheory.Measure.ae_smul_measure_eq","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nR : Type u_8\ninst✝³ : Zero R\ninst✝² : SMulWithZero R ENNReal\ninst✝¹ : IsScalarTower R ENNReal ENNReal\ninst✝ : NoZeroSMulDivisors R ENNReal\nc : R\nhc : Ne c 0\nμ : MeasureTheory.Measure α\n⊢ Eq (MeasureTheory.ae (HSMul.hSMul c μ)) (MeasureTheory.ae μ)","decl":"@[simp] lemma ae_smul_measure_eq (hc : c ≠ 0) (μ : Measure α) : ae (c • μ) = ae μ := by\n  ext; exact ae_smul_measure_iff hc\n\n"}
{"name":"MeasureTheory.Measure.measure_eq_left_of_subset_of_measure_add_eq","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\ns t : Set α\nh : Ne ((HAdd.hAdd μ ν) t) Top.top\nh' : HasSubset.Subset s t\nh'' : Eq ((HAdd.hAdd μ ν) s) ((HAdd.hAdd μ ν) t)\n⊢ Eq (μ s) (μ t)","decl":"theorem measure_eq_left_of_subset_of_measure_add_eq {s t : Set α} (h : (μ + ν) t ≠ ∞) (h' : s ⊆ t)\n    (h'' : (μ + ν) s = (μ + ν) t) : μ s = μ t := by\n  refine le_antisymm (measure_mono h') ?_\n  have : μ t + ν t ≤ μ s + ν t :=\n    calc\n      μ t + ν t = μ s + ν s := h''.symm\n      _ ≤ μ s + ν t := by gcongr\n  apply ENNReal.le_of_add_le_add_right _ this\n  exact ne_top_of_le_ne_top h (le_add_left le_rfl)\n\n"}
{"name":"MeasureTheory.Measure.measure_eq_right_of_subset_of_measure_add_eq","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\ns t : Set α\nh : Ne ((HAdd.hAdd μ ν) t) Top.top\nh' : HasSubset.Subset s t\nh'' : Eq ((HAdd.hAdd μ ν) s) ((HAdd.hAdd μ ν) t)\n⊢ Eq (ν s) (ν t)","decl":"theorem measure_eq_right_of_subset_of_measure_add_eq {s t : Set α} (h : (μ + ν) t ≠ ∞) (h' : s ⊆ t)\n    (h'' : (μ + ν) s = (μ + ν) t) : ν s = ν t := by\n  rw [add_comm] at h'' h\n  exact measure_eq_left_of_subset_of_measure_add_eq h h' h''\n\n"}
{"name":"MeasureTheory.Measure.measure_toMeasurable_add_inter_left","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\ns t : Set α\nhs : MeasurableSet s\nht : Ne ((HAdd.hAdd μ ν) t) Top.top\n⊢ Eq (μ (Inter.inter (MeasureTheory.toMeasurable (HAdd.hAdd μ ν) t) s)) (μ (Inter.inter t s))","decl":"theorem measure_toMeasurable_add_inter_left {s t : Set α} (hs : MeasurableSet s)\n    (ht : (μ + ν) t ≠ ∞) : μ (toMeasurable (μ + ν) t ∩ s) = μ (t ∩ s) := by\n  refine (measure_inter_eq_of_measure_eq hs ?_ (subset_toMeasurable _ _) ?_).symm\n  · refine\n      measure_eq_left_of_subset_of_measure_add_eq ?_ (subset_toMeasurable _ _)\n        (measure_toMeasurable t).symm\n    rwa [measure_toMeasurable t]\n  · simp only [not_or, ENNReal.add_eq_top, Pi.add_apply, Ne, coe_add] at ht\n    exact ht.1\n\n"}
{"name":"MeasureTheory.Measure.measure_toMeasurable_add_inter_right","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\ns t : Set α\nhs : MeasurableSet s\nht : Ne ((HAdd.hAdd μ ν) t) Top.top\n⊢ Eq (ν (Inter.inter (MeasureTheory.toMeasurable (HAdd.hAdd μ ν) t) s)) (ν (Inter.inter t s))","decl":"theorem measure_toMeasurable_add_inter_right {s t : Set α} (hs : MeasurableSet s)\n    (ht : (μ + ν) t ≠ ∞) : ν (toMeasurable (μ + ν) t ∩ s) = ν (t ∩ s) := by\n  rw [add_comm] at ht ⊢\n  exact measure_toMeasurable_add_inter_left hs ht\n\n"}
{"name":"MeasureTheory.Measure.toOuterMeasure_le","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ₁ μ₂ : MeasureTheory.Measure α\n⊢ Iff (LE.le μ₁.toOuterMeasure μ₂.toOuterMeasure) (LE.le μ₁ μ₂)","decl":"theorem toOuterMeasure_le : μ₁.toOuterMeasure ≤ μ₂.toOuterMeasure ↔ μ₁ ≤ μ₂ := .rfl\n\n"}
{"name":"MeasureTheory.Measure.le_iff","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ₁ μ₂ : MeasureTheory.Measure α\n⊢ Iff (LE.le μ₁ μ₂) (∀ (s : Set α), MeasurableSet s → LE.le (μ₁ s) (μ₂ s))","decl":"theorem le_iff : μ₁ ≤ μ₂ ↔ ∀ s, MeasurableSet s → μ₁ s ≤ μ₂ s := outerMeasure_le_iff\n\n"}
{"name":"MeasureTheory.Measure.le_intro","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ₁ μ₂ : MeasureTheory.Measure α\nh : ∀ (s : Set α), MeasurableSet s → s.Nonempty → LE.le (μ₁ s) (μ₂ s)\n⊢ LE.le μ₁ μ₂","decl":"theorem le_intro (h : ∀ s, MeasurableSet s → s.Nonempty → μ₁ s ≤ μ₂ s) : μ₁ ≤ μ₂ :=\n  le_iff.2 fun s hs ↦ s.eq_empty_or_nonempty.elim (by rintro rfl; simp) (h s hs)\n\n"}
{"name":"MeasureTheory.Measure.le_iff'","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ₁ μ₂ : MeasureTheory.Measure α\n⊢ Iff (LE.le μ₁ μ₂) (∀ (s : Set α), LE.le (μ₁ s) (μ₂ s))","decl":"theorem le_iff' : μ₁ ≤ μ₂ ↔ ∀ s, μ₁ s ≤ μ₂ s := .rfl\n\n"}
{"name":"MeasureTheory.Measure.lt_iff","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\n⊢ Iff (LT.lt μ ν) (And (LE.le μ ν) (Exists fun s => And (MeasurableSet s) (LT.lt (μ s) (ν s))))","decl":"theorem lt_iff : μ < ν ↔ μ ≤ ν ∧ ∃ s, MeasurableSet s ∧ μ s < ν s :=\n  lt_iff_le_not_le.trans <|\n    and_congr Iff.rfl <| by simp only [le_iff, not_forall, not_le, exists_prop]\n\n"}
{"name":"MeasureTheory.Measure.lt_iff'","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\n⊢ Iff (LT.lt μ ν) (And (LE.le μ ν) (Exists fun s => LT.lt (μ s) (ν s)))","decl":"theorem lt_iff' : μ < ν ↔ μ ≤ ν ∧ ∃ s, μ s < ν s :=\n  lt_iff_le_not_le.trans <| and_congr Iff.rfl <| by simp only [le_iff', not_forall, not_le]\n\n"}
{"name":"MeasureTheory.Measure.instAddLeftMono","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nx✝ : MeasurableSpace α\n⊢ AddLeftMono (MeasureTheory.Measure α)","decl":"instance instAddLeftMono {_ : MeasurableSpace α} : AddLeftMono (Measure α) :=\n  ⟨fun _ν _μ₁ _μ₂ hμ s => add_le_add_left (hμ s) _⟩\n\n"}
{"name":"MeasureTheory.Measure.le_add_left","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ ν ν' : MeasureTheory.Measure α\nh : LE.le μ ν\n⊢ LE.le μ (HAdd.hAdd ν' ν)","decl":"protected theorem le_add_left (h : μ ≤ ν) : μ ≤ ν' + ν := fun s => le_add_left (h s)\n\n"}
{"name":"MeasureTheory.Measure.le_add_right","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ ν ν' : MeasureTheory.Measure α\nh : LE.le μ ν\n⊢ LE.le μ (HAdd.hAdd ν ν')","decl":"protected theorem le_add_right (h : μ ≤ ν) : μ ≤ ν + ν' := fun s => le_add_right (h s)\n\n"}
{"name":"MeasureTheory.Measure.sInf_caratheodory","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nm : Set (MeasureTheory.Measure α)\ns : Set α\nhs : MeasurableSet s\n⊢ MeasurableSet s","decl":"theorem sInf_caratheodory (s : Set α) (hs : MeasurableSet s) :\n    MeasurableSet[(sInf (toOuterMeasure '' m)).caratheodory] s := by\n  rw [OuterMeasure.sInf_eq_boundedBy_sInfGen]\n  refine OuterMeasure.boundedBy_caratheodory fun t => ?_\n  simp only [OuterMeasure.sInfGen, le_iInf_iff, forall_mem_image, measure_eq_iInf t,\n    coe_toOuterMeasure]\n  intro μ hμ u htu _hu\n  have hm : ∀ {s t}, s ⊆ t → OuterMeasure.sInfGen (toOuterMeasure '' m) s ≤ μ t := by\n    intro s t hst\n    rw [OuterMeasure.sInfGen_def, iInf_image]\n    exact iInf₂_le_of_le μ hμ <| measure_mono hst\n  rw [← measure_inter_add_diff u hs]\n  exact add_le_add (hm <| inter_subset_inter_left _ htu) (hm <| diff_subset_diff_left htu)\n\n"}
{"name":"MeasureTheory.Measure.sInf_apply","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\ns : Set α\nm : Set (MeasureTheory.Measure α)\nhs : MeasurableSet s\n⊢ Eq ((InfSet.sInf m) s) ((InfSet.sInf (Set.image MeasureTheory.Measure.toOuterMeasure m)) s)","decl":"theorem sInf_apply (hs : MeasurableSet s) : sInf m s = sInf (toOuterMeasure '' m) s :=\n  toMeasure_apply _ _ hs\n\n"}
{"name":"MeasureTheory.Measure.inf_apply","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\ns : Set α\nhs : MeasurableSet s\n⊢ Eq ((Min.min μ ν) s) (InfSet.sInf (setOf fun m => Exists fun t => Eq m (HAdd.hAdd (μ (Inter.inter t s)) (ν (Inter.inter (HasCompl.compl t) s)))))","decl":"lemma inf_apply {s : Set α} (hs : MeasurableSet s) :\n    (μ ⊓ ν) s = sInf {m | ∃ t, m = μ (t ∩ s) + ν (tᶜ ∩ s)} := by\n  -- `(μ ⊓ ν) s` is defined as `⊓ (t : ℕ → Set α) (ht : s ⊆ ⋃ n, t n), ∑' n, μ (t n) ⊓ ν (t n)`\n  rw [← sInf_pair, Measure.sInf_apply hs, OuterMeasure.sInf_apply\n    (image_nonempty.2 <| insert_nonempty μ {ν})]\n  refine le_antisymm (le_sInf fun m ⟨t, ht₁⟩ ↦ ?_) (le_iInf₂ fun t' ht' ↦ ?_)\n  · subst ht₁\n    -- We first show `(μ ⊓ ν) s ≤ μ (t ∩ s) + ν (tᶜ ∩ s)` for any `t : Set α`\n    -- For this, define the sequence `t' : ℕ → Set α` where `t' 0 = t ∩ s`, `t' 1 = tᶜ ∩ s` and\n    -- `∅` otherwise. Then, we have by construction\n    -- `(μ ⊓ ν) s ≤ ∑' n, μ (t' n) ⊓ ν (t' n) ≤ μ (t' 0) + ν (t' 1) = μ (t ∩ s) + ν (tᶜ ∩ s)`.\n    set t' : ℕ → Set α := fun n ↦ if n = 0 then t ∩ s else if n = 1 then tᶜ ∩ s else ∅ with ht'\n    refine (iInf₂_le t' fun x hx ↦ ?_).trans ?_\n    · by_cases hxt : x ∈ t\n      · refine mem_iUnion.2 ⟨0, ?_⟩\n        simp [hx, hxt]\n      · refine mem_iUnion.2 ⟨1, ?_⟩\n        simp [hx, hxt]\n    · simp only [iInf_image, coe_toOuterMeasure, iInf_pair]\n      rw [tsum_eq_add_tsum_ite 0, tsum_eq_add_tsum_ite 1, if_neg zero_ne_one.symm,\n        (tsum_eq_zero_iff ENNReal.summable).2 _, add_zero]\n      · exact add_le_add (inf_le_left.trans <| by simp [ht']) (inf_le_right.trans <| by simp [ht'])\n      · simp only [ite_eq_left_iff]\n        intro n hn₁ hn₀\n        simp only [ht', if_neg hn₀, if_neg hn₁, measure_empty, iInf_pair, le_refl, inf_of_le_left]\n  · simp only [iInf_image, coe_toOuterMeasure, iInf_pair]\n    -- Conversely, fixing `t' : ℕ → Set α` such that `s ⊆ ⋃ n, t' n`, we construct `t : Set α`\n    -- for which `μ (t ∩ s) + ν (tᶜ ∩ s) ≤ ∑' n, μ (t' n) ⊓ ν (t' n)`.\n    -- Denoting `I := {n | μ (t' n) ≤ ν (t' n)}`, we set `t = ⋃ n ∈ I, t' n`.\n    -- Clearly `μ (t ∩ s) ≤ ∑' n ∈ I, μ (t' n)` and `ν (tᶜ ∩ s) ≤ ∑' n ∉ I, ν (t' n)`, so\n    -- `μ (t ∩ s) + ν (tᶜ ∩ s) ≤ ∑' n ∈ I, μ (t' n) + ∑' n ∉ I, ν (t' n)`\n    -- where the RHS equals `∑' n, μ (t' n) ⊓ ν (t' n)` by the choice of `I`.\n    set t := ⋃ n ∈ {k : ℕ | μ (t' k) ≤ ν (t' k)}, t' n with ht\n    suffices hadd : μ (t ∩ s) + ν (tᶜ ∩ s) ≤ ∑' n, μ (t' n) ⊓ ν (t' n) by\n      exact le_trans (sInf_le ⟨t, rfl⟩) hadd\n    have hle₁ : μ (t ∩ s) ≤ ∑' (n : {k | μ (t' k) ≤ ν (t' k)}), μ (t' n) :=\n      (measure_mono inter_subset_left).trans <| measure_biUnion_le _ (to_countable _) _\n    have hcap : tᶜ ∩ s ⊆ ⋃ n ∈ {k | ν (t' k) < μ (t' k)}, t' n := by\n      simp_rw [ht, compl_iUnion]\n      refine fun x ⟨hx₁, hx₂⟩ ↦ mem_iUnion₂.2 ?_\n      obtain ⟨i, hi⟩ := mem_iUnion.1 <| ht' hx₂\n      refine ⟨i, ?_, hi⟩\n      by_contra h\n      simp only [mem_setOf_eq, not_lt] at h\n      exact mem_iInter₂.1 hx₁ i h hi\n    have hle₂ : ν (tᶜ ∩ s) ≤ ∑' (n : {k | ν (t' k) < μ (t' k)}), ν (t' n) :=\n      (measure_mono hcap).trans (measure_biUnion_le ν (to_countable {k | ν (t' k) < μ (t' k)}) _)\n    refine (add_le_add hle₁ hle₂).trans ?_\n    have heq : {k | μ (t' k) ≤ ν (t' k)} ∪ {k | ν (t' k) < μ (t' k)} = univ := by\n      ext k; simp [le_or_lt]\n    conv in ∑' (n : ℕ), μ (t' n) ⊓ ν (t' n) => rw [← tsum_univ, ← heq]\n    rw [tsum_union_disjoint (f := fun n ↦ μ (t' n) ⊓ ν (t' n)) ?_ ENNReal.summable ENNReal.summable]\n    · refine add_le_add (tsum_congr ?_).le (tsum_congr ?_).le\n      · rw [Subtype.forall]\n        intro n hn; simpa\n      · rw [Subtype.forall]\n        intro n hn\n        rw [mem_setOf_eq] at hn\n        simp [le_of_lt hn]\n    · rw [Set.disjoint_iff]\n      rintro k ⟨hk₁, hk₂⟩\n      rw [mem_setOf_eq] at hk₁ hk₂\n      exact False.elim <| hk₂.not_le hk₁\n\n"}
{"name":"MeasureTheory.OuterMeasure.toMeasure_top","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\n⊢ Eq (Top.top.toMeasure ⋯) Top.top","decl":"@[simp]\ntheorem _root_.MeasureTheory.OuterMeasure.toMeasure_top :\n    (⊤ : OuterMeasure α).toMeasure (by rw [OuterMeasure.top_caratheodory]; exact le_top) =\n      (⊤ : Measure α) :=\n  toOuterMeasure_toMeasure (μ := ⊤)\n\n"}
{"name":"MeasureTheory.Measure.toOuterMeasure_top","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nx✝ : MeasurableSpace α\n⊢ Eq Top.top.toOuterMeasure Top.top","decl":"@[simp]\ntheorem toOuterMeasure_top {_ : MeasurableSpace α} :\n    (⊤ : Measure α).toOuterMeasure = (⊤ : OuterMeasure α) :=\n  rfl\n\n"}
{"name":"MeasureTheory.Measure.top_add","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\n⊢ Eq (HAdd.hAdd Top.top μ) Top.top","decl":"@[simp]\ntheorem top_add : ⊤ + μ = ⊤ :=\n  top_unique <| Measure.le_add_right le_rfl\n\n"}
{"name":"MeasureTheory.Measure.add_top","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\n⊢ Eq (HAdd.hAdd μ Top.top) Top.top","decl":"@[simp]\ntheorem add_top : μ + ⊤ = ⊤ :=\n  top_unique <| Measure.le_add_left le_rfl\n\n"}
{"name":"MeasureTheory.Measure.zero_le","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\n_m0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\n⊢ LE.le 0 μ","decl":"protected theorem zero_le {_m0 : MeasurableSpace α} (μ : Measure α) : 0 ≤ μ :=\n  bot_le\n\n"}
{"name":"MeasureTheory.Measure.nonpos_iff_eq_zero'","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\n⊢ Iff (LE.le μ 0) (Eq μ 0)","decl":"theorem nonpos_iff_eq_zero' : μ ≤ 0 ↔ μ = 0 :=\n  μ.zero_le.le_iff_eq\n\n"}
{"name":"MeasureTheory.Measure.measure_univ_eq_zero","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\n⊢ Iff (Eq (μ Set.univ) 0) (Eq μ 0)","decl":"@[simp]\ntheorem measure_univ_eq_zero : μ univ = 0 ↔ μ = 0 :=\n  ⟨fun h => bot_unique fun s => (h ▸ measure_mono (subset_univ s) : μ s ≤ 0), fun h =>\n    h.symm ▸ rfl⟩\n\n"}
{"name":"MeasureTheory.Measure.measure_univ_ne_zero","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\n⊢ Iff (Ne (μ Set.univ) 0) (Ne μ 0)","decl":"theorem measure_univ_ne_zero : μ univ ≠ 0 ↔ μ ≠ 0 :=\n  measure_univ_eq_zero.not\n\n"}
{"name":"MeasureTheory.Measure.instNeZeroENNRealCoeSetUniv","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : NeZero μ\n⊢ NeZero (μ Set.univ)","decl":"instance [NeZero μ] : NeZero (μ univ) := ⟨measure_univ_ne_zero.2 <| NeZero.ne μ⟩\n\n"}
{"name":"MeasureTheory.Measure.measure_univ_pos","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\n⊢ Iff (LT.lt 0 (μ Set.univ)) (Ne μ 0)","decl":"@[simp]\ntheorem measure_univ_pos : 0 < μ univ ↔ μ ≠ 0 :=\n  pos_iff_ne_zero.trans measure_univ_ne_zero\n\n"}
{"name":"MeasureTheory.Measure.nonempty_of_neZero","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : NeZero μ\n⊢ Nonempty α","decl":"lemma nonempty_of_neZero (μ : Measure α) [NeZero μ] : Nonempty α :=\n  (isEmpty_or_nonempty α).resolve_left fun h ↦ by\n    simpa [eq_empty_of_isEmpty] using NeZero.ne (μ univ)\n\n"}
{"name":"MeasureTheory.Measure.le_sum_apply","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nι : Type u_5\nm0 : MeasurableSpace α\nf : ι → MeasureTheory.Measure α\ns : Set α\n⊢ LE.le (tsum fun i => (f i) s) ((MeasureTheory.Measure.sum f) s)","decl":"theorem le_sum_apply (f : ι → Measure α) (s : Set α) : ∑' i, f i s ≤ sum f s :=\n  le_toMeasure_apply _ _ _\n\n"}
{"name":"MeasureTheory.Measure.sum_apply","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nι : Type u_5\nm0 : MeasurableSpace α\nf : ι → MeasureTheory.Measure α\ns : Set α\nhs : MeasurableSet s\n⊢ Eq ((MeasureTheory.Measure.sum f) s) (tsum fun i => (f i) s)","decl":"@[simp]\ntheorem sum_apply (f : ι → Measure α) {s : Set α} (hs : MeasurableSet s) :\n    sum f s = ∑' i, f i s :=\n  toMeasure_apply _ _ hs\n\n"}
{"name":"MeasureTheory.Measure.sum_apply₀","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nι : Type u_5\nm0 : MeasurableSpace α\nf : ι → MeasureTheory.Measure α\ns : Set α\nhs : MeasureTheory.NullMeasurableSet s (MeasureTheory.Measure.sum f)\n⊢ Eq ((MeasureTheory.Measure.sum f) s) (tsum fun i => (f i) s)","decl":"theorem sum_apply₀ (f : ι → Measure α) {s : Set α} (hs : NullMeasurableSet s (sum f)) :\n    sum f s = ∑' i, f i s := by\n  apply le_antisymm ?_ (le_sum_apply _ _)\n  rcases hs.exists_measurable_subset_ae_eq with ⟨t, ts, t_meas, ht⟩\n  calc\n  sum f s = sum f t := measure_congr ht.symm\n  _ = ∑' i, f i t := sum_apply _ t_meas\n  _ ≤ ∑' i, f i s := ENNReal.tsum_le_tsum fun i ↦ measure_mono ts\n\n"}
{"name":"MeasureTheory.Measure.sum_apply_of_countable","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nι : Type u_5\nm0 : MeasurableSpace α\ninst✝ : Countable ι\nf : ι → MeasureTheory.Measure α\ns : Set α\n⊢ Eq ((MeasureTheory.Measure.sum f) s) (tsum fun i => (f i) s)","decl":"theorem sum_apply_of_countable [Countable ι] (f : ι → Measure α) (s : Set α) :\n    sum f s = ∑' i, f i s := by\n  apply le_antisymm ?_ (le_sum_apply _ _)\n  rcases exists_measurable_superset_forall_eq f s with ⟨t, hst, htm, ht⟩\n  calc\n  sum f s ≤ sum f t := measure_mono hst\n  _ = ∑' i, f i t := sum_apply _ htm\n  _ = ∑' i, f i s := by simp [ht]\n\n"}
{"name":"MeasureTheory.Measure.le_sum","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nι : Type u_5\nm0 : MeasurableSpace α\nμ : ι → MeasureTheory.Measure α\ni : ι\n⊢ LE.le (μ i) (MeasureTheory.Measure.sum μ)","decl":"theorem le_sum (μ : ι → Measure α) (i : ι) : μ i ≤ sum μ :=\n  le_iff.2 fun s hs ↦ by simpa only [sum_apply μ hs] using ENNReal.le_tsum i\n\n"}
{"name":"MeasureTheory.Measure.sum_apply_eq_zero","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nι : Type u_5\nm0 : MeasurableSpace α\ninst✝ : Countable ι\nμ : ι → MeasureTheory.Measure α\ns : Set α\n⊢ Iff (Eq ((MeasureTheory.Measure.sum μ) s) 0) (∀ (i : ι), Eq ((μ i) s) 0)","decl":"@[simp]\ntheorem sum_apply_eq_zero [Countable ι] {μ : ι → Measure α} {s : Set α} :\n    sum μ s = 0 ↔ ∀ i, μ i s = 0 := by\n  simp [sum_apply_of_countable]\n\n"}
{"name":"MeasureTheory.Measure.sum_apply_eq_zero'","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nι : Type u_5\nm0 : MeasurableSpace α\nμ : ι → MeasureTheory.Measure α\ns : Set α\nhs : MeasurableSet s\n⊢ Iff (Eq ((MeasureTheory.Measure.sum μ) s) 0) (∀ (i : ι), Eq ((μ i) s) 0)","decl":"theorem sum_apply_eq_zero' {μ : ι → Measure α} {s : Set α} (hs : MeasurableSet s) :\n    sum μ s = 0 ↔ ∀ i, μ i s = 0 := by simp [hs]\n\n"}
{"name":"MeasureTheory.Measure.sum_eq_zero","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nι : Type u_5\nm0 : MeasurableSpace α\nf : ι → MeasureTheory.Measure α\n⊢ Iff (Eq (MeasureTheory.Measure.sum f) 0) (∀ (i : ι), Eq (f i) 0)","decl":"@[simp] lemma sum_eq_zero : sum f = 0 ↔ ∀ i, f i = 0 := by\n  simp +contextual [Measure.ext_iff, forall_swap (α := ι)]\n\n"}
{"name":"MeasureTheory.Measure.sum_zero","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nι : Type u_5\nm0 : MeasurableSpace α\n⊢ Eq (MeasureTheory.Measure.sum fun x => 0) 0","decl":"@[simp]\nlemma sum_zero : Measure.sum (fun (_ : ι) ↦ (0 : Measure α)) = 0 := by\n  ext s hs\n  simp [Measure.sum_apply _ hs]\n\n"}
{"name":"MeasureTheory.Measure.sum_sum","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nι : Type u_5\nm0 : MeasurableSpace α\nι' : Type u_8\nμ : ι → ι' → MeasureTheory.Measure α\n⊢ Eq (MeasureTheory.Measure.sum fun n => MeasureTheory.Measure.sum (μ n)) (MeasureTheory.Measure.sum fun p => μ p.1 p.2)","decl":"theorem sum_sum {ι' : Type*} (μ : ι → ι' → Measure α) :\n    (sum fun n => sum (μ n)) = sum (fun (p : ι × ι') ↦ μ p.1 p.2) := by\n  ext1 s hs\n  simp [sum_apply _ hs, ENNReal.tsum_prod']\n\n"}
{"name":"MeasureTheory.Measure.sum_comm","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nι : Type u_5\nm0 : MeasurableSpace α\nι' : Type u_8\nμ : ι → ι' → MeasureTheory.Measure α\n⊢ Eq (MeasureTheory.Measure.sum fun n => MeasureTheory.Measure.sum (μ n)) (MeasureTheory.Measure.sum fun m => MeasureTheory.Measure.sum fun n => μ n m)","decl":"theorem sum_comm {ι' : Type*} (μ : ι → ι' → Measure α) :\n    (sum fun n => sum (μ n)) = sum fun m => sum fun n => μ n m := by\n  ext1 s hs\n  simp_rw [sum_apply _ hs]\n  rw [ENNReal.tsum_comm]\n\n"}
{"name":"MeasureTheory.Measure.ae_sum_iff","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nι : Type u_5\nm0 : MeasurableSpace α\ninst✝ : Countable ι\nμ : ι → MeasureTheory.Measure α\np : α → Prop\n⊢ Iff (Filter.Eventually (fun x => p x) (MeasureTheory.ae (MeasureTheory.Measure.sum μ))) (∀ (i : ι), Filter.Eventually (fun x => p x) (MeasureTheory.ae (μ i)))","decl":"theorem ae_sum_iff [Countable ι] {μ : ι → Measure α} {p : α → Prop} :\n    (∀ᵐ x ∂sum μ, p x) ↔ ∀ i, ∀ᵐ x ∂μ i, p x :=\n  sum_apply_eq_zero\n\n"}
{"name":"MeasureTheory.Measure.ae_sum_iff'","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nι : Type u_5\nm0 : MeasurableSpace α\nμ : ι → MeasureTheory.Measure α\np : α → Prop\nh : MeasurableSet (setOf fun x => p x)\n⊢ Iff (Filter.Eventually (fun x => p x) (MeasureTheory.ae (MeasureTheory.Measure.sum μ))) (∀ (i : ι), Filter.Eventually (fun x => p x) (MeasureTheory.ae (μ i)))","decl":"theorem ae_sum_iff' {μ : ι → Measure α} {p : α → Prop} (h : MeasurableSet { x | p x }) :\n    (∀ᵐ x ∂sum μ, p x) ↔ ∀ i, ∀ᵐ x ∂μ i, p x :=\n  sum_apply_eq_zero' h.compl\n\n"}
{"name":"MeasureTheory.Measure.sum_fintype","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nι : Type u_5\nm0 : MeasurableSpace α\ninst✝ : Fintype ι\nμ : ι → MeasureTheory.Measure α\n⊢ Eq (MeasureTheory.Measure.sum μ) (Finset.univ.sum fun i => μ i)","decl":"@[simp]\ntheorem sum_fintype [Fintype ι] (μ : ι → Measure α) : sum μ = ∑ i, μ i := by\n  ext1 s hs\n  simp only [sum_apply, finset_sum_apply, hs, tsum_fintype]\n\n"}
{"name":"MeasureTheory.Measure.sum_coe_finset","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nι : Type u_5\nm0 : MeasurableSpace α\ns : Finset ι\nμ : ι → MeasureTheory.Measure α\n⊢ Eq (MeasureTheory.Measure.sum fun i => μ ↑i) (s.sum fun i => μ i)","decl":"theorem sum_coe_finset (s : Finset ι) (μ : ι → Measure α) :\n    (sum fun i : s => μ i) = ∑ i ∈ s, μ i := by rw [sum_fintype, Finset.sum_coe_sort s μ]\n\n"}
{"name":"MeasureTheory.Measure.ae_sum_eq","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nι : Type u_5\nm0 : MeasurableSpace α\ninst✝ : Countable ι\nμ : ι → MeasureTheory.Measure α\n⊢ Eq (MeasureTheory.ae (MeasureTheory.Measure.sum μ)) (iSup fun i => MeasureTheory.ae (μ i))","decl":"@[simp]\ntheorem ae_sum_eq [Countable ι] (μ : ι → Measure α) : ae (sum μ) = ⨆ i, ae (μ i) :=\n  Filter.ext fun _ => ae_sum_iff.trans mem_iSup.symm\n\n"}
{"name":"MeasureTheory.Measure.sum_bool","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nf : Bool → MeasureTheory.Measure α\n⊢ Eq (MeasureTheory.Measure.sum f) (HAdd.hAdd (f Bool.true) (f Bool.false))","decl":"theorem sum_bool (f : Bool → Measure α) : sum f = f true + f false := by\n  rw [sum_fintype, Fintype.sum_bool]\n\n"}
{"name":"MeasureTheory.Measure.sum_cond","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\n⊢ Eq (MeasureTheory.Measure.sum fun b => cond b μ ν) (HAdd.hAdd μ ν)","decl":"theorem sum_cond (μ ν : Measure α) : (sum fun b => cond b μ ν) = μ + ν :=\n  sum_bool _\n\n"}
{"name":"MeasureTheory.Measure.sum_of_isEmpty","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nι : Type u_5\nm0 : MeasurableSpace α\ninst✝ : IsEmpty ι\nμ : ι → MeasureTheory.Measure α\n⊢ Eq (MeasureTheory.Measure.sum μ) 0","decl":"@[simp]\ntheorem sum_of_isEmpty [IsEmpty ι] (μ : ι → Measure α) : sum μ = 0 := by\n  rw [← measure_univ_eq_zero, sum_apply _ MeasurableSet.univ, tsum_empty]\n\n"}
{"name":"MeasureTheory.Measure.sum_add_sum_compl","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nι : Type u_5\nm0 : MeasurableSpace α\ns : Set ι\nμ : ι → MeasureTheory.Measure α\n⊢ Eq (HAdd.hAdd (MeasureTheory.Measure.sum fun i => μ ↑i) (MeasureTheory.Measure.sum fun i => μ ↑i)) (MeasureTheory.Measure.sum μ)","decl":"theorem sum_add_sum_compl (s : Set ι) (μ : ι → Measure α) :\n    ((sum fun i : s => μ i) + sum fun i : ↥sᶜ => μ i) = sum μ := by\n  ext1 t ht\n  simp only [add_apply, sum_apply _ ht]\n  exact tsum_add_tsum_compl (f := fun i => μ i t) ENNReal.summable ENNReal.summable\n\n"}
{"name":"MeasureTheory.Measure.sum_congr","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ ν : Nat → MeasureTheory.Measure α\nh : ∀ (n : Nat), Eq (μ n) (ν n)\n⊢ Eq (MeasureTheory.Measure.sum μ) (MeasureTheory.Measure.sum ν)","decl":"theorem sum_congr {μ ν : ℕ → Measure α} (h : ∀ n, μ n = ν n) : sum μ = sum ν :=\n  congr_arg sum (funext h)\n\n"}
{"name":"MeasureTheory.Measure.sum_add_sum","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nι : Type u_8\nμ ν : ι → MeasureTheory.Measure α\n⊢ Eq (HAdd.hAdd (MeasureTheory.Measure.sum μ) (MeasureTheory.Measure.sum ν)) (MeasureTheory.Measure.sum fun n => HAdd.hAdd (μ n) (ν n))","decl":"theorem sum_add_sum {ι : Type*} (μ ν : ι → Measure α) : sum μ + sum ν = sum fun n => μ n + ν n := by\n  ext1 s hs\n  simp only [add_apply, sum_apply _ hs, Pi.add_apply, coe_add,\n    tsum_add ENNReal.summable ENNReal.summable]\n\n"}
{"name":"MeasureTheory.Measure.sum_comp_equiv","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nι : Type u_8\nι' : Type u_9\ne : Equiv ι' ι\nm : ι → MeasureTheory.Measure α\n⊢ Eq (MeasureTheory.Measure.sum (Function.comp m ⇑e)) (MeasureTheory.Measure.sum m)","decl":"@[simp] lemma sum_comp_equiv {ι ι' : Type*} (e : ι' ≃ ι) (m : ι → Measure α) :\n    sum (m ∘ e) = sum m := by\n  ext s hs\n  simpa [hs, sum_apply] using e.tsum_eq (fun n ↦ m n s)\n\n"}
{"name":"MeasureTheory.Measure.sum_extend_zero","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nι : Type u_8\nι' : Type u_9\nf : ι → ι'\nhf : Function.Injective f\nm : ι → MeasureTheory.Measure α\n⊢ Eq (MeasureTheory.Measure.sum (Function.extend f m 0)) (MeasureTheory.Measure.sum m)","decl":"@[simp] lemma sum_extend_zero {ι ι' : Type*} {f : ι → ι'} (hf : Injective f) (m : ι → Measure α) :\n    sum (Function.extend f m 0) = sum m := by\n  ext s hs\n  simp [*, Function.apply_extend (fun μ : Measure α ↦ μ s)]\n"}
{"name":"MeasureTheory.Measure.mem_cofinite","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\n⊢ Iff (Membership.mem μ.cofinite s) (LT.lt (μ (HasCompl.compl s)) Top.top)","decl":"theorem mem_cofinite : s ∈ μ.cofinite ↔ μ sᶜ < ∞ :=\n  Iff.rfl\n\n"}
{"name":"MeasureTheory.Measure.compl_mem_cofinite","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\n⊢ Iff (Membership.mem μ.cofinite (HasCompl.compl s)) (LT.lt (μ s) Top.top)","decl":"theorem compl_mem_cofinite : sᶜ ∈ μ.cofinite ↔ μ s < ∞ := by rw [mem_cofinite, compl_compl]\n\n"}
{"name":"MeasureTheory.Measure.eventually_cofinite","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\np : α → Prop\n⊢ Iff (Filter.Eventually (fun x => p x) μ.cofinite) (LT.lt (μ (setOf fun x => Not (p x))) Top.top)","decl":"theorem eventually_cofinite {p : α → Prop} : (∀ᶠ x in μ.cofinite, p x) ↔ μ { x | ¬p x } < ∞ :=\n  Iff.rfl\n\n"}
{"name":"MeasureTheory.Measure.cofinite.instIsMeasurablyGenerated","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\n⊢ μ.cofinite.IsMeasurablyGenerated","decl":"instance cofinite.instIsMeasurablyGenerated : IsMeasurablyGenerated μ.cofinite where\n  exists_measurable_subset s hs := by\n    refine ⟨(toMeasurable μ sᶜ)ᶜ, ?_, (measurableSet_toMeasurable _ _).compl, ?_⟩\n    · rwa [compl_mem_cofinite, measure_toMeasurable]\n    · rw [compl_subset_comm]\n      apply subset_toMeasurable\n\n"}
{"name":"AEMeasurable.nullMeasurable","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nβ : Type u_2\nm0 : MeasurableSpace α\nmβ : MeasurableSpace β\nμ : MeasureTheory.Measure α\nf : α → β\nh : AEMeasurable f μ\n⊢ MeasureTheory.NullMeasurable f μ","decl":"protected theorem _root_.AEMeasurable.nullMeasurable {f : α → β} (h : AEMeasurable f μ) :\n    NullMeasurable f μ :=\n  let ⟨_g, hgm, hg⟩ := h; hgm.nullMeasurable.congr hg.symm\n\n"}
{"name":"AEMeasurable.nullMeasurableSet_preimage","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nβ : Type u_2\nm0 : MeasurableSpace α\nmβ : MeasurableSpace β\nμ : MeasureTheory.Measure α\nf : α → β\ns : Set β\nhf : AEMeasurable f μ\nhs : MeasurableSet s\n⊢ MeasureTheory.NullMeasurableSet (Set.preimage f s) μ","decl":"lemma _root_.AEMeasurable.nullMeasurableSet_preimage {f : α → β} {s : Set β}\n    (hf : AEMeasurable f μ) (hs : MeasurableSet s) : NullMeasurableSet (f ⁻¹' s) μ :=\n  hf.nullMeasurable hs\n\n"}
{"name":"MeasureTheory.ae_eq_bot","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\n⊢ Iff (Eq (MeasureTheory.ae μ) Bot.bot) (Eq μ 0)","decl":"@[simp]\ntheorem ae_eq_bot : ae μ = ⊥ ↔ μ = 0 := by\n  rw [← empty_mem_iff_bot, mem_ae_iff, compl_empty, measure_univ_eq_zero]\n\n"}
{"name":"MeasureTheory.ae_neBot","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\n⊢ Iff (MeasureTheory.ae μ).NeBot (Ne μ 0)","decl":"@[simp]\ntheorem ae_neBot : (ae μ).NeBot ↔ μ ≠ 0 :=\n  neBot_iff.trans (not_congr ae_eq_bot)\n\n"}
{"name":"MeasureTheory.Measure.ae.neBot","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : NeZero μ\n⊢ (MeasureTheory.ae μ).NeBot","decl":"instance Measure.ae.neBot [NeZero μ] : (ae μ).NeBot := ae_neBot.2 <| NeZero.ne μ\n\n"}
{"name":"MeasureTheory.ae_zero","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\n_m0 : MeasurableSpace α\n⊢ Eq (MeasureTheory.ae 0) Bot.bot","decl":"@[simp]\ntheorem ae_zero {_m0 : MeasurableSpace α} : ae (0 : Measure α) = ⊥ :=\n  ae_eq_bot.2 rfl\n\n"}
{"name":"MeasureTheory.biSup_measure_Iic","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : Preorder α\ns : Set α\nhsc : s.Countable\nhst : ∀ (x : α), Exists fun y => And (Membership.mem s y) (LE.le x y)\nhdir : DirectedOn (fun x1 x2 => LE.le x1 x2) s\n⊢ Eq (iSup fun x => iSup fun h => μ (Set.Iic x)) (μ Set.univ)","decl":"theorem biSup_measure_Iic [Preorder α] {s : Set α} (hsc : s.Countable)\n    (hst : ∀ x : α, ∃ y ∈ s, x ≤ y) (hdir : DirectedOn (· ≤ ·) s) :\n    ⨆ x ∈ s, μ (Iic x) = μ univ := by\n  rw [← measure_biUnion_eq_iSup hsc]\n  · congr\n    simp only [← bex_def] at hst\n    exact iUnion₂_eq_univ_iff.2 hst\n  · exact directedOn_iff_directed.2 (hdir.directed_val.mono_comp _ fun x y => Iic_subset_Iic.2)\n\n"}
{"name":"MeasureTheory.tendsto_measure_Ico_atTop","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\ninst✝² : Preorder α\ninst✝¹ : NoMaxOrder α\ninst✝ : Filter.atTop.IsCountablyGenerated\nμ : MeasureTheory.Measure α\na : α\n⊢ Filter.Tendsto (fun x => μ (Set.Ico a x)) Filter.atTop (nhds (μ (Set.Ici a)))","decl":"theorem tendsto_measure_Ico_atTop [Preorder α] [NoMaxOrder α]\n    [(atTop : Filter α).IsCountablyGenerated] (μ : Measure α) (a : α) :\n    Tendsto (fun x => μ (Ico a x)) atTop (𝓝 (μ (Ici a))) := by\n  rw [← iUnion_Ico_right]\n  exact tendsto_measure_iUnion_atTop (antitone_const.Ico monotone_id)\n\n"}
{"name":"MeasureTheory.tendsto_measure_Ioc_atBot","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\ninst✝² : Preorder α\ninst✝¹ : NoMinOrder α\ninst✝ : Filter.atBot.IsCountablyGenerated\nμ : MeasureTheory.Measure α\na : α\n⊢ Filter.Tendsto (fun x => μ (Set.Ioc x a)) Filter.atBot (nhds (μ (Set.Iic a)))","decl":"theorem tendsto_measure_Ioc_atBot [Preorder α] [NoMinOrder α]\n    [(atBot : Filter α).IsCountablyGenerated] (μ : Measure α) (a : α) :\n    Tendsto (fun x => μ (Ioc x a)) atBot (𝓝 (μ (Iic a))) := by\n  rw [← iUnion_Ioc_left]\n  exact tendsto_measure_iUnion_atBot (monotone_id.Ioc antitone_const)\n\n"}
{"name":"MeasureTheory.tendsto_measure_Iic_atTop","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\ninst✝¹ : Preorder α\ninst✝ : Filter.atTop.IsCountablyGenerated\nμ : MeasureTheory.Measure α\n⊢ Filter.Tendsto (fun x => μ (Set.Iic x)) Filter.atTop (nhds (μ Set.univ))","decl":"theorem tendsto_measure_Iic_atTop [Preorder α] [(atTop : Filter α).IsCountablyGenerated]\n    (μ : Measure α) : Tendsto (fun x => μ (Iic x)) atTop (𝓝 (μ univ)) := by\n  rw [← iUnion_Iic]\n  exact tendsto_measure_iUnion_atTop monotone_Iic\n\n"}
{"name":"MeasureTheory.tendsto_measure_Ici_atBot","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\ninst✝¹ : Preorder α\ninst✝ : Filter.atBot.IsCountablyGenerated\nμ : MeasureTheory.Measure α\n⊢ Filter.Tendsto (fun x => μ (Set.Ici x)) Filter.atBot (nhds (μ Set.univ))","decl":"theorem tendsto_measure_Ici_atBot [Preorder α] [(atBot : Filter α).IsCountablyGenerated]\n    (μ : Measure α) : Tendsto (fun x => μ (Ici x)) atBot (𝓝 (μ univ)) :=\n  tendsto_measure_Iic_atTop (α := αᵒᵈ) μ\n\n"}
{"name":"MeasureTheory.Iio_ae_eq_Iic'","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : PartialOrder α\na : α\nha : Eq (μ (Singleton.singleton a)) 0\n⊢ (MeasureTheory.ae μ).EventuallyEq (Set.Iio a) (Set.Iic a)","decl":"theorem Iio_ae_eq_Iic' (ha : μ {a} = 0) : Iio a =ᵐ[μ] Iic a := by\n  rw [← Iic_diff_right, diff_ae_eq_self, measure_mono_null Set.inter_subset_right ha]\n\n"}
{"name":"MeasureTheory.Ioi_ae_eq_Ici'","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : PartialOrder α\na : α\nha : Eq (μ (Singleton.singleton a)) 0\n⊢ (MeasureTheory.ae μ).EventuallyEq (Set.Ioi a) (Set.Ici a)","decl":"theorem Ioi_ae_eq_Ici' (ha : μ {a} = 0) : Ioi a =ᵐ[μ] Ici a :=\n  Iio_ae_eq_Iic' (α := αᵒᵈ) ha\n\n"}
{"name":"MeasureTheory.Ioo_ae_eq_Ioc'","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : PartialOrder α\na b : α\nhb : Eq (μ (Singleton.singleton b)) 0\n⊢ (MeasureTheory.ae μ).EventuallyEq (Set.Ioo a b) (Set.Ioc a b)","decl":"theorem Ioo_ae_eq_Ioc' (hb : μ {b} = 0) : Ioo a b =ᵐ[μ] Ioc a b :=\n  (ae_eq_refl _).inter (Iio_ae_eq_Iic' hb)\n\n"}
{"name":"MeasureTheory.Ioc_ae_eq_Icc'","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : PartialOrder α\na b : α\nha : Eq (μ (Singleton.singleton a)) 0\n⊢ (MeasureTheory.ae μ).EventuallyEq (Set.Ioc a b) (Set.Icc a b)","decl":"theorem Ioc_ae_eq_Icc' (ha : μ {a} = 0) : Ioc a b =ᵐ[μ] Icc a b :=\n  (Ioi_ae_eq_Ici' ha).inter (ae_eq_refl _)\n\n"}
{"name":"MeasureTheory.Ioo_ae_eq_Ico'","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : PartialOrder α\na b : α\nha : Eq (μ (Singleton.singleton a)) 0\n⊢ (MeasureTheory.ae μ).EventuallyEq (Set.Ioo a b) (Set.Ico a b)","decl":"theorem Ioo_ae_eq_Ico' (ha : μ {a} = 0) : Ioo a b =ᵐ[μ] Ico a b :=\n  (Ioi_ae_eq_Ici' ha).inter (ae_eq_refl _)\n\n"}
{"name":"MeasureTheory.Ioo_ae_eq_Icc'","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : PartialOrder α\na b : α\nha : Eq (μ (Singleton.singleton a)) 0\nhb : Eq (μ (Singleton.singleton b)) 0\n⊢ (MeasureTheory.ae μ).EventuallyEq (Set.Ioo a b) (Set.Icc a b)","decl":"theorem Ioo_ae_eq_Icc' (ha : μ {a} = 0) (hb : μ {b} = 0) : Ioo a b =ᵐ[μ] Icc a b :=\n  (Ioi_ae_eq_Ici' ha).inter (Iio_ae_eq_Iic' hb)\n\n"}
{"name":"MeasureTheory.Ico_ae_eq_Icc'","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : PartialOrder α\na b : α\nhb : Eq (μ (Singleton.singleton b)) 0\n⊢ (MeasureTheory.ae μ).EventuallyEq (Set.Ico a b) (Set.Icc a b)","decl":"theorem Ico_ae_eq_Icc' (hb : μ {b} = 0) : Ico a b =ᵐ[μ] Icc a b :=\n  (ae_eq_refl _).inter (Iio_ae_eq_Iic' hb)\n\n"}
{"name":"MeasureTheory.Ico_ae_eq_Ioc'","module":"Mathlib.MeasureTheory.Measure.MeasureSpace","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : PartialOrder α\na b : α\nha : Eq (μ (Singleton.singleton a)) 0\nhb : Eq (μ (Singleton.singleton b)) 0\n⊢ (MeasureTheory.ae μ).EventuallyEq (Set.Ico a b) (Set.Ioc a b)","decl":"theorem Ico_ae_eq_Ioc' (ha : μ {a} = 0) (hb : μ {b} = 0) : Ico a b =ᵐ[μ] Ioc a b :=\n  (Ioo_ae_eq_Ico' ha).symm.trans (Ioo_ae_eq_Ioc' hb)\n\n"}
