{"name":"HomologicalComplex.opcyclesToCycles_iCycles","module":"Mathlib.Algebra.Homology.HomologySequence","initialProofState":"C : Type u_1\nŒπ : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\nc : ComplexShape Œπ\nK : HomologicalComplex C c\ni j : Œπ\ninst‚úù¬π : K.HasHomology i\ninst‚úù : K.HasHomology j\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (K.opcyclesToCycles i j) (K.iCycles j)) (K.fromOpcycles i j)","decl":"@[reassoc (attr := simp)]\nlemma opcyclesToCycles_iCycles : K.opcyclesToCycles i j ‚â´ K.iCycles j = K.fromOpcycles i j := by\n  dsimp only [opcyclesToCycles]\n  simp\n\n"}
{"name":"HomologicalComplex.opcyclesToCycles_iCycles_assoc","module":"Mathlib.Algebra.Homology.HomologySequence","initialProofState":"C : Type u_1\nŒπ : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\nc : ComplexShape Œπ\nK : HomologicalComplex C c\ni j : Œπ\ninst‚úù¬π : K.HasHomology i\ninst‚úù : K.HasHomology j\nZ : C\nh : Quiver.Hom (K.X j) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (K.opcyclesToCycles i j) (CategoryTheory.CategoryStruct.comp (K.iCycles j) h)) (CategoryTheory.CategoryStruct.comp (K.fromOpcycles i j) h)","decl":"@[reassoc (attr := simp)]\nlemma opcyclesToCycles_iCycles : K.opcyclesToCycles i j ‚â´ K.iCycles j = K.fromOpcycles i j := by\n  dsimp only [opcyclesToCycles]\n  simp\n\n"}
{"name":"HomologicalComplex.pOpcycles_opcyclesToCycles_iCycles","module":"Mathlib.Algebra.Homology.HomologySequence","initialProofState":"C : Type u_1\nŒπ : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\nc : ComplexShape Œπ\nK : HomologicalComplex C c\ni j : Œπ\ninst‚úù¬π : K.HasHomology i\ninst‚úù : K.HasHomology j\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (K.pOpcycles i) (CategoryTheory.CategoryStruct.comp (K.opcyclesToCycles i j) (K.iCycles j))) (K.d i j)","decl":"@[reassoc]\nlemma pOpcycles_opcyclesToCycles_iCycles :\n    K.pOpcycles i ‚â´ K.opcyclesToCycles i j ‚â´ K.iCycles j = K.d i j := by\n  simp [opcyclesToCycles]\n\n"}
{"name":"HomologicalComplex.pOpcycles_opcyclesToCycles_iCycles_assoc","module":"Mathlib.Algebra.Homology.HomologySequence","initialProofState":"C : Type u_1\nŒπ : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\nc : ComplexShape Œπ\nK : HomologicalComplex C c\ni j : Œπ\ninst‚úù¬π : K.HasHomology i\ninst‚úù : K.HasHomology j\nZ : C\nh : Quiver.Hom (K.X j) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (K.pOpcycles i) (CategoryTheory.CategoryStruct.comp (K.opcyclesToCycles i j) (CategoryTheory.CategoryStruct.comp (K.iCycles j) h))) (CategoryTheory.CategoryStruct.comp (K.d i j) h)","decl":"@[reassoc]\nlemma pOpcycles_opcyclesToCycles_iCycles :\n    K.pOpcycles i ‚â´ K.opcyclesToCycles i j ‚â´ K.iCycles j = K.d i j := by\n  simp [opcyclesToCycles]\n\n"}
{"name":"HomologicalComplex.pOpcycles_opcyclesToCycles_assoc","module":"Mathlib.Algebra.Homology.HomologySequence","initialProofState":"C : Type u_1\nŒπ : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\nc : ComplexShape Œπ\nK : HomologicalComplex C c\ni j : Œπ\ninst‚úù¬π : K.HasHomology i\ninst‚úù : K.HasHomology j\nZ : C\nh : Quiver.Hom (K.cycles j) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (K.pOpcycles i) (CategoryTheory.CategoryStruct.comp (K.opcyclesToCycles i j) h)) (CategoryTheory.CategoryStruct.comp (K.toCycles i j) h)","decl":"@[reassoc (attr := simp)]\nlemma pOpcycles_opcyclesToCycles :\n    K.pOpcycles i ‚â´ K.opcyclesToCycles i j = K.toCycles i j := by\n  simp only [‚Üê cancel_mono (K.iCycles j), assoc, opcyclesToCycles_iCycles,\n    p_fromOpcycles, toCycles_i]\n\n"}
{"name":"HomologicalComplex.pOpcycles_opcyclesToCycles","module":"Mathlib.Algebra.Homology.HomologySequence","initialProofState":"C : Type u_1\nŒπ : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\nc : ComplexShape Œπ\nK : HomologicalComplex C c\ni j : Œπ\ninst‚úù¬π : K.HasHomology i\ninst‚úù : K.HasHomology j\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (K.pOpcycles i) (K.opcyclesToCycles i j)) (K.toCycles i j)","decl":"@[reassoc (attr := simp)]\nlemma pOpcycles_opcyclesToCycles :\n    K.pOpcycles i ‚â´ K.opcyclesToCycles i j = K.toCycles i j := by\n  simp only [‚Üê cancel_mono (K.iCycles j), assoc, opcyclesToCycles_iCycles,\n    p_fromOpcycles, toCycles_i]\n\n"}
{"name":"HomologicalComplex.homologyŒπ_opcyclesToCycles_assoc","module":"Mathlib.Algebra.Homology.HomologySequence","initialProofState":"C : Type u_1\nŒπ : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\nc : ComplexShape Œπ\nK : HomologicalComplex C c\ni j : Œπ\ninst‚úù¬π : K.HasHomology i\ninst‚úù : K.HasHomology j\nZ : C\nh : Quiver.Hom (K.cycles j) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (K.homologyŒπ i) (CategoryTheory.CategoryStruct.comp (K.opcyclesToCycles i j) h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"@[reassoc (attr := simp)]\nlemma homologyŒπ_opcyclesToCycles :\n    K.homologyŒπ i ‚â´ K.opcyclesToCycles i j = 0 := by\n  simp only [‚Üê cancel_mono (K.iCycles j), assoc, opcyclesToCycles_iCycles,\n    homologyŒπ_comp_fromOpcycles, zero_comp]\n\n"}
{"name":"HomologicalComplex.homologyŒπ_opcyclesToCycles","module":"Mathlib.Algebra.Homology.HomologySequence","initialProofState":"C : Type u_1\nŒπ : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\nc : ComplexShape Œπ\nK : HomologicalComplex C c\ni j : Œπ\ninst‚úù¬π : K.HasHomology i\ninst‚úù : K.HasHomology j\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (K.homologyŒπ i) (K.opcyclesToCycles i j)) 0","decl":"@[reassoc (attr := simp)]\nlemma homologyŒπ_opcyclesToCycles :\n    K.homologyŒπ i ‚â´ K.opcyclesToCycles i j = 0 := by\n  simp only [‚Üê cancel_mono (K.iCycles j), assoc, opcyclesToCycles_iCycles,\n    homologyŒπ_comp_fromOpcycles, zero_comp]\n\n"}
{"name":"HomologicalComplex.opcyclesToCycles_homologyœÄ_assoc","module":"Mathlib.Algebra.Homology.HomologySequence","initialProofState":"C : Type u_1\nŒπ : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\nc : ComplexShape Œπ\nK : HomologicalComplex C c\ni j : Œπ\ninst‚úù¬π : K.HasHomology i\ninst‚úù : K.HasHomology j\nZ : C\nh : Quiver.Hom (K.homology j) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (K.opcyclesToCycles i j) (CategoryTheory.CategoryStruct.comp (K.homologyœÄ j) h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"@[reassoc (attr := simp)]\nlemma opcyclesToCycles_homologyœÄ :\n    K.opcyclesToCycles i j ‚â´ K.homologyœÄ j = 0 := by\n  simp only [‚Üê cancel_epi (K.pOpcycles i),\n    pOpcycles_opcyclesToCycles_assoc, toCycles_comp_homologyœÄ, comp_zero]\n\n"}
{"name":"HomologicalComplex.opcyclesToCycles_homologyœÄ","module":"Mathlib.Algebra.Homology.HomologySequence","initialProofState":"C : Type u_1\nŒπ : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\nc : ComplexShape Œπ\nK : HomologicalComplex C c\ni j : Œπ\ninst‚úù¬π : K.HasHomology i\ninst‚úù : K.HasHomology j\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (K.opcyclesToCycles i j) (K.homologyœÄ j)) 0","decl":"@[reassoc (attr := simp)]\nlemma opcyclesToCycles_homologyœÄ :\n    K.opcyclesToCycles i j ‚â´ K.homologyœÄ j = 0 := by\n  simp only [‚Üê cancel_epi (K.pOpcycles i),\n    pOpcycles_opcyclesToCycles_assoc, toCycles_comp_homologyœÄ, comp_zero]\n\n"}
{"name":"HomologicalComplex.opcyclesToCycles_naturality","module":"Mathlib.Algebra.Homology.HomologySequence","initialProofState":"C : Type u_1\nŒπ : Type u_2\ninst‚úù‚Åµ : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù‚Å¥ : CategoryTheory.Limits.HasZeroMorphisms C\nc : ComplexShape Œπ\nK L : HomologicalComplex C c\nœÜ : Quiver.Hom K L\ni j : Œπ\ninst‚úù¬≥ : K.HasHomology i\ninst‚úù¬≤ : K.HasHomology j\ninst‚úù¬π : L.HasHomology i\ninst‚úù : L.HasHomology j\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.opcyclesMap œÜ i) (L.opcyclesToCycles i j)) (CategoryTheory.CategoryStruct.comp (K.opcyclesToCycles i j) (HomologicalComplex.cyclesMap œÜ j))","decl":"@[reassoc (attr := simp)]\nlemma opcyclesToCycles_naturality :\n    opcyclesMap œÜ i ‚â´ opcyclesToCycles L i j = opcyclesToCycles K i j ‚â´ cyclesMap œÜ j := by\n  simp only [‚Üê cancel_mono (L.iCycles j), ‚Üê cancel_epi (K.pOpcycles i),\n    assoc, p_opcyclesMap_assoc, pOpcycles_opcyclesToCycles_iCycles, Hom.comm, cyclesMap_i,\n    pOpcycles_opcyclesToCycles_iCycles_assoc]\n\n"}
{"name":"HomologicalComplex.opcyclesToCycles_naturality_assoc","module":"Mathlib.Algebra.Homology.HomologySequence","initialProofState":"C : Type u_1\nŒπ : Type u_2\ninst‚úù‚Åµ : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù‚Å¥ : CategoryTheory.Limits.HasZeroMorphisms C\nc : ComplexShape Œπ\nK L : HomologicalComplex C c\nœÜ : Quiver.Hom K L\ni j : Œπ\ninst‚úù¬≥ : K.HasHomology i\ninst‚úù¬≤ : K.HasHomology j\ninst‚úù¬π : L.HasHomology i\ninst‚úù : L.HasHomology j\nZ : C\nh : Quiver.Hom (L.cycles j) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.opcyclesMap œÜ i) (CategoryTheory.CategoryStruct.comp (L.opcyclesToCycles i j) h)) (CategoryTheory.CategoryStruct.comp (K.opcyclesToCycles i j) (CategoryTheory.CategoryStruct.comp (HomologicalComplex.cyclesMap œÜ j) h))","decl":"@[reassoc (attr := simp)]\nlemma opcyclesToCycles_naturality :\n    opcyclesMap œÜ i ‚â´ opcyclesToCycles L i j = opcyclesToCycles K i j ‚â´ cyclesMap œÜ j := by\n  simp only [‚Üê cancel_mono (L.iCycles j), ‚Üê cancel_epi (K.pOpcycles i),\n    assoc, p_opcyclesMap_assoc, pOpcycles_opcyclesToCycles_iCycles, Hom.comm, cyclesMap_i,\n    pOpcycles_opcyclesToCycles_iCycles_assoc]\n\n"}
{"name":"HomologicalComplex.natTransOpCyclesToCycles_app","module":"Mathlib.Algebra.Homology.HomologySequence","initialProofState":"C : Type u_1\nŒπ : Type u_2\ninst‚úù¬≤ : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nc : ComplexShape Œπ\ni j : Œπ\ninst‚úù : CategoryTheory.CategoryWithHomology C\nK : HomologicalComplex C c\n‚ä¢ Eq ((HomologicalComplex.natTransOpCyclesToCycles C c i j).app K) (K.opcyclesToCycles i j)","decl":"/-- The natural transformation `K.opcyclesToCycles i j : K.opcycles i ‚ü∂ K.cycles j` for all\n`K : HomologicalComplex C c`. -/\n@[simps]\nnoncomputable def natTransOpCyclesToCycles [CategoryWithHomology C] :\n    opcyclesFunctor C c i ‚ü∂ cyclesFunctor C c j where\n  app K := K.opcyclesToCycles i j\n\n"}
{"name":"HomologicalComplex.HomologySequence.instMonoMap'ComposableArrows‚ÇÉOfNatNat","module":"Mathlib.Algebra.Homology.HomologySequence","initialProofState":"C : Type u_1\nŒπ : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù¬≤ : CategoryTheory.Preadditive C\nc : ComplexShape Œπ\nK : HomologicalComplex C c\ni j : Œπ\ninst‚úù¬π : K.HasHomology i\ninst‚úù : K.HasHomology j\n‚ä¢ CategoryTheory.Mono ((HomologicalComplex.HomologySequence.composableArrows‚ÇÉ K i j).map' 0 1 ‚ãØ ‚ãØ)","decl":"instance [K.HasHomology i] [K.HasHomology j] :\n    Mono ((composableArrows‚ÇÉ K i j).map' 0 1) := by\n  dsimp\n  infer_instance\n\n"}
{"name":"HomologicalComplex.HomologySequence.instEpiMap'ComposableArrows‚ÇÉOfNatNat","module":"Mathlib.Algebra.Homology.HomologySequence","initialProofState":"C : Type u_1\nŒπ : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù¬≤ : CategoryTheory.Preadditive C\nc : ComplexShape Œπ\nK : HomologicalComplex C c\ni j : Œπ\ninst‚úù¬π : K.HasHomology i\ninst‚úù : K.HasHomology j\n‚ä¢ CategoryTheory.Epi ((HomologicalComplex.HomologySequence.composableArrows‚ÇÉ K i j).map' 2 3 ‚ãØ ‚ãØ)","decl":"set_option simprocs false in\ninstance [K.HasHomology i] [K.HasHomology j] :\n    Epi ((composableArrows‚ÇÉ K i j).map' 2 3) := by\n  dsimp\n  infer_instance\n\n"}
{"name":"HomologicalComplex.HomologySequence.composableArrows‚ÇÉ_exact","module":"Mathlib.Algebra.Homology.HomologySequence","initialProofState":"C : Type u_1\nŒπ : Type u_2\ninst‚úù¬≤ : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù¬π : CategoryTheory.Preadditive C\nc : ComplexShape Œπ\nK : HomologicalComplex C c\ni j : Œπ\nhij : c.Rel i j\ninst‚úù : CategoryTheory.CategoryWithHomology C\n‚ä¢ (HomologicalComplex.HomologySequence.composableArrows‚ÇÉ K i j).Exact","decl":"include hij in\n/-- The diagram `K.homology i ‚ü∂ K.opcycles i ‚ü∂ K.cycles j ‚ü∂ K.homology j` is exact\nwhen `c.Rel i j`. -/\nlemma composableArrows‚ÇÉ_exact [CategoryWithHomology C] :\n    (composableArrows‚ÇÉ K i j).Exact := by\n  let S := ShortComplex.mk (K.homologyŒπ i) (K.opcyclesToCycles i j) (by simp)\n  let S' := ShortComplex.mk (K.homologyŒπ i) (K.fromOpcycles i j) (by simp)\n  let Œπ : S ‚ü∂ S' :=\n    { œÑ‚ÇÅ := ùüô _\n      œÑ‚ÇÇ := ùüô _\n      œÑ‚ÇÉ := K.iCycles j }\n  have hS : S.Exact := by\n    rw [ShortComplex.exact_iff_of_epi_of_isIso_of_mono Œπ]\n    exact S'.exact_of_f_is_kernel (K.homologyIsKernel i j (c.next_eq' hij))\n  let T := ShortComplex.mk (K.opcyclesToCycles i j) (K.homologyœÄ j) (by simp)\n  let T' := ShortComplex.mk (K.toCycles i j) (K.homologyœÄ j) (by simp)\n  let œÄ : T' ‚ü∂ T :=\n    { œÑ‚ÇÅ := K.pOpcycles i\n      œÑ‚ÇÇ := ùüô _\n      œÑ‚ÇÉ := ùüô _ }\n  have hT : T.Exact := by\n    rw [‚Üê ShortComplex.exact_iff_of_epi_of_isIso_of_mono œÄ]\n    exact T'.exact_of_g_is_cokernel (K.homologyIsCokernel i j (c.prev_eq' hij))\n  apply ComposableArrows.exact_of_Œ¥‚ÇÄ\n  ¬∑ exact hS.exact_toComposableArrows\n  ¬∑ exact hT.exact_toComposableArrows\n\n"}
{"name":"HomologicalComplex.HomologySequence.composableArrows‚ÇÉFunctor_obj","module":"Mathlib.Algebra.Homology.HomologySequence","initialProofState":"C : Type u_1\nŒπ : Type u_2\ninst‚úù¬≤ : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù¬π : CategoryTheory.Preadditive C\nc : ComplexShape Œπ\ni j : Œπ\ninst‚úù : CategoryTheory.CategoryWithHomology C\nK : HomologicalComplex C c\n‚ä¢ Eq ((HomologicalComplex.HomologySequence.composableArrows‚ÇÉFunctor C i j).obj K) (HomologicalComplex.HomologySequence.composableArrows‚ÇÉ K i j)","decl":"set_option simprocs false in\n/-- The functor `HomologicalComplex C c ‚•§ ComposableArrows C 3` that maps `K` to the\ndiagram `K.homology i ‚ü∂ K.opcycles i ‚ü∂ K.cycles j ‚ü∂ K.homology j`. -/\n@[simps]\nnoncomputable def composableArrows‚ÇÉFunctor [CategoryWithHomology C] :\n    HomologicalComplex C c ‚•§ ComposableArrows C 3 where\n  obj K := composableArrows‚ÇÉ K i j\n  map {K L} œÜ := ComposableArrows.homMk‚ÇÉ (homologyMap œÜ i) (opcyclesMap œÜ i) (cyclesMap œÜ j)\n    (homologyMap œÜ j) (by simp) (by simp) (by simp)\n\n"}
{"name":"HomologicalComplex.HomologySequence.composableArrows‚ÇÉFunctor_map","module":"Mathlib.Algebra.Homology.HomologySequence","initialProofState":"C : Type u_1\nŒπ : Type u_2\ninst‚úù¬≤ : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù¬π : CategoryTheory.Preadditive C\nc : ComplexShape Œπ\ni j : Œπ\ninst‚úù : CategoryTheory.CategoryWithHomology C\nK L : HomologicalComplex C c\nœÜ : Quiver.Hom K L\n‚ä¢ Eq ((HomologicalComplex.HomologySequence.composableArrows‚ÇÉFunctor C i j).map œÜ) (CategoryTheory.ComposableArrows.homMk‚ÇÉ (HomologicalComplex.homologyMap œÜ i) (HomologicalComplex.opcyclesMap œÜ i) (HomologicalComplex.cyclesMap œÜ j) (HomologicalComplex.homologyMap œÜ j) ‚ãØ ‚ãØ ‚ãØ)","decl":"set_option simprocs false in\n/-- The functor `HomologicalComplex C c ‚•§ ComposableArrows C 3` that maps `K` to the\ndiagram `K.homology i ‚ü∂ K.opcycles i ‚ü∂ K.cycles j ‚ü∂ K.homology j`. -/\n@[simps]\nnoncomputable def composableArrows‚ÇÉFunctor [CategoryWithHomology C] :\n    HomologicalComplex C c ‚•§ ComposableArrows C 3 where\n  obj K := composableArrows‚ÇÉ K i j\n  map {K L} œÜ := ComposableArrows.homMk‚ÇÉ (homologyMap œÜ i) (opcyclesMap œÜ i) (cyclesMap œÜ j)\n    (homologyMap œÜ j) (by simp) (by simp) (by simp)\n\n"}
{"name":"HomologicalComplex.opcycles_right_exact","module":"Mathlib.Algebra.Homology.HomologySequence","initialProofState":"C : Type u_1\nŒπ : Type u_2\ninst‚úù‚Åµ : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù‚Å¥ : CategoryTheory.Abelian C\nc : ComplexShape Œπ\nS : CategoryTheory.ShortComplex (HomologicalComplex C c)\nhS : S.Exact\ninst‚úù¬≥ : CategoryTheory.Epi S.g\ni : Œπ\ninst‚úù¬≤ : S.X‚ÇÅ.HasHomology i\ninst‚úù¬π : S.X‚ÇÇ.HasHomology i\ninst‚úù : S.X‚ÇÉ.HasHomology i\n‚ä¢ (CategoryTheory.ShortComplex.mk (HomologicalComplex.opcyclesMap S.f i) (HomologicalComplex.opcyclesMap S.g i) ‚ãØ).Exact","decl":"/-- If `X‚ÇÅ ‚ü∂ X‚ÇÇ ‚ü∂ X‚ÇÉ ‚ü∂ 0` is an exact sequence of homological complexes, then\n`X‚ÇÅ.opcycles i ‚ü∂ X‚ÇÇ.opcycles i ‚ü∂ X‚ÇÉ.opcycles i ‚ü∂ 0` is exact. This lemma states\nthe exactness at `X‚ÇÇ.opcycles i`, while the fact that `X‚ÇÇ.opcycles i ‚ü∂ X‚ÇÉ.opcycles i`\nis an epi is an instance. -/\nlemma opcycles_right_exact (S : ShortComplex (HomologicalComplex C c)) (hS : S.Exact) [Epi S.g]\n    (i : Œπ) [S.X‚ÇÅ.HasHomology i] [S.X‚ÇÇ.HasHomology i] [S.X‚ÇÉ.HasHomology i] :\n    (ShortComplex.mk (opcyclesMap S.f i) (opcyclesMap S.g i)\n      (by rw [‚Üê opcyclesMap_comp, S.zero, opcyclesMap_zero])).Exact := by\n  have : Epi (ShortComplex.map S (eval C c i)).g := by dsimp; infer_instance\n  have hj := (hS.map (HomologicalComplex.eval C c i)).gIsCokernel\n  apply ShortComplex.exact_of_g_is_cokernel\n  refine CokernelCofork.IsColimit.ofœÄ' _ _  (fun {A} k hk => by\n    dsimp at k hk ‚ä¢\n    have H := CokernelCofork.IsColimit.desc' hj (S.X‚ÇÇ.pOpcycles i ‚â´ k) (by\n      dsimp\n      rw [‚Üê p_opcyclesMap_assoc, hk, comp_zero])\n    dsimp at H\n    refine ‚ü®S.X‚ÇÉ.descOpcycles H.1 _ rfl ?_, ?_‚ü©\n    ¬∑ rw [‚Üê cancel_epi (S.g.f (c.prev i)), comp_zero, Hom.comm_assoc, H.2,\n        d_pOpcycles_assoc, zero_comp]\n    ¬∑ rw [‚Üê cancel_epi (S.X‚ÇÇ.pOpcycles i), opcyclesMap_comp_descOpcycles, p_descOpcycles, H.2])\n\n"}
{"name":"HomologicalComplex.cycles_left_exact","module":"Mathlib.Algebra.Homology.HomologySequence","initialProofState":"C : Type u_1\nŒπ : Type u_2\ninst‚úù‚Åµ : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù‚Å¥ : CategoryTheory.Abelian C\nc : ComplexShape Œπ\nS : CategoryTheory.ShortComplex (HomologicalComplex C c)\nhS : S.Exact\ninst‚úù¬≥ : CategoryTheory.Mono S.f\ni : Œπ\ninst‚úù¬≤ : S.X‚ÇÅ.HasHomology i\ninst‚úù¬π : S.X‚ÇÇ.HasHomology i\ninst‚úù : S.X‚ÇÉ.HasHomology i\n‚ä¢ (CategoryTheory.ShortComplex.mk (HomologicalComplex.cyclesMap S.f i) (HomologicalComplex.cyclesMap S.g i) ‚ãØ).Exact","decl":"/-- If `0 ‚ü∂ X‚ÇÅ ‚ü∂ X‚ÇÇ ‚ü∂ X‚ÇÉ` is an exact sequence of homological complex, then\n`0 ‚ü∂ X‚ÇÅ.cycles i ‚ü∂ X‚ÇÇ.cycles i ‚ü∂ X‚ÇÉ.cycles i` is exact. This lemma states\nthe exactness at `X‚ÇÇ.cycles i`, while the fact that `X‚ÇÅ.cycles i ‚ü∂ X‚ÇÇ.cycles i`\nis a mono is an instance. -/\nlemma cycles_left_exact (S : ShortComplex (HomologicalComplex C c)) (hS : S.Exact) [Mono S.f]\n    (i : Œπ) [S.X‚ÇÅ.HasHomology i] [S.X‚ÇÇ.HasHomology i] [S.X‚ÇÉ.HasHomology i] :\n    (ShortComplex.mk (cyclesMap S.f i) (cyclesMap S.g i)\n      (by rw [‚Üê cyclesMap_comp, S.zero, cyclesMap_zero])).Exact := by\n  have : Mono (ShortComplex.map S (eval C c i)).f := by dsimp; infer_instance\n  have hi := (hS.map (HomologicalComplex.eval C c i)).fIsKernel\n  apply ShortComplex.exact_of_f_is_kernel\n  exact KernelFork.IsLimit.ofŒπ' _ _ (fun {A} k hk => by\n    dsimp at k hk ‚ä¢\n    have H := KernelFork.IsLimit.lift' hi (k ‚â´ S.X‚ÇÇ.iCycles i) (by\n      dsimp\n      rw [assoc, ‚Üê cyclesMap_i, reassoc_of% hk, zero_comp])\n    dsimp at H\n    refine ‚ü®S.X‚ÇÅ.liftCycles H.1 _ rfl ?_, ?_‚ü©\n    ¬∑ rw [‚Üê cancel_mono (S.f.f _), assoc, zero_comp, ‚Üê Hom.comm, reassoc_of% H.2,\n        iCycles_d, comp_zero]\n    ¬∑ rw [‚Üê cancel_mono (S.X‚ÇÇ.iCycles i), liftCycles_comp_cyclesMap, liftCycles_i, H.2])\n\n"}
{"name":"HomologicalComplex.HomologySequence.snakeInput_L‚ÇÉ","module":"Mathlib.Algebra.Homology.HomologySequence","initialProofState":"C : Type u_1\nŒπ : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù : CategoryTheory.Abelian C\nc : ComplexShape Œπ\nS : CategoryTheory.ShortComplex (HomologicalComplex C c)\nhS : S.ShortExact\ni j : Œπ\nhij : c.Rel i j\n‚ä¢ Eq (HomologicalComplex.HomologySequence.snakeInput hS i j hij).L‚ÇÉ ((HomologicalComplex.homologyFunctor C c j).mapShortComplex.obj S)","decl":"/-- Given a short exact short complex `S : HomologicalComplex C c`, and degrees `i` and `j`\nsuch that `c.Rel i j`, this is the snake diagram whose four lines are respectively\nobtained by applying the functors `homologyFunctor C c i`, `opcyclesFunctor C c i`,\n`cyclesFunctor C c j`, `homologyFunctor C c j` to `S`. Applying the snake lemma to this\ngives the homology sequence of `S`. -/\n@[simps]\nnoncomputable def snakeInput (hS : S.ShortExact) (i j : Œπ) (hij : c.Rel i j) :\n    ShortComplex.SnakeInput C where\n  L‚ÇÄ := (homologyFunctor C c i).mapShortComplex.obj S\n  L‚ÇÅ := (opcyclesFunctor C c i).mapShortComplex.obj S\n  L‚ÇÇ := (cyclesFunctor C c j).mapShortComplex.obj S\n  L‚ÇÉ := (homologyFunctor C c j).mapShortComplex.obj S\n  v‚ÇÄ‚ÇÅ := S.mapNatTrans (natTransHomologyŒπ C c i)\n  v‚ÇÅ‚ÇÇ := S.mapNatTrans (natTransOpCyclesToCycles C c i j)\n  v‚ÇÇ‚ÇÉ := S.mapNatTrans (natTransHomologyœÄ C c j)\n  h‚ÇÄ := by\n    apply ShortComplex.isLimitOfIsLimitœÄ\n    all_goals\n      exact (KernelFork.isLimitMapConeEquiv _ _).symm\n        ((composableArrows‚ÇÉ_exact _ i j hij).exact 0).fIsKernel\n  h‚ÇÉ := by\n    apply ShortComplex.isColimitOfIsColimitœÄ\n    all_goals\n      exact (CokernelCofork.isColimitMapCoconeEquiv _ _).symm\n        ((composableArrows‚ÇÉ_exact _ i j hij).exact 1).gIsCokernel\n  L‚ÇÅ_exact := by\n    have := hS.epi_g\n    exact opcycles_right_exact S hS.exact i\n  L‚ÇÇ_exact := by\n    have := hS.mono_f\n    exact cycles_left_exact S hS.exact j\n  epi_L‚ÇÅ_g := by\n    have := hS.epi_g\n    dsimp\n    infer_instance\n  mono_L‚ÇÇ_f := by\n    have := hS.mono_f\n    dsimp\n    infer_instance\n\n"}
{"name":"HomologicalComplex.HomologySequence.snakeInput_v‚ÇÅ‚ÇÇ","module":"Mathlib.Algebra.Homology.HomologySequence","initialProofState":"C : Type u_1\nŒπ : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù : CategoryTheory.Abelian C\nc : ComplexShape Œπ\nS : CategoryTheory.ShortComplex (HomologicalComplex C c)\nhS : S.ShortExact\ni j : Œπ\nhij : c.Rel i j\n‚ä¢ Eq (HomologicalComplex.HomologySequence.snakeInput hS i j hij).v‚ÇÅ‚ÇÇ (S.mapNatTrans (HomologicalComplex.natTransOpCyclesToCycles C c i j))","decl":"/-- Given a short exact short complex `S : HomologicalComplex C c`, and degrees `i` and `j`\nsuch that `c.Rel i j`, this is the snake diagram whose four lines are respectively\nobtained by applying the functors `homologyFunctor C c i`, `opcyclesFunctor C c i`,\n`cyclesFunctor C c j`, `homologyFunctor C c j` to `S`. Applying the snake lemma to this\ngives the homology sequence of `S`. -/\n@[simps]\nnoncomputable def snakeInput (hS : S.ShortExact) (i j : Œπ) (hij : c.Rel i j) :\n    ShortComplex.SnakeInput C where\n  L‚ÇÄ := (homologyFunctor C c i).mapShortComplex.obj S\n  L‚ÇÅ := (opcyclesFunctor C c i).mapShortComplex.obj S\n  L‚ÇÇ := (cyclesFunctor C c j).mapShortComplex.obj S\n  L‚ÇÉ := (homologyFunctor C c j).mapShortComplex.obj S\n  v‚ÇÄ‚ÇÅ := S.mapNatTrans (natTransHomologyŒπ C c i)\n  v‚ÇÅ‚ÇÇ := S.mapNatTrans (natTransOpCyclesToCycles C c i j)\n  v‚ÇÇ‚ÇÉ := S.mapNatTrans (natTransHomologyœÄ C c j)\n  h‚ÇÄ := by\n    apply ShortComplex.isLimitOfIsLimitœÄ\n    all_goals\n      exact (KernelFork.isLimitMapConeEquiv _ _).symm\n        ((composableArrows‚ÇÉ_exact _ i j hij).exact 0).fIsKernel\n  h‚ÇÉ := by\n    apply ShortComplex.isColimitOfIsColimitœÄ\n    all_goals\n      exact (CokernelCofork.isColimitMapCoconeEquiv _ _).symm\n        ((composableArrows‚ÇÉ_exact _ i j hij).exact 1).gIsCokernel\n  L‚ÇÅ_exact := by\n    have := hS.epi_g\n    exact opcycles_right_exact S hS.exact i\n  L‚ÇÇ_exact := by\n    have := hS.mono_f\n    exact cycles_left_exact S hS.exact j\n  epi_L‚ÇÅ_g := by\n    have := hS.epi_g\n    dsimp\n    infer_instance\n  mono_L‚ÇÇ_f := by\n    have := hS.mono_f\n    dsimp\n    infer_instance\n\n"}
{"name":"HomologicalComplex.HomologySequence.snakeInput_L‚ÇÄ","module":"Mathlib.Algebra.Homology.HomologySequence","initialProofState":"C : Type u_1\nŒπ : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù : CategoryTheory.Abelian C\nc : ComplexShape Œπ\nS : CategoryTheory.ShortComplex (HomologicalComplex C c)\nhS : S.ShortExact\ni j : Œπ\nhij : c.Rel i j\n‚ä¢ Eq (HomologicalComplex.HomologySequence.snakeInput hS i j hij).L‚ÇÄ ((HomologicalComplex.homologyFunctor C c i).mapShortComplex.obj S)","decl":"/-- Given a short exact short complex `S : HomologicalComplex C c`, and degrees `i` and `j`\nsuch that `c.Rel i j`, this is the snake diagram whose four lines are respectively\nobtained by applying the functors `homologyFunctor C c i`, `opcyclesFunctor C c i`,\n`cyclesFunctor C c j`, `homologyFunctor C c j` to `S`. Applying the snake lemma to this\ngives the homology sequence of `S`. -/\n@[simps]\nnoncomputable def snakeInput (hS : S.ShortExact) (i j : Œπ) (hij : c.Rel i j) :\n    ShortComplex.SnakeInput C where\n  L‚ÇÄ := (homologyFunctor C c i).mapShortComplex.obj S\n  L‚ÇÅ := (opcyclesFunctor C c i).mapShortComplex.obj S\n  L‚ÇÇ := (cyclesFunctor C c j).mapShortComplex.obj S\n  L‚ÇÉ := (homologyFunctor C c j).mapShortComplex.obj S\n  v‚ÇÄ‚ÇÅ := S.mapNatTrans (natTransHomologyŒπ C c i)\n  v‚ÇÅ‚ÇÇ := S.mapNatTrans (natTransOpCyclesToCycles C c i j)\n  v‚ÇÇ‚ÇÉ := S.mapNatTrans (natTransHomologyœÄ C c j)\n  h‚ÇÄ := by\n    apply ShortComplex.isLimitOfIsLimitœÄ\n    all_goals\n      exact (KernelFork.isLimitMapConeEquiv _ _).symm\n        ((composableArrows‚ÇÉ_exact _ i j hij).exact 0).fIsKernel\n  h‚ÇÉ := by\n    apply ShortComplex.isColimitOfIsColimitœÄ\n    all_goals\n      exact (CokernelCofork.isColimitMapCoconeEquiv _ _).symm\n        ((composableArrows‚ÇÉ_exact _ i j hij).exact 1).gIsCokernel\n  L‚ÇÅ_exact := by\n    have := hS.epi_g\n    exact opcycles_right_exact S hS.exact i\n  L‚ÇÇ_exact := by\n    have := hS.mono_f\n    exact cycles_left_exact S hS.exact j\n  epi_L‚ÇÅ_g := by\n    have := hS.epi_g\n    dsimp\n    infer_instance\n  mono_L‚ÇÇ_f := by\n    have := hS.mono_f\n    dsimp\n    infer_instance\n\n"}
{"name":"HomologicalComplex.HomologySequence.snakeInput_v‚ÇÇ‚ÇÉ","module":"Mathlib.Algebra.Homology.HomologySequence","initialProofState":"C : Type u_1\nŒπ : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù : CategoryTheory.Abelian C\nc : ComplexShape Œπ\nS : CategoryTheory.ShortComplex (HomologicalComplex C c)\nhS : S.ShortExact\ni j : Œπ\nhij : c.Rel i j\n‚ä¢ Eq (HomologicalComplex.HomologySequence.snakeInput hS i j hij).v‚ÇÇ‚ÇÉ (S.mapNatTrans (HomologicalComplex.natTransHomologyœÄ C c j))","decl":"/-- Given a short exact short complex `S : HomologicalComplex C c`, and degrees `i` and `j`\nsuch that `c.Rel i j`, this is the snake diagram whose four lines are respectively\nobtained by applying the functors `homologyFunctor C c i`, `opcyclesFunctor C c i`,\n`cyclesFunctor C c j`, `homologyFunctor C c j` to `S`. Applying the snake lemma to this\ngives the homology sequence of `S`. -/\n@[simps]\nnoncomputable def snakeInput (hS : S.ShortExact) (i j : Œπ) (hij : c.Rel i j) :\n    ShortComplex.SnakeInput C where\n  L‚ÇÄ := (homologyFunctor C c i).mapShortComplex.obj S\n  L‚ÇÅ := (opcyclesFunctor C c i).mapShortComplex.obj S\n  L‚ÇÇ := (cyclesFunctor C c j).mapShortComplex.obj S\n  L‚ÇÉ := (homologyFunctor C c j).mapShortComplex.obj S\n  v‚ÇÄ‚ÇÅ := S.mapNatTrans (natTransHomologyŒπ C c i)\n  v‚ÇÅ‚ÇÇ := S.mapNatTrans (natTransOpCyclesToCycles C c i j)\n  v‚ÇÇ‚ÇÉ := S.mapNatTrans (natTransHomologyœÄ C c j)\n  h‚ÇÄ := by\n    apply ShortComplex.isLimitOfIsLimitœÄ\n    all_goals\n      exact (KernelFork.isLimitMapConeEquiv _ _).symm\n        ((composableArrows‚ÇÉ_exact _ i j hij).exact 0).fIsKernel\n  h‚ÇÉ := by\n    apply ShortComplex.isColimitOfIsColimitœÄ\n    all_goals\n      exact (CokernelCofork.isColimitMapCoconeEquiv _ _).symm\n        ((composableArrows‚ÇÉ_exact _ i j hij).exact 1).gIsCokernel\n  L‚ÇÅ_exact := by\n    have := hS.epi_g\n    exact opcycles_right_exact S hS.exact i\n  L‚ÇÇ_exact := by\n    have := hS.mono_f\n    exact cycles_left_exact S hS.exact j\n  epi_L‚ÇÅ_g := by\n    have := hS.epi_g\n    dsimp\n    infer_instance\n  mono_L‚ÇÇ_f := by\n    have := hS.mono_f\n    dsimp\n    infer_instance\n\n"}
{"name":"HomologicalComplex.HomologySequence.snakeInput_L‚ÇÅ","module":"Mathlib.Algebra.Homology.HomologySequence","initialProofState":"C : Type u_1\nŒπ : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù : CategoryTheory.Abelian C\nc : ComplexShape Œπ\nS : CategoryTheory.ShortComplex (HomologicalComplex C c)\nhS : S.ShortExact\ni j : Œπ\nhij : c.Rel i j\n‚ä¢ Eq (HomologicalComplex.HomologySequence.snakeInput hS i j hij).L‚ÇÅ ((HomologicalComplex.opcyclesFunctor C c i).mapShortComplex.obj S)","decl":"/-- Given a short exact short complex `S : HomologicalComplex C c`, and degrees `i` and `j`\nsuch that `c.Rel i j`, this is the snake diagram whose four lines are respectively\nobtained by applying the functors `homologyFunctor C c i`, `opcyclesFunctor C c i`,\n`cyclesFunctor C c j`, `homologyFunctor C c j` to `S`. Applying the snake lemma to this\ngives the homology sequence of `S`. -/\n@[simps]\nnoncomputable def snakeInput (hS : S.ShortExact) (i j : Œπ) (hij : c.Rel i j) :\n    ShortComplex.SnakeInput C where\n  L‚ÇÄ := (homologyFunctor C c i).mapShortComplex.obj S\n  L‚ÇÅ := (opcyclesFunctor C c i).mapShortComplex.obj S\n  L‚ÇÇ := (cyclesFunctor C c j).mapShortComplex.obj S\n  L‚ÇÉ := (homologyFunctor C c j).mapShortComplex.obj S\n  v‚ÇÄ‚ÇÅ := S.mapNatTrans (natTransHomologyŒπ C c i)\n  v‚ÇÅ‚ÇÇ := S.mapNatTrans (natTransOpCyclesToCycles C c i j)\n  v‚ÇÇ‚ÇÉ := S.mapNatTrans (natTransHomologyœÄ C c j)\n  h‚ÇÄ := by\n    apply ShortComplex.isLimitOfIsLimitœÄ\n    all_goals\n      exact (KernelFork.isLimitMapConeEquiv _ _).symm\n        ((composableArrows‚ÇÉ_exact _ i j hij).exact 0).fIsKernel\n  h‚ÇÉ := by\n    apply ShortComplex.isColimitOfIsColimitœÄ\n    all_goals\n      exact (CokernelCofork.isColimitMapCoconeEquiv _ _).symm\n        ((composableArrows‚ÇÉ_exact _ i j hij).exact 1).gIsCokernel\n  L‚ÇÅ_exact := by\n    have := hS.epi_g\n    exact opcycles_right_exact S hS.exact i\n  L‚ÇÇ_exact := by\n    have := hS.mono_f\n    exact cycles_left_exact S hS.exact j\n  epi_L‚ÇÅ_g := by\n    have := hS.epi_g\n    dsimp\n    infer_instance\n  mono_L‚ÇÇ_f := by\n    have := hS.mono_f\n    dsimp\n    infer_instance\n\n"}
{"name":"HomologicalComplex.HomologySequence.snakeInput_L‚ÇÇ","module":"Mathlib.Algebra.Homology.HomologySequence","initialProofState":"C : Type u_1\nŒπ : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù : CategoryTheory.Abelian C\nc : ComplexShape Œπ\nS : CategoryTheory.ShortComplex (HomologicalComplex C c)\nhS : S.ShortExact\ni j : Œπ\nhij : c.Rel i j\n‚ä¢ Eq (HomologicalComplex.HomologySequence.snakeInput hS i j hij).L‚ÇÇ ((HomologicalComplex.cyclesFunctor C c j).mapShortComplex.obj S)","decl":"/-- Given a short exact short complex `S : HomologicalComplex C c`, and degrees `i` and `j`\nsuch that `c.Rel i j`, this is the snake diagram whose four lines are respectively\nobtained by applying the functors `homologyFunctor C c i`, `opcyclesFunctor C c i`,\n`cyclesFunctor C c j`, `homologyFunctor C c j` to `S`. Applying the snake lemma to this\ngives the homology sequence of `S`. -/\n@[simps]\nnoncomputable def snakeInput (hS : S.ShortExact) (i j : Œπ) (hij : c.Rel i j) :\n    ShortComplex.SnakeInput C where\n  L‚ÇÄ := (homologyFunctor C c i).mapShortComplex.obj S\n  L‚ÇÅ := (opcyclesFunctor C c i).mapShortComplex.obj S\n  L‚ÇÇ := (cyclesFunctor C c j).mapShortComplex.obj S\n  L‚ÇÉ := (homologyFunctor C c j).mapShortComplex.obj S\n  v‚ÇÄ‚ÇÅ := S.mapNatTrans (natTransHomologyŒπ C c i)\n  v‚ÇÅ‚ÇÇ := S.mapNatTrans (natTransOpCyclesToCycles C c i j)\n  v‚ÇÇ‚ÇÉ := S.mapNatTrans (natTransHomologyœÄ C c j)\n  h‚ÇÄ := by\n    apply ShortComplex.isLimitOfIsLimitœÄ\n    all_goals\n      exact (KernelFork.isLimitMapConeEquiv _ _).symm\n        ((composableArrows‚ÇÉ_exact _ i j hij).exact 0).fIsKernel\n  h‚ÇÉ := by\n    apply ShortComplex.isColimitOfIsColimitœÄ\n    all_goals\n      exact (CokernelCofork.isColimitMapCoconeEquiv _ _).symm\n        ((composableArrows‚ÇÉ_exact _ i j hij).exact 1).gIsCokernel\n  L‚ÇÅ_exact := by\n    have := hS.epi_g\n    exact opcycles_right_exact S hS.exact i\n  L‚ÇÇ_exact := by\n    have := hS.mono_f\n    exact cycles_left_exact S hS.exact j\n  epi_L‚ÇÅ_g := by\n    have := hS.epi_g\n    dsimp\n    infer_instance\n  mono_L‚ÇÇ_f := by\n    have := hS.mono_f\n    dsimp\n    infer_instance\n\n"}
{"name":"HomologicalComplex.HomologySequence.snakeInput_v‚ÇÄ‚ÇÅ","module":"Mathlib.Algebra.Homology.HomologySequence","initialProofState":"C : Type u_1\nŒπ : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù : CategoryTheory.Abelian C\nc : ComplexShape Œπ\nS : CategoryTheory.ShortComplex (HomologicalComplex C c)\nhS : S.ShortExact\ni j : Œπ\nhij : c.Rel i j\n‚ä¢ Eq (HomologicalComplex.HomologySequence.snakeInput hS i j hij).v‚ÇÄ‚ÇÅ (S.mapNatTrans (HomologicalComplex.natTransHomologyŒπ C c i))","decl":"/-- Given a short exact short complex `S : HomologicalComplex C c`, and degrees `i` and `j`\nsuch that `c.Rel i j`, this is the snake diagram whose four lines are respectively\nobtained by applying the functors `homologyFunctor C c i`, `opcyclesFunctor C c i`,\n`cyclesFunctor C c j`, `homologyFunctor C c j` to `S`. Applying the snake lemma to this\ngives the homology sequence of `S`. -/\n@[simps]\nnoncomputable def snakeInput (hS : S.ShortExact) (i j : Œπ) (hij : c.Rel i j) :\n    ShortComplex.SnakeInput C where\n  L‚ÇÄ := (homologyFunctor C c i).mapShortComplex.obj S\n  L‚ÇÅ := (opcyclesFunctor C c i).mapShortComplex.obj S\n  L‚ÇÇ := (cyclesFunctor C c j).mapShortComplex.obj S\n  L‚ÇÉ := (homologyFunctor C c j).mapShortComplex.obj S\n  v‚ÇÄ‚ÇÅ := S.mapNatTrans (natTransHomologyŒπ C c i)\n  v‚ÇÅ‚ÇÇ := S.mapNatTrans (natTransOpCyclesToCycles C c i j)\n  v‚ÇÇ‚ÇÉ := S.mapNatTrans (natTransHomologyœÄ C c j)\n  h‚ÇÄ := by\n    apply ShortComplex.isLimitOfIsLimitœÄ\n    all_goals\n      exact (KernelFork.isLimitMapConeEquiv _ _).symm\n        ((composableArrows‚ÇÉ_exact _ i j hij).exact 0).fIsKernel\n  h‚ÇÉ := by\n    apply ShortComplex.isColimitOfIsColimitœÄ\n    all_goals\n      exact (CokernelCofork.isColimitMapCoconeEquiv _ _).symm\n        ((composableArrows‚ÇÉ_exact _ i j hij).exact 1).gIsCokernel\n  L‚ÇÅ_exact := by\n    have := hS.epi_g\n    exact opcycles_right_exact S hS.exact i\n  L‚ÇÇ_exact := by\n    have := hS.mono_f\n    exact cycles_left_exact S hS.exact j\n  epi_L‚ÇÅ_g := by\n    have := hS.epi_g\n    dsimp\n    infer_instance\n  mono_L‚ÇÇ_f := by\n    have := hS.mono_f\n    dsimp\n    infer_instance\n\n"}
{"name":"CategoryTheory.ShortComplex.ShortExact.Œ¥_comp","module":"Mathlib.Algebra.Homology.HomologySequence","initialProofState":"C : Type u_1\nŒπ : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù : CategoryTheory.Abelian C\nc : ComplexShape Œπ\nS : CategoryTheory.ShortComplex (HomologicalComplex C c)\nhS : S.ShortExact\ni j : Œπ\nhij : c.Rel i j\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (hS.Œ¥ i j hij) (HomologicalComplex.homologyMap S.f j)) 0","decl":"@[reassoc (attr := simp)]\nlemma Œ¥_comp : hS.Œ¥ i j hij ‚â´ HomologicalComplex.homologyMap S.f j = 0 :=\n  (snakeInput hS i j hij).Œ¥_L‚ÇÉ_f\n\n"}
{"name":"CategoryTheory.ShortComplex.ShortExact.Œ¥_comp_assoc","module":"Mathlib.Algebra.Homology.HomologySequence","initialProofState":"C : Type u_1\nŒπ : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù : CategoryTheory.Abelian C\nc : ComplexShape Œπ\nS : CategoryTheory.ShortComplex (HomologicalComplex C c)\nhS : S.ShortExact\ni j : Œπ\nhij : c.Rel i j\nZ : C\nh : Quiver.Hom (S.X‚ÇÇ.homology j) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (hS.Œ¥ i j hij) (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homologyMap S.f j) h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"@[reassoc (attr := simp)]\nlemma Œ¥_comp : hS.Œ¥ i j hij ‚â´ HomologicalComplex.homologyMap S.f j = 0 :=\n  (snakeInput hS i j hij).Œ¥_L‚ÇÉ_f\n\n"}
{"name":"CategoryTheory.ShortComplex.ShortExact.comp_Œ¥_assoc","module":"Mathlib.Algebra.Homology.HomologySequence","initialProofState":"C : Type u_1\nŒπ : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù : CategoryTheory.Abelian C\nc : ComplexShape Œπ\nS : CategoryTheory.ShortComplex (HomologicalComplex C c)\nhS : S.ShortExact\ni j : Œπ\nhij : c.Rel i j\nZ : C\nh : Quiver.Hom (S.X‚ÇÅ.homology j) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homologyMap S.g i) (CategoryTheory.CategoryStruct.comp (hS.Œ¥ i j hij) h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"@[reassoc (attr := simp)]\nlemma comp_Œ¥ : HomologicalComplex.homologyMap S.g i ‚â´ hS.Œ¥ i j hij = 0 :=\n  (snakeInput hS i j hij).L‚ÇÄ_g_Œ¥\n\n"}
{"name":"CategoryTheory.ShortComplex.ShortExact.comp_Œ¥","module":"Mathlib.Algebra.Homology.HomologySequence","initialProofState":"C : Type u_1\nŒπ : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù : CategoryTheory.Abelian C\nc : ComplexShape Œπ\nS : CategoryTheory.ShortComplex (HomologicalComplex C c)\nhS : S.ShortExact\ni j : Œπ\nhij : c.Rel i j\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homologyMap S.g i) (hS.Œ¥ i j hij)) 0","decl":"@[reassoc (attr := simp)]\nlemma comp_Œ¥ : HomologicalComplex.homologyMap S.g i ‚â´ hS.Œ¥ i j hij = 0 :=\n  (snakeInput hS i j hij).L‚ÇÄ_g_Œ¥\n\n"}
{"name":"CategoryTheory.ShortComplex.ShortExact.homology_exact‚ÇÅ","module":"Mathlib.Algebra.Homology.HomologySequence","initialProofState":"C : Type u_1\nŒπ : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù : CategoryTheory.Abelian C\nc : ComplexShape Œπ\nS : CategoryTheory.ShortComplex (HomologicalComplex C c)\nhS : S.ShortExact\ni j : Œπ\nhij : c.Rel i j\n‚ä¢ (CategoryTheory.ShortComplex.mk (hS.Œ¥ i j hij) (HomologicalComplex.homologyMap S.f j) ‚ãØ).Exact","decl":"/-- Exactness of `S.X‚ÇÉ.homology i ‚ü∂ S.X‚ÇÅ.homology j ‚ü∂ S.X‚ÇÇ.homology j`. -/\nlemma homology_exact‚ÇÅ : (ShortComplex.mk _ _ (Œ¥_comp hS i j hij)).Exact :=\n  (snakeInput hS i j hij).L‚ÇÇ'_exact\n\n"}
{"name":"CategoryTheory.ShortComplex.ShortExact.homology_exact‚ÇÇ","module":"Mathlib.Algebra.Homology.HomologySequence","initialProofState":"C : Type u_1\nŒπ : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù : CategoryTheory.Abelian C\nc : ComplexShape Œπ\nS : CategoryTheory.ShortComplex (HomologicalComplex C c)\nhS : S.ShortExact\ni : Œπ\n‚ä¢ (CategoryTheory.ShortComplex.mk (HomologicalComplex.homologyMap S.f i) (HomologicalComplex.homologyMap S.g i) ‚ãØ).Exact","decl":"include hS in\n/-- Exactness of `S.X‚ÇÅ.homology i ‚ü∂ S.X‚ÇÇ.homology i ‚ü∂ S.X‚ÇÉ.homology i`. -/\nlemma homology_exact‚ÇÇ : (ShortComplex.mk (HomologicalComplex.homologyMap S.f i)\n    (HomologicalComplex.homologyMap S.g i) (by rw [‚Üê HomologicalComplex.homologyMap_comp,\n      S.zero, HomologicalComplex.homologyMap_zero])).Exact := by\n  by_cases h : c.Rel i (c.next i)\n  ¬∑ exact (snakeInput hS i _ h).L‚ÇÄ_exact\n  ¬∑ have := hS.epi_g\n    have : ‚àÄ (K : HomologicalComplex C c), IsIso (K.homologyŒπ i) :=\n      fun K => ShortComplex.isIso_homologyŒπ (K.sc i) (K.shape _ _ h)\n    have e : S.map (HomologicalComplex.homologyFunctor C c i) ‚âÖ\n        S.map (HomologicalComplex.opcyclesFunctor C c i) :=\n      ShortComplex.isoMk (asIso (S.X‚ÇÅ.homologyŒπ i))\n        (asIso (S.X‚ÇÇ.homologyŒπ i)) (asIso (S.X‚ÇÉ.homologyŒπ i)) (by simp) (by simp)\n    exact ShortComplex.exact_of_iso e.symm (opcycles_right_exact S hS.exact i)\n\n"}
{"name":"CategoryTheory.ShortComplex.ShortExact.homology_exact‚ÇÉ","module":"Mathlib.Algebra.Homology.HomologySequence","initialProofState":"C : Type u_1\nŒπ : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù : CategoryTheory.Abelian C\nc : ComplexShape Œπ\nS : CategoryTheory.ShortComplex (HomologicalComplex C c)\nhS : S.ShortExact\ni j : Œπ\nhij : c.Rel i j\n‚ä¢ (CategoryTheory.ShortComplex.mk (HomologicalComplex.homologyMap S.g i) (hS.Œ¥ i j hij) ‚ãØ).Exact","decl":"/-- Exactness of `S.X‚ÇÇ.homology i ‚ü∂ S.X‚ÇÉ.homology i ‚ü∂ S.X‚ÇÅ.homology j`. -/\nlemma homology_exact‚ÇÉ : (ShortComplex.mk _ _ (comp_Œ¥ hS i j hij)).Exact :=\n  (snakeInput hS i j hij).L‚ÇÅ'_exact\n\n"}
{"name":"CategoryTheory.ShortComplex.ShortExact.Œ¥_eq'","module":"Mathlib.Algebra.Homology.HomologySequence","initialProofState":"C : Type u_1\nŒπ : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù : CategoryTheory.Abelian C\nc : ComplexShape Œπ\nS : CategoryTheory.ShortComplex (HomologicalComplex C c)\nhS : S.ShortExact\ni j : Œπ\nhij : c.Rel i j\nA : C\nx‚ÇÉ : Quiver.Hom A (S.X‚ÇÉ.homology i)\nx‚ÇÇ : Quiver.Hom A (S.X‚ÇÇ.opcycles i)\nx‚ÇÅ : Quiver.Hom A (S.X‚ÇÅ.cycles j)\nh‚ÇÇ : Eq (CategoryTheory.CategoryStruct.comp x‚ÇÇ (HomologicalComplex.opcyclesMap S.g i)) (CategoryTheory.CategoryStruct.comp x‚ÇÉ (S.X‚ÇÉ.homologyŒπ i))\nh‚ÇÅ : Eq (CategoryTheory.CategoryStruct.comp x‚ÇÅ (HomologicalComplex.cyclesMap S.f j)) (CategoryTheory.CategoryStruct.comp x‚ÇÇ (S.X‚ÇÇ.opcyclesToCycles i j))\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp x‚ÇÉ (hS.Œ¥ i j hij)) (CategoryTheory.CategoryStruct.comp x‚ÇÅ (S.X‚ÇÅ.homologyœÄ j))","decl":"lemma Œ¥_eq' {A : C} (x‚ÇÉ : A ‚ü∂ S.X‚ÇÉ.homology i) (x‚ÇÇ : A ‚ü∂ S.X‚ÇÇ.opcycles i)\n    (x‚ÇÅ : A ‚ü∂ S.X‚ÇÅ.cycles j)\n    (h‚ÇÇ : x‚ÇÇ ‚â´ HomologicalComplex.opcyclesMap S.g i = x‚ÇÉ ‚â´ S.X‚ÇÉ.homologyŒπ i)\n    (h‚ÇÅ : x‚ÇÅ ‚â´ HomologicalComplex.cyclesMap S.f j = x‚ÇÇ ‚â´ S.X‚ÇÇ.opcyclesToCycles i j) :\n    x‚ÇÉ ‚â´ hS.Œ¥ i j hij = x‚ÇÅ ‚â´ S.X‚ÇÅ.homologyœÄ j :=\n  (snakeInput hS i j hij).Œ¥_eq x‚ÇÉ x‚ÇÇ x‚ÇÅ h‚ÇÇ h‚ÇÅ\n\n"}
{"name":"CategoryTheory.ShortComplex.ShortExact.Œ¥_eq","module":"Mathlib.Algebra.Homology.HomologySequence","initialProofState":"C : Type u_1\nŒπ : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù : CategoryTheory.Abelian C\nc : ComplexShape Œπ\nS : CategoryTheory.ShortComplex (HomologicalComplex C c)\nhS : S.ShortExact\ni j : Œπ\nhij : c.Rel i j\nA : C\nx‚ÇÉ : Quiver.Hom A (S.X‚ÇÉ.X i)\nhx‚ÇÉ : Eq (CategoryTheory.CategoryStruct.comp x‚ÇÉ (S.X‚ÇÉ.d i j)) 0\nx‚ÇÇ : Quiver.Hom A (S.X‚ÇÇ.X i)\nhx‚ÇÇ : Eq (CategoryTheory.CategoryStruct.comp x‚ÇÇ (S.g.f i)) x‚ÇÉ\nx‚ÇÅ : Quiver.Hom A (S.X‚ÇÅ.X j)\nhx‚ÇÅ : Eq (CategoryTheory.CategoryStruct.comp x‚ÇÅ (S.f.f j)) (CategoryTheory.CategoryStruct.comp x‚ÇÇ (S.X‚ÇÇ.d i j))\nk : Œπ\nhk : Eq (c.next j) k\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (S.X‚ÇÉ.liftCycles x‚ÇÉ j ‚ãØ hx‚ÇÉ) (CategoryTheory.CategoryStruct.comp (S.X‚ÇÉ.homologyœÄ i) (hS.Œ¥ i j hij))) (CategoryTheory.CategoryStruct.comp (S.X‚ÇÅ.liftCycles x‚ÇÅ k hk ‚ãØ) (S.X‚ÇÅ.homologyœÄ j))","decl":"lemma Œ¥_eq {A : C} (x‚ÇÉ : A ‚ü∂ S.X‚ÇÉ.X i) (hx‚ÇÉ : x‚ÇÉ ‚â´ S.X‚ÇÉ.d i j = 0)\n    (x‚ÇÇ : A ‚ü∂ S.X‚ÇÇ.X i) (hx‚ÇÇ : x‚ÇÇ ‚â´ S.g.f i = x‚ÇÉ)\n    (x‚ÇÅ : A ‚ü∂ S.X‚ÇÅ.X j) (hx‚ÇÅ : x‚ÇÅ ‚â´ S.f.f j = x‚ÇÇ ‚â´ S.X‚ÇÇ.d i j)\n    (k : Œπ) (hk : c.next j = k) :\n    S.X‚ÇÉ.liftCycles x‚ÇÉ j (c.next_eq' hij) hx‚ÇÉ ‚â´ S.X‚ÇÉ.homologyœÄ i ‚â´ hS.Œ¥ i j hij =\n      S.X‚ÇÅ.liftCycles x‚ÇÅ k hk (by\n        have := hS.mono_f\n        rw [‚Üê cancel_mono (S.f.f k), assoc, ‚Üê S.f.comm, reassoc_of% hx‚ÇÅ,\n          d_comp_d, comp_zero, zero_comp]) ‚â´ S.X‚ÇÅ.homologyœÄ j := by\n  simpa only [assoc] using hS.Œ¥_eq' i j hij (S.X‚ÇÉ.liftCycles x‚ÇÉ j\n    (c.next_eq' hij) hx‚ÇÉ ‚â´ S.X‚ÇÉ.homologyœÄ i)\n    (x‚ÇÇ ‚â´ S.X‚ÇÇ.pOpcycles i) (S.X‚ÇÅ.liftCycles x‚ÇÅ k hk _)\n      (by simp only [assoc, HomologicalComplex.p_opcyclesMap,\n        HomologicalComplex.homology_œÄ_Œπ,\n        HomologicalComplex.liftCycles_i_assoc, reassoc_of% hx‚ÇÇ])\n      (by rw [‚Üê cancel_mono (S.X‚ÇÇ.iCycles j), HomologicalComplex.liftCycles_comp_cyclesMap,\n        HomologicalComplex.liftCycles_i, assoc, assoc, opcyclesToCycles_iCycles,\n        HomologicalComplex.p_fromOpcycles, hx‚ÇÅ])\n\n"}
