{"name":"HomologicalComplex.opcyclesToCycles_iCycles","module":"Mathlib.Algebra.Homology.HomologySequence","initialProofState":"C : Type u_1\nι : Type u_2\ninst✝³ : CategoryTheory.Category.{u_3, u_1} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nc : ComplexShape ι\nK : HomologicalComplex C c\ni j : ι\ninst✝¹ : K.HasHomology i\ninst✝ : K.HasHomology j\n⊢ Eq (CategoryTheory.CategoryStruct.comp (K.opcyclesToCycles i j) (K.iCycles j)) (K.fromOpcycles i j)","decl":"@[reassoc (attr := simp)]\nlemma opcyclesToCycles_iCycles : K.opcyclesToCycles i j ≫ K.iCycles j = K.fromOpcycles i j := by\n  dsimp only [opcyclesToCycles]\n  simp\n\n"}
{"name":"HomologicalComplex.opcyclesToCycles_iCycles_assoc","module":"Mathlib.Algebra.Homology.HomologySequence","initialProofState":"C : Type u_1\nι : Type u_2\ninst✝³ : CategoryTheory.Category.{u_3, u_1} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nc : ComplexShape ι\nK : HomologicalComplex C c\ni j : ι\ninst✝¹ : K.HasHomology i\ninst✝ : K.HasHomology j\nZ : C\nh : Quiver.Hom (K.X j) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (K.opcyclesToCycles i j) (CategoryTheory.CategoryStruct.comp (K.iCycles j) h)) (CategoryTheory.CategoryStruct.comp (K.fromOpcycles i j) h)","decl":"@[reassoc (attr := simp)]\nlemma opcyclesToCycles_iCycles : K.opcyclesToCycles i j ≫ K.iCycles j = K.fromOpcycles i j := by\n  dsimp only [opcyclesToCycles]\n  simp\n\n"}
{"name":"HomologicalComplex.pOpcycles_opcyclesToCycles_iCycles","module":"Mathlib.Algebra.Homology.HomologySequence","initialProofState":"C : Type u_1\nι : Type u_2\ninst✝³ : CategoryTheory.Category.{u_3, u_1} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nc : ComplexShape ι\nK : HomologicalComplex C c\ni j : ι\ninst✝¹ : K.HasHomology i\ninst✝ : K.HasHomology j\n⊢ Eq (CategoryTheory.CategoryStruct.comp (K.pOpcycles i) (CategoryTheory.CategoryStruct.comp (K.opcyclesToCycles i j) (K.iCycles j))) (K.d i j)","decl":"@[reassoc]\nlemma pOpcycles_opcyclesToCycles_iCycles :\n    K.pOpcycles i ≫ K.opcyclesToCycles i j ≫ K.iCycles j = K.d i j := by\n  simp [opcyclesToCycles]\n\n"}
{"name":"HomologicalComplex.pOpcycles_opcyclesToCycles_iCycles_assoc","module":"Mathlib.Algebra.Homology.HomologySequence","initialProofState":"C : Type u_1\nι : Type u_2\ninst✝³ : CategoryTheory.Category.{u_3, u_1} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nc : ComplexShape ι\nK : HomologicalComplex C c\ni j : ι\ninst✝¹ : K.HasHomology i\ninst✝ : K.HasHomology j\nZ : C\nh : Quiver.Hom (K.X j) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (K.pOpcycles i) (CategoryTheory.CategoryStruct.comp (K.opcyclesToCycles i j) (CategoryTheory.CategoryStruct.comp (K.iCycles j) h))) (CategoryTheory.CategoryStruct.comp (K.d i j) h)","decl":"@[reassoc]\nlemma pOpcycles_opcyclesToCycles_iCycles :\n    K.pOpcycles i ≫ K.opcyclesToCycles i j ≫ K.iCycles j = K.d i j := by\n  simp [opcyclesToCycles]\n\n"}
{"name":"HomologicalComplex.pOpcycles_opcyclesToCycles_assoc","module":"Mathlib.Algebra.Homology.HomologySequence","initialProofState":"C : Type u_1\nι : Type u_2\ninst✝³ : CategoryTheory.Category.{u_3, u_1} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nc : ComplexShape ι\nK : HomologicalComplex C c\ni j : ι\ninst✝¹ : K.HasHomology i\ninst✝ : K.HasHomology j\nZ : C\nh : Quiver.Hom (K.cycles j) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (K.pOpcycles i) (CategoryTheory.CategoryStruct.comp (K.opcyclesToCycles i j) h)) (CategoryTheory.CategoryStruct.comp (K.toCycles i j) h)","decl":"@[reassoc (attr := simp)]\nlemma pOpcycles_opcyclesToCycles :\n    K.pOpcycles i ≫ K.opcyclesToCycles i j = K.toCycles i j := by\n  simp only [← cancel_mono (K.iCycles j), assoc, opcyclesToCycles_iCycles,\n    p_fromOpcycles, toCycles_i]\n\n"}
{"name":"HomologicalComplex.pOpcycles_opcyclesToCycles","module":"Mathlib.Algebra.Homology.HomologySequence","initialProofState":"C : Type u_1\nι : Type u_2\ninst✝³ : CategoryTheory.Category.{u_3, u_1} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nc : ComplexShape ι\nK : HomologicalComplex C c\ni j : ι\ninst✝¹ : K.HasHomology i\ninst✝ : K.HasHomology j\n⊢ Eq (CategoryTheory.CategoryStruct.comp (K.pOpcycles i) (K.opcyclesToCycles i j)) (K.toCycles i j)","decl":"@[reassoc (attr := simp)]\nlemma pOpcycles_opcyclesToCycles :\n    K.pOpcycles i ≫ K.opcyclesToCycles i j = K.toCycles i j := by\n  simp only [← cancel_mono (K.iCycles j), assoc, opcyclesToCycles_iCycles,\n    p_fromOpcycles, toCycles_i]\n\n"}
{"name":"HomologicalComplex.homologyι_opcyclesToCycles_assoc","module":"Mathlib.Algebra.Homology.HomologySequence","initialProofState":"C : Type u_1\nι : Type u_2\ninst✝³ : CategoryTheory.Category.{u_3, u_1} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nc : ComplexShape ι\nK : HomologicalComplex C c\ni j : ι\ninst✝¹ : K.HasHomology i\ninst✝ : K.HasHomology j\nZ : C\nh : Quiver.Hom (K.cycles j) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (K.homologyι i) (CategoryTheory.CategoryStruct.comp (K.opcyclesToCycles i j) h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"@[reassoc (attr := simp)]\nlemma homologyι_opcyclesToCycles :\n    K.homologyι i ≫ K.opcyclesToCycles i j = 0 := by\n  simp only [← cancel_mono (K.iCycles j), assoc, opcyclesToCycles_iCycles,\n    homologyι_comp_fromOpcycles, zero_comp]\n\n"}
{"name":"HomologicalComplex.homologyι_opcyclesToCycles","module":"Mathlib.Algebra.Homology.HomologySequence","initialProofState":"C : Type u_1\nι : Type u_2\ninst✝³ : CategoryTheory.Category.{u_3, u_1} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nc : ComplexShape ι\nK : HomologicalComplex C c\ni j : ι\ninst✝¹ : K.HasHomology i\ninst✝ : K.HasHomology j\n⊢ Eq (CategoryTheory.CategoryStruct.comp (K.homologyι i) (K.opcyclesToCycles i j)) 0","decl":"@[reassoc (attr := simp)]\nlemma homologyι_opcyclesToCycles :\n    K.homologyι i ≫ K.opcyclesToCycles i j = 0 := by\n  simp only [← cancel_mono (K.iCycles j), assoc, opcyclesToCycles_iCycles,\n    homologyι_comp_fromOpcycles, zero_comp]\n\n"}
{"name":"HomologicalComplex.opcyclesToCycles_homologyπ_assoc","module":"Mathlib.Algebra.Homology.HomologySequence","initialProofState":"C : Type u_1\nι : Type u_2\ninst✝³ : CategoryTheory.Category.{u_3, u_1} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nc : ComplexShape ι\nK : HomologicalComplex C c\ni j : ι\ninst✝¹ : K.HasHomology i\ninst✝ : K.HasHomology j\nZ : C\nh : Quiver.Hom (K.homology j) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (K.opcyclesToCycles i j) (CategoryTheory.CategoryStruct.comp (K.homologyπ j) h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"@[reassoc (attr := simp)]\nlemma opcyclesToCycles_homologyπ :\n    K.opcyclesToCycles i j ≫ K.homologyπ j = 0 := by\n  simp only [← cancel_epi (K.pOpcycles i),\n    pOpcycles_opcyclesToCycles_assoc, toCycles_comp_homologyπ, comp_zero]\n\n"}
{"name":"HomologicalComplex.opcyclesToCycles_homologyπ","module":"Mathlib.Algebra.Homology.HomologySequence","initialProofState":"C : Type u_1\nι : Type u_2\ninst✝³ : CategoryTheory.Category.{u_3, u_1} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nc : ComplexShape ι\nK : HomologicalComplex C c\ni j : ι\ninst✝¹ : K.HasHomology i\ninst✝ : K.HasHomology j\n⊢ Eq (CategoryTheory.CategoryStruct.comp (K.opcyclesToCycles i j) (K.homologyπ j)) 0","decl":"@[reassoc (attr := simp)]\nlemma opcyclesToCycles_homologyπ :\n    K.opcyclesToCycles i j ≫ K.homologyπ j = 0 := by\n  simp only [← cancel_epi (K.pOpcycles i),\n    pOpcycles_opcyclesToCycles_assoc, toCycles_comp_homologyπ, comp_zero]\n\n"}
{"name":"HomologicalComplex.opcyclesToCycles_naturality","module":"Mathlib.Algebra.Homology.HomologySequence","initialProofState":"C : Type u_1\nι : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁴ : CategoryTheory.Limits.HasZeroMorphisms C\nc : ComplexShape ι\nK L : HomologicalComplex C c\nφ : Quiver.Hom K L\ni j : ι\ninst✝³ : K.HasHomology i\ninst✝² : K.HasHomology j\ninst✝¹ : L.HasHomology i\ninst✝ : L.HasHomology j\n⊢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.opcyclesMap φ i) (L.opcyclesToCycles i j)) (CategoryTheory.CategoryStruct.comp (K.opcyclesToCycles i j) (HomologicalComplex.cyclesMap φ j))","decl":"@[reassoc (attr := simp)]\nlemma opcyclesToCycles_naturality :\n    opcyclesMap φ i ≫ opcyclesToCycles L i j = opcyclesToCycles K i j ≫ cyclesMap φ j := by\n  simp only [← cancel_mono (L.iCycles j), ← cancel_epi (K.pOpcycles i),\n    assoc, p_opcyclesMap_assoc, pOpcycles_opcyclesToCycles_iCycles, Hom.comm, cyclesMap_i,\n    pOpcycles_opcyclesToCycles_iCycles_assoc]\n\n"}
{"name":"HomologicalComplex.opcyclesToCycles_naturality_assoc","module":"Mathlib.Algebra.Homology.HomologySequence","initialProofState":"C : Type u_1\nι : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁴ : CategoryTheory.Limits.HasZeroMorphisms C\nc : ComplexShape ι\nK L : HomologicalComplex C c\nφ : Quiver.Hom K L\ni j : ι\ninst✝³ : K.HasHomology i\ninst✝² : K.HasHomology j\ninst✝¹ : L.HasHomology i\ninst✝ : L.HasHomology j\nZ : C\nh : Quiver.Hom (L.cycles j) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.opcyclesMap φ i) (CategoryTheory.CategoryStruct.comp (L.opcyclesToCycles i j) h)) (CategoryTheory.CategoryStruct.comp (K.opcyclesToCycles i j) (CategoryTheory.CategoryStruct.comp (HomologicalComplex.cyclesMap φ j) h))","decl":"@[reassoc (attr := simp)]\nlemma opcyclesToCycles_naturality :\n    opcyclesMap φ i ≫ opcyclesToCycles L i j = opcyclesToCycles K i j ≫ cyclesMap φ j := by\n  simp only [← cancel_mono (L.iCycles j), ← cancel_epi (K.pOpcycles i),\n    assoc, p_opcyclesMap_assoc, pOpcycles_opcyclesToCycles_iCycles, Hom.comm, cyclesMap_i,\n    pOpcycles_opcyclesToCycles_iCycles_assoc]\n\n"}
{"name":"HomologicalComplex.natTransOpCyclesToCycles_app","module":"Mathlib.Algebra.Homology.HomologySequence","initialProofState":"C : Type u_1\nι : Type u_2\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nc : ComplexShape ι\ni j : ι\ninst✝ : CategoryTheory.CategoryWithHomology C\nK : HomologicalComplex C c\n⊢ Eq ((HomologicalComplex.natTransOpCyclesToCycles C c i j).app K) (K.opcyclesToCycles i j)","decl":"/-- The natural transformation `K.opcyclesToCycles i j : K.opcycles i ⟶ K.cycles j` for all\n`K : HomologicalComplex C c`. -/\n@[simps]\nnoncomputable def natTransOpCyclesToCycles [CategoryWithHomology C] :\n    opcyclesFunctor C c i ⟶ cyclesFunctor C c j where\n  app K := K.opcyclesToCycles i j\n\n"}
{"name":"HomologicalComplex.HomologySequence.instMonoMap'ComposableArrows₃OfNatNat","module":"Mathlib.Algebra.Homology.HomologySequence","initialProofState":"C : Type u_1\nι : Type u_2\ninst✝³ : CategoryTheory.Category.{u_3, u_1} C\ninst✝² : CategoryTheory.Preadditive C\nc : ComplexShape ι\nK : HomologicalComplex C c\ni j : ι\ninst✝¹ : K.HasHomology i\ninst✝ : K.HasHomology j\n⊢ CategoryTheory.Mono ((HomologicalComplex.HomologySequence.composableArrows₃ K i j).map' 0 1 ⋯ ⋯)","decl":"instance [K.HasHomology i] [K.HasHomology j] :\n    Mono ((composableArrows₃ K i j).map' 0 1) := by\n  dsimp\n  infer_instance\n\n"}
{"name":"HomologicalComplex.HomologySequence.instEpiMap'ComposableArrows₃OfNatNat","module":"Mathlib.Algebra.Homology.HomologySequence","initialProofState":"C : Type u_1\nι : Type u_2\ninst✝³ : CategoryTheory.Category.{u_3, u_1} C\ninst✝² : CategoryTheory.Preadditive C\nc : ComplexShape ι\nK : HomologicalComplex C c\ni j : ι\ninst✝¹ : K.HasHomology i\ninst✝ : K.HasHomology j\n⊢ CategoryTheory.Epi ((HomologicalComplex.HomologySequence.composableArrows₃ K i j).map' 2 3 ⋯ ⋯)","decl":"set_option simprocs false in\ninstance [K.HasHomology i] [K.HasHomology j] :\n    Epi ((composableArrows₃ K i j).map' 2 3) := by\n  dsimp\n  infer_instance\n\n"}
{"name":"HomologicalComplex.HomologySequence.composableArrows₃_exact","module":"Mathlib.Algebra.Homology.HomologySequence","initialProofState":"C : Type u_1\nι : Type u_2\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nc : ComplexShape ι\nK : HomologicalComplex C c\ni j : ι\nhij : c.Rel i j\ninst✝ : CategoryTheory.CategoryWithHomology C\n⊢ (HomologicalComplex.HomologySequence.composableArrows₃ K i j).Exact","decl":"include hij in\n/-- The diagram `K.homology i ⟶ K.opcycles i ⟶ K.cycles j ⟶ K.homology j` is exact\nwhen `c.Rel i j`. -/\nlemma composableArrows₃_exact [CategoryWithHomology C] :\n    (composableArrows₃ K i j).Exact := by\n  let S := ShortComplex.mk (K.homologyι i) (K.opcyclesToCycles i j) (by simp)\n  let S' := ShortComplex.mk (K.homologyι i) (K.fromOpcycles i j) (by simp)\n  let ι : S ⟶ S' :=\n    { τ₁ := 𝟙 _\n      τ₂ := 𝟙 _\n      τ₃ := K.iCycles j }\n  have hS : S.Exact := by\n    rw [ShortComplex.exact_iff_of_epi_of_isIso_of_mono ι]\n    exact S'.exact_of_f_is_kernel (K.homologyIsKernel i j (c.next_eq' hij))\n  let T := ShortComplex.mk (K.opcyclesToCycles i j) (K.homologyπ j) (by simp)\n  let T' := ShortComplex.mk (K.toCycles i j) (K.homologyπ j) (by simp)\n  let π : T' ⟶ T :=\n    { τ₁ := K.pOpcycles i\n      τ₂ := 𝟙 _\n      τ₃ := 𝟙 _ }\n  have hT : T.Exact := by\n    rw [← ShortComplex.exact_iff_of_epi_of_isIso_of_mono π]\n    exact T'.exact_of_g_is_cokernel (K.homologyIsCokernel i j (c.prev_eq' hij))\n  apply ComposableArrows.exact_of_δ₀\n  · exact hS.exact_toComposableArrows\n  · exact hT.exact_toComposableArrows\n\n"}
{"name":"HomologicalComplex.HomologySequence.composableArrows₃Functor_obj","module":"Mathlib.Algebra.Homology.HomologySequence","initialProofState":"C : Type u_1\nι : Type u_2\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nc : ComplexShape ι\ni j : ι\ninst✝ : CategoryTheory.CategoryWithHomology C\nK : HomologicalComplex C c\n⊢ Eq ((HomologicalComplex.HomologySequence.composableArrows₃Functor C i j).obj K) (HomologicalComplex.HomologySequence.composableArrows₃ K i j)","decl":"set_option simprocs false in\n/-- The functor `HomologicalComplex C c ⥤ ComposableArrows C 3` that maps `K` to the\ndiagram `K.homology i ⟶ K.opcycles i ⟶ K.cycles j ⟶ K.homology j`. -/\n@[simps]\nnoncomputable def composableArrows₃Functor [CategoryWithHomology C] :\n    HomologicalComplex C c ⥤ ComposableArrows C 3 where\n  obj K := composableArrows₃ K i j\n  map {K L} φ := ComposableArrows.homMk₃ (homologyMap φ i) (opcyclesMap φ i) (cyclesMap φ j)\n    (homologyMap φ j) (by simp) (by simp) (by simp)\n\n"}
{"name":"HomologicalComplex.HomologySequence.composableArrows₃Functor_map","module":"Mathlib.Algebra.Homology.HomologySequence","initialProofState":"C : Type u_1\nι : Type u_2\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nc : ComplexShape ι\ni j : ι\ninst✝ : CategoryTheory.CategoryWithHomology C\nK L : HomologicalComplex C c\nφ : Quiver.Hom K L\n⊢ Eq ((HomologicalComplex.HomologySequence.composableArrows₃Functor C i j).map φ) (CategoryTheory.ComposableArrows.homMk₃ (HomologicalComplex.homologyMap φ i) (HomologicalComplex.opcyclesMap φ i) (HomologicalComplex.cyclesMap φ j) (HomologicalComplex.homologyMap φ j) ⋯ ⋯ ⋯)","decl":"set_option simprocs false in\n/-- The functor `HomologicalComplex C c ⥤ ComposableArrows C 3` that maps `K` to the\ndiagram `K.homology i ⟶ K.opcycles i ⟶ K.cycles j ⟶ K.homology j`. -/\n@[simps]\nnoncomputable def composableArrows₃Functor [CategoryWithHomology C] :\n    HomologicalComplex C c ⥤ ComposableArrows C 3 where\n  obj K := composableArrows₃ K i j\n  map {K L} φ := ComposableArrows.homMk₃ (homologyMap φ i) (opcyclesMap φ i) (cyclesMap φ j)\n    (homologyMap φ j) (by simp) (by simp) (by simp)\n\n"}
{"name":"HomologicalComplex.opcycles_right_exact","module":"Mathlib.Algebra.Homology.HomologySequence","initialProofState":"C : Type u_1\nι : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁴ : CategoryTheory.Abelian C\nc : ComplexShape ι\nS : CategoryTheory.ShortComplex (HomologicalComplex C c)\nhS : S.Exact\ninst✝³ : CategoryTheory.Epi S.g\ni : ι\ninst✝² : S.X₁.HasHomology i\ninst✝¹ : S.X₂.HasHomology i\ninst✝ : S.X₃.HasHomology i\n⊢ (CategoryTheory.ShortComplex.mk (HomologicalComplex.opcyclesMap S.f i) (HomologicalComplex.opcyclesMap S.g i) ⋯).Exact","decl":"/-- If `X₁ ⟶ X₂ ⟶ X₃ ⟶ 0` is an exact sequence of homological complexes, then\n`X₁.opcycles i ⟶ X₂.opcycles i ⟶ X₃.opcycles i ⟶ 0` is exact. This lemma states\nthe exactness at `X₂.opcycles i`, while the fact that `X₂.opcycles i ⟶ X₃.opcycles i`\nis an epi is an instance. -/\nlemma opcycles_right_exact (S : ShortComplex (HomologicalComplex C c)) (hS : S.Exact) [Epi S.g]\n    (i : ι) [S.X₁.HasHomology i] [S.X₂.HasHomology i] [S.X₃.HasHomology i] :\n    (ShortComplex.mk (opcyclesMap S.f i) (opcyclesMap S.g i)\n      (by rw [← opcyclesMap_comp, S.zero, opcyclesMap_zero])).Exact := by\n  have : Epi (ShortComplex.map S (eval C c i)).g := by dsimp; infer_instance\n  have hj := (hS.map (HomologicalComplex.eval C c i)).gIsCokernel\n  apply ShortComplex.exact_of_g_is_cokernel\n  refine CokernelCofork.IsColimit.ofπ' _ _  (fun {A} k hk => by\n    dsimp at k hk ⊢\n    have H := CokernelCofork.IsColimit.desc' hj (S.X₂.pOpcycles i ≫ k) (by\n      dsimp\n      rw [← p_opcyclesMap_assoc, hk, comp_zero])\n    dsimp at H\n    refine ⟨S.X₃.descOpcycles H.1 _ rfl ?_, ?_⟩\n    · rw [← cancel_epi (S.g.f (c.prev i)), comp_zero, Hom.comm_assoc, H.2,\n        d_pOpcycles_assoc, zero_comp]\n    · rw [← cancel_epi (S.X₂.pOpcycles i), opcyclesMap_comp_descOpcycles, p_descOpcycles, H.2])\n\n"}
{"name":"HomologicalComplex.cycles_left_exact","module":"Mathlib.Algebra.Homology.HomologySequence","initialProofState":"C : Type u_1\nι : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁴ : CategoryTheory.Abelian C\nc : ComplexShape ι\nS : CategoryTheory.ShortComplex (HomologicalComplex C c)\nhS : S.Exact\ninst✝³ : CategoryTheory.Mono S.f\ni : ι\ninst✝² : S.X₁.HasHomology i\ninst✝¹ : S.X₂.HasHomology i\ninst✝ : S.X₃.HasHomology i\n⊢ (CategoryTheory.ShortComplex.mk (HomologicalComplex.cyclesMap S.f i) (HomologicalComplex.cyclesMap S.g i) ⋯).Exact","decl":"/-- If `0 ⟶ X₁ ⟶ X₂ ⟶ X₃` is an exact sequence of homological complex, then\n`0 ⟶ X₁.cycles i ⟶ X₂.cycles i ⟶ X₃.cycles i` is exact. This lemma states\nthe exactness at `X₂.cycles i`, while the fact that `X₁.cycles i ⟶ X₂.cycles i`\nis a mono is an instance. -/\nlemma cycles_left_exact (S : ShortComplex (HomologicalComplex C c)) (hS : S.Exact) [Mono S.f]\n    (i : ι) [S.X₁.HasHomology i] [S.X₂.HasHomology i] [S.X₃.HasHomology i] :\n    (ShortComplex.mk (cyclesMap S.f i) (cyclesMap S.g i)\n      (by rw [← cyclesMap_comp, S.zero, cyclesMap_zero])).Exact := by\n  have : Mono (ShortComplex.map S (eval C c i)).f := by dsimp; infer_instance\n  have hi := (hS.map (HomologicalComplex.eval C c i)).fIsKernel\n  apply ShortComplex.exact_of_f_is_kernel\n  exact KernelFork.IsLimit.ofι' _ _ (fun {A} k hk => by\n    dsimp at k hk ⊢\n    have H := KernelFork.IsLimit.lift' hi (k ≫ S.X₂.iCycles i) (by\n      dsimp\n      rw [assoc, ← cyclesMap_i, reassoc_of% hk, zero_comp])\n    dsimp at H\n    refine ⟨S.X₁.liftCycles H.1 _ rfl ?_, ?_⟩\n    · rw [← cancel_mono (S.f.f _), assoc, zero_comp, ← Hom.comm, reassoc_of% H.2,\n        iCycles_d, comp_zero]\n    · rw [← cancel_mono (S.X₂.iCycles i), liftCycles_comp_cyclesMap, liftCycles_i, H.2])\n\n"}
{"name":"HomologicalComplex.HomologySequence.snakeInput_L₃","module":"Mathlib.Algebra.Homology.HomologySequence","initialProofState":"C : Type u_1\nι : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\ninst✝ : CategoryTheory.Abelian C\nc : ComplexShape ι\nS : CategoryTheory.ShortComplex (HomologicalComplex C c)\nhS : S.ShortExact\ni j : ι\nhij : c.Rel i j\n⊢ Eq (HomologicalComplex.HomologySequence.snakeInput hS i j hij).L₃ ((HomologicalComplex.homologyFunctor C c j).mapShortComplex.obj S)","decl":"/-- Given a short exact short complex `S : HomologicalComplex C c`, and degrees `i` and `j`\nsuch that `c.Rel i j`, this is the snake diagram whose four lines are respectively\nobtained by applying the functors `homologyFunctor C c i`, `opcyclesFunctor C c i`,\n`cyclesFunctor C c j`, `homologyFunctor C c j` to `S`. Applying the snake lemma to this\ngives the homology sequence of `S`. -/\n@[simps]\nnoncomputable def snakeInput (hS : S.ShortExact) (i j : ι) (hij : c.Rel i j) :\n    ShortComplex.SnakeInput C where\n  L₀ := (homologyFunctor C c i).mapShortComplex.obj S\n  L₁ := (opcyclesFunctor C c i).mapShortComplex.obj S\n  L₂ := (cyclesFunctor C c j).mapShortComplex.obj S\n  L₃ := (homologyFunctor C c j).mapShortComplex.obj S\n  v₀₁ := S.mapNatTrans (natTransHomologyι C c i)\n  v₁₂ := S.mapNatTrans (natTransOpCyclesToCycles C c i j)\n  v₂₃ := S.mapNatTrans (natTransHomologyπ C c j)\n  h₀ := by\n    apply ShortComplex.isLimitOfIsLimitπ\n    all_goals\n      exact (KernelFork.isLimitMapConeEquiv _ _).symm\n        ((composableArrows₃_exact _ i j hij).exact 0).fIsKernel\n  h₃ := by\n    apply ShortComplex.isColimitOfIsColimitπ\n    all_goals\n      exact (CokernelCofork.isColimitMapCoconeEquiv _ _).symm\n        ((composableArrows₃_exact _ i j hij).exact 1).gIsCokernel\n  L₁_exact := by\n    have := hS.epi_g\n    exact opcycles_right_exact S hS.exact i\n  L₂_exact := by\n    have := hS.mono_f\n    exact cycles_left_exact S hS.exact j\n  epi_L₁_g := by\n    have := hS.epi_g\n    dsimp\n    infer_instance\n  mono_L₂_f := by\n    have := hS.mono_f\n    dsimp\n    infer_instance\n\n"}
{"name":"HomologicalComplex.HomologySequence.snakeInput_v₁₂","module":"Mathlib.Algebra.Homology.HomologySequence","initialProofState":"C : Type u_1\nι : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\ninst✝ : CategoryTheory.Abelian C\nc : ComplexShape ι\nS : CategoryTheory.ShortComplex (HomologicalComplex C c)\nhS : S.ShortExact\ni j : ι\nhij : c.Rel i j\n⊢ Eq (HomologicalComplex.HomologySequence.snakeInput hS i j hij).v₁₂ (S.mapNatTrans (HomologicalComplex.natTransOpCyclesToCycles C c i j))","decl":"/-- Given a short exact short complex `S : HomologicalComplex C c`, and degrees `i` and `j`\nsuch that `c.Rel i j`, this is the snake diagram whose four lines are respectively\nobtained by applying the functors `homologyFunctor C c i`, `opcyclesFunctor C c i`,\n`cyclesFunctor C c j`, `homologyFunctor C c j` to `S`. Applying the snake lemma to this\ngives the homology sequence of `S`. -/\n@[simps]\nnoncomputable def snakeInput (hS : S.ShortExact) (i j : ι) (hij : c.Rel i j) :\n    ShortComplex.SnakeInput C where\n  L₀ := (homologyFunctor C c i).mapShortComplex.obj S\n  L₁ := (opcyclesFunctor C c i).mapShortComplex.obj S\n  L₂ := (cyclesFunctor C c j).mapShortComplex.obj S\n  L₃ := (homologyFunctor C c j).mapShortComplex.obj S\n  v₀₁ := S.mapNatTrans (natTransHomologyι C c i)\n  v₁₂ := S.mapNatTrans (natTransOpCyclesToCycles C c i j)\n  v₂₃ := S.mapNatTrans (natTransHomologyπ C c j)\n  h₀ := by\n    apply ShortComplex.isLimitOfIsLimitπ\n    all_goals\n      exact (KernelFork.isLimitMapConeEquiv _ _).symm\n        ((composableArrows₃_exact _ i j hij).exact 0).fIsKernel\n  h₃ := by\n    apply ShortComplex.isColimitOfIsColimitπ\n    all_goals\n      exact (CokernelCofork.isColimitMapCoconeEquiv _ _).symm\n        ((composableArrows₃_exact _ i j hij).exact 1).gIsCokernel\n  L₁_exact := by\n    have := hS.epi_g\n    exact opcycles_right_exact S hS.exact i\n  L₂_exact := by\n    have := hS.mono_f\n    exact cycles_left_exact S hS.exact j\n  epi_L₁_g := by\n    have := hS.epi_g\n    dsimp\n    infer_instance\n  mono_L₂_f := by\n    have := hS.mono_f\n    dsimp\n    infer_instance\n\n"}
{"name":"HomologicalComplex.HomologySequence.snakeInput_L₀","module":"Mathlib.Algebra.Homology.HomologySequence","initialProofState":"C : Type u_1\nι : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\ninst✝ : CategoryTheory.Abelian C\nc : ComplexShape ι\nS : CategoryTheory.ShortComplex (HomologicalComplex C c)\nhS : S.ShortExact\ni j : ι\nhij : c.Rel i j\n⊢ Eq (HomologicalComplex.HomologySequence.snakeInput hS i j hij).L₀ ((HomologicalComplex.homologyFunctor C c i).mapShortComplex.obj S)","decl":"/-- Given a short exact short complex `S : HomologicalComplex C c`, and degrees `i` and `j`\nsuch that `c.Rel i j`, this is the snake diagram whose four lines are respectively\nobtained by applying the functors `homologyFunctor C c i`, `opcyclesFunctor C c i`,\n`cyclesFunctor C c j`, `homologyFunctor C c j` to `S`. Applying the snake lemma to this\ngives the homology sequence of `S`. -/\n@[simps]\nnoncomputable def snakeInput (hS : S.ShortExact) (i j : ι) (hij : c.Rel i j) :\n    ShortComplex.SnakeInput C where\n  L₀ := (homologyFunctor C c i).mapShortComplex.obj S\n  L₁ := (opcyclesFunctor C c i).mapShortComplex.obj S\n  L₂ := (cyclesFunctor C c j).mapShortComplex.obj S\n  L₃ := (homologyFunctor C c j).mapShortComplex.obj S\n  v₀₁ := S.mapNatTrans (natTransHomologyι C c i)\n  v₁₂ := S.mapNatTrans (natTransOpCyclesToCycles C c i j)\n  v₂₃ := S.mapNatTrans (natTransHomologyπ C c j)\n  h₀ := by\n    apply ShortComplex.isLimitOfIsLimitπ\n    all_goals\n      exact (KernelFork.isLimitMapConeEquiv _ _).symm\n        ((composableArrows₃_exact _ i j hij).exact 0).fIsKernel\n  h₃ := by\n    apply ShortComplex.isColimitOfIsColimitπ\n    all_goals\n      exact (CokernelCofork.isColimitMapCoconeEquiv _ _).symm\n        ((composableArrows₃_exact _ i j hij).exact 1).gIsCokernel\n  L₁_exact := by\n    have := hS.epi_g\n    exact opcycles_right_exact S hS.exact i\n  L₂_exact := by\n    have := hS.mono_f\n    exact cycles_left_exact S hS.exact j\n  epi_L₁_g := by\n    have := hS.epi_g\n    dsimp\n    infer_instance\n  mono_L₂_f := by\n    have := hS.mono_f\n    dsimp\n    infer_instance\n\n"}
{"name":"HomologicalComplex.HomologySequence.snakeInput_v₂₃","module":"Mathlib.Algebra.Homology.HomologySequence","initialProofState":"C : Type u_1\nι : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\ninst✝ : CategoryTheory.Abelian C\nc : ComplexShape ι\nS : CategoryTheory.ShortComplex (HomologicalComplex C c)\nhS : S.ShortExact\ni j : ι\nhij : c.Rel i j\n⊢ Eq (HomologicalComplex.HomologySequence.snakeInput hS i j hij).v₂₃ (S.mapNatTrans (HomologicalComplex.natTransHomologyπ C c j))","decl":"/-- Given a short exact short complex `S : HomologicalComplex C c`, and degrees `i` and `j`\nsuch that `c.Rel i j`, this is the snake diagram whose four lines are respectively\nobtained by applying the functors `homologyFunctor C c i`, `opcyclesFunctor C c i`,\n`cyclesFunctor C c j`, `homologyFunctor C c j` to `S`. Applying the snake lemma to this\ngives the homology sequence of `S`. -/\n@[simps]\nnoncomputable def snakeInput (hS : S.ShortExact) (i j : ι) (hij : c.Rel i j) :\n    ShortComplex.SnakeInput C where\n  L₀ := (homologyFunctor C c i).mapShortComplex.obj S\n  L₁ := (opcyclesFunctor C c i).mapShortComplex.obj S\n  L₂ := (cyclesFunctor C c j).mapShortComplex.obj S\n  L₃ := (homologyFunctor C c j).mapShortComplex.obj S\n  v₀₁ := S.mapNatTrans (natTransHomologyι C c i)\n  v₁₂ := S.mapNatTrans (natTransOpCyclesToCycles C c i j)\n  v₂₃ := S.mapNatTrans (natTransHomologyπ C c j)\n  h₀ := by\n    apply ShortComplex.isLimitOfIsLimitπ\n    all_goals\n      exact (KernelFork.isLimitMapConeEquiv _ _).symm\n        ((composableArrows₃_exact _ i j hij).exact 0).fIsKernel\n  h₃ := by\n    apply ShortComplex.isColimitOfIsColimitπ\n    all_goals\n      exact (CokernelCofork.isColimitMapCoconeEquiv _ _).symm\n        ((composableArrows₃_exact _ i j hij).exact 1).gIsCokernel\n  L₁_exact := by\n    have := hS.epi_g\n    exact opcycles_right_exact S hS.exact i\n  L₂_exact := by\n    have := hS.mono_f\n    exact cycles_left_exact S hS.exact j\n  epi_L₁_g := by\n    have := hS.epi_g\n    dsimp\n    infer_instance\n  mono_L₂_f := by\n    have := hS.mono_f\n    dsimp\n    infer_instance\n\n"}
{"name":"HomologicalComplex.HomologySequence.snakeInput_L₁","module":"Mathlib.Algebra.Homology.HomologySequence","initialProofState":"C : Type u_1\nι : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\ninst✝ : CategoryTheory.Abelian C\nc : ComplexShape ι\nS : CategoryTheory.ShortComplex (HomologicalComplex C c)\nhS : S.ShortExact\ni j : ι\nhij : c.Rel i j\n⊢ Eq (HomologicalComplex.HomologySequence.snakeInput hS i j hij).L₁ ((HomologicalComplex.opcyclesFunctor C c i).mapShortComplex.obj S)","decl":"/-- Given a short exact short complex `S : HomologicalComplex C c`, and degrees `i` and `j`\nsuch that `c.Rel i j`, this is the snake diagram whose four lines are respectively\nobtained by applying the functors `homologyFunctor C c i`, `opcyclesFunctor C c i`,\n`cyclesFunctor C c j`, `homologyFunctor C c j` to `S`. Applying the snake lemma to this\ngives the homology sequence of `S`. -/\n@[simps]\nnoncomputable def snakeInput (hS : S.ShortExact) (i j : ι) (hij : c.Rel i j) :\n    ShortComplex.SnakeInput C where\n  L₀ := (homologyFunctor C c i).mapShortComplex.obj S\n  L₁ := (opcyclesFunctor C c i).mapShortComplex.obj S\n  L₂ := (cyclesFunctor C c j).mapShortComplex.obj S\n  L₃ := (homologyFunctor C c j).mapShortComplex.obj S\n  v₀₁ := S.mapNatTrans (natTransHomologyι C c i)\n  v₁₂ := S.mapNatTrans (natTransOpCyclesToCycles C c i j)\n  v₂₃ := S.mapNatTrans (natTransHomologyπ C c j)\n  h₀ := by\n    apply ShortComplex.isLimitOfIsLimitπ\n    all_goals\n      exact (KernelFork.isLimitMapConeEquiv _ _).symm\n        ((composableArrows₃_exact _ i j hij).exact 0).fIsKernel\n  h₃ := by\n    apply ShortComplex.isColimitOfIsColimitπ\n    all_goals\n      exact (CokernelCofork.isColimitMapCoconeEquiv _ _).symm\n        ((composableArrows₃_exact _ i j hij).exact 1).gIsCokernel\n  L₁_exact := by\n    have := hS.epi_g\n    exact opcycles_right_exact S hS.exact i\n  L₂_exact := by\n    have := hS.mono_f\n    exact cycles_left_exact S hS.exact j\n  epi_L₁_g := by\n    have := hS.epi_g\n    dsimp\n    infer_instance\n  mono_L₂_f := by\n    have := hS.mono_f\n    dsimp\n    infer_instance\n\n"}
{"name":"HomologicalComplex.HomologySequence.snakeInput_L₂","module":"Mathlib.Algebra.Homology.HomologySequence","initialProofState":"C : Type u_1\nι : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\ninst✝ : CategoryTheory.Abelian C\nc : ComplexShape ι\nS : CategoryTheory.ShortComplex (HomologicalComplex C c)\nhS : S.ShortExact\ni j : ι\nhij : c.Rel i j\n⊢ Eq (HomologicalComplex.HomologySequence.snakeInput hS i j hij).L₂ ((HomologicalComplex.cyclesFunctor C c j).mapShortComplex.obj S)","decl":"/-- Given a short exact short complex `S : HomologicalComplex C c`, and degrees `i` and `j`\nsuch that `c.Rel i j`, this is the snake diagram whose four lines are respectively\nobtained by applying the functors `homologyFunctor C c i`, `opcyclesFunctor C c i`,\n`cyclesFunctor C c j`, `homologyFunctor C c j` to `S`. Applying the snake lemma to this\ngives the homology sequence of `S`. -/\n@[simps]\nnoncomputable def snakeInput (hS : S.ShortExact) (i j : ι) (hij : c.Rel i j) :\n    ShortComplex.SnakeInput C where\n  L₀ := (homologyFunctor C c i).mapShortComplex.obj S\n  L₁ := (opcyclesFunctor C c i).mapShortComplex.obj S\n  L₂ := (cyclesFunctor C c j).mapShortComplex.obj S\n  L₃ := (homologyFunctor C c j).mapShortComplex.obj S\n  v₀₁ := S.mapNatTrans (natTransHomologyι C c i)\n  v₁₂ := S.mapNatTrans (natTransOpCyclesToCycles C c i j)\n  v₂₃ := S.mapNatTrans (natTransHomologyπ C c j)\n  h₀ := by\n    apply ShortComplex.isLimitOfIsLimitπ\n    all_goals\n      exact (KernelFork.isLimitMapConeEquiv _ _).symm\n        ((composableArrows₃_exact _ i j hij).exact 0).fIsKernel\n  h₃ := by\n    apply ShortComplex.isColimitOfIsColimitπ\n    all_goals\n      exact (CokernelCofork.isColimitMapCoconeEquiv _ _).symm\n        ((composableArrows₃_exact _ i j hij).exact 1).gIsCokernel\n  L₁_exact := by\n    have := hS.epi_g\n    exact opcycles_right_exact S hS.exact i\n  L₂_exact := by\n    have := hS.mono_f\n    exact cycles_left_exact S hS.exact j\n  epi_L₁_g := by\n    have := hS.epi_g\n    dsimp\n    infer_instance\n  mono_L₂_f := by\n    have := hS.mono_f\n    dsimp\n    infer_instance\n\n"}
{"name":"HomologicalComplex.HomologySequence.snakeInput_v₀₁","module":"Mathlib.Algebra.Homology.HomologySequence","initialProofState":"C : Type u_1\nι : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\ninst✝ : CategoryTheory.Abelian C\nc : ComplexShape ι\nS : CategoryTheory.ShortComplex (HomologicalComplex C c)\nhS : S.ShortExact\ni j : ι\nhij : c.Rel i j\n⊢ Eq (HomologicalComplex.HomologySequence.snakeInput hS i j hij).v₀₁ (S.mapNatTrans (HomologicalComplex.natTransHomologyι C c i))","decl":"/-- Given a short exact short complex `S : HomologicalComplex C c`, and degrees `i` and `j`\nsuch that `c.Rel i j`, this is the snake diagram whose four lines are respectively\nobtained by applying the functors `homologyFunctor C c i`, `opcyclesFunctor C c i`,\n`cyclesFunctor C c j`, `homologyFunctor C c j` to `S`. Applying the snake lemma to this\ngives the homology sequence of `S`. -/\n@[simps]\nnoncomputable def snakeInput (hS : S.ShortExact) (i j : ι) (hij : c.Rel i j) :\n    ShortComplex.SnakeInput C where\n  L₀ := (homologyFunctor C c i).mapShortComplex.obj S\n  L₁ := (opcyclesFunctor C c i).mapShortComplex.obj S\n  L₂ := (cyclesFunctor C c j).mapShortComplex.obj S\n  L₃ := (homologyFunctor C c j).mapShortComplex.obj S\n  v₀₁ := S.mapNatTrans (natTransHomologyι C c i)\n  v₁₂ := S.mapNatTrans (natTransOpCyclesToCycles C c i j)\n  v₂₃ := S.mapNatTrans (natTransHomologyπ C c j)\n  h₀ := by\n    apply ShortComplex.isLimitOfIsLimitπ\n    all_goals\n      exact (KernelFork.isLimitMapConeEquiv _ _).symm\n        ((composableArrows₃_exact _ i j hij).exact 0).fIsKernel\n  h₃ := by\n    apply ShortComplex.isColimitOfIsColimitπ\n    all_goals\n      exact (CokernelCofork.isColimitMapCoconeEquiv _ _).symm\n        ((composableArrows₃_exact _ i j hij).exact 1).gIsCokernel\n  L₁_exact := by\n    have := hS.epi_g\n    exact opcycles_right_exact S hS.exact i\n  L₂_exact := by\n    have := hS.mono_f\n    exact cycles_left_exact S hS.exact j\n  epi_L₁_g := by\n    have := hS.epi_g\n    dsimp\n    infer_instance\n  mono_L₂_f := by\n    have := hS.mono_f\n    dsimp\n    infer_instance\n\n"}
{"name":"CategoryTheory.ShortComplex.ShortExact.δ_comp","module":"Mathlib.Algebra.Homology.HomologySequence","initialProofState":"C : Type u_1\nι : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\ninst✝ : CategoryTheory.Abelian C\nc : ComplexShape ι\nS : CategoryTheory.ShortComplex (HomologicalComplex C c)\nhS : S.ShortExact\ni j : ι\nhij : c.Rel i j\n⊢ Eq (CategoryTheory.CategoryStruct.comp (hS.δ i j hij) (HomologicalComplex.homologyMap S.f j)) 0","decl":"@[reassoc (attr := simp)]\nlemma δ_comp : hS.δ i j hij ≫ HomologicalComplex.homologyMap S.f j = 0 :=\n  (snakeInput hS i j hij).δ_L₃_f\n\n"}
{"name":"CategoryTheory.ShortComplex.ShortExact.δ_comp_assoc","module":"Mathlib.Algebra.Homology.HomologySequence","initialProofState":"C : Type u_1\nι : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\ninst✝ : CategoryTheory.Abelian C\nc : ComplexShape ι\nS : CategoryTheory.ShortComplex (HomologicalComplex C c)\nhS : S.ShortExact\ni j : ι\nhij : c.Rel i j\nZ : C\nh : Quiver.Hom (S.X₂.homology j) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (hS.δ i j hij) (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homologyMap S.f j) h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"@[reassoc (attr := simp)]\nlemma δ_comp : hS.δ i j hij ≫ HomologicalComplex.homologyMap S.f j = 0 :=\n  (snakeInput hS i j hij).δ_L₃_f\n\n"}
{"name":"CategoryTheory.ShortComplex.ShortExact.comp_δ_assoc","module":"Mathlib.Algebra.Homology.HomologySequence","initialProofState":"C : Type u_1\nι : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\ninst✝ : CategoryTheory.Abelian C\nc : ComplexShape ι\nS : CategoryTheory.ShortComplex (HomologicalComplex C c)\nhS : S.ShortExact\ni j : ι\nhij : c.Rel i j\nZ : C\nh : Quiver.Hom (S.X₁.homology j) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homologyMap S.g i) (CategoryTheory.CategoryStruct.comp (hS.δ i j hij) h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"@[reassoc (attr := simp)]\nlemma comp_δ : HomologicalComplex.homologyMap S.g i ≫ hS.δ i j hij = 0 :=\n  (snakeInput hS i j hij).L₀_g_δ\n\n"}
{"name":"CategoryTheory.ShortComplex.ShortExact.comp_δ","module":"Mathlib.Algebra.Homology.HomologySequence","initialProofState":"C : Type u_1\nι : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\ninst✝ : CategoryTheory.Abelian C\nc : ComplexShape ι\nS : CategoryTheory.ShortComplex (HomologicalComplex C c)\nhS : S.ShortExact\ni j : ι\nhij : c.Rel i j\n⊢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homologyMap S.g i) (hS.δ i j hij)) 0","decl":"@[reassoc (attr := simp)]\nlemma comp_δ : HomologicalComplex.homologyMap S.g i ≫ hS.δ i j hij = 0 :=\n  (snakeInput hS i j hij).L₀_g_δ\n\n"}
{"name":"CategoryTheory.ShortComplex.ShortExact.homology_exact₁","module":"Mathlib.Algebra.Homology.HomologySequence","initialProofState":"C : Type u_1\nι : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\ninst✝ : CategoryTheory.Abelian C\nc : ComplexShape ι\nS : CategoryTheory.ShortComplex (HomologicalComplex C c)\nhS : S.ShortExact\ni j : ι\nhij : c.Rel i j\n⊢ (CategoryTheory.ShortComplex.mk (hS.δ i j hij) (HomologicalComplex.homologyMap S.f j) ⋯).Exact","decl":"/-- Exactness of `S.X₃.homology i ⟶ S.X₁.homology j ⟶ S.X₂.homology j`. -/\nlemma homology_exact₁ : (ShortComplex.mk _ _ (δ_comp hS i j hij)).Exact :=\n  (snakeInput hS i j hij).L₂'_exact\n\n"}
{"name":"CategoryTheory.ShortComplex.ShortExact.homology_exact₂","module":"Mathlib.Algebra.Homology.HomologySequence","initialProofState":"C : Type u_1\nι : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\ninst✝ : CategoryTheory.Abelian C\nc : ComplexShape ι\nS : CategoryTheory.ShortComplex (HomologicalComplex C c)\nhS : S.ShortExact\ni : ι\n⊢ (CategoryTheory.ShortComplex.mk (HomologicalComplex.homologyMap S.f i) (HomologicalComplex.homologyMap S.g i) ⋯).Exact","decl":"include hS in\n/-- Exactness of `S.X₁.homology i ⟶ S.X₂.homology i ⟶ S.X₃.homology i`. -/\nlemma homology_exact₂ : (ShortComplex.mk (HomologicalComplex.homologyMap S.f i)\n    (HomologicalComplex.homologyMap S.g i) (by rw [← HomologicalComplex.homologyMap_comp,\n      S.zero, HomologicalComplex.homologyMap_zero])).Exact := by\n  by_cases h : c.Rel i (c.next i)\n  · exact (snakeInput hS i _ h).L₀_exact\n  · have := hS.epi_g\n    have : ∀ (K : HomologicalComplex C c), IsIso (K.homologyι i) :=\n      fun K => ShortComplex.isIso_homologyι (K.sc i) (K.shape _ _ h)\n    have e : S.map (HomologicalComplex.homologyFunctor C c i) ≅\n        S.map (HomologicalComplex.opcyclesFunctor C c i) :=\n      ShortComplex.isoMk (asIso (S.X₁.homologyι i))\n        (asIso (S.X₂.homologyι i)) (asIso (S.X₃.homologyι i)) (by simp) (by simp)\n    exact ShortComplex.exact_of_iso e.symm (opcycles_right_exact S hS.exact i)\n\n"}
{"name":"CategoryTheory.ShortComplex.ShortExact.homology_exact₃","module":"Mathlib.Algebra.Homology.HomologySequence","initialProofState":"C : Type u_1\nι : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\ninst✝ : CategoryTheory.Abelian C\nc : ComplexShape ι\nS : CategoryTheory.ShortComplex (HomologicalComplex C c)\nhS : S.ShortExact\ni j : ι\nhij : c.Rel i j\n⊢ (CategoryTheory.ShortComplex.mk (HomologicalComplex.homologyMap S.g i) (hS.δ i j hij) ⋯).Exact","decl":"/-- Exactness of `S.X₂.homology i ⟶ S.X₃.homology i ⟶ S.X₁.homology j`. -/\nlemma homology_exact₃ : (ShortComplex.mk _ _ (comp_δ hS i j hij)).Exact :=\n  (snakeInput hS i j hij).L₁'_exact\n\n"}
{"name":"CategoryTheory.ShortComplex.ShortExact.δ_eq'","module":"Mathlib.Algebra.Homology.HomologySequence","initialProofState":"C : Type u_1\nι : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\ninst✝ : CategoryTheory.Abelian C\nc : ComplexShape ι\nS : CategoryTheory.ShortComplex (HomologicalComplex C c)\nhS : S.ShortExact\ni j : ι\nhij : c.Rel i j\nA : C\nx₃ : Quiver.Hom A (S.X₃.homology i)\nx₂ : Quiver.Hom A (S.X₂.opcycles i)\nx₁ : Quiver.Hom A (S.X₁.cycles j)\nh₂ : Eq (CategoryTheory.CategoryStruct.comp x₂ (HomologicalComplex.opcyclesMap S.g i)) (CategoryTheory.CategoryStruct.comp x₃ (S.X₃.homologyι i))\nh₁ : Eq (CategoryTheory.CategoryStruct.comp x₁ (HomologicalComplex.cyclesMap S.f j)) (CategoryTheory.CategoryStruct.comp x₂ (S.X₂.opcyclesToCycles i j))\n⊢ Eq (CategoryTheory.CategoryStruct.comp x₃ (hS.δ i j hij)) (CategoryTheory.CategoryStruct.comp x₁ (S.X₁.homologyπ j))","decl":"lemma δ_eq' {A : C} (x₃ : A ⟶ S.X₃.homology i) (x₂ : A ⟶ S.X₂.opcycles i)\n    (x₁ : A ⟶ S.X₁.cycles j)\n    (h₂ : x₂ ≫ HomologicalComplex.opcyclesMap S.g i = x₃ ≫ S.X₃.homologyι i)\n    (h₁ : x₁ ≫ HomologicalComplex.cyclesMap S.f j = x₂ ≫ S.X₂.opcyclesToCycles i j) :\n    x₃ ≫ hS.δ i j hij = x₁ ≫ S.X₁.homologyπ j :=\n  (snakeInput hS i j hij).δ_eq x₃ x₂ x₁ h₂ h₁\n\n"}
{"name":"CategoryTheory.ShortComplex.ShortExact.δ_eq","module":"Mathlib.Algebra.Homology.HomologySequence","initialProofState":"C : Type u_1\nι : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\ninst✝ : CategoryTheory.Abelian C\nc : ComplexShape ι\nS : CategoryTheory.ShortComplex (HomologicalComplex C c)\nhS : S.ShortExact\ni j : ι\nhij : c.Rel i j\nA : C\nx₃ : Quiver.Hom A (S.X₃.X i)\nhx₃ : Eq (CategoryTheory.CategoryStruct.comp x₃ (S.X₃.d i j)) 0\nx₂ : Quiver.Hom A (S.X₂.X i)\nhx₂ : Eq (CategoryTheory.CategoryStruct.comp x₂ (S.g.f i)) x₃\nx₁ : Quiver.Hom A (S.X₁.X j)\nhx₁ : Eq (CategoryTheory.CategoryStruct.comp x₁ (S.f.f j)) (CategoryTheory.CategoryStruct.comp x₂ (S.X₂.d i j))\nk : ι\nhk : Eq (c.next j) k\n⊢ Eq (CategoryTheory.CategoryStruct.comp (S.X₃.liftCycles x₃ j ⋯ hx₃) (CategoryTheory.CategoryStruct.comp (S.X₃.homologyπ i) (hS.δ i j hij))) (CategoryTheory.CategoryStruct.comp (S.X₁.liftCycles x₁ k hk ⋯) (S.X₁.homologyπ j))","decl":"lemma δ_eq {A : C} (x₃ : A ⟶ S.X₃.X i) (hx₃ : x₃ ≫ S.X₃.d i j = 0)\n    (x₂ : A ⟶ S.X₂.X i) (hx₂ : x₂ ≫ S.g.f i = x₃)\n    (x₁ : A ⟶ S.X₁.X j) (hx₁ : x₁ ≫ S.f.f j = x₂ ≫ S.X₂.d i j)\n    (k : ι) (hk : c.next j = k) :\n    S.X₃.liftCycles x₃ j (c.next_eq' hij) hx₃ ≫ S.X₃.homologyπ i ≫ hS.δ i j hij =\n      S.X₁.liftCycles x₁ k hk (by\n        have := hS.mono_f\n        rw [← cancel_mono (S.f.f k), assoc, ← S.f.comm, reassoc_of% hx₁,\n          d_comp_d, comp_zero, zero_comp]) ≫ S.X₁.homologyπ j := by\n  simpa only [assoc] using hS.δ_eq' i j hij (S.X₃.liftCycles x₃ j\n    (c.next_eq' hij) hx₃ ≫ S.X₃.homologyπ i)\n    (x₂ ≫ S.X₂.pOpcycles i) (S.X₁.liftCycles x₁ k hk _)\n      (by simp only [assoc, HomologicalComplex.p_opcyclesMap,\n        HomologicalComplex.homology_π_ι,\n        HomologicalComplex.liftCycles_i_assoc, reassoc_of% hx₂])\n      (by rw [← cancel_mono (S.X₂.iCycles j), HomologicalComplex.liftCycles_comp_cyclesMap,\n        HomologicalComplex.liftCycles_i, assoc, assoc, opcyclesToCycles_iCycles,\n        HomologicalComplex.p_fromOpcycles, hx₁])\n\n"}
