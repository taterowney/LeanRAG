{"name":"Nat.instMulLeftMono","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"⊢ MulLeftMono Nat","decl":"instance Nat.instMulLeftMono : MulLeftMono ℕ where\n  elim := fun _ _ _ h => mul_le_mul_left _ h\n\n"}
{"name":"Int.instAddLeftMono","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"⊢ AddLeftMono Int","decl":"instance Int.instAddLeftMono : AddLeftMono ℤ where\n  elim := fun _ _ _ h => Int.add_le_add_left h _\n\n"}
{"name":"mul_le_mul_left'","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : Mul α\ninst✝¹ : LE α\ninst✝ : MulLeftMono α\nb c : α\nbc : LE.le b c\na : α\n⊢ LE.le (HMul.hMul a b) (HMul.hMul a c)","decl":"@[to_additive (attr := gcongr) add_le_add_left]\ntheorem mul_le_mul_left' [MulLeftMono α] {b c : α} (bc : b ≤ c) (a : α) :\n    a * b ≤ a * c :=\n  CovariantClass.elim _ bc\n\n"}
{"name":"add_le_add_left","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : Add α\ninst✝¹ : LE α\ninst✝ : AddLeftMono α\nb c : α\nbc : LE.le b c\na : α\n⊢ LE.le (HAdd.hAdd a b) (HAdd.hAdd a c)","decl":"@[to_additive (attr := gcongr) add_le_add_left]\ntheorem mul_le_mul_left' [MulLeftMono α] {b c : α} (bc : b ≤ c) (a : α) :\n    a * b ≤ a * c :=\n  CovariantClass.elim _ bc\n\n"}
{"name":"le_of_mul_le_mul_left'","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : Mul α\ninst✝¹ : LE α\ninst✝ : MulLeftReflectLE α\na b c : α\nbc : LE.le (HMul.hMul a b) (HMul.hMul a c)\n⊢ LE.le b c","decl":"@[to_additive le_of_add_le_add_left]\ntheorem le_of_mul_le_mul_left' [MulLeftReflectLE α] {a b c : α}\n    (bc : a * b ≤ a * c) :\n    b ≤ c :=\n  ContravariantClass.elim _ bc\n\n/- The prime on this lemma is present only on the multiplicative version.  The unprimed version\nis taken by the analogous lemma for semiring, with an extra non-negativity assumption. -/\n"}
{"name":"le_of_add_le_add_left","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : Add α\ninst✝¹ : LE α\ninst✝ : AddLeftReflectLE α\na b c : α\nbc : LE.le (HAdd.hAdd a b) (HAdd.hAdd a c)\n⊢ LE.le b c","decl":"@[to_additive le_of_add_le_add_left]\ntheorem le_of_mul_le_mul_left' [MulLeftReflectLE α] {a b c : α}\n    (bc : a * b ≤ a * c) :\n    b ≤ c :=\n  ContravariantClass.elim _ bc\n\n/- The prime on this lemma is present only on the multiplicative version.  The unprimed version\nis taken by the analogous lemma for semiring, with an extra non-negativity assumption. -/\n"}
{"name":"mul_le_mul_right'","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Mul α\ninst✝ : LE α\ni : MulRightMono α\nb c : α\nbc : LE.le b c\na : α\n⊢ LE.le (HMul.hMul b a) (HMul.hMul c a)","decl":"@[to_additive (attr := gcongr) add_le_add_right]\ntheorem mul_le_mul_right' [i : MulRightMono α] {b c : α} (bc : b ≤ c)\n    (a : α) :\n    b * a ≤ c * a :=\n  i.elim a bc\n\n"}
{"name":"add_le_add_right","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Add α\ninst✝ : LE α\ni : AddRightMono α\nb c : α\nbc : LE.le b c\na : α\n⊢ LE.le (HAdd.hAdd b a) (HAdd.hAdd c a)","decl":"@[to_additive (attr := gcongr) add_le_add_right]\ntheorem mul_le_mul_right' [i : MulRightMono α] {b c : α} (bc : b ≤ c)\n    (a : α) :\n    b * a ≤ c * a :=\n  i.elim a bc\n\n"}
{"name":"le_of_add_le_add_right","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Add α\ninst✝ : LE α\ni : AddRightReflectLE α\na b c : α\nbc : LE.le (HAdd.hAdd b a) (HAdd.hAdd c a)\n⊢ LE.le b c","decl":"@[to_additive le_of_add_le_add_right]\ntheorem le_of_mul_le_mul_right' [i : MulRightReflectLE α] {a b c : α}\n    (bc : b * a ≤ c * a) :\n    b ≤ c :=\n  i.elim a bc\n\n"}
{"name":"le_of_mul_le_mul_right'","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Mul α\ninst✝ : LE α\ni : MulRightReflectLE α\na b c : α\nbc : LE.le (HMul.hMul b a) (HMul.hMul c a)\n⊢ LE.le b c","decl":"@[to_additive le_of_add_le_add_right]\ntheorem le_of_mul_le_mul_right' [i : MulRightReflectLE α] {a b c : α}\n    (bc : b * a ≤ c * a) :\n    b ≤ c :=\n  i.elim a bc\n\n"}
{"name":"mul_le_mul_iff_left","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝³ : Mul α\ninst✝² : LE α\ninst✝¹ : MulLeftMono α\ninst✝ : MulLeftReflectLE α\na b c : α\n⊢ Iff (LE.le (HMul.hMul a b) (HMul.hMul a c)) (LE.le b c)","decl":"@[to_additive (attr := simp)]\ntheorem mul_le_mul_iff_left [MulLeftMono α]\n    [MulLeftReflectLE α] (a : α) {b c : α} :\n    a * b ≤ a * c ↔ b ≤ c :=\n  rel_iff_cov α α (· * ·) (· ≤ ·) a\n\n"}
{"name":"add_le_add_iff_left","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝³ : Add α\ninst✝² : LE α\ninst✝¹ : AddLeftMono α\ninst✝ : AddLeftReflectLE α\na b c : α\n⊢ Iff (LE.le (HAdd.hAdd a b) (HAdd.hAdd a c)) (LE.le b c)","decl":"@[to_additive (attr := simp)]\ntheorem mul_le_mul_iff_left [MulLeftMono α]\n    [MulLeftReflectLE α] (a : α) {b c : α} :\n    a * b ≤ a * c ↔ b ≤ c :=\n  rel_iff_cov α α (· * ·) (· ≤ ·) a\n\n"}
{"name":"add_le_add_iff_right","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝³ : Add α\ninst✝² : LE α\ninst✝¹ : AddRightMono α\ninst✝ : AddRightReflectLE α\na b c : α\n⊢ Iff (LE.le (HAdd.hAdd b a) (HAdd.hAdd c a)) (LE.le b c)","decl":"@[to_additive (attr := simp)]\ntheorem mul_le_mul_iff_right [MulRightMono α]\n    [MulRightReflectLE α] (a : α) {b c : α} :\n    b * a ≤ c * a ↔ b ≤ c :=\n  rel_iff_cov α α (swap (· * ·)) (· ≤ ·) a\n\n"}
{"name":"mul_le_mul_iff_right","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝³ : Mul α\ninst✝² : LE α\ninst✝¹ : MulRightMono α\ninst✝ : MulRightReflectLE α\na b c : α\n⊢ Iff (LE.le (HMul.hMul b a) (HMul.hMul c a)) (LE.le b c)","decl":"@[to_additive (attr := simp)]\ntheorem mul_le_mul_iff_right [MulRightMono α]\n    [MulRightReflectLE α] (a : α) {b c : α} :\n    b * a ≤ c * a ↔ b ≤ c :=\n  rel_iff_cov α α (swap (· * ·)) (· ≤ ·) a\n\n"}
{"name":"mul_lt_mul_iff_left","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝³ : Mul α\ninst✝² : LT α\ninst✝¹ : MulLeftStrictMono α\ninst✝ : MulLeftReflectLT α\na b c : α\n⊢ Iff (LT.lt (HMul.hMul a b) (HMul.hMul a c)) (LT.lt b c)","decl":"@[to_additive (attr := simp)]\ntheorem mul_lt_mul_iff_left [MulLeftStrictMono α]\n    [MulLeftReflectLT α] (a : α) {b c : α} :\n    a * b < a * c ↔ b < c :=\n  rel_iff_cov α α (· * ·) (· < ·) a\n\n"}
{"name":"add_lt_add_iff_left","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝³ : Add α\ninst✝² : LT α\ninst✝¹ : AddLeftStrictMono α\ninst✝ : AddLeftReflectLT α\na b c : α\n⊢ Iff (LT.lt (HAdd.hAdd a b) (HAdd.hAdd a c)) (LT.lt b c)","decl":"@[to_additive (attr := simp)]\ntheorem mul_lt_mul_iff_left [MulLeftStrictMono α]\n    [MulLeftReflectLT α] (a : α) {b c : α} :\n    a * b < a * c ↔ b < c :=\n  rel_iff_cov α α (· * ·) (· < ·) a\n\n"}
{"name":"mul_lt_mul_iff_right","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝³ : Mul α\ninst✝² : LT α\ninst✝¹ : MulRightStrictMono α\ninst✝ : MulRightReflectLT α\na b c : α\n⊢ Iff (LT.lt (HMul.hMul b a) (HMul.hMul c a)) (LT.lt b c)","decl":"@[to_additive (attr := simp)]\ntheorem mul_lt_mul_iff_right [MulRightStrictMono α]\n    [MulRightReflectLT α] (a : α) {b c : α} :\n    b * a < c * a ↔ b < c :=\n  rel_iff_cov α α (swap (· * ·)) (· < ·) a\n\n"}
{"name":"add_lt_add_iff_right","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝³ : Add α\ninst✝² : LT α\ninst✝¹ : AddRightStrictMono α\ninst✝ : AddRightReflectLT α\na b c : α\n⊢ Iff (LT.lt (HAdd.hAdd b a) (HAdd.hAdd c a)) (LT.lt b c)","decl":"@[to_additive (attr := simp)]\ntheorem mul_lt_mul_iff_right [MulRightStrictMono α]\n    [MulRightReflectLT α] (a : α) {b c : α} :\n    b * a < c * a ↔ b < c :=\n  rel_iff_cov α α (swap (· * ·)) (· < ·) a\n\n"}
{"name":"mul_lt_mul_left'","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : Mul α\ninst✝¹ : LT α\ninst✝ : MulLeftStrictMono α\nb c : α\nbc : LT.lt b c\na : α\n⊢ LT.lt (HMul.hMul a b) (HMul.hMul a c)","decl":"@[to_additive (attr := gcongr) add_lt_add_left]\ntheorem mul_lt_mul_left' [MulLeftStrictMono α] {b c : α} (bc : b < c) (a : α) :\n    a * b < a * c :=\n  CovariantClass.elim _ bc\n\n"}
{"name":"add_lt_add_left","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : Add α\ninst✝¹ : LT α\ninst✝ : AddLeftStrictMono α\nb c : α\nbc : LT.lt b c\na : α\n⊢ LT.lt (HAdd.hAdd a b) (HAdd.hAdd a c)","decl":"@[to_additive (attr := gcongr) add_lt_add_left]\ntheorem mul_lt_mul_left' [MulLeftStrictMono α] {b c : α} (bc : b < c) (a : α) :\n    a * b < a * c :=\n  CovariantClass.elim _ bc\n\n"}
{"name":"lt_of_mul_lt_mul_left'","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : Mul α\ninst✝¹ : LT α\ninst✝ : MulLeftReflectLT α\na b c : α\nbc : LT.lt (HMul.hMul a b) (HMul.hMul a c)\n⊢ LT.lt b c","decl":"@[to_additive lt_of_add_lt_add_left]\ntheorem lt_of_mul_lt_mul_left' [MulLeftReflectLT α] {a b c : α}\n    (bc : a * b < a * c) :\n    b < c :=\n  ContravariantClass.elim _ bc\n\n"}
{"name":"lt_of_add_lt_add_left","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : Add α\ninst✝¹ : LT α\ninst✝ : AddLeftReflectLT α\na b c : α\nbc : LT.lt (HAdd.hAdd a b) (HAdd.hAdd a c)\n⊢ LT.lt b c","decl":"@[to_additive lt_of_add_lt_add_left]\ntheorem lt_of_mul_lt_mul_left' [MulLeftReflectLT α] {a b c : α}\n    (bc : a * b < a * c) :\n    b < c :=\n  ContravariantClass.elim _ bc\n\n"}
{"name":"add_lt_add_right","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Add α\ninst✝ : LT α\ni : AddRightStrictMono α\nb c : α\nbc : LT.lt b c\na : α\n⊢ LT.lt (HAdd.hAdd b a) (HAdd.hAdd c a)","decl":"@[to_additive (attr := gcongr) add_lt_add_right]\ntheorem mul_lt_mul_right' [i : MulRightStrictMono α] {b c : α} (bc : b < c)\n    (a : α) :\n    b * a < c * a :=\n  i.elim a bc\n\n"}
{"name":"mul_lt_mul_right'","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Mul α\ninst✝ : LT α\ni : MulRightStrictMono α\nb c : α\nbc : LT.lt b c\na : α\n⊢ LT.lt (HMul.hMul b a) (HMul.hMul c a)","decl":"@[to_additive (attr := gcongr) add_lt_add_right]\ntheorem mul_lt_mul_right' [i : MulRightStrictMono α] {b c : α} (bc : b < c)\n    (a : α) :\n    b * a < c * a :=\n  i.elim a bc\n\n"}
{"name":"lt_of_mul_lt_mul_right'","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Mul α\ninst✝ : LT α\ni : MulRightReflectLT α\na b c : α\nbc : LT.lt (HMul.hMul b a) (HMul.hMul c a)\n⊢ LT.lt b c","decl":"@[to_additive lt_of_add_lt_add_right]\ntheorem lt_of_mul_lt_mul_right' [i : MulRightReflectLT α] {a b c : α}\n    (bc : b * a < c * a) :\n    b < c :=\n  i.elim a bc\n\n"}
{"name":"lt_of_add_lt_add_right","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Add α\ninst✝ : LT α\ni : AddRightReflectLT α\na b c : α\nbc : LT.lt (HAdd.hAdd b a) (HAdd.hAdd c a)\n⊢ LT.lt b c","decl":"@[to_additive lt_of_add_lt_add_right]\ntheorem lt_of_mul_lt_mul_right' [i : MulRightReflectLT α] {a b c : α}\n    (bc : b * a < c * a) :\n    b < c :=\n  i.elim a bc\n\n"}
{"name":"add_left_mono","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : Add α\ninst✝¹ : Preorder α\ninst✝ : AddLeftMono α\na : α\n⊢ Monotone fun x => HAdd.hAdd a x","decl":"@[to_additive]\nlemma mul_left_mono [MulLeftMono α] {a : α} : Monotone (a * ·) :=\n  fun _ _ h ↦ mul_le_mul_left' h _\n\n"}
{"name":"mul_left_mono","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : Mul α\ninst✝¹ : Preorder α\ninst✝ : MulLeftMono α\na : α\n⊢ Monotone fun x => HMul.hMul a x","decl":"@[to_additive]\nlemma mul_left_mono [MulLeftMono α] {a : α} : Monotone (a * ·) :=\n  fun _ _ h ↦ mul_le_mul_left' h _\n\n"}
{"name":"mul_right_mono","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : Mul α\ninst✝¹ : Preorder α\ninst✝ : MulRightMono α\na : α\n⊢ Monotone fun x => HMul.hMul x a","decl":"@[to_additive]\nlemma mul_right_mono [MulRightMono α] {a : α} : Monotone (· * a) :=\n  fun _ _ h ↦ mul_le_mul_right' h _\n\n"}
{"name":"add_right_mono","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : Add α\ninst✝¹ : Preorder α\ninst✝ : AddRightMono α\na : α\n⊢ Monotone fun x => HAdd.hAdd x a","decl":"@[to_additive]\nlemma mul_right_mono [MulRightMono α] {a : α} : Monotone (· * a) :=\n  fun _ _ h ↦ mul_le_mul_right' h _\n\n"}
{"name":"add_left_strictMono","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : Add α\ninst✝¹ : Preorder α\ninst✝ : AddLeftStrictMono α\na : α\n⊢ StrictMono fun x => HAdd.hAdd a x","decl":"@[to_additive]\nlemma mul_left_strictMono [MulLeftStrictMono α] {a : α} : StrictMono (a * ·) :=\n  fun _ _ h ↦ mul_lt_mul_left' h _\n\n"}
{"name":"mul_left_strictMono","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : Mul α\ninst✝¹ : Preorder α\ninst✝ : MulLeftStrictMono α\na : α\n⊢ StrictMono fun x => HMul.hMul a x","decl":"@[to_additive]\nlemma mul_left_strictMono [MulLeftStrictMono α] {a : α} : StrictMono (a * ·) :=\n  fun _ _ h ↦ mul_lt_mul_left' h _\n\n"}
{"name":"mul_right_strictMono","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : Mul α\ninst✝¹ : Preorder α\ninst✝ : MulRightStrictMono α\na : α\n⊢ StrictMono fun x => HMul.hMul x a","decl":"@[to_additive]\nlemma mul_right_strictMono [MulRightStrictMono α] {a : α} : StrictMono (· * a) :=\n  fun _ _ h ↦ mul_lt_mul_right' h _\n\n"}
{"name":"add_right_strictMono","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : Add α\ninst✝¹ : Preorder α\ninst✝ : AddRightStrictMono α\na : α\n⊢ StrictMono fun x => HAdd.hAdd x a","decl":"@[to_additive]\nlemma mul_right_strictMono [MulRightStrictMono α] {a : α} : StrictMono (· * a) :=\n  fun _ _ h ↦ mul_lt_mul_right' h _\n\n"}
{"name":"mul_lt_mul_of_lt_of_lt","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝³ : Mul α\ninst✝² : Preorder α\ninst✝¹ : MulLeftStrictMono α\ninst✝ : MulRightStrictMono α\na b c d : α\nh₁ : LT.lt a b\nh₂ : LT.lt c d\n⊢ LT.lt (HMul.hMul a c) (HMul.hMul b d)","decl":"@[to_additive (attr := gcongr)]\ntheorem mul_lt_mul_of_lt_of_lt [MulLeftStrictMono α]\n    [MulRightStrictMono α]\n    {a b c d : α} (h₁ : a < b) (h₂ : c < d) : a * c < b * d :=\n  calc\n    a * c < a * d := mul_lt_mul_left' h₂ a\n    _ < b * d := mul_lt_mul_right' h₁ d\n\n"}
{"name":"add_lt_add_of_lt_of_lt","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝³ : Add α\ninst✝² : Preorder α\ninst✝¹ : AddLeftStrictMono α\ninst✝ : AddRightStrictMono α\na b c d : α\nh₁ : LT.lt a b\nh₂ : LT.lt c d\n⊢ LT.lt (HAdd.hAdd a c) (HAdd.hAdd b d)","decl":"@[to_additive (attr := gcongr)]\ntheorem mul_lt_mul_of_lt_of_lt [MulLeftStrictMono α]\n    [MulRightStrictMono α]\n    {a b c d : α} (h₁ : a < b) (h₂ : c < d) : a * c < b * d :=\n  calc\n    a * c < a * d := mul_lt_mul_left' h₂ a\n    _ < b * d := mul_lt_mul_right' h₁ d\n\n"}
{"name":"add_lt_add","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝³ : Add α\ninst✝² : Preorder α\ninst✝¹ : AddLeftStrictMono α\ninst✝ : AddRightStrictMono α\na b c d : α\nh₁ : LT.lt a b\nh₂ : LT.lt c d\n⊢ LT.lt (HAdd.hAdd a c) (HAdd.hAdd b d)","decl":"alias add_lt_add := add_lt_add_of_lt_of_lt\n\n"}
{"name":"add_lt_add_of_le_of_lt","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝³ : Add α\ninst✝² : Preorder α\ninst✝¹ : AddLeftStrictMono α\ninst✝ : AddRightMono α\na b c d : α\nh₁ : LE.le a b\nh₂ : LT.lt c d\n⊢ LT.lt (HAdd.hAdd a c) (HAdd.hAdd b d)","decl":"@[to_additive]\ntheorem mul_lt_mul_of_le_of_lt [MulLeftStrictMono α]\n    [MulRightMono α] {a b c d : α} (h₁ : a ≤ b) (h₂ : c < d) :\n    a * c < b * d :=\n  (mul_le_mul_right' h₁ _).trans_lt (mul_lt_mul_left' h₂ b)\n\n"}
{"name":"mul_lt_mul_of_le_of_lt","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝³ : Mul α\ninst✝² : Preorder α\ninst✝¹ : MulLeftStrictMono α\ninst✝ : MulRightMono α\na b c d : α\nh₁ : LE.le a b\nh₂ : LT.lt c d\n⊢ LT.lt (HMul.hMul a c) (HMul.hMul b d)","decl":"@[to_additive]\ntheorem mul_lt_mul_of_le_of_lt [MulLeftStrictMono α]\n    [MulRightMono α] {a b c d : α} (h₁ : a ≤ b) (h₂ : c < d) :\n    a * c < b * d :=\n  (mul_le_mul_right' h₁ _).trans_lt (mul_lt_mul_left' h₂ b)\n\n"}
{"name":"mul_lt_mul_of_lt_of_le","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝³ : Mul α\ninst✝² : Preorder α\ninst✝¹ : MulLeftMono α\ninst✝ : MulRightStrictMono α\na b c d : α\nh₁ : LT.lt a b\nh₂ : LE.le c d\n⊢ LT.lt (HMul.hMul a c) (HMul.hMul b d)","decl":"@[to_additive]\ntheorem mul_lt_mul_of_lt_of_le [MulLeftMono α]\n    [MulRightStrictMono α] {a b c d : α} (h₁ : a < b) (h₂ : c ≤ d) :\n    a * c < b * d :=\n  (mul_le_mul_left' h₂ _).trans_lt (mul_lt_mul_right' h₁ d)\n\n"}
{"name":"add_lt_add_of_lt_of_le","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝³ : Add α\ninst✝² : Preorder α\ninst✝¹ : AddLeftMono α\ninst✝ : AddRightStrictMono α\na b c d : α\nh₁ : LT.lt a b\nh₂ : LE.le c d\n⊢ LT.lt (HAdd.hAdd a c) (HAdd.hAdd b d)","decl":"@[to_additive]\ntheorem mul_lt_mul_of_lt_of_le [MulLeftMono α]\n    [MulRightStrictMono α] {a b c d : α} (h₁ : a < b) (h₂ : c ≤ d) :\n    a * c < b * d :=\n  (mul_le_mul_left' h₂ _).trans_lt (mul_lt_mul_right' h₁ d)\n\n"}
{"name":"Left.add_lt_add","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝³ : Add α\ninst✝² : Preorder α\ninst✝¹ : AddLeftStrictMono α\ninst✝ : AddRightMono α\na b c d : α\nh₁ : LT.lt a b\nh₂ : LT.lt c d\n⊢ LT.lt (HAdd.hAdd a c) (HAdd.hAdd b d)","decl":"/-- Only assumes left strict covariance. -/\n@[to_additive \"Only assumes left strict covariance\"]\ntheorem Left.mul_lt_mul [MulLeftStrictMono α]\n    [MulRightMono α] {a b c d : α} (h₁ : a < b) (h₂ : c < d) :\n    a * c < b * d :=\n  mul_lt_mul_of_le_of_lt h₁.le h₂\n\n"}
{"name":"Left.mul_lt_mul","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝³ : Mul α\ninst✝² : Preorder α\ninst✝¹ : MulLeftStrictMono α\ninst✝ : MulRightMono α\na b c d : α\nh₁ : LT.lt a b\nh₂ : LT.lt c d\n⊢ LT.lt (HMul.hMul a c) (HMul.hMul b d)","decl":"/-- Only assumes left strict covariance. -/\n@[to_additive \"Only assumes left strict covariance\"]\ntheorem Left.mul_lt_mul [MulLeftStrictMono α]\n    [MulRightMono α] {a b c d : α} (h₁ : a < b) (h₂ : c < d) :\n    a * c < b * d :=\n  mul_lt_mul_of_le_of_lt h₁.le h₂\n\n"}
{"name":"Right.add_lt_add","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝³ : Add α\ninst✝² : Preorder α\ninst✝¹ : AddLeftMono α\ninst✝ : AddRightStrictMono α\na b c d : α\nh₁ : LT.lt a b\nh₂ : LT.lt c d\n⊢ LT.lt (HAdd.hAdd a c) (HAdd.hAdd b d)","decl":"/-- Only assumes right strict covariance. -/\n@[to_additive \"Only assumes right strict covariance\"]\ntheorem Right.mul_lt_mul [MulLeftMono α]\n    [MulRightStrictMono α] {a b c d : α}\n    (h₁ : a < b) (h₂ : c < d) :\n    a * c < b * d :=\n  mul_lt_mul_of_lt_of_le h₁ h₂.le\n\n"}
{"name":"Right.mul_lt_mul","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝³ : Mul α\ninst✝² : Preorder α\ninst✝¹ : MulLeftMono α\ninst✝ : MulRightStrictMono α\na b c d : α\nh₁ : LT.lt a b\nh₂ : LT.lt c d\n⊢ LT.lt (HMul.hMul a c) (HMul.hMul b d)","decl":"/-- Only assumes right strict covariance. -/\n@[to_additive \"Only assumes right strict covariance\"]\ntheorem Right.mul_lt_mul [MulLeftMono α]\n    [MulRightStrictMono α] {a b c d : α}\n    (h₁ : a < b) (h₂ : c < d) :\n    a * c < b * d :=\n  mul_lt_mul_of_lt_of_le h₁ h₂.le\n\n"}
{"name":"add_le_add","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝³ : Add α\ninst✝² : Preorder α\ninst✝¹ : AddLeftMono α\ninst✝ : AddRightMono α\na b c d : α\nh₁ : LE.le a b\nh₂ : LE.le c d\n⊢ LE.le (HAdd.hAdd a c) (HAdd.hAdd b d)","decl":"@[to_additive (attr := gcongr) add_le_add]\ntheorem mul_le_mul' [MulLeftMono α] [MulRightMono α]\n    {a b c d : α} (h₁ : a ≤ b) (h₂ : c ≤ d) :\n    a * c ≤ b * d :=\n  (mul_le_mul_left' h₂ _).trans (mul_le_mul_right' h₁ d)\n\n"}
{"name":"mul_le_mul'","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝³ : Mul α\ninst✝² : Preorder α\ninst✝¹ : MulLeftMono α\ninst✝ : MulRightMono α\na b c d : α\nh₁ : LE.le a b\nh₂ : LE.le c d\n⊢ LE.le (HMul.hMul a c) (HMul.hMul b d)","decl":"@[to_additive (attr := gcongr) add_le_add]\ntheorem mul_le_mul' [MulLeftMono α] [MulRightMono α]\n    {a b c d : α} (h₁ : a ≤ b) (h₂ : c ≤ d) :\n    a * c ≤ b * d :=\n  (mul_le_mul_left' h₂ _).trans (mul_le_mul_right' h₁ d)\n\n"}
{"name":"add_le_add_three","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝³ : Add α\ninst✝² : Preorder α\ninst✝¹ : AddLeftMono α\ninst✝ : AddRightMono α\na b c d e f : α\nh₁ : LE.le a d\nh₂ : LE.le b e\nh₃ : LE.le c f\n⊢ LE.le (HAdd.hAdd (HAdd.hAdd a b) c) (HAdd.hAdd (HAdd.hAdd d e) f)","decl":"@[to_additive]\ntheorem mul_le_mul_three [MulLeftMono α]\n    [MulRightMono α] {a b c d e f : α} (h₁ : a ≤ d) (h₂ : b ≤ e)\n    (h₃ : c ≤ f) :\n    a * b * c ≤ d * e * f :=\n  mul_le_mul' (mul_le_mul' h₁ h₂) h₃\n\n"}
{"name":"mul_le_mul_three","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝³ : Mul α\ninst✝² : Preorder α\ninst✝¹ : MulLeftMono α\ninst✝ : MulRightMono α\na b c d e f : α\nh₁ : LE.le a d\nh₂ : LE.le b e\nh₃ : LE.le c f\n⊢ LE.le (HMul.hMul (HMul.hMul a b) c) (HMul.hMul (HMul.hMul d e) f)","decl":"@[to_additive]\ntheorem mul_le_mul_three [MulLeftMono α]\n    [MulRightMono α] {a b c d e f : α} (h₁ : a ≤ d) (h₂ : b ≤ e)\n    (h₃ : c ≤ f) :\n    a * b * c ≤ d * e * f :=\n  mul_le_mul' (mul_le_mul' h₁ h₂) h₃\n\n"}
{"name":"add_lt_of_add_lt_left","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : Add α\ninst✝¹ : Preorder α\ninst✝ : AddLeftMono α\na b c d : α\nh : LT.lt (HAdd.hAdd a b) c\nhle : LE.le d b\n⊢ LT.lt (HAdd.hAdd a d) c","decl":"@[to_additive]\ntheorem mul_lt_of_mul_lt_left [MulLeftMono α] {a b c d : α} (h : a * b < c)\n    (hle : d ≤ b) :\n    a * d < c :=\n  (mul_le_mul_left' hle a).trans_lt h\n\n"}
{"name":"mul_lt_of_mul_lt_left","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : Mul α\ninst✝¹ : Preorder α\ninst✝ : MulLeftMono α\na b c d : α\nh : LT.lt (HMul.hMul a b) c\nhle : LE.le d b\n⊢ LT.lt (HMul.hMul a d) c","decl":"@[to_additive]\ntheorem mul_lt_of_mul_lt_left [MulLeftMono α] {a b c d : α} (h : a * b < c)\n    (hle : d ≤ b) :\n    a * d < c :=\n  (mul_le_mul_left' hle a).trans_lt h\n\n"}
{"name":"add_le_of_add_le_left","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : Add α\ninst✝¹ : Preorder α\ninst✝ : AddLeftMono α\na b c d : α\nh : LE.le (HAdd.hAdd a b) c\nhle : LE.le d b\n⊢ LE.le (HAdd.hAdd a d) c","decl":"@[to_additive]\ntheorem mul_le_of_mul_le_left [MulLeftMono α] {a b c d : α} (h : a * b ≤ c)\n    (hle : d ≤ b) :\n    a * d ≤ c :=\n  @act_rel_of_rel_of_act_rel _ _ _ (· ≤ ·) _ _ a _ _ _ hle h\n\n"}
{"name":"mul_le_of_mul_le_left","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : Mul α\ninst✝¹ : Preorder α\ninst✝ : MulLeftMono α\na b c d : α\nh : LE.le (HMul.hMul a b) c\nhle : LE.le d b\n⊢ LE.le (HMul.hMul a d) c","decl":"@[to_additive]\ntheorem mul_le_of_mul_le_left [MulLeftMono α] {a b c d : α} (h : a * b ≤ c)\n    (hle : d ≤ b) :\n    a * d ≤ c :=\n  @act_rel_of_rel_of_act_rel _ _ _ (· ≤ ·) _ _ a _ _ _ hle h\n\n"}
{"name":"add_lt_of_add_lt_right","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : Add α\ninst✝¹ : Preorder α\ninst✝ : AddRightMono α\na b c d : α\nh : LT.lt (HAdd.hAdd a b) c\nhle : LE.le d a\n⊢ LT.lt (HAdd.hAdd d b) c","decl":"@[to_additive]\ntheorem mul_lt_of_mul_lt_right [MulRightMono α] {a b c d : α}\n    (h : a * b < c) (hle : d ≤ a) :\n    d * b < c :=\n  (mul_le_mul_right' hle b).trans_lt h\n\n"}
{"name":"mul_lt_of_mul_lt_right","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : Mul α\ninst✝¹ : Preorder α\ninst✝ : MulRightMono α\na b c d : α\nh : LT.lt (HMul.hMul a b) c\nhle : LE.le d a\n⊢ LT.lt (HMul.hMul d b) c","decl":"@[to_additive]\ntheorem mul_lt_of_mul_lt_right [MulRightMono α] {a b c d : α}\n    (h : a * b < c) (hle : d ≤ a) :\n    d * b < c :=\n  (mul_le_mul_right' hle b).trans_lt h\n\n"}
{"name":"add_le_of_add_le_right","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : Add α\ninst✝¹ : Preorder α\ninst✝ : AddRightMono α\na b c d : α\nh : LE.le (HAdd.hAdd a b) c\nhle : LE.le d a\n⊢ LE.le (HAdd.hAdd d b) c","decl":"@[to_additive]\ntheorem mul_le_of_mul_le_right [MulRightMono α] {a b c d : α}\n    (h : a * b ≤ c) (hle : d ≤ a) :\n    d * b ≤ c :=\n  (mul_le_mul_right' hle b).trans h\n\n"}
{"name":"mul_le_of_mul_le_right","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : Mul α\ninst✝¹ : Preorder α\ninst✝ : MulRightMono α\na b c d : α\nh : LE.le (HMul.hMul a b) c\nhle : LE.le d a\n⊢ LE.le (HMul.hMul d b) c","decl":"@[to_additive]\ntheorem mul_le_of_mul_le_right [MulRightMono α] {a b c d : α}\n    (h : a * b ≤ c) (hle : d ≤ a) :\n    d * b ≤ c :=\n  (mul_le_mul_right' hle b).trans h\n\n"}
{"name":"lt_add_of_lt_add_left","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : Add α\ninst✝¹ : Preorder α\ninst✝ : AddLeftMono α\na b c d : α\nh : LT.lt a (HAdd.hAdd b c)\nhle : LE.le c d\n⊢ LT.lt a (HAdd.hAdd b d)","decl":"@[to_additive]\ntheorem lt_mul_of_lt_mul_left [MulLeftMono α] {a b c d : α} (h : a < b * c)\n    (hle : c ≤ d) :\n    a < b * d :=\n  h.trans_le (mul_le_mul_left' hle b)\n\n"}
{"name":"lt_mul_of_lt_mul_left","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : Mul α\ninst✝¹ : Preorder α\ninst✝ : MulLeftMono α\na b c d : α\nh : LT.lt a (HMul.hMul b c)\nhle : LE.le c d\n⊢ LT.lt a (HMul.hMul b d)","decl":"@[to_additive]\ntheorem lt_mul_of_lt_mul_left [MulLeftMono α] {a b c d : α} (h : a < b * c)\n    (hle : c ≤ d) :\n    a < b * d :=\n  h.trans_le (mul_le_mul_left' hle b)\n\n"}
{"name":"le_mul_of_le_mul_left","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : Mul α\ninst✝¹ : Preorder α\ninst✝ : MulLeftMono α\na b c d : α\nh : LE.le a (HMul.hMul b c)\nhle : LE.le c d\n⊢ LE.le a (HMul.hMul b d)","decl":"@[to_additive]\ntheorem le_mul_of_le_mul_left [MulLeftMono α] {a b c d : α} (h : a ≤ b * c)\n    (hle : c ≤ d) :\n    a ≤ b * d :=\n  @rel_act_of_rel_of_rel_act _ _ _ (· ≤ ·) _ _ b _ _ _ hle h\n\n"}
{"name":"le_add_of_le_add_left","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : Add α\ninst✝¹ : Preorder α\ninst✝ : AddLeftMono α\na b c d : α\nh : LE.le a (HAdd.hAdd b c)\nhle : LE.le c d\n⊢ LE.le a (HAdd.hAdd b d)","decl":"@[to_additive]\ntheorem le_mul_of_le_mul_left [MulLeftMono α] {a b c d : α} (h : a ≤ b * c)\n    (hle : c ≤ d) :\n    a ≤ b * d :=\n  @rel_act_of_rel_of_rel_act _ _ _ (· ≤ ·) _ _ b _ _ _ hle h\n\n"}
{"name":"lt_mul_of_lt_mul_right","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : Mul α\ninst✝¹ : Preorder α\ninst✝ : MulRightMono α\na b c d : α\nh : LT.lt a (HMul.hMul b c)\nhle : LE.le b d\n⊢ LT.lt a (HMul.hMul d c)","decl":"@[to_additive]\ntheorem lt_mul_of_lt_mul_right [MulRightMono α] {a b c d : α}\n    (h : a < b * c) (hle : b ≤ d) :\n    a < d * c :=\n  h.trans_le (mul_le_mul_right' hle c)\n\n"}
{"name":"lt_add_of_lt_add_right","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : Add α\ninst✝¹ : Preorder α\ninst✝ : AddRightMono α\na b c d : α\nh : LT.lt a (HAdd.hAdd b c)\nhle : LE.le b d\n⊢ LT.lt a (HAdd.hAdd d c)","decl":"@[to_additive]\ntheorem lt_mul_of_lt_mul_right [MulRightMono α] {a b c d : α}\n    (h : a < b * c) (hle : b ≤ d) :\n    a < d * c :=\n  h.trans_le (mul_le_mul_right' hle c)\n\n"}
{"name":"le_mul_of_le_mul_right","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : Mul α\ninst✝¹ : Preorder α\ninst✝ : MulRightMono α\na b c d : α\nh : LE.le a (HMul.hMul b c)\nhle : LE.le b d\n⊢ LE.le a (HMul.hMul d c)","decl":"@[to_additive]\ntheorem le_mul_of_le_mul_right [MulRightMono α] {a b c d : α}\n    (h : a ≤ b * c) (hle : b ≤ d) :\n    a ≤ d * c :=\n  h.trans (mul_le_mul_right' hle c)\n\n"}
{"name":"le_add_of_le_add_right","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : Add α\ninst✝¹ : Preorder α\ninst✝ : AddRightMono α\na b c d : α\nh : LE.le a (HAdd.hAdd b c)\nhle : LE.le b d\n⊢ LE.le a (HAdd.hAdd d c)","decl":"@[to_additive]\ntheorem le_mul_of_le_mul_right [MulRightMono α] {a b c d : α}\n    (h : a ≤ b * c) (hle : b ≤ d) :\n    a ≤ d * c :=\n  h.trans (mul_le_mul_right' hle c)\n\n"}
{"name":"add_left_cancel''","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : Add α\ninst✝¹ : PartialOrder α\ninst✝ : AddLeftReflectLE α\na b c : α\nh : Eq (HAdd.hAdd a b) (HAdd.hAdd a c)\n⊢ Eq b c","decl":"@[to_additive]\ntheorem mul_left_cancel'' [MulLeftReflectLE α] {a b c : α} (h : a * b = a * c) :\n    b = c :=\n  (le_of_mul_le_mul_left' h.le).antisymm (le_of_mul_le_mul_left' h.ge)\n\n"}
{"name":"mul_left_cancel''","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : Mul α\ninst✝¹ : PartialOrder α\ninst✝ : MulLeftReflectLE α\na b c : α\nh : Eq (HMul.hMul a b) (HMul.hMul a c)\n⊢ Eq b c","decl":"@[to_additive]\ntheorem mul_left_cancel'' [MulLeftReflectLE α] {a b c : α} (h : a * b = a * c) :\n    b = c :=\n  (le_of_mul_le_mul_left' h.le).antisymm (le_of_mul_le_mul_left' h.ge)\n\n"}
{"name":"mul_right_cancel''","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : Mul α\ninst✝¹ : PartialOrder α\ninst✝ : MulRightReflectLE α\na b c : α\nh : Eq (HMul.hMul a b) (HMul.hMul c b)\n⊢ Eq a c","decl":"@[to_additive]\ntheorem mul_right_cancel'' [MulRightReflectLE α] {a b c : α}\n    (h : a * b = c * b) :\n    a = c :=\n  (le_of_mul_le_mul_right' h.le).antisymm (le_of_mul_le_mul_right' h.ge)\n\n"}
{"name":"add_right_cancel''","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : Add α\ninst✝¹ : PartialOrder α\ninst✝ : AddRightReflectLE α\na b c : α\nh : Eq (HAdd.hAdd a b) (HAdd.hAdd c b)\n⊢ Eq a c","decl":"@[to_additive]\ntheorem mul_right_cancel'' [MulRightReflectLE α] {a b c : α}\n    (h : a * b = c * b) :\n    a = c :=\n  (le_of_mul_le_mul_right' h.le).antisymm (le_of_mul_le_mul_right' h.ge)\n\n"}
{"name":"mul_le_mul_iff_of_ge","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝³ : Mul α\ninst✝² : PartialOrder α\ninst✝¹ : MulLeftStrictMono α\ninst✝ : MulRightStrictMono α\na₁ a₂ b₁ b₂ : α\nha : LE.le a₁ a₂\nhb : LE.le b₁ b₂\n⊢ Iff (LE.le (HMul.hMul a₂ b₂) (HMul.hMul a₁ b₁)) (And (Eq a₁ a₂) (Eq b₁ b₂))","decl":"@[to_additive] lemma mul_le_mul_iff_of_ge [MulLeftStrictMono α]\n    [MulRightStrictMono α] {a₁ a₂ b₁ b₂ : α} (ha : a₁ ≤ a₂) (hb : b₁ ≤ b₂) :\n    a₂ * b₂ ≤ a₁ * b₁ ↔ a₁ = a₂ ∧ b₁ = b₂ := by\n  haveI := mulLeftMono_of_mulLeftStrictMono α\n  haveI := mulRightMono_of_mulRightStrictMono α\n  refine ⟨fun h ↦ ?_, by rintro ⟨rfl, rfl⟩; rfl⟩\n  simp only [eq_iff_le_not_lt, ha, hb, true_and]\n  refine ⟨fun ha ↦ h.not_lt ?_, fun hb ↦ h.not_lt ?_⟩\n  exacts [mul_lt_mul_of_lt_of_le ha hb, mul_lt_mul_of_le_of_lt ha hb]\n\n"}
{"name":"add_le_add_iff_of_ge","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝³ : Add α\ninst✝² : PartialOrder α\ninst✝¹ : AddLeftStrictMono α\ninst✝ : AddRightStrictMono α\na₁ a₂ b₁ b₂ : α\nha : LE.le a₁ a₂\nhb : LE.le b₁ b₂\n⊢ Iff (LE.le (HAdd.hAdd a₂ b₂) (HAdd.hAdd a₁ b₁)) (And (Eq a₁ a₂) (Eq b₁ b₂))","decl":"@[to_additive] lemma mul_le_mul_iff_of_ge [MulLeftStrictMono α]\n    [MulRightStrictMono α] {a₁ a₂ b₁ b₂ : α} (ha : a₁ ≤ a₂) (hb : b₁ ≤ b₂) :\n    a₂ * b₂ ≤ a₁ * b₁ ↔ a₁ = a₂ ∧ b₁ = b₂ := by\n  haveI := mulLeftMono_of_mulLeftStrictMono α\n  haveI := mulRightMono_of_mulRightStrictMono α\n  refine ⟨fun h ↦ ?_, by rintro ⟨rfl, rfl⟩; rfl⟩\n  simp only [eq_iff_le_not_lt, ha, hb, true_and]\n  refine ⟨fun ha ↦ h.not_lt ?_, fun hb ↦ h.not_lt ?_⟩\n  exacts [mul_lt_mul_of_lt_of_le ha hb, mul_lt_mul_of_le_of_lt ha hb]\n\n"}
{"name":"mul_eq_mul_iff_eq_and_eq","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝³ : Mul α\ninst✝² : PartialOrder α\ninst✝¹ : MulLeftStrictMono α\ninst✝ : MulRightStrictMono α\na b c d : α\nhac : LE.le a c\nhbd : LE.le b d\n⊢ Iff (Eq (HMul.hMul a b) (HMul.hMul c d)) (And (Eq a c) (Eq b d))","decl":"@[to_additive] theorem mul_eq_mul_iff_eq_and_eq [MulLeftStrictMono α]\n    [MulRightStrictMono α] {a b c d : α} (hac : a ≤ c) (hbd : b ≤ d) :\n    a * b = c * d ↔ a = c ∧ b = d := by\n  haveI := mulLeftMono_of_mulLeftStrictMono α\n  haveI := mulRightMono_of_mulRightStrictMono α\n  rw [le_antisymm_iff, eq_true (mul_le_mul' hac hbd), true_and, mul_le_mul_iff_of_ge hac hbd]\n\n"}
{"name":"add_eq_add_iff_eq_and_eq","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝³ : Add α\ninst✝² : PartialOrder α\ninst✝¹ : AddLeftStrictMono α\ninst✝ : AddRightStrictMono α\na b c d : α\nhac : LE.le a c\nhbd : LE.le b d\n⊢ Iff (Eq (HAdd.hAdd a b) (HAdd.hAdd c d)) (And (Eq a c) (Eq b d))","decl":"@[to_additive] theorem mul_eq_mul_iff_eq_and_eq [MulLeftStrictMono α]\n    [MulRightStrictMono α] {a b c d : α} (hac : a ≤ c) (hbd : b ≤ d) :\n    a * b = c * d ↔ a = c ∧ b = d := by\n  haveI := mulLeftMono_of_mulLeftStrictMono α\n  haveI := mulRightMono_of_mulRightStrictMono α\n  rw [le_antisymm_iff, eq_true (mul_le_mul' hac hbd), true_and, mul_le_mul_iff_of_ge hac hbd]\n\n"}
{"name":"add_left_inj_of_comparable","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : Add α\ninst✝¹ : PartialOrder α\ninst✝ : AddRightStrictMono α\na b c : α\nh : Or (LE.le b c) (LE.le c b)\n⊢ Iff (Eq (HAdd.hAdd c a) (HAdd.hAdd b a)) (Eq c b)","decl":"@[to_additive]\nlemma mul_left_inj_of_comparable [MulRightStrictMono α] {a b c : α} (h : b ≤ c ∨ c ≤ b) :\n    c * a = b * a ↔ c = b := by\n  refine ⟨fun h' => ?_, (· ▸ rfl)⟩\n  contrapose h'\n  obtain h | h := h\n  · exact mul_lt_mul_right' (h.lt_of_ne' h') a |>.ne'\n  · exact mul_lt_mul_right' (h.lt_of_ne h') a |>.ne\n\n"}
{"name":"mul_left_inj_of_comparable","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : Mul α\ninst✝¹ : PartialOrder α\ninst✝ : MulRightStrictMono α\na b c : α\nh : Or (LE.le b c) (LE.le c b)\n⊢ Iff (Eq (HMul.hMul c a) (HMul.hMul b a)) (Eq c b)","decl":"@[to_additive]\nlemma mul_left_inj_of_comparable [MulRightStrictMono α] {a b c : α} (h : b ≤ c ∨ c ≤ b) :\n    c * a = b * a ↔ c = b := by\n  refine ⟨fun h' => ?_, (· ▸ rfl)⟩\n  contrapose h'\n  obtain h | h := h\n  · exact mul_lt_mul_right' (h.lt_of_ne' h') a |>.ne'\n  · exact mul_lt_mul_right' (h.lt_of_ne h') a |>.ne\n\n"}
{"name":"add_right_inj_of_comparable","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : Add α\ninst✝¹ : PartialOrder α\ninst✝ : AddLeftStrictMono α\na b c : α\nh : Or (LE.le b c) (LE.le c b)\n⊢ Iff (Eq (HAdd.hAdd a c) (HAdd.hAdd a b)) (Eq c b)","decl":"@[to_additive]\nlemma mul_right_inj_of_comparable [MulLeftStrictMono α] {a b c : α} (h : b ≤ c ∨ c ≤ b) :\n    a * c = a * b ↔ c = b := by\n  refine ⟨fun h' => ?_, (· ▸ rfl)⟩\n  contrapose h'\n  obtain h | h := h\n  · exact mul_lt_mul_left' (h.lt_of_ne' h') a |>.ne'\n  · exact mul_lt_mul_left' (h.lt_of_ne h') a |>.ne\n\n"}
{"name":"mul_right_inj_of_comparable","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : Mul α\ninst✝¹ : PartialOrder α\ninst✝ : MulLeftStrictMono α\na b c : α\nh : Or (LE.le b c) (LE.le c b)\n⊢ Iff (Eq (HMul.hMul a c) (HMul.hMul a b)) (Eq c b)","decl":"@[to_additive]\nlemma mul_right_inj_of_comparable [MulLeftStrictMono α] {a b c : α} (h : b ≤ c ∨ c ≤ b) :\n    a * c = a * b ↔ c = b := by\n  refine ⟨fun h' => ?_, (· ▸ rfl)⟩\n  contrapose h'\n  obtain h | h := h\n  · exact mul_lt_mul_left' (h.lt_of_ne' h') a |>.ne'\n  · exact mul_lt_mul_left' (h.lt_of_ne h') a |>.ne\n\n"}
{"name":"add_max","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : Add α\ninst✝¹ : LinearOrder α\ninst✝ : CovariantClass α α (fun x1 x2 => HAdd.hAdd x1 x2) fun x1 x2 => LE.le x1 x2\na b c : α\n⊢ Eq (HAdd.hAdd a (Max.max b c)) (Max.max (HAdd.hAdd a b) (HAdd.hAdd a c))","decl":"@[to_additive]\nlemma mul_max [CovariantClass α α (· * ·) (· ≤ ·)] (a b c : α) :\n    a * max b c = max (a * b) (a * c) := mul_left_mono.map_max\n\n"}
{"name":"mul_max","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : Mul α\ninst✝¹ : LinearOrder α\ninst✝ : CovariantClass α α (fun x1 x2 => HMul.hMul x1 x2) fun x1 x2 => LE.le x1 x2\na b c : α\n⊢ Eq (HMul.hMul a (Max.max b c)) (Max.max (HMul.hMul a b) (HMul.hMul a c))","decl":"@[to_additive]\nlemma mul_max [CovariantClass α α (· * ·) (· ≤ ·)] (a b c : α) :\n    a * max b c = max (a * b) (a * c) := mul_left_mono.map_max\n\n"}
{"name":"max_add","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : Add α\ninst✝¹ : LinearOrder α\ninst✝ : CovariantClass α α (Function.swap fun x1 x2 => HAdd.hAdd x1 x2) fun x1 x2 => LE.le x1 x2\na b c : α\n⊢ Eq (HAdd.hAdd (Max.max a b) c) (Max.max (HAdd.hAdd a c) (HAdd.hAdd b c))","decl":"@[to_additive]\nlemma max_mul [CovariantClass α α (swap (· * ·)) (· ≤ ·)] (a b c : α) :\n    max a b * c = max (a * c) (b * c) := mul_right_mono.map_max\n\n"}
{"name":"max_mul","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : Mul α\ninst✝¹ : LinearOrder α\ninst✝ : CovariantClass α α (Function.swap fun x1 x2 => HMul.hMul x1 x2) fun x1 x2 => LE.le x1 x2\na b c : α\n⊢ Eq (HMul.hMul (Max.max a b) c) (Max.max (HMul.hMul a c) (HMul.hMul b c))","decl":"@[to_additive]\nlemma max_mul [CovariantClass α α (swap (· * ·)) (· ≤ ·)] (a b c : α) :\n    max a b * c = max (a * c) (b * c) := mul_right_mono.map_max\n\n"}
{"name":"mul_min","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : Mul α\ninst✝¹ : LinearOrder α\ninst✝ : CovariantClass α α (fun x1 x2 => HMul.hMul x1 x2) fun x1 x2 => LE.le x1 x2\na b c : α\n⊢ Eq (HMul.hMul a (Min.min b c)) (Min.min (HMul.hMul a b) (HMul.hMul a c))","decl":"@[to_additive]\nlemma mul_min [CovariantClass α α (· * ·) (· ≤ ·)] (a b c : α) :\n    a * min b c = min (a * b) (a * c) := mul_left_mono.map_min\n\n"}
{"name":"add_min","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : Add α\ninst✝¹ : LinearOrder α\ninst✝ : CovariantClass α α (fun x1 x2 => HAdd.hAdd x1 x2) fun x1 x2 => LE.le x1 x2\na b c : α\n⊢ Eq (HAdd.hAdd a (Min.min b c)) (Min.min (HAdd.hAdd a b) (HAdd.hAdd a c))","decl":"@[to_additive]\nlemma mul_min [CovariantClass α α (· * ·) (· ≤ ·)] (a b c : α) :\n    a * min b c = min (a * b) (a * c) := mul_left_mono.map_min\n\n"}
{"name":"min_mul","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : Mul α\ninst✝¹ : LinearOrder α\ninst✝ : CovariantClass α α (Function.swap fun x1 x2 => HMul.hMul x1 x2) fun x1 x2 => LE.le x1 x2\na b c : α\n⊢ Eq (HMul.hMul (Min.min a b) c) (Min.min (HMul.hMul a c) (HMul.hMul b c))","decl":"@[to_additive]\nlemma min_mul [CovariantClass α α (swap (· * ·)) (· ≤ ·)] (a b c : α) :\n    min a b * c = min (a * c) (b * c) := mul_right_mono.map_min\n\n"}
{"name":"min_add","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : Add α\ninst✝¹ : LinearOrder α\ninst✝ : CovariantClass α α (Function.swap fun x1 x2 => HAdd.hAdd x1 x2) fun x1 x2 => LE.le x1 x2\na b c : α\n⊢ Eq (HAdd.hAdd (Min.min a b) c) (Min.min (HAdd.hAdd a c) (HAdd.hAdd b c))","decl":"@[to_additive]\nlemma min_mul [CovariantClass α α (swap (· * ·)) (· ≤ ·)] (a b c : α) :\n    min a b * c = min (a * c) (b * c) := mul_right_mono.map_min\n\n"}
{"name":"min_lt_max_of_mul_lt_mul","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝³ : Mul α\ninst✝² : LinearOrder α\na b c d : α\ninst✝¹ : MulLeftMono α\ninst✝ : MulRightMono α\nh : LT.lt (HMul.hMul a b) (HMul.hMul c d)\n⊢ LT.lt (Min.min a b) (Max.max c d)","decl":"@[to_additive] lemma min_lt_max_of_mul_lt_mul\n    [MulLeftMono α] [MulRightMono α]\n    (h : a * b < c * d) : min a b < max c d := by\n  simp_rw [min_lt_iff, lt_max_iff]; contrapose! h; exact mul_le_mul' h.1.1 h.2.2\n\n"}
{"name":"min_lt_max_of_add_lt_add","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝³ : Add α\ninst✝² : LinearOrder α\na b c d : α\ninst✝¹ : AddLeftMono α\ninst✝ : AddRightMono α\nh : LT.lt (HAdd.hAdd a b) (HAdd.hAdd c d)\n⊢ LT.lt (Min.min a b) (Max.max c d)","decl":"@[to_additive] lemma min_lt_max_of_mul_lt_mul\n    [MulLeftMono α] [MulRightMono α]\n    (h : a * b < c * d) : min a b < max c d := by\n  simp_rw [min_lt_iff, lt_max_iff]; contrapose! h; exact mul_le_mul' h.1.1 h.2.2\n\n"}
{"name":"Left.min_le_max_of_mul_le_mul","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝³ : Mul α\ninst✝² : LinearOrder α\na b c d : α\ninst✝¹ : MulLeftStrictMono α\ninst✝ : MulRightMono α\nh : LE.le (HMul.hMul a b) (HMul.hMul c d)\n⊢ LE.le (Min.min a b) (Max.max c d)","decl":"@[to_additive] lemma Left.min_le_max_of_mul_le_mul\n    [MulLeftStrictMono α] [MulRightMono α]\n    (h : a * b ≤ c * d) : min a b ≤ max c d := by\n  simp_rw [min_le_iff, le_max_iff]; contrapose! h; exact mul_lt_mul_of_le_of_lt h.1.1.le h.2.2\n\n"}
{"name":"Left.min_le_max_of_add_le_add","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝³ : Add α\ninst✝² : LinearOrder α\na b c d : α\ninst✝¹ : AddLeftStrictMono α\ninst✝ : AddRightMono α\nh : LE.le (HAdd.hAdd a b) (HAdd.hAdd c d)\n⊢ LE.le (Min.min a b) (Max.max c d)","decl":"@[to_additive] lemma Left.min_le_max_of_mul_le_mul\n    [MulLeftStrictMono α] [MulRightMono α]\n    (h : a * b ≤ c * d) : min a b ≤ max c d := by\n  simp_rw [min_le_iff, le_max_iff]; contrapose! h; exact mul_lt_mul_of_le_of_lt h.1.1.le h.2.2\n\n"}
{"name":"Right.min_le_max_of_add_le_add","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝³ : Add α\ninst✝² : LinearOrder α\na b c d : α\ninst✝¹ : AddLeftMono α\ninst✝ : AddRightStrictMono α\nh : LE.le (HAdd.hAdd a b) (HAdd.hAdd c d)\n⊢ LE.le (Min.min a b) (Max.max c d)","decl":"@[to_additive] lemma Right.min_le_max_of_mul_le_mul\n    [MulLeftMono α] [MulRightStrictMono α]\n    (h : a * b ≤ c * d) : min a b ≤ max c d := by\n  simp_rw [min_le_iff, le_max_iff]; contrapose! h; exact mul_lt_mul_of_lt_of_le h.1.1 h.2.2.le\n\n"}
{"name":"Right.min_le_max_of_mul_le_mul","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝³ : Mul α\ninst✝² : LinearOrder α\na b c d : α\ninst✝¹ : MulLeftMono α\ninst✝ : MulRightStrictMono α\nh : LE.le (HMul.hMul a b) (HMul.hMul c d)\n⊢ LE.le (Min.min a b) (Max.max c d)","decl":"@[to_additive] lemma Right.min_le_max_of_mul_le_mul\n    [MulLeftMono α] [MulRightStrictMono α]\n    (h : a * b ≤ c * d) : min a b ≤ max c d := by\n  simp_rw [min_le_iff, le_max_iff]; contrapose! h; exact mul_lt_mul_of_lt_of_le h.1.1 h.2.2.le\n\n"}
{"name":"min_le_max_of_add_le_add","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝³ : Add α\ninst✝² : LinearOrder α\na b c d : α\ninst✝¹ : AddLeftStrictMono α\ninst✝ : AddRightStrictMono α\nh : LE.le (HAdd.hAdd a b) (HAdd.hAdd c d)\n⊢ LE.le (Min.min a b) (Max.max c d)","decl":"@[to_additive] lemma min_le_max_of_mul_le_mul\n    [MulLeftStrictMono α] [MulRightStrictMono α]\n    (h : a * b ≤ c * d) : min a b ≤ max c d :=\n  haveI := mulRightMono_of_mulRightStrictMono α\n  Left.min_le_max_of_mul_le_mul h\n\n"}
{"name":"min_le_max_of_mul_le_mul","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝³ : Mul α\ninst✝² : LinearOrder α\na b c d : α\ninst✝¹ : MulLeftStrictMono α\ninst✝ : MulRightStrictMono α\nh : LE.le (HMul.hMul a b) (HMul.hMul c d)\n⊢ LE.le (Min.min a b) (Max.max c d)","decl":"@[to_additive] lemma min_le_max_of_mul_le_mul\n    [MulLeftStrictMono α] [MulRightStrictMono α]\n    (h : a * b ≤ c * d) : min a b ≤ max c d :=\n  haveI := mulRightMono_of_mulRightStrictMono α\n  Left.min_le_max_of_mul_le_mul h\n\n"}
{"name":"MulLeftStrictMono.toIsLeftCancelMul","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : Mul α\ninst✝¹ : LinearOrder α\ninst✝ : MulLeftStrictMono α\n⊢ IsLeftCancelMul α","decl":"/-- Not an instance, to avoid loops with `IsLeftCancelMul.mulLeftStrictMono_of_mulLeftMono`. -/\n@[to_additive]\ntheorem MulLeftStrictMono.toIsLeftCancelMul [MulLeftStrictMono α] : IsLeftCancelMul α where\n  mul_left_cancel _ _ _ h := mul_left_strictMono.injective h\n\n"}
{"name":"AddLeftStrictMono.toIsAddLeftCancel","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : Add α\ninst✝¹ : LinearOrder α\ninst✝ : AddLeftStrictMono α\n⊢ IsLeftCancelAdd α","decl":"/-- Not an instance, to avoid loops with `IsLeftCancelMul.mulLeftStrictMono_of_mulLeftMono`. -/\n@[to_additive]\ntheorem MulLeftStrictMono.toIsLeftCancelMul [MulLeftStrictMono α] : IsLeftCancelMul α where\n  mul_left_cancel _ _ _ h := mul_left_strictMono.injective h\n\n"}
{"name":"AddRightStrictMono.toIsAddRightCancel","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : Add α\ninst✝¹ : LinearOrder α\ninst✝ : AddRightStrictMono α\n⊢ IsRightCancelAdd α","decl":"/-- Not an instance, to avoid loops with `IsRightCancelMul.mulRightStrictMono_of_mulRightMono`. -/\n@[to_additive]\ntheorem MulRightStrictMono.toIsRightCancelMul [MulRightStrictMono α] : IsRightCancelMul α where\n  mul_right_cancel _ _ _ h := mul_right_strictMono.injective h\n\n"}
{"name":"MulRightStrictMono.toIsRightCancelMul","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : Mul α\ninst✝¹ : LinearOrder α\ninst✝ : MulRightStrictMono α\n⊢ IsRightCancelMul α","decl":"/-- Not an instance, to avoid loops with `IsRightCancelMul.mulRightStrictMono_of_mulRightMono`. -/\n@[to_additive]\ntheorem MulRightStrictMono.toIsRightCancelMul [MulRightStrictMono α] : IsRightCancelMul α where\n  mul_right_cancel _ _ _ h := mul_right_strictMono.injective h\n\n"}
{"name":"max_mul_mul_le_max_mul_max'","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝³ : Mul α\ninst✝² : LinearOrder α\ninst✝¹ : MulLeftMono α\ninst✝ : MulRightMono α\na b c d : α\n⊢ LE.le (Max.max (HMul.hMul a b) (HMul.hMul c d)) (HMul.hMul (Max.max a c) (Max.max b d))","decl":"@[to_additive max_add_add_le_max_add_max]\ntheorem max_mul_mul_le_max_mul_max' : max (a * b) (c * d) ≤ max a c * max b d :=\n  max_le (mul_le_mul' (le_max_left _ _) <| le_max_left _ _) <|\n    mul_le_mul' (le_max_right _ _) <| le_max_right _ _\n\n"}
{"name":"max_add_add_le_max_add_max","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝³ : Add α\ninst✝² : LinearOrder α\ninst✝¹ : AddLeftMono α\ninst✝ : AddRightMono α\na b c d : α\n⊢ LE.le (Max.max (HAdd.hAdd a b) (HAdd.hAdd c d)) (HAdd.hAdd (Max.max a c) (Max.max b d))","decl":"@[to_additive max_add_add_le_max_add_max]\ntheorem max_mul_mul_le_max_mul_max' : max (a * b) (c * d) ≤ max a c * max b d :=\n  max_le (mul_le_mul' (le_max_left _ _) <| le_max_left _ _) <|\n    mul_le_mul' (le_max_right _ _) <| le_max_right _ _\n\n"}
{"name":"min_add_min_le_min_add_add","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝³ : Add α\ninst✝² : LinearOrder α\ninst✝¹ : AddLeftMono α\ninst✝ : AddRightMono α\na b c d : α\n⊢ LE.le (HAdd.hAdd (Min.min a c) (Min.min b d)) (Min.min (HAdd.hAdd a b) (HAdd.hAdd c d))","decl":"@[to_additive min_add_min_le_min_add_add]\ntheorem min_mul_min_le_min_mul_mul' : min a c * min b d ≤ min (a * b) (c * d) :=\n  le_min (mul_le_mul' (min_le_left _ _) <| min_le_left _ _) <|\n    mul_le_mul' (min_le_right _ _) <| min_le_right _ _\n\n"}
{"name":"min_mul_min_le_min_mul_mul'","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝³ : Mul α\ninst✝² : LinearOrder α\ninst✝¹ : MulLeftMono α\ninst✝ : MulRightMono α\na b c d : α\n⊢ LE.le (HMul.hMul (Min.min a c) (Min.min b d)) (Min.min (HMul.hMul a b) (HMul.hMul c d))","decl":"@[to_additive min_add_min_le_min_add_add]\ntheorem min_mul_min_le_min_mul_mul' : min a c * min b d ≤ min (a * b) (c * d) :=\n  le_min (mul_le_mul' (min_le_left _ _) <| min_le_left _ _) <|\n    mul_le_mul' (min_le_right _ _) <| min_le_right _ _\n\n"}
{"name":"le_add_of_nonneg_right","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : AddZeroClass α\ninst✝¹ : LE α\ninst✝ : AddLeftMono α\na b : α\nh : LE.le 0 b\n⊢ LE.le a (HAdd.hAdd a b)","decl":"@[to_additive le_add_of_nonneg_right]\ntheorem le_mul_of_one_le_right' [MulLeftMono α] {a b : α} (h : 1 ≤ b) :\n    a ≤ a * b :=\n  calc\n    a = a * 1 := (mul_one a).symm\n    _ ≤ a * b := mul_le_mul_left' h a\n\n"}
{"name":"le_mul_of_one_le_right'","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : MulOneClass α\ninst✝¹ : LE α\ninst✝ : MulLeftMono α\na b : α\nh : LE.le 1 b\n⊢ LE.le a (HMul.hMul a b)","decl":"@[to_additive le_add_of_nonneg_right]\ntheorem le_mul_of_one_le_right' [MulLeftMono α] {a b : α} (h : 1 ≤ b) :\n    a ≤ a * b :=\n  calc\n    a = a * 1 := (mul_one a).symm\n    _ ≤ a * b := mul_le_mul_left' h a\n\n"}
{"name":"add_le_of_nonpos_right","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : AddZeroClass α\ninst✝¹ : LE α\ninst✝ : AddLeftMono α\na b : α\nh : LE.le b 0\n⊢ LE.le (HAdd.hAdd a b) a","decl":"@[to_additive add_le_of_nonpos_right]\ntheorem mul_le_of_le_one_right' [MulLeftMono α] {a b : α} (h : b ≤ 1) :\n    a * b ≤ a :=\n  calc\n    a * b ≤ a * 1 := mul_le_mul_left' h a\n    _ = a := mul_one a\n\n"}
{"name":"mul_le_of_le_one_right'","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : MulOneClass α\ninst✝¹ : LE α\ninst✝ : MulLeftMono α\na b : α\nh : LE.le b 1\n⊢ LE.le (HMul.hMul a b) a","decl":"@[to_additive add_le_of_nonpos_right]\ntheorem mul_le_of_le_one_right' [MulLeftMono α] {a b : α} (h : b ≤ 1) :\n    a * b ≤ a :=\n  calc\n    a * b ≤ a * 1 := mul_le_mul_left' h a\n    _ = a := mul_one a\n\n"}
{"name":"le_mul_of_one_le_left'","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : MulOneClass α\ninst✝¹ : LE α\ninst✝ : MulRightMono α\na b : α\nh : LE.le 1 b\n⊢ LE.le a (HMul.hMul b a)","decl":"@[to_additive le_add_of_nonneg_left]\ntheorem le_mul_of_one_le_left' [MulRightMono α] {a b : α} (h : 1 ≤ b) :\n    a ≤ b * a :=\n  calc\n    a = 1 * a := (one_mul a).symm\n    _ ≤ b * a := mul_le_mul_right' h a\n\n"}
{"name":"le_add_of_nonneg_left","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : AddZeroClass α\ninst✝¹ : LE α\ninst✝ : AddRightMono α\na b : α\nh : LE.le 0 b\n⊢ LE.le a (HAdd.hAdd b a)","decl":"@[to_additive le_add_of_nonneg_left]\ntheorem le_mul_of_one_le_left' [MulRightMono α] {a b : α} (h : 1 ≤ b) :\n    a ≤ b * a :=\n  calc\n    a = 1 * a := (one_mul a).symm\n    _ ≤ b * a := mul_le_mul_right' h a\n\n"}
{"name":"mul_le_of_le_one_left'","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : MulOneClass α\ninst✝¹ : LE α\ninst✝ : MulRightMono α\na b : α\nh : LE.le b 1\n⊢ LE.le (HMul.hMul b a) a","decl":"@[to_additive add_le_of_nonpos_left]\ntheorem mul_le_of_le_one_left' [MulRightMono α] {a b : α} (h : b ≤ 1) :\n    b * a ≤ a :=\n  calc\n    b * a ≤ 1 * a := mul_le_mul_right' h a\n    _ = a := one_mul a\n\n"}
{"name":"add_le_of_nonpos_left","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : AddZeroClass α\ninst✝¹ : LE α\ninst✝ : AddRightMono α\na b : α\nh : LE.le b 0\n⊢ LE.le (HAdd.hAdd b a) a","decl":"@[to_additive add_le_of_nonpos_left]\ntheorem mul_le_of_le_one_left' [MulRightMono α] {a b : α} (h : b ≤ 1) :\n    b * a ≤ a :=\n  calc\n    b * a ≤ 1 * a := mul_le_mul_right' h a\n    _ = a := one_mul a\n\n"}
{"name":"nonneg_of_le_add_right","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : AddZeroClass α\ninst✝¹ : LE α\ninst✝ : AddLeftReflectLE α\na b : α\nh : LE.le a (HAdd.hAdd a b)\n⊢ LE.le 0 b","decl":"@[to_additive]\ntheorem one_le_of_le_mul_right [MulLeftReflectLE α] {a b : α} (h : a ≤ a * b) :\n    1 ≤ b :=\n  le_of_mul_le_mul_left' (a := a) <| by simpa only [mul_one]\n\n"}
{"name":"one_le_of_le_mul_right","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : MulOneClass α\ninst✝¹ : LE α\ninst✝ : MulLeftReflectLE α\na b : α\nh : LE.le a (HMul.hMul a b)\n⊢ LE.le 1 b","decl":"@[to_additive]\ntheorem one_le_of_le_mul_right [MulLeftReflectLE α] {a b : α} (h : a ≤ a * b) :\n    1 ≤ b :=\n  le_of_mul_le_mul_left' (a := a) <| by simpa only [mul_one]\n\n"}
{"name":"nonpos_of_add_le_right","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : AddZeroClass α\ninst✝¹ : LE α\ninst✝ : AddLeftReflectLE α\na b : α\nh : LE.le (HAdd.hAdd a b) a\n⊢ LE.le b 0","decl":"@[to_additive]\ntheorem le_one_of_mul_le_right [MulLeftReflectLE α] {a b : α} (h : a * b ≤ a) :\n    b ≤ 1 :=\n  le_of_mul_le_mul_left' (a := a) <| by simpa only [mul_one]\n\n"}
{"name":"le_one_of_mul_le_right","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : MulOneClass α\ninst✝¹ : LE α\ninst✝ : MulLeftReflectLE α\na b : α\nh : LE.le (HMul.hMul a b) a\n⊢ LE.le b 1","decl":"@[to_additive]\ntheorem le_one_of_mul_le_right [MulLeftReflectLE α] {a b : α} (h : a * b ≤ a) :\n    b ≤ 1 :=\n  le_of_mul_le_mul_left' (a := a) <| by simpa only [mul_one]\n\n"}
{"name":"nonneg_of_le_add_left","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : AddZeroClass α\ninst✝¹ : LE α\ninst✝ : AddRightReflectLE α\na b : α\nh : LE.le b (HAdd.hAdd a b)\n⊢ LE.le 0 a","decl":"@[to_additive]\ntheorem one_le_of_le_mul_left [MulRightReflectLE α] {a b : α}\n    (h : b ≤ a * b) :\n    1 ≤ a :=\n  le_of_mul_le_mul_right' (a := b) <| by simpa only [one_mul]\n\n"}
{"name":"one_le_of_le_mul_left","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : MulOneClass α\ninst✝¹ : LE α\ninst✝ : MulRightReflectLE α\na b : α\nh : LE.le b (HMul.hMul a b)\n⊢ LE.le 1 a","decl":"@[to_additive]\ntheorem one_le_of_le_mul_left [MulRightReflectLE α] {a b : α}\n    (h : b ≤ a * b) :\n    1 ≤ a :=\n  le_of_mul_le_mul_right' (a := b) <| by simpa only [one_mul]\n\n"}
{"name":"le_one_of_mul_le_left","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : MulOneClass α\ninst✝¹ : LE α\ninst✝ : MulRightReflectLE α\na b : α\nh : LE.le (HMul.hMul a b) b\n⊢ LE.le a 1","decl":"@[to_additive]\ntheorem le_one_of_mul_le_left [MulRightReflectLE α] {a b : α}\n    (h : a * b ≤ b) :\n    a ≤ 1 :=\n  le_of_mul_le_mul_right' (a := b) <| by simpa only [one_mul]\n\n"}
{"name":"nonpos_of_add_le_left","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : AddZeroClass α\ninst✝¹ : LE α\ninst✝ : AddRightReflectLE α\na b : α\nh : LE.le (HAdd.hAdd a b) b\n⊢ LE.le a 0","decl":"@[to_additive]\ntheorem le_one_of_mul_le_left [MulRightReflectLE α] {a b : α}\n    (h : a * b ≤ b) :\n    a ≤ 1 :=\n  le_of_mul_le_mul_right' (a := b) <| by simpa only [one_mul]\n\n"}
{"name":"le_add_iff_nonneg_right","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝³ : AddZeroClass α\ninst✝² : LE α\ninst✝¹ : AddLeftMono α\ninst✝ : AddLeftReflectLE α\na b : α\n⊢ Iff (LE.le a (HAdd.hAdd a b)) (LE.le 0 b)","decl":"@[to_additive (attr := simp) le_add_iff_nonneg_right]\ntheorem le_mul_iff_one_le_right' [MulLeftMono α]\n    [MulLeftReflectLE α] (a : α) {b : α} :\n    a ≤ a * b ↔ 1 ≤ b :=\n  Iff.trans (by rw [mul_one]) (mul_le_mul_iff_left a)\n\n"}
{"name":"le_mul_iff_one_le_right'","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝³ : MulOneClass α\ninst✝² : LE α\ninst✝¹ : MulLeftMono α\ninst✝ : MulLeftReflectLE α\na b : α\n⊢ Iff (LE.le a (HMul.hMul a b)) (LE.le 1 b)","decl":"@[to_additive (attr := simp) le_add_iff_nonneg_right]\ntheorem le_mul_iff_one_le_right' [MulLeftMono α]\n    [MulLeftReflectLE α] (a : α) {b : α} :\n    a ≤ a * b ↔ 1 ≤ b :=\n  Iff.trans (by rw [mul_one]) (mul_le_mul_iff_left a)\n\n"}
{"name":"le_add_iff_nonneg_left","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝³ : AddZeroClass α\ninst✝² : LE α\ninst✝¹ : AddRightMono α\ninst✝ : AddRightReflectLE α\na b : α\n⊢ Iff (LE.le a (HAdd.hAdd b a)) (LE.le 0 b)","decl":"@[to_additive (attr := simp) le_add_iff_nonneg_left]\ntheorem le_mul_iff_one_le_left' [MulRightMono α]\n    [MulRightReflectLE α] (a : α) {b : α} :\n    a ≤ b * a ↔ 1 ≤ b :=\n  Iff.trans (by rw [one_mul]) (mul_le_mul_iff_right a)\n\n"}
{"name":"le_mul_iff_one_le_left'","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝³ : MulOneClass α\ninst✝² : LE α\ninst✝¹ : MulRightMono α\ninst✝ : MulRightReflectLE α\na b : α\n⊢ Iff (LE.le a (HMul.hMul b a)) (LE.le 1 b)","decl":"@[to_additive (attr := simp) le_add_iff_nonneg_left]\ntheorem le_mul_iff_one_le_left' [MulRightMono α]\n    [MulRightReflectLE α] (a : α) {b : α} :\n    a ≤ b * a ↔ 1 ≤ b :=\n  Iff.trans (by rw [one_mul]) (mul_le_mul_iff_right a)\n\n"}
{"name":"mul_le_iff_le_one_right'","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝³ : MulOneClass α\ninst✝² : LE α\ninst✝¹ : MulLeftMono α\ninst✝ : MulLeftReflectLE α\na b : α\n⊢ Iff (LE.le (HMul.hMul a b) a) (LE.le b 1)","decl":"@[to_additive (attr := simp) add_le_iff_nonpos_right]\ntheorem mul_le_iff_le_one_right' [MulLeftMono α]\n    [MulLeftReflectLE α] (a : α) {b : α} :\n    a * b ≤ a ↔ b ≤ 1 :=\n  Iff.trans (by rw [mul_one]) (mul_le_mul_iff_left a)\n\n"}
{"name":"add_le_iff_nonpos_right","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝³ : AddZeroClass α\ninst✝² : LE α\ninst✝¹ : AddLeftMono α\ninst✝ : AddLeftReflectLE α\na b : α\n⊢ Iff (LE.le (HAdd.hAdd a b) a) (LE.le b 0)","decl":"@[to_additive (attr := simp) add_le_iff_nonpos_right]\ntheorem mul_le_iff_le_one_right' [MulLeftMono α]\n    [MulLeftReflectLE α] (a : α) {b : α} :\n    a * b ≤ a ↔ b ≤ 1 :=\n  Iff.trans (by rw [mul_one]) (mul_le_mul_iff_left a)\n\n"}
{"name":"add_le_iff_nonpos_left","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝³ : AddZeroClass α\ninst✝² : LE α\ninst✝¹ : AddRightMono α\ninst✝ : AddRightReflectLE α\na b : α\n⊢ Iff (LE.le (HAdd.hAdd a b) b) (LE.le a 0)","decl":"@[to_additive (attr := simp) add_le_iff_nonpos_left]\ntheorem mul_le_iff_le_one_left' [MulRightMono α]\n    [MulRightReflectLE α] {a b : α} :\n    a * b ≤ b ↔ a ≤ 1 :=\n  Iff.trans (by rw [one_mul]) (mul_le_mul_iff_right b)\n\n"}
{"name":"mul_le_iff_le_one_left'","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝³ : MulOneClass α\ninst✝² : LE α\ninst✝¹ : MulRightMono α\ninst✝ : MulRightReflectLE α\na b : α\n⊢ Iff (LE.le (HMul.hMul a b) b) (LE.le a 1)","decl":"@[to_additive (attr := simp) add_le_iff_nonpos_left]\ntheorem mul_le_iff_le_one_left' [MulRightMono α]\n    [MulRightReflectLE α] {a b : α} :\n    a * b ≤ b ↔ a ≤ 1 :=\n  Iff.trans (by rw [one_mul]) (mul_le_mul_iff_right b)\n\n"}
{"name":"lt_add_of_pos_right","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : AddZeroClass α\ninst✝¹ : LT α\ninst✝ : AddLeftStrictMono α\na b : α\nh : LT.lt 0 b\n⊢ LT.lt a (HAdd.hAdd a b)","decl":"@[to_additive lt_add_of_pos_right]\ntheorem lt_mul_of_one_lt_right' [MulLeftStrictMono α] (a : α) {b : α} (h : 1 < b) :\n    a < a * b :=\n  calc\n    a = a * 1 := (mul_one a).symm\n    _ < a * b := mul_lt_mul_left' h a\n\n"}
{"name":"lt_mul_of_one_lt_right'","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : MulOneClass α\ninst✝¹ : LT α\ninst✝ : MulLeftStrictMono α\na b : α\nh : LT.lt 1 b\n⊢ LT.lt a (HMul.hMul a b)","decl":"@[to_additive lt_add_of_pos_right]\ntheorem lt_mul_of_one_lt_right' [MulLeftStrictMono α] (a : α) {b : α} (h : 1 < b) :\n    a < a * b :=\n  calc\n    a = a * 1 := (mul_one a).symm\n    _ < a * b := mul_lt_mul_left' h a\n\n"}
{"name":"add_lt_of_neg_right","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : AddZeroClass α\ninst✝¹ : LT α\ninst✝ : AddLeftStrictMono α\na b : α\nh : LT.lt b 0\n⊢ LT.lt (HAdd.hAdd a b) a","decl":"@[to_additive add_lt_of_neg_right]\ntheorem mul_lt_of_lt_one_right' [MulLeftStrictMono α] (a : α) {b : α} (h : b < 1) :\n    a * b < a :=\n  calc\n    a * b < a * 1 := mul_lt_mul_left' h a\n    _ = a := mul_one a\n\n"}
{"name":"mul_lt_of_lt_one_right'","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : MulOneClass α\ninst✝¹ : LT α\ninst✝ : MulLeftStrictMono α\na b : α\nh : LT.lt b 1\n⊢ LT.lt (HMul.hMul a b) a","decl":"@[to_additive add_lt_of_neg_right]\ntheorem mul_lt_of_lt_one_right' [MulLeftStrictMono α] (a : α) {b : α} (h : b < 1) :\n    a * b < a :=\n  calc\n    a * b < a * 1 := mul_lt_mul_left' h a\n    _ = a := mul_one a\n\n"}
{"name":"lt_add_of_pos_left","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : AddZeroClass α\ninst✝¹ : LT α\ninst✝ : AddRightStrictMono α\na b : α\nh : LT.lt 0 b\n⊢ LT.lt a (HAdd.hAdd b a)","decl":"@[to_additive lt_add_of_pos_left]\ntheorem lt_mul_of_one_lt_left' [MulRightStrictMono α] (a : α) {b : α}\n    (h : 1 < b) :\n    a < b * a :=\n  calc\n    a = 1 * a := (one_mul a).symm\n    _ < b * a := mul_lt_mul_right' h a\n\n"}
{"name":"lt_mul_of_one_lt_left'","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : MulOneClass α\ninst✝¹ : LT α\ninst✝ : MulRightStrictMono α\na b : α\nh : LT.lt 1 b\n⊢ LT.lt a (HMul.hMul b a)","decl":"@[to_additive lt_add_of_pos_left]\ntheorem lt_mul_of_one_lt_left' [MulRightStrictMono α] (a : α) {b : α}\n    (h : 1 < b) :\n    a < b * a :=\n  calc\n    a = 1 * a := (one_mul a).symm\n    _ < b * a := mul_lt_mul_right' h a\n\n"}
{"name":"add_lt_of_neg_left","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : AddZeroClass α\ninst✝¹ : LT α\ninst✝ : AddRightStrictMono α\na b : α\nh : LT.lt b 0\n⊢ LT.lt (HAdd.hAdd b a) a","decl":"@[to_additive add_lt_of_neg_left]\ntheorem mul_lt_of_lt_one_left' [MulRightStrictMono α] (a : α) {b : α}\n    (h : b < 1) :\n    b * a < a :=\n  calc\n    b * a < 1 * a := mul_lt_mul_right' h a\n    _ = a := one_mul a\n\n"}
{"name":"mul_lt_of_lt_one_left'","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : MulOneClass α\ninst✝¹ : LT α\ninst✝ : MulRightStrictMono α\na b : α\nh : LT.lt b 1\n⊢ LT.lt (HMul.hMul b a) a","decl":"@[to_additive add_lt_of_neg_left]\ntheorem mul_lt_of_lt_one_left' [MulRightStrictMono α] (a : α) {b : α}\n    (h : b < 1) :\n    b * a < a :=\n  calc\n    b * a < 1 * a := mul_lt_mul_right' h a\n    _ = a := one_mul a\n\n"}
{"name":"pos_of_lt_add_right","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : AddZeroClass α\ninst✝¹ : LT α\ninst✝ : AddLeftReflectLT α\na b : α\nh : LT.lt a (HAdd.hAdd a b)\n⊢ LT.lt 0 b","decl":"@[to_additive]\ntheorem one_lt_of_lt_mul_right [MulLeftReflectLT α] {a b : α} (h : a < a * b) :\n    1 < b :=\n  lt_of_mul_lt_mul_left' (a := a) <| by simpa only [mul_one]\n\n"}
{"name":"one_lt_of_lt_mul_right","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : MulOneClass α\ninst✝¹ : LT α\ninst✝ : MulLeftReflectLT α\na b : α\nh : LT.lt a (HMul.hMul a b)\n⊢ LT.lt 1 b","decl":"@[to_additive]\ntheorem one_lt_of_lt_mul_right [MulLeftReflectLT α] {a b : α} (h : a < a * b) :\n    1 < b :=\n  lt_of_mul_lt_mul_left' (a := a) <| by simpa only [mul_one]\n\n"}
{"name":"neg_of_add_lt_right","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : AddZeroClass α\ninst✝¹ : LT α\ninst✝ : AddLeftReflectLT α\na b : α\nh : LT.lt (HAdd.hAdd a b) a\n⊢ LT.lt b 0","decl":"@[to_additive]\ntheorem lt_one_of_mul_lt_right [MulLeftReflectLT α] {a b : α} (h : a * b < a) :\n    b < 1 :=\n  lt_of_mul_lt_mul_left' (a := a) <| by simpa only [mul_one]\n\n"}
{"name":"lt_one_of_mul_lt_right","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : MulOneClass α\ninst✝¹ : LT α\ninst✝ : MulLeftReflectLT α\na b : α\nh : LT.lt (HMul.hMul a b) a\n⊢ LT.lt b 1","decl":"@[to_additive]\ntheorem lt_one_of_mul_lt_right [MulLeftReflectLT α] {a b : α} (h : a * b < a) :\n    b < 1 :=\n  lt_of_mul_lt_mul_left' (a := a) <| by simpa only [mul_one]\n\n"}
{"name":"pos_of_lt_add_left","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : AddZeroClass α\ninst✝¹ : LT α\ninst✝ : AddRightReflectLT α\na b : α\nh : LT.lt b (HAdd.hAdd a b)\n⊢ LT.lt 0 a","decl":"@[to_additive]\ntheorem one_lt_of_lt_mul_left [MulRightReflectLT α] {a b : α}\n    (h : b < a * b) :\n    1 < a :=\n  lt_of_mul_lt_mul_right' (a := b) <| by simpa only [one_mul]\n\n"}
{"name":"one_lt_of_lt_mul_left","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : MulOneClass α\ninst✝¹ : LT α\ninst✝ : MulRightReflectLT α\na b : α\nh : LT.lt b (HMul.hMul a b)\n⊢ LT.lt 1 a","decl":"@[to_additive]\ntheorem one_lt_of_lt_mul_left [MulRightReflectLT α] {a b : α}\n    (h : b < a * b) :\n    1 < a :=\n  lt_of_mul_lt_mul_right' (a := b) <| by simpa only [one_mul]\n\n"}
{"name":"lt_one_of_mul_lt_left","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : MulOneClass α\ninst✝¹ : LT α\ninst✝ : MulRightReflectLT α\na b : α\nh : LT.lt (HMul.hMul a b) b\n⊢ LT.lt a 1","decl":"@[to_additive]\ntheorem lt_one_of_mul_lt_left [MulRightReflectLT α] {a b : α}\n    (h : a * b < b) :\n    a < 1 :=\n  lt_of_mul_lt_mul_right' (a := b) <| by simpa only [one_mul]\n\n"}
{"name":"neg_of_add_lt_left","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : AddZeroClass α\ninst✝¹ : LT α\ninst✝ : AddRightReflectLT α\na b : α\nh : LT.lt (HAdd.hAdd a b) b\n⊢ LT.lt a 0","decl":"@[to_additive]\ntheorem lt_one_of_mul_lt_left [MulRightReflectLT α] {a b : α}\n    (h : a * b < b) :\n    a < 1 :=\n  lt_of_mul_lt_mul_right' (a := b) <| by simpa only [one_mul]\n\n"}
{"name":"lt_mul_iff_one_lt_right'","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝³ : MulOneClass α\ninst✝² : LT α\ninst✝¹ : MulLeftStrictMono α\ninst✝ : MulLeftReflectLT α\na b : α\n⊢ Iff (LT.lt a (HMul.hMul a b)) (LT.lt 1 b)","decl":"@[to_additive (attr := simp) lt_add_iff_pos_right]\ntheorem lt_mul_iff_one_lt_right' [MulLeftStrictMono α]\n    [MulLeftReflectLT α] (a : α) {b : α} :\n    a < a * b ↔ 1 < b :=\n  Iff.trans (by rw [mul_one]) (mul_lt_mul_iff_left a)\n\n"}
{"name":"lt_add_iff_pos_right","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝³ : AddZeroClass α\ninst✝² : LT α\ninst✝¹ : AddLeftStrictMono α\ninst✝ : AddLeftReflectLT α\na b : α\n⊢ Iff (LT.lt a (HAdd.hAdd a b)) (LT.lt 0 b)","decl":"@[to_additive (attr := simp) lt_add_iff_pos_right]\ntheorem lt_mul_iff_one_lt_right' [MulLeftStrictMono α]\n    [MulLeftReflectLT α] (a : α) {b : α} :\n    a < a * b ↔ 1 < b :=\n  Iff.trans (by rw [mul_one]) (mul_lt_mul_iff_left a)\n\n"}
{"name":"lt_mul_iff_one_lt_left'","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝³ : MulOneClass α\ninst✝² : LT α\ninst✝¹ : MulRightStrictMono α\ninst✝ : MulRightReflectLT α\na b : α\n⊢ Iff (LT.lt a (HMul.hMul b a)) (LT.lt 1 b)","decl":"@[to_additive (attr := simp) lt_add_iff_pos_left]\ntheorem lt_mul_iff_one_lt_left' [MulRightStrictMono α]\n    [MulRightReflectLT α] (a : α) {b : α} : a < b * a ↔ 1 < b :=\n  Iff.trans (by rw [one_mul]) (mul_lt_mul_iff_right a)\n\n"}
{"name":"lt_add_iff_pos_left","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝³ : AddZeroClass α\ninst✝² : LT α\ninst✝¹ : AddRightStrictMono α\ninst✝ : AddRightReflectLT α\na b : α\n⊢ Iff (LT.lt a (HAdd.hAdd b a)) (LT.lt 0 b)","decl":"@[to_additive (attr := simp) lt_add_iff_pos_left]\ntheorem lt_mul_iff_one_lt_left' [MulRightStrictMono α]\n    [MulRightReflectLT α] (a : α) {b : α} : a < b * a ↔ 1 < b :=\n  Iff.trans (by rw [one_mul]) (mul_lt_mul_iff_right a)\n\n"}
{"name":"add_lt_iff_neg_left","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝³ : AddZeroClass α\ninst✝² : LT α\ninst✝¹ : AddLeftStrictMono α\ninst✝ : AddLeftReflectLT α\na b : α\n⊢ Iff (LT.lt (HAdd.hAdd a b) a) (LT.lt b 0)","decl":"@[to_additive (attr := simp) add_lt_iff_neg_left]\ntheorem mul_lt_iff_lt_one_left' [MulLeftStrictMono α]\n    [MulLeftReflectLT α] {a b : α} :\n    a * b < a ↔ b < 1 :=\n  Iff.trans (by rw [mul_one]) (mul_lt_mul_iff_left a)\n\n"}
{"name":"mul_lt_iff_lt_one_left'","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝³ : MulOneClass α\ninst✝² : LT α\ninst✝¹ : MulLeftStrictMono α\ninst✝ : MulLeftReflectLT α\na b : α\n⊢ Iff (LT.lt (HMul.hMul a b) a) (LT.lt b 1)","decl":"@[to_additive (attr := simp) add_lt_iff_neg_left]\ntheorem mul_lt_iff_lt_one_left' [MulLeftStrictMono α]\n    [MulLeftReflectLT α] {a b : α} :\n    a * b < a ↔ b < 1 :=\n  Iff.trans (by rw [mul_one]) (mul_lt_mul_iff_left a)\n\n"}
{"name":"add_lt_iff_neg_right","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝³ : AddZeroClass α\ninst✝² : LT α\ninst✝¹ : AddRightStrictMono α\ninst✝ : AddRightReflectLT α\na b : α\n⊢ Iff (LT.lt (HAdd.hAdd a b) b) (LT.lt a 0)","decl":"@[to_additive (attr := simp) add_lt_iff_neg_right]\ntheorem mul_lt_iff_lt_one_right' [MulRightStrictMono α]\n    [MulRightReflectLT α] {a : α} (b : α) : a * b < b ↔ a < 1 :=\n  Iff.trans (by rw [one_mul]) (mul_lt_mul_iff_right b)\n\n"}
{"name":"mul_lt_iff_lt_one_right'","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝³ : MulOneClass α\ninst✝² : LT α\ninst✝¹ : MulRightStrictMono α\ninst✝ : MulRightReflectLT α\na b : α\n⊢ Iff (LT.lt (HMul.hMul a b) b) (LT.lt a 1)","decl":"@[to_additive (attr := simp) add_lt_iff_neg_right]\ntheorem mul_lt_iff_lt_one_right' [MulRightStrictMono α]\n    [MulRightReflectLT α] {a : α} (b : α) : a * b < b ↔ a < 1 :=\n  Iff.trans (by rw [one_mul]) (mul_lt_mul_iff_right b)\n\n"}
{"name":"mul_le_of_le_of_le_one","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : MulOneClass α\ninst✝¹ : Preorder α\ninst✝ : MulLeftMono α\na b c : α\nhbc : LE.le b c\nha : LE.le a 1\n⊢ LE.le (HMul.hMul b a) c","decl":"@[to_additive]\ntheorem mul_le_of_le_of_le_one [MulLeftMono α] {a b c : α} (hbc : b ≤ c)\n    (ha : a ≤ 1) :\n    b * a ≤ c :=\n  calc\n    b * a ≤ b * 1 := mul_le_mul_left' ha b\n    _ = b := mul_one b\n    _ ≤ c := hbc\n\n"}
{"name":"add_le_of_le_of_nonpos","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : AddZeroClass α\ninst✝¹ : Preorder α\ninst✝ : AddLeftMono α\na b c : α\nhbc : LE.le b c\nha : LE.le a 0\n⊢ LE.le (HAdd.hAdd b a) c","decl":"@[to_additive]\ntheorem mul_le_of_le_of_le_one [MulLeftMono α] {a b c : α} (hbc : b ≤ c)\n    (ha : a ≤ 1) :\n    b * a ≤ c :=\n  calc\n    b * a ≤ b * 1 := mul_le_mul_left' ha b\n    _ = b := mul_one b\n    _ ≤ c := hbc\n\n"}
{"name":"mul_lt_of_le_of_lt_one","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : MulOneClass α\ninst✝¹ : Preorder α\ninst✝ : MulLeftStrictMono α\na b c : α\nhbc : LE.le b c\nha : LT.lt a 1\n⊢ LT.lt (HMul.hMul b a) c","decl":"@[to_additive]\ntheorem mul_lt_of_le_of_lt_one [MulLeftStrictMono α] {a b c : α} (hbc : b ≤ c)\n    (ha : a < 1) :\n    b * a < c :=\n  calc\n    b * a < b * 1 := mul_lt_mul_left' ha b\n    _ = b := mul_one b\n    _ ≤ c := hbc\n\n"}
{"name":"add_lt_of_le_of_neg","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : AddZeroClass α\ninst✝¹ : Preorder α\ninst✝ : AddLeftStrictMono α\na b c : α\nhbc : LE.le b c\nha : LT.lt a 0\n⊢ LT.lt (HAdd.hAdd b a) c","decl":"@[to_additive]\ntheorem mul_lt_of_le_of_lt_one [MulLeftStrictMono α] {a b c : α} (hbc : b ≤ c)\n    (ha : a < 1) :\n    b * a < c :=\n  calc\n    b * a < b * 1 := mul_lt_mul_left' ha b\n    _ = b := mul_one b\n    _ ≤ c := hbc\n\n"}
{"name":"add_lt_of_lt_of_nonpos","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : AddZeroClass α\ninst✝¹ : Preorder α\ninst✝ : AddLeftMono α\na b c : α\nhbc : LT.lt b c\nha : LE.le a 0\n⊢ LT.lt (HAdd.hAdd b a) c","decl":"@[to_additive]\ntheorem mul_lt_of_lt_of_le_one [MulLeftMono α] {a b c : α} (hbc : b < c)\n    (ha : a ≤ 1) :\n    b * a < c :=\n  calc\n    b * a ≤ b * 1 := mul_le_mul_left' ha b\n    _ = b := mul_one b\n    _ < c := hbc\n\n"}
{"name":"mul_lt_of_lt_of_le_one","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : MulOneClass α\ninst✝¹ : Preorder α\ninst✝ : MulLeftMono α\na b c : α\nhbc : LT.lt b c\nha : LE.le a 1\n⊢ LT.lt (HMul.hMul b a) c","decl":"@[to_additive]\ntheorem mul_lt_of_lt_of_le_one [MulLeftMono α] {a b c : α} (hbc : b < c)\n    (ha : a ≤ 1) :\n    b * a < c :=\n  calc\n    b * a ≤ b * 1 := mul_le_mul_left' ha b\n    _ = b := mul_one b\n    _ < c := hbc\n\n"}
{"name":"mul_lt_of_lt_of_lt_one","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : MulOneClass α\ninst✝¹ : Preorder α\ninst✝ : MulLeftStrictMono α\na b c : α\nhbc : LT.lt b c\nha : LT.lt a 1\n⊢ LT.lt (HMul.hMul b a) c","decl":"@[to_additive]\ntheorem mul_lt_of_lt_of_lt_one [MulLeftStrictMono α] {a b c : α} (hbc : b < c)\n    (ha : a < 1) :\n    b * a < c :=\n  calc\n    b * a < b * 1 := mul_lt_mul_left' ha b\n    _ = b := mul_one b\n    _ < c := hbc\n\n"}
{"name":"add_lt_of_lt_of_neg","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : AddZeroClass α\ninst✝¹ : Preorder α\ninst✝ : AddLeftStrictMono α\na b c : α\nhbc : LT.lt b c\nha : LT.lt a 0\n⊢ LT.lt (HAdd.hAdd b a) c","decl":"@[to_additive]\ntheorem mul_lt_of_lt_of_lt_one [MulLeftStrictMono α] {a b c : α} (hbc : b < c)\n    (ha : a < 1) :\n    b * a < c :=\n  calc\n    b * a < b * 1 := mul_lt_mul_left' ha b\n    _ = b := mul_one b\n    _ < c := hbc\n\n"}
{"name":"mul_lt_of_lt_of_lt_one'","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : MulOneClass α\ninst✝¹ : Preorder α\ninst✝ : MulLeftMono α\na b c : α\nhbc : LT.lt b c\nha : LT.lt a 1\n⊢ LT.lt (HMul.hMul b a) c","decl":"@[to_additive]\ntheorem mul_lt_of_lt_of_lt_one' [MulLeftMono α] {a b c : α} (hbc : b < c)\n    (ha : a < 1) :\n    b * a < c :=\n  mul_lt_of_lt_of_le_one hbc ha.le\n\n"}
{"name":"add_lt_of_lt_of_neg'","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : AddZeroClass α\ninst✝¹ : Preorder α\ninst✝ : AddLeftMono α\na b c : α\nhbc : LT.lt b c\nha : LT.lt a 0\n⊢ LT.lt (HAdd.hAdd b a) c","decl":"@[to_additive]\ntheorem mul_lt_of_lt_of_lt_one' [MulLeftMono α] {a b c : α} (hbc : b < c)\n    (ha : a < 1) :\n    b * a < c :=\n  mul_lt_of_lt_of_le_one hbc ha.le\n\n"}
{"name":"Left.add_nonpos","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : AddZeroClass α\ninst✝¹ : Preorder α\ninst✝ : AddLeftMono α\na b : α\nha : LE.le a 0\nhb : LE.le b 0\n⊢ LE.le (HAdd.hAdd a b) 0","decl":"/-- Assumes left covariance.\nThe lemma assuming right covariance is `Right.mul_le_one`. -/\n@[to_additive \"Assumes left covariance.\nThe lemma assuming right covariance is `Right.add_nonpos`.\"]\ntheorem Left.mul_le_one [MulLeftMono α] {a b : α} (ha : a ≤ 1) (hb : b ≤ 1) :\n    a * b ≤ 1 :=\n  mul_le_of_le_of_le_one ha hb\n\n"}
{"name":"Left.mul_le_one","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : MulOneClass α\ninst✝¹ : Preorder α\ninst✝ : MulLeftMono α\na b : α\nha : LE.le a 1\nhb : LE.le b 1\n⊢ LE.le (HMul.hMul a b) 1","decl":"/-- Assumes left covariance.\nThe lemma assuming right covariance is `Right.mul_le_one`. -/\n@[to_additive \"Assumes left covariance.\nThe lemma assuming right covariance is `Right.add_nonpos`.\"]\ntheorem Left.mul_le_one [MulLeftMono α] {a b : α} (ha : a ≤ 1) (hb : b ≤ 1) :\n    a * b ≤ 1 :=\n  mul_le_of_le_of_le_one ha hb\n\n"}
{"name":"Left.add_neg_of_nonpos_of_neg","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : AddZeroClass α\ninst✝¹ : Preorder α\ninst✝ : AddLeftStrictMono α\na b : α\nha : LE.le a 0\nhb : LT.lt b 0\n⊢ LT.lt (HAdd.hAdd a b) 0","decl":"/-- Assumes left covariance.\nThe lemma assuming right covariance is `Right.mul_lt_one_of_le_of_lt`. -/\n@[to_additive Left.add_neg_of_nonpos_of_neg\n      \"Assumes left covariance.\n      The lemma assuming right covariance is `Right.add_neg_of_nonpos_of_neg`.\"]\ntheorem Left.mul_lt_one_of_le_of_lt [MulLeftStrictMono α] {a b : α} (ha : a ≤ 1)\n    (hb : b < 1) :\n    a * b < 1 :=\n  mul_lt_of_le_of_lt_one ha hb\n\n"}
{"name":"Left.mul_lt_one_of_le_of_lt","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : MulOneClass α\ninst✝¹ : Preorder α\ninst✝ : MulLeftStrictMono α\na b : α\nha : LE.le a 1\nhb : LT.lt b 1\n⊢ LT.lt (HMul.hMul a b) 1","decl":"/-- Assumes left covariance.\nThe lemma assuming right covariance is `Right.mul_lt_one_of_le_of_lt`. -/\n@[to_additive Left.add_neg_of_nonpos_of_neg\n      \"Assumes left covariance.\n      The lemma assuming right covariance is `Right.add_neg_of_nonpos_of_neg`.\"]\ntheorem Left.mul_lt_one_of_le_of_lt [MulLeftStrictMono α] {a b : α} (ha : a ≤ 1)\n    (hb : b < 1) :\n    a * b < 1 :=\n  mul_lt_of_le_of_lt_one ha hb\n\n"}
{"name":"Left.mul_lt_one_of_lt_of_le","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : MulOneClass α\ninst✝¹ : Preorder α\ninst✝ : MulLeftMono α\na b : α\nha : LT.lt a 1\nhb : LE.le b 1\n⊢ LT.lt (HMul.hMul a b) 1","decl":"/-- Assumes left covariance.\nThe lemma assuming right covariance is `Right.mul_lt_one_of_lt_of_le`. -/\n@[to_additive Left.add_neg_of_neg_of_nonpos\n      \"Assumes left covariance.\n      The lemma assuming right covariance is `Right.add_neg_of_neg_of_nonpos`.\"]\ntheorem Left.mul_lt_one_of_lt_of_le [MulLeftMono α] {a b : α} (ha : a < 1)\n    (hb : b ≤ 1) :\n    a * b < 1 :=\n  mul_lt_of_lt_of_le_one ha hb\n\n"}
{"name":"Left.add_neg_of_neg_of_nonpos","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : AddZeroClass α\ninst✝¹ : Preorder α\ninst✝ : AddLeftMono α\na b : α\nha : LT.lt a 0\nhb : LE.le b 0\n⊢ LT.lt (HAdd.hAdd a b) 0","decl":"/-- Assumes left covariance.\nThe lemma assuming right covariance is `Right.mul_lt_one_of_lt_of_le`. -/\n@[to_additive Left.add_neg_of_neg_of_nonpos\n      \"Assumes left covariance.\n      The lemma assuming right covariance is `Right.add_neg_of_neg_of_nonpos`.\"]\ntheorem Left.mul_lt_one_of_lt_of_le [MulLeftMono α] {a b : α} (ha : a < 1)\n    (hb : b ≤ 1) :\n    a * b < 1 :=\n  mul_lt_of_lt_of_le_one ha hb\n\n"}
{"name":"Left.add_neg","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : AddZeroClass α\ninst✝¹ : Preorder α\ninst✝ : AddLeftStrictMono α\na b : α\nha : LT.lt a 0\nhb : LT.lt b 0\n⊢ LT.lt (HAdd.hAdd a b) 0","decl":"/-- Assumes left covariance.\nThe lemma assuming right covariance is `Right.mul_lt_one`. -/\n@[to_additive \"Assumes left covariance.\nThe lemma assuming right covariance is `Right.add_neg`.\"]\ntheorem Left.mul_lt_one [MulLeftStrictMono α] {a b : α} (ha : a < 1) (hb : b < 1) :\n    a * b < 1 :=\n  mul_lt_of_lt_of_lt_one ha hb\n\n"}
{"name":"Left.mul_lt_one","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : MulOneClass α\ninst✝¹ : Preorder α\ninst✝ : MulLeftStrictMono α\na b : α\nha : LT.lt a 1\nhb : LT.lt b 1\n⊢ LT.lt (HMul.hMul a b) 1","decl":"/-- Assumes left covariance.\nThe lemma assuming right covariance is `Right.mul_lt_one`. -/\n@[to_additive \"Assumes left covariance.\nThe lemma assuming right covariance is `Right.add_neg`.\"]\ntheorem Left.mul_lt_one [MulLeftStrictMono α] {a b : α} (ha : a < 1) (hb : b < 1) :\n    a * b < 1 :=\n  mul_lt_of_lt_of_lt_one ha hb\n\n"}
{"name":"Left.add_neg'","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : AddZeroClass α\ninst✝¹ : Preorder α\ninst✝ : AddLeftMono α\na b : α\nha : LT.lt a 0\nhb : LT.lt b 0\n⊢ LT.lt (HAdd.hAdd a b) 0","decl":"/-- Assumes left covariance.\nThe lemma assuming right covariance is `Right.mul_lt_one'`. -/\n@[to_additive \"Assumes left covariance.\nThe lemma assuming right covariance is `Right.add_neg'`.\"]\ntheorem Left.mul_lt_one' [MulLeftMono α] {a b : α} (ha : a < 1) (hb : b < 1) :\n    a * b < 1 :=\n  mul_lt_of_lt_of_lt_one' ha hb\n\n"}
{"name":"Left.mul_lt_one'","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : MulOneClass α\ninst✝¹ : Preorder α\ninst✝ : MulLeftMono α\na b : α\nha : LT.lt a 1\nhb : LT.lt b 1\n⊢ LT.lt (HMul.hMul a b) 1","decl":"/-- Assumes left covariance.\nThe lemma assuming right covariance is `Right.mul_lt_one'`. -/\n@[to_additive \"Assumes left covariance.\nThe lemma assuming right covariance is `Right.add_neg'`.\"]\ntheorem Left.mul_lt_one' [MulLeftMono α] {a b : α} (ha : a < 1) (hb : b < 1) :\n    a * b < 1 :=\n  mul_lt_of_lt_of_lt_one' ha hb\n\n"}
{"name":"le_add_of_le_of_nonneg","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : AddZeroClass α\ninst✝¹ : Preorder α\ninst✝ : AddLeftMono α\na b c : α\nhbc : LE.le b c\nha : LE.le 0 a\n⊢ LE.le b (HAdd.hAdd c a)","decl":"@[to_additive]\ntheorem le_mul_of_le_of_one_le [MulLeftMono α] {a b c : α} (hbc : b ≤ c)\n    (ha : 1 ≤ a) :\n    b ≤ c * a :=\n  calc\n    b ≤ c := hbc\n    _ = c * 1 := (mul_one c).symm\n    _ ≤ c * a := mul_le_mul_left' ha c\n\n"}
{"name":"le_mul_of_le_of_one_le","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : MulOneClass α\ninst✝¹ : Preorder α\ninst✝ : MulLeftMono α\na b c : α\nhbc : LE.le b c\nha : LE.le 1 a\n⊢ LE.le b (HMul.hMul c a)","decl":"@[to_additive]\ntheorem le_mul_of_le_of_one_le [MulLeftMono α] {a b c : α} (hbc : b ≤ c)\n    (ha : 1 ≤ a) :\n    b ≤ c * a :=\n  calc\n    b ≤ c := hbc\n    _ = c * 1 := (mul_one c).symm\n    _ ≤ c * a := mul_le_mul_left' ha c\n\n"}
{"name":"lt_mul_of_le_of_one_lt","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : MulOneClass α\ninst✝¹ : Preorder α\ninst✝ : MulLeftStrictMono α\na b c : α\nhbc : LE.le b c\nha : LT.lt 1 a\n⊢ LT.lt b (HMul.hMul c a)","decl":"@[to_additive]\ntheorem lt_mul_of_le_of_one_lt [MulLeftStrictMono α] {a b c : α} (hbc : b ≤ c)\n    (ha : 1 < a) :\n    b < c * a :=\n  calc\n    b ≤ c := hbc\n    _ = c * 1 := (mul_one c).symm\n    _ < c * a := mul_lt_mul_left' ha c\n\n"}
{"name":"lt_add_of_le_of_pos","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : AddZeroClass α\ninst✝¹ : Preorder α\ninst✝ : AddLeftStrictMono α\na b c : α\nhbc : LE.le b c\nha : LT.lt 0 a\n⊢ LT.lt b (HAdd.hAdd c a)","decl":"@[to_additive]\ntheorem lt_mul_of_le_of_one_lt [MulLeftStrictMono α] {a b c : α} (hbc : b ≤ c)\n    (ha : 1 < a) :\n    b < c * a :=\n  calc\n    b ≤ c := hbc\n    _ = c * 1 := (mul_one c).symm\n    _ < c * a := mul_lt_mul_left' ha c\n\n"}
{"name":"lt_mul_of_lt_of_one_le","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : MulOneClass α\ninst✝¹ : Preorder α\ninst✝ : MulLeftMono α\na b c : α\nhbc : LT.lt b c\nha : LE.le 1 a\n⊢ LT.lt b (HMul.hMul c a)","decl":"@[to_additive]\ntheorem lt_mul_of_lt_of_one_le [MulLeftMono α] {a b c : α} (hbc : b < c)\n    (ha : 1 ≤ a) :\n    b < c * a :=\n  calc\n    b < c := hbc\n    _ = c * 1 := (mul_one c).symm\n    _ ≤ c * a := mul_le_mul_left' ha c\n\n"}
{"name":"lt_add_of_lt_of_nonneg","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : AddZeroClass α\ninst✝¹ : Preorder α\ninst✝ : AddLeftMono α\na b c : α\nhbc : LT.lt b c\nha : LE.le 0 a\n⊢ LT.lt b (HAdd.hAdd c a)","decl":"@[to_additive]\ntheorem lt_mul_of_lt_of_one_le [MulLeftMono α] {a b c : α} (hbc : b < c)\n    (ha : 1 ≤ a) :\n    b < c * a :=\n  calc\n    b < c := hbc\n    _ = c * 1 := (mul_one c).symm\n    _ ≤ c * a := mul_le_mul_left' ha c\n\n"}
{"name":"lt_mul_of_lt_of_one_lt","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : MulOneClass α\ninst✝¹ : Preorder α\ninst✝ : MulLeftStrictMono α\na b c : α\nhbc : LT.lt b c\nha : LT.lt 1 a\n⊢ LT.lt b (HMul.hMul c a)","decl":"@[to_additive]\ntheorem lt_mul_of_lt_of_one_lt [MulLeftStrictMono α] {a b c : α} (hbc : b < c)\n    (ha : 1 < a) :\n    b < c * a :=\n  calc\n    b < c := hbc\n    _ = c * 1 := (mul_one c).symm\n    _ < c * a := mul_lt_mul_left' ha c\n\n"}
{"name":"lt_add_of_lt_of_pos","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : AddZeroClass α\ninst✝¹ : Preorder α\ninst✝ : AddLeftStrictMono α\na b c : α\nhbc : LT.lt b c\nha : LT.lt 0 a\n⊢ LT.lt b (HAdd.hAdd c a)","decl":"@[to_additive]\ntheorem lt_mul_of_lt_of_one_lt [MulLeftStrictMono α] {a b c : α} (hbc : b < c)\n    (ha : 1 < a) :\n    b < c * a :=\n  calc\n    b < c := hbc\n    _ = c * 1 := (mul_one c).symm\n    _ < c * a := mul_lt_mul_left' ha c\n\n"}
{"name":"lt_mul_of_lt_of_one_lt'","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : MulOneClass α\ninst✝¹ : Preorder α\ninst✝ : MulLeftMono α\na b c : α\nhbc : LT.lt b c\nha : LT.lt 1 a\n⊢ LT.lt b (HMul.hMul c a)","decl":"@[to_additive]\ntheorem lt_mul_of_lt_of_one_lt' [MulLeftMono α] {a b c : α} (hbc : b < c)\n    (ha : 1 < a) :\n    b < c * a :=\n  lt_mul_of_lt_of_one_le hbc ha.le\n\n"}
{"name":"lt_add_of_lt_of_pos'","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : AddZeroClass α\ninst✝¹ : Preorder α\ninst✝ : AddLeftMono α\na b c : α\nhbc : LT.lt b c\nha : LT.lt 0 a\n⊢ LT.lt b (HAdd.hAdd c a)","decl":"@[to_additive]\ntheorem lt_mul_of_lt_of_one_lt' [MulLeftMono α] {a b c : α} (hbc : b < c)\n    (ha : 1 < a) :\n    b < c * a :=\n  lt_mul_of_lt_of_one_le hbc ha.le\n\n"}
{"name":"Left.one_le_mul","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : MulOneClass α\ninst✝¹ : Preorder α\ninst✝ : MulLeftMono α\na b : α\nha : LE.le 1 a\nhb : LE.le 1 b\n⊢ LE.le 1 (HMul.hMul a b)","decl":"/-- Assumes left covariance.\nThe lemma assuming right covariance is `Right.one_le_mul`. -/\n@[to_additive Left.add_nonneg \"Assumes left covariance.\nThe lemma assuming right covariance is `Right.add_nonneg`.\"]\ntheorem Left.one_le_mul [MulLeftMono α] {a b : α} (ha : 1 ≤ a) (hb : 1 ≤ b) :\n    1 ≤ a * b :=\n  le_mul_of_le_of_one_le ha hb\n\n"}
{"name":"Left.add_nonneg","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : AddZeroClass α\ninst✝¹ : Preorder α\ninst✝ : AddLeftMono α\na b : α\nha : LE.le 0 a\nhb : LE.le 0 b\n⊢ LE.le 0 (HAdd.hAdd a b)","decl":"/-- Assumes left covariance.\nThe lemma assuming right covariance is `Right.one_le_mul`. -/\n@[to_additive Left.add_nonneg \"Assumes left covariance.\nThe lemma assuming right covariance is `Right.add_nonneg`.\"]\ntheorem Left.one_le_mul [MulLeftMono α] {a b : α} (ha : 1 ≤ a) (hb : 1 ≤ b) :\n    1 ≤ a * b :=\n  le_mul_of_le_of_one_le ha hb\n\n"}
{"name":"Left.one_lt_mul_of_le_of_lt","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : MulOneClass α\ninst✝¹ : Preorder α\ninst✝ : MulLeftStrictMono α\na b : α\nha : LE.le 1 a\nhb : LT.lt 1 b\n⊢ LT.lt 1 (HMul.hMul a b)","decl":"/-- Assumes left covariance.\nThe lemma assuming right covariance is `Right.one_lt_mul_of_le_of_lt`. -/\n@[to_additive Left.add_pos_of_nonneg_of_pos\n      \"Assumes left covariance.\n      The lemma assuming right covariance is `Right.add_pos_of_nonneg_of_pos`.\"]\ntheorem Left.one_lt_mul_of_le_of_lt [MulLeftStrictMono α] {a b : α} (ha : 1 ≤ a)\n    (hb : 1 < b) :\n    1 < a * b :=\n  lt_mul_of_le_of_one_lt ha hb\n\n"}
{"name":"Left.add_pos_of_nonneg_of_pos","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : AddZeroClass α\ninst✝¹ : Preorder α\ninst✝ : AddLeftStrictMono α\na b : α\nha : LE.le 0 a\nhb : LT.lt 0 b\n⊢ LT.lt 0 (HAdd.hAdd a b)","decl":"/-- Assumes left covariance.\nThe lemma assuming right covariance is `Right.one_lt_mul_of_le_of_lt`. -/\n@[to_additive Left.add_pos_of_nonneg_of_pos\n      \"Assumes left covariance.\n      The lemma assuming right covariance is `Right.add_pos_of_nonneg_of_pos`.\"]\ntheorem Left.one_lt_mul_of_le_of_lt [MulLeftStrictMono α] {a b : α} (ha : 1 ≤ a)\n    (hb : 1 < b) :\n    1 < a * b :=\n  lt_mul_of_le_of_one_lt ha hb\n\n"}
{"name":"Left.one_lt_mul_of_lt_of_le","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : MulOneClass α\ninst✝¹ : Preorder α\ninst✝ : MulLeftMono α\na b : α\nha : LT.lt 1 a\nhb : LE.le 1 b\n⊢ LT.lt 1 (HMul.hMul a b)","decl":"/-- Assumes left covariance.\nThe lemma assuming right covariance is `Right.one_lt_mul_of_lt_of_le`. -/\n@[to_additive Left.add_pos_of_pos_of_nonneg\n      \"Assumes left covariance.\n      The lemma assuming right covariance is `Right.add_pos_of_pos_of_nonneg`.\"]\ntheorem Left.one_lt_mul_of_lt_of_le [MulLeftMono α] {a b : α} (ha : 1 < a)\n    (hb : 1 ≤ b) :\n    1 < a * b :=\n  lt_mul_of_lt_of_one_le ha hb\n\n"}
{"name":"Left.add_pos_of_pos_of_nonneg","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : AddZeroClass α\ninst✝¹ : Preorder α\ninst✝ : AddLeftMono α\na b : α\nha : LT.lt 0 a\nhb : LE.le 0 b\n⊢ LT.lt 0 (HAdd.hAdd a b)","decl":"/-- Assumes left covariance.\nThe lemma assuming right covariance is `Right.one_lt_mul_of_lt_of_le`. -/\n@[to_additive Left.add_pos_of_pos_of_nonneg\n      \"Assumes left covariance.\n      The lemma assuming right covariance is `Right.add_pos_of_pos_of_nonneg`.\"]\ntheorem Left.one_lt_mul_of_lt_of_le [MulLeftMono α] {a b : α} (ha : 1 < a)\n    (hb : 1 ≤ b) :\n    1 < a * b :=\n  lt_mul_of_lt_of_one_le ha hb\n\n"}
{"name":"Left.one_lt_mul","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : MulOneClass α\ninst✝¹ : Preorder α\ninst✝ : MulLeftStrictMono α\na b : α\nha : LT.lt 1 a\nhb : LT.lt 1 b\n⊢ LT.lt 1 (HMul.hMul a b)","decl":"/-- Assumes left covariance.\nThe lemma assuming right covariance is `Right.one_lt_mul`. -/\n@[to_additive Left.add_pos \"Assumes left covariance.\nThe lemma assuming right covariance is `Right.add_pos`.\"]\ntheorem Left.one_lt_mul [MulLeftStrictMono α] {a b : α} (ha : 1 < a) (hb : 1 < b) :\n    1 < a * b :=\n  lt_mul_of_lt_of_one_lt ha hb\n\n"}
{"name":"Left.add_pos","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : AddZeroClass α\ninst✝¹ : Preorder α\ninst✝ : AddLeftStrictMono α\na b : α\nha : LT.lt 0 a\nhb : LT.lt 0 b\n⊢ LT.lt 0 (HAdd.hAdd a b)","decl":"/-- Assumes left covariance.\nThe lemma assuming right covariance is `Right.one_lt_mul`. -/\n@[to_additive Left.add_pos \"Assumes left covariance.\nThe lemma assuming right covariance is `Right.add_pos`.\"]\ntheorem Left.one_lt_mul [MulLeftStrictMono α] {a b : α} (ha : 1 < a) (hb : 1 < b) :\n    1 < a * b :=\n  lt_mul_of_lt_of_one_lt ha hb\n\n"}
{"name":"Left.add_pos'","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : AddZeroClass α\ninst✝¹ : Preorder α\ninst✝ : AddLeftMono α\na b : α\nha : LT.lt 0 a\nhb : LT.lt 0 b\n⊢ LT.lt 0 (HAdd.hAdd a b)","decl":"/-- Assumes left covariance.\nThe lemma assuming right covariance is `Right.one_lt_mul'`. -/\n@[to_additive Left.add_pos' \"Assumes left covariance.\nThe lemma assuming right covariance is `Right.add_pos'`.\"]\ntheorem Left.one_lt_mul' [MulLeftMono α] {a b : α} (ha : 1 < a) (hb : 1 < b) :\n    1 < a * b :=\n  lt_mul_of_lt_of_one_lt' ha hb\n\n"}
{"name":"Left.one_lt_mul'","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : MulOneClass α\ninst✝¹ : Preorder α\ninst✝ : MulLeftMono α\na b : α\nha : LT.lt 1 a\nhb : LT.lt 1 b\n⊢ LT.lt 1 (HMul.hMul a b)","decl":"/-- Assumes left covariance.\nThe lemma assuming right covariance is `Right.one_lt_mul'`. -/\n@[to_additive Left.add_pos' \"Assumes left covariance.\nThe lemma assuming right covariance is `Right.add_pos'`.\"]\ntheorem Left.one_lt_mul' [MulLeftMono α] {a b : α} (ha : 1 < a) (hb : 1 < b) :\n    1 < a * b :=\n  lt_mul_of_lt_of_one_lt' ha hb\n\n"}
{"name":"add_le_of_nonpos_of_le","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : AddZeroClass α\ninst✝¹ : Preorder α\ninst✝ : AddRightMono α\na b c : α\nha : LE.le a 0\nhbc : LE.le b c\n⊢ LE.le (HAdd.hAdd a b) c","decl":"@[to_additive]\ntheorem mul_le_of_le_one_of_le [MulRightMono α] {a b c : α} (ha : a ≤ 1)\n    (hbc : b ≤ c) :\n    a * b ≤ c :=\n  calc\n    a * b ≤ 1 * b := mul_le_mul_right' ha b\n    _ = b := one_mul b\n    _ ≤ c := hbc\n\n"}
{"name":"mul_le_of_le_one_of_le","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : MulOneClass α\ninst✝¹ : Preorder α\ninst✝ : MulRightMono α\na b c : α\nha : LE.le a 1\nhbc : LE.le b c\n⊢ LE.le (HMul.hMul a b) c","decl":"@[to_additive]\ntheorem mul_le_of_le_one_of_le [MulRightMono α] {a b c : α} (ha : a ≤ 1)\n    (hbc : b ≤ c) :\n    a * b ≤ c :=\n  calc\n    a * b ≤ 1 * b := mul_le_mul_right' ha b\n    _ = b := one_mul b\n    _ ≤ c := hbc\n\n"}
{"name":"add_lt_of_neg_of_le","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : AddZeroClass α\ninst✝¹ : Preorder α\ninst✝ : AddRightStrictMono α\na b c : α\nha : LT.lt a 0\nhbc : LE.le b c\n⊢ LT.lt (HAdd.hAdd a b) c","decl":"@[to_additive]\ntheorem mul_lt_of_lt_one_of_le [MulRightStrictMono α] {a b c : α} (ha : a < 1)\n    (hbc : b ≤ c) :\n    a * b < c :=\n  calc\n    a * b < 1 * b := mul_lt_mul_right' ha b\n    _ = b := one_mul b\n    _ ≤ c := hbc\n\n"}
{"name":"mul_lt_of_lt_one_of_le","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : MulOneClass α\ninst✝¹ : Preorder α\ninst✝ : MulRightStrictMono α\na b c : α\nha : LT.lt a 1\nhbc : LE.le b c\n⊢ LT.lt (HMul.hMul a b) c","decl":"@[to_additive]\ntheorem mul_lt_of_lt_one_of_le [MulRightStrictMono α] {a b c : α} (ha : a < 1)\n    (hbc : b ≤ c) :\n    a * b < c :=\n  calc\n    a * b < 1 * b := mul_lt_mul_right' ha b\n    _ = b := one_mul b\n    _ ≤ c := hbc\n\n"}
{"name":"add_lt_of_nonpos_of_lt","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : AddZeroClass α\ninst✝¹ : Preorder α\ninst✝ : AddRightMono α\na b c : α\nha : LE.le a 0\nhb : LT.lt b c\n⊢ LT.lt (HAdd.hAdd a b) c","decl":"@[to_additive]\ntheorem mul_lt_of_le_one_of_lt [MulRightMono α] {a b c : α} (ha : a ≤ 1)\n    (hb : b < c) :\n    a * b < c :=\n  calc\n    a * b ≤ 1 * b := mul_le_mul_right' ha b\n    _ = b := one_mul b\n    _ < c := hb\n\n"}
{"name":"mul_lt_of_le_one_of_lt","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : MulOneClass α\ninst✝¹ : Preorder α\ninst✝ : MulRightMono α\na b c : α\nha : LE.le a 1\nhb : LT.lt b c\n⊢ LT.lt (HMul.hMul a b) c","decl":"@[to_additive]\ntheorem mul_lt_of_le_one_of_lt [MulRightMono α] {a b c : α} (ha : a ≤ 1)\n    (hb : b < c) :\n    a * b < c :=\n  calc\n    a * b ≤ 1 * b := mul_le_mul_right' ha b\n    _ = b := one_mul b\n    _ < c := hb\n\n"}
{"name":"add_lt_of_neg_of_lt","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : AddZeroClass α\ninst✝¹ : Preorder α\ninst✝ : AddRightStrictMono α\na b c : α\nha : LT.lt a 0\nhb : LT.lt b c\n⊢ LT.lt (HAdd.hAdd a b) c","decl":"@[to_additive]\ntheorem mul_lt_of_lt_one_of_lt [MulRightStrictMono α] {a b c : α} (ha : a < 1)\n    (hb : b < c) :\n    a * b < c :=\n  calc\n    a * b < 1 * b := mul_lt_mul_right' ha b\n    _ = b := one_mul b\n    _ < c := hb\n\n"}
{"name":"mul_lt_of_lt_one_of_lt","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : MulOneClass α\ninst✝¹ : Preorder α\ninst✝ : MulRightStrictMono α\na b c : α\nha : LT.lt a 1\nhb : LT.lt b c\n⊢ LT.lt (HMul.hMul a b) c","decl":"@[to_additive]\ntheorem mul_lt_of_lt_one_of_lt [MulRightStrictMono α] {a b c : α} (ha : a < 1)\n    (hb : b < c) :\n    a * b < c :=\n  calc\n    a * b < 1 * b := mul_lt_mul_right' ha b\n    _ = b := one_mul b\n    _ < c := hb\n\n"}
{"name":"add_lt_of_neg_of_lt'","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : AddZeroClass α\ninst✝¹ : Preorder α\ninst✝ : AddRightMono α\na b c : α\nha : LT.lt a 0\nhbc : LT.lt b c\n⊢ LT.lt (HAdd.hAdd a b) c","decl":"@[to_additive]\ntheorem mul_lt_of_lt_one_of_lt' [MulRightMono α] {a b c : α} (ha : a < 1)\n    (hbc : b < c) :\n    a * b < c :=\n  mul_lt_of_le_one_of_lt ha.le hbc\n\n"}
{"name":"mul_lt_of_lt_one_of_lt'","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : MulOneClass α\ninst✝¹ : Preorder α\ninst✝ : MulRightMono α\na b c : α\nha : LT.lt a 1\nhbc : LT.lt b c\n⊢ LT.lt (HMul.hMul a b) c","decl":"@[to_additive]\ntheorem mul_lt_of_lt_one_of_lt' [MulRightMono α] {a b c : α} (ha : a < 1)\n    (hbc : b < c) :\n    a * b < c :=\n  mul_lt_of_le_one_of_lt ha.le hbc\n\n"}
{"name":"Right.add_nonpos","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : AddZeroClass α\ninst✝¹ : Preorder α\ninst✝ : AddRightMono α\na b : α\nha : LE.le a 0\nhb : LE.le b 0\n⊢ LE.le (HAdd.hAdd a b) 0","decl":"/-- Assumes right covariance.\nThe lemma assuming left covariance is `Left.mul_le_one`. -/\n@[to_additive \"Assumes right covariance.\nThe lemma assuming left covariance is `Left.add_nonpos`.\"]\ntheorem Right.mul_le_one [MulRightMono α] {a b : α} (ha : a ≤ 1)\n    (hb : b ≤ 1) :\n    a * b ≤ 1 :=\n  mul_le_of_le_one_of_le ha hb\n\n"}
{"name":"Right.mul_le_one","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : MulOneClass α\ninst✝¹ : Preorder α\ninst✝ : MulRightMono α\na b : α\nha : LE.le a 1\nhb : LE.le b 1\n⊢ LE.le (HMul.hMul a b) 1","decl":"/-- Assumes right covariance.\nThe lemma assuming left covariance is `Left.mul_le_one`. -/\n@[to_additive \"Assumes right covariance.\nThe lemma assuming left covariance is `Left.add_nonpos`.\"]\ntheorem Right.mul_le_one [MulRightMono α] {a b : α} (ha : a ≤ 1)\n    (hb : b ≤ 1) :\n    a * b ≤ 1 :=\n  mul_le_of_le_one_of_le ha hb\n\n"}
{"name":"Right.mul_lt_one_of_lt_of_le","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : MulOneClass α\ninst✝¹ : Preorder α\ninst✝ : MulRightStrictMono α\na b : α\nha : LT.lt a 1\nhb : LE.le b 1\n⊢ LT.lt (HMul.hMul a b) 1","decl":"/-- Assumes right covariance.\nThe lemma assuming left covariance is `Left.mul_lt_one_of_lt_of_le`. -/\n@[to_additive Right.add_neg_of_neg_of_nonpos\n      \"Assumes right covariance.\n      The lemma assuming left covariance is `Left.add_neg_of_neg_of_nonpos`.\"]\ntheorem Right.mul_lt_one_of_lt_of_le [MulRightStrictMono α] {a b : α}\n    (ha : a < 1) (hb : b ≤ 1) :\n    a * b < 1 :=\n  mul_lt_of_lt_one_of_le ha hb\n\n"}
{"name":"Right.add_neg_of_neg_of_nonpos","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : AddZeroClass α\ninst✝¹ : Preorder α\ninst✝ : AddRightStrictMono α\na b : α\nha : LT.lt a 0\nhb : LE.le b 0\n⊢ LT.lt (HAdd.hAdd a b) 0","decl":"/-- Assumes right covariance.\nThe lemma assuming left covariance is `Left.mul_lt_one_of_lt_of_le`. -/\n@[to_additive Right.add_neg_of_neg_of_nonpos\n      \"Assumes right covariance.\n      The lemma assuming left covariance is `Left.add_neg_of_neg_of_nonpos`.\"]\ntheorem Right.mul_lt_one_of_lt_of_le [MulRightStrictMono α] {a b : α}\n    (ha : a < 1) (hb : b ≤ 1) :\n    a * b < 1 :=\n  mul_lt_of_lt_one_of_le ha hb\n\n"}
{"name":"Right.mul_lt_one_of_le_of_lt","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : MulOneClass α\ninst✝¹ : Preorder α\ninst✝ : MulRightMono α\na b : α\nha : LE.le a 1\nhb : LT.lt b 1\n⊢ LT.lt (HMul.hMul a b) 1","decl":"/-- Assumes right covariance.\nThe lemma assuming left covariance is `Left.mul_lt_one_of_le_of_lt`. -/\n@[to_additive Right.add_neg_of_nonpos_of_neg\n      \"Assumes right covariance.\n      The lemma assuming left covariance is `Left.add_neg_of_nonpos_of_neg`.\"]\ntheorem Right.mul_lt_one_of_le_of_lt [MulRightMono α] {a b : α}\n    (ha : a ≤ 1) (hb : b < 1) :\n    a * b < 1 :=\n  mul_lt_of_le_one_of_lt ha hb\n\n"}
{"name":"Right.add_neg_of_nonpos_of_neg","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : AddZeroClass α\ninst✝¹ : Preorder α\ninst✝ : AddRightMono α\na b : α\nha : LE.le a 0\nhb : LT.lt b 0\n⊢ LT.lt (HAdd.hAdd a b) 0","decl":"/-- Assumes right covariance.\nThe lemma assuming left covariance is `Left.mul_lt_one_of_le_of_lt`. -/\n@[to_additive Right.add_neg_of_nonpos_of_neg\n      \"Assumes right covariance.\n      The lemma assuming left covariance is `Left.add_neg_of_nonpos_of_neg`.\"]\ntheorem Right.mul_lt_one_of_le_of_lt [MulRightMono α] {a b : α}\n    (ha : a ≤ 1) (hb : b < 1) :\n    a * b < 1 :=\n  mul_lt_of_le_one_of_lt ha hb\n\n"}
{"name":"Right.mul_lt_one","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : MulOneClass α\ninst✝¹ : Preorder α\ninst✝ : MulRightStrictMono α\na b : α\nha : LT.lt a 1\nhb : LT.lt b 1\n⊢ LT.lt (HMul.hMul a b) 1","decl":"/-- Assumes right covariance.\nThe lemma assuming left covariance is `Left.mul_lt_one`. -/\n@[to_additive \"Assumes right covariance.\nThe lemma assuming left covariance is `Left.add_neg`.\"]\ntheorem Right.mul_lt_one [MulRightStrictMono α] {a b : α} (ha : a < 1)\n    (hb : b < 1) :\n    a * b < 1 :=\n  mul_lt_of_lt_one_of_lt ha hb\n\n"}
{"name":"Right.add_neg","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : AddZeroClass α\ninst✝¹ : Preorder α\ninst✝ : AddRightStrictMono α\na b : α\nha : LT.lt a 0\nhb : LT.lt b 0\n⊢ LT.lt (HAdd.hAdd a b) 0","decl":"/-- Assumes right covariance.\nThe lemma assuming left covariance is `Left.mul_lt_one`. -/\n@[to_additive \"Assumes right covariance.\nThe lemma assuming left covariance is `Left.add_neg`.\"]\ntheorem Right.mul_lt_one [MulRightStrictMono α] {a b : α} (ha : a < 1)\n    (hb : b < 1) :\n    a * b < 1 :=\n  mul_lt_of_lt_one_of_lt ha hb\n\n"}
{"name":"Right.add_neg'","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : AddZeroClass α\ninst✝¹ : Preorder α\ninst✝ : AddRightMono α\na b : α\nha : LT.lt a 0\nhb : LT.lt b 0\n⊢ LT.lt (HAdd.hAdd a b) 0","decl":"/-- Assumes right covariance.\nThe lemma assuming left covariance is `Left.mul_lt_one'`. -/\n@[to_additive \"Assumes right covariance.\nThe lemma assuming left covariance is `Left.add_neg'`.\"]\ntheorem Right.mul_lt_one' [MulRightMono α] {a b : α} (ha : a < 1)\n    (hb : b < 1) :\n    a * b < 1 :=\n  mul_lt_of_lt_one_of_lt' ha hb\n\n"}
{"name":"Right.mul_lt_one'","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : MulOneClass α\ninst✝¹ : Preorder α\ninst✝ : MulRightMono α\na b : α\nha : LT.lt a 1\nhb : LT.lt b 1\n⊢ LT.lt (HMul.hMul a b) 1","decl":"/-- Assumes right covariance.\nThe lemma assuming left covariance is `Left.mul_lt_one'`. -/\n@[to_additive \"Assumes right covariance.\nThe lemma assuming left covariance is `Left.add_neg'`.\"]\ntheorem Right.mul_lt_one' [MulRightMono α] {a b : α} (ha : a < 1)\n    (hb : b < 1) :\n    a * b < 1 :=\n  mul_lt_of_lt_one_of_lt' ha hb\n\n"}
{"name":"le_add_of_nonneg_of_le","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : AddZeroClass α\ninst✝¹ : Preorder α\ninst✝ : AddRightMono α\na b c : α\nha : LE.le 0 a\nhbc : LE.le b c\n⊢ LE.le b (HAdd.hAdd a c)","decl":"@[to_additive]\ntheorem le_mul_of_one_le_of_le [MulRightMono α] {a b c : α} (ha : 1 ≤ a)\n    (hbc : b ≤ c) :\n    b ≤ a * c :=\n  calc\n    b ≤ c := hbc\n    _ = 1 * c := (one_mul c).symm\n    _ ≤ a * c := mul_le_mul_right' ha c\n\n"}
{"name":"le_mul_of_one_le_of_le","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : MulOneClass α\ninst✝¹ : Preorder α\ninst✝ : MulRightMono α\na b c : α\nha : LE.le 1 a\nhbc : LE.le b c\n⊢ LE.le b (HMul.hMul a c)","decl":"@[to_additive]\ntheorem le_mul_of_one_le_of_le [MulRightMono α] {a b c : α} (ha : 1 ≤ a)\n    (hbc : b ≤ c) :\n    b ≤ a * c :=\n  calc\n    b ≤ c := hbc\n    _ = 1 * c := (one_mul c).symm\n    _ ≤ a * c := mul_le_mul_right' ha c\n\n"}
{"name":"lt_mul_of_one_lt_of_le","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : MulOneClass α\ninst✝¹ : Preorder α\ninst✝ : MulRightStrictMono α\na b c : α\nha : LT.lt 1 a\nhbc : LE.le b c\n⊢ LT.lt b (HMul.hMul a c)","decl":"@[to_additive]\ntheorem lt_mul_of_one_lt_of_le [MulRightStrictMono α] {a b c : α} (ha : 1 < a)\n    (hbc : b ≤ c) :\n    b < a * c :=\n  calc\n    b ≤ c := hbc\n    _ = 1 * c := (one_mul c).symm\n    _ < a * c := mul_lt_mul_right' ha c\n\n"}
{"name":"lt_add_of_pos_of_le","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : AddZeroClass α\ninst✝¹ : Preorder α\ninst✝ : AddRightStrictMono α\na b c : α\nha : LT.lt 0 a\nhbc : LE.le b c\n⊢ LT.lt b (HAdd.hAdd a c)","decl":"@[to_additive]\ntheorem lt_mul_of_one_lt_of_le [MulRightStrictMono α] {a b c : α} (ha : 1 < a)\n    (hbc : b ≤ c) :\n    b < a * c :=\n  calc\n    b ≤ c := hbc\n    _ = 1 * c := (one_mul c).symm\n    _ < a * c := mul_lt_mul_right' ha c\n\n"}
{"name":"lt_add_of_nonneg_of_lt","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : AddZeroClass α\ninst✝¹ : Preorder α\ninst✝ : AddRightMono α\na b c : α\nha : LE.le 0 a\nhbc : LT.lt b c\n⊢ LT.lt b (HAdd.hAdd a c)","decl":"@[to_additive]\ntheorem lt_mul_of_one_le_of_lt [MulRightMono α] {a b c : α} (ha : 1 ≤ a)\n    (hbc : b < c) :\n    b < a * c :=\n  calc\n    b < c := hbc\n    _ = 1 * c := (one_mul c).symm\n    _ ≤ a * c := mul_le_mul_right' ha c\n\n"}
{"name":"lt_mul_of_one_le_of_lt","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : MulOneClass α\ninst✝¹ : Preorder α\ninst✝ : MulRightMono α\na b c : α\nha : LE.le 1 a\nhbc : LT.lt b c\n⊢ LT.lt b (HMul.hMul a c)","decl":"@[to_additive]\ntheorem lt_mul_of_one_le_of_lt [MulRightMono α] {a b c : α} (ha : 1 ≤ a)\n    (hbc : b < c) :\n    b < a * c :=\n  calc\n    b < c := hbc\n    _ = 1 * c := (one_mul c).symm\n    _ ≤ a * c := mul_le_mul_right' ha c\n\n"}
{"name":"lt_mul_of_one_lt_of_lt","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : MulOneClass α\ninst✝¹ : Preorder α\ninst✝ : MulRightStrictMono α\na b c : α\nha : LT.lt 1 a\nhbc : LT.lt b c\n⊢ LT.lt b (HMul.hMul a c)","decl":"@[to_additive]\ntheorem lt_mul_of_one_lt_of_lt [MulRightStrictMono α] {a b c : α} (ha : 1 < a)\n    (hbc : b < c) :\n    b < a * c :=\n  calc\n    b < c := hbc\n    _ = 1 * c := (one_mul c).symm\n    _ < a * c := mul_lt_mul_right' ha c\n\n"}
{"name":"lt_add_of_pos_of_lt","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : AddZeroClass α\ninst✝¹ : Preorder α\ninst✝ : AddRightStrictMono α\na b c : α\nha : LT.lt 0 a\nhbc : LT.lt b c\n⊢ LT.lt b (HAdd.hAdd a c)","decl":"@[to_additive]\ntheorem lt_mul_of_one_lt_of_lt [MulRightStrictMono α] {a b c : α} (ha : 1 < a)\n    (hbc : b < c) :\n    b < a * c :=\n  calc\n    b < c := hbc\n    _ = 1 * c := (one_mul c).symm\n    _ < a * c := mul_lt_mul_right' ha c\n\n"}
{"name":"lt_add_of_pos_of_lt'","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : AddZeroClass α\ninst✝¹ : Preorder α\ninst✝ : AddRightMono α\na b c : α\nha : LT.lt 0 a\nhbc : LT.lt b c\n⊢ LT.lt b (HAdd.hAdd a c)","decl":"@[to_additive]\ntheorem lt_mul_of_one_lt_of_lt' [MulRightMono α] {a b c : α} (ha : 1 < a)\n    (hbc : b < c) :\n    b < a * c :=\n  lt_mul_of_one_le_of_lt ha.le hbc\n\n"}
{"name":"lt_mul_of_one_lt_of_lt'","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : MulOneClass α\ninst✝¹ : Preorder α\ninst✝ : MulRightMono α\na b c : α\nha : LT.lt 1 a\nhbc : LT.lt b c\n⊢ LT.lt b (HMul.hMul a c)","decl":"@[to_additive]\ntheorem lt_mul_of_one_lt_of_lt' [MulRightMono α] {a b c : α} (ha : 1 < a)\n    (hbc : b < c) :\n    b < a * c :=\n  lt_mul_of_one_le_of_lt ha.le hbc\n\n"}
{"name":"Right.add_nonneg","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : AddZeroClass α\ninst✝¹ : Preorder α\ninst✝ : AddRightMono α\na b : α\nha : LE.le 0 a\nhb : LE.le 0 b\n⊢ LE.le 0 (HAdd.hAdd a b)","decl":"/-- Assumes right covariance.\nThe lemma assuming left covariance is `Left.one_le_mul`. -/\n@[to_additive Right.add_nonneg \"Assumes right covariance.\nThe lemma assuming left covariance is `Left.add_nonneg`.\"]\ntheorem Right.one_le_mul [MulRightMono α] {a b : α} (ha : 1 ≤ a)\n    (hb : 1 ≤ b) :\n    1 ≤ a * b :=\n  le_mul_of_one_le_of_le ha hb\n\n"}
{"name":"Right.one_le_mul","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : MulOneClass α\ninst✝¹ : Preorder α\ninst✝ : MulRightMono α\na b : α\nha : LE.le 1 a\nhb : LE.le 1 b\n⊢ LE.le 1 (HMul.hMul a b)","decl":"/-- Assumes right covariance.\nThe lemma assuming left covariance is `Left.one_le_mul`. -/\n@[to_additive Right.add_nonneg \"Assumes right covariance.\nThe lemma assuming left covariance is `Left.add_nonneg`.\"]\ntheorem Right.one_le_mul [MulRightMono α] {a b : α} (ha : 1 ≤ a)\n    (hb : 1 ≤ b) :\n    1 ≤ a * b :=\n  le_mul_of_one_le_of_le ha hb\n\n"}
{"name":"Right.one_lt_mul_of_lt_of_le","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : MulOneClass α\ninst✝¹ : Preorder α\ninst✝ : MulRightStrictMono α\na b : α\nha : LT.lt 1 a\nhb : LE.le 1 b\n⊢ LT.lt 1 (HMul.hMul a b)","decl":"/-- Assumes right covariance.\nThe lemma assuming left covariance is `Left.one_lt_mul_of_lt_of_le`. -/\n@[to_additive Right.add_pos_of_pos_of_nonneg\n\"Assumes right covariance.\nThe lemma assuming left covariance is `Left.add_pos_of_pos_of_nonneg`.\"]\ntheorem Right.one_lt_mul_of_lt_of_le [MulRightStrictMono α] {a b : α}\n    (ha : 1 < a) (hb : 1 ≤ b) :\n    1 < a * b :=\n  lt_mul_of_one_lt_of_le ha hb\n\n"}
{"name":"Right.add_pos_of_pos_of_nonneg","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : AddZeroClass α\ninst✝¹ : Preorder α\ninst✝ : AddRightStrictMono α\na b : α\nha : LT.lt 0 a\nhb : LE.le 0 b\n⊢ LT.lt 0 (HAdd.hAdd a b)","decl":"/-- Assumes right covariance.\nThe lemma assuming left covariance is `Left.one_lt_mul_of_lt_of_le`. -/\n@[to_additive Right.add_pos_of_pos_of_nonneg\n\"Assumes right covariance.\nThe lemma assuming left covariance is `Left.add_pos_of_pos_of_nonneg`.\"]\ntheorem Right.one_lt_mul_of_lt_of_le [MulRightStrictMono α] {a b : α}\n    (ha : 1 < a) (hb : 1 ≤ b) :\n    1 < a * b :=\n  lt_mul_of_one_lt_of_le ha hb\n\n"}
{"name":"Right.one_lt_mul_of_le_of_lt","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : MulOneClass α\ninst✝¹ : Preorder α\ninst✝ : MulRightMono α\na b : α\nha : LE.le 1 a\nhb : LT.lt 1 b\n⊢ LT.lt 1 (HMul.hMul a b)","decl":"/-- Assumes right covariance.\nThe lemma assuming left covariance is `Left.one_lt_mul_of_le_of_lt`. -/\n@[to_additive Right.add_pos_of_nonneg_of_pos\n\"Assumes right covariance.\nThe lemma assuming left covariance is `Left.add_pos_of_nonneg_of_pos`.\"]\ntheorem Right.one_lt_mul_of_le_of_lt [MulRightMono α] {a b : α}\n    (ha : 1 ≤ a) (hb : 1 < b) :\n    1 < a * b :=\n  lt_mul_of_one_le_of_lt ha hb\n\n"}
{"name":"Right.add_pos_of_nonneg_of_pos","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : AddZeroClass α\ninst✝¹ : Preorder α\ninst✝ : AddRightMono α\na b : α\nha : LE.le 0 a\nhb : LT.lt 0 b\n⊢ LT.lt 0 (HAdd.hAdd a b)","decl":"/-- Assumes right covariance.\nThe lemma assuming left covariance is `Left.one_lt_mul_of_le_of_lt`. -/\n@[to_additive Right.add_pos_of_nonneg_of_pos\n\"Assumes right covariance.\nThe lemma assuming left covariance is `Left.add_pos_of_nonneg_of_pos`.\"]\ntheorem Right.one_lt_mul_of_le_of_lt [MulRightMono α] {a b : α}\n    (ha : 1 ≤ a) (hb : 1 < b) :\n    1 < a * b :=\n  lt_mul_of_one_le_of_lt ha hb\n\n"}
{"name":"Right.one_lt_mul","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : MulOneClass α\ninst✝¹ : Preorder α\ninst✝ : MulRightStrictMono α\na b : α\nha : LT.lt 1 a\nhb : LT.lt 1 b\n⊢ LT.lt 1 (HMul.hMul a b)","decl":"/-- Assumes right covariance.\nThe lemma assuming left covariance is `Left.one_lt_mul`. -/\n@[to_additive Right.add_pos \"Assumes right covariance.\nThe lemma assuming left covariance is `Left.add_pos`.\"]\ntheorem Right.one_lt_mul [MulRightStrictMono α] {a b : α} (ha : 1 < a)\n    (hb : 1 < b) :\n    1 < a * b :=\n  lt_mul_of_one_lt_of_lt ha hb\n\n"}
{"name":"Right.add_pos","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : AddZeroClass α\ninst✝¹ : Preorder α\ninst✝ : AddRightStrictMono α\na b : α\nha : LT.lt 0 a\nhb : LT.lt 0 b\n⊢ LT.lt 0 (HAdd.hAdd a b)","decl":"/-- Assumes right covariance.\nThe lemma assuming left covariance is `Left.one_lt_mul`. -/\n@[to_additive Right.add_pos \"Assumes right covariance.\nThe lemma assuming left covariance is `Left.add_pos`.\"]\ntheorem Right.one_lt_mul [MulRightStrictMono α] {a b : α} (ha : 1 < a)\n    (hb : 1 < b) :\n    1 < a * b :=\n  lt_mul_of_one_lt_of_lt ha hb\n\n"}
{"name":"Right.add_pos'","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : AddZeroClass α\ninst✝¹ : Preorder α\ninst✝ : AddRightMono α\na b : α\nha : LT.lt 0 a\nhb : LT.lt 0 b\n⊢ LT.lt 0 (HAdd.hAdd a b)","decl":"/-- Assumes right covariance.\nThe lemma assuming left covariance is `Left.one_lt_mul'`. -/\n@[to_additive Right.add_pos' \"Assumes right covariance.\nThe lemma assuming left covariance is `Left.add_pos'`.\"]\ntheorem Right.one_lt_mul' [MulRightMono α] {a b : α} (ha : 1 < a)\n    (hb : 1 < b) :\n    1 < a * b :=\n  lt_mul_of_one_lt_of_lt' ha hb\n\n"}
{"name":"Right.one_lt_mul'","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : MulOneClass α\ninst✝¹ : Preorder α\ninst✝ : MulRightMono α\na b : α\nha : LT.lt 1 a\nhb : LT.lt 1 b\n⊢ LT.lt 1 (HMul.hMul a b)","decl":"/-- Assumes right covariance.\nThe lemma assuming left covariance is `Left.one_lt_mul'`. -/\n@[to_additive Right.add_pos' \"Assumes right covariance.\nThe lemma assuming left covariance is `Left.add_pos'`.\"]\ntheorem Right.one_lt_mul' [MulRightMono α] {a b : α} (ha : 1 < a)\n    (hb : 1 < b) :\n    1 < a * b :=\n  lt_mul_of_one_lt_of_lt' ha hb\n\n"}
{"name":"mul_le_one'","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : MulOneClass α\ninst✝¹ : Preorder α\ninst✝ : MulLeftMono α\na b : α\nha : LE.le a 1\nhb : LE.le b 1\n⊢ LE.le (HMul.hMul a b) 1","decl":"alias mul_le_one' := Left.mul_le_one\n\n"}
{"name":"mul_lt_one_of_le_of_lt","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : MulOneClass α\ninst✝¹ : Preorder α\ninst✝ : MulLeftStrictMono α\na b : α\nha : LE.le a 1\nhb : LT.lt b 1\n⊢ LT.lt (HMul.hMul a b) 1","decl":"alias mul_lt_one_of_le_of_lt := Left.mul_lt_one_of_le_of_lt\n\n"}
{"name":"mul_lt_one_of_lt_of_le","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : MulOneClass α\ninst✝¹ : Preorder α\ninst✝ : MulLeftMono α\na b : α\nha : LT.lt a 1\nhb : LE.le b 1\n⊢ LT.lt (HMul.hMul a b) 1","decl":"alias mul_lt_one_of_lt_of_le := Left.mul_lt_one_of_lt_of_le\n\n"}
{"name":"mul_lt_one","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : MulOneClass α\ninst✝¹ : Preorder α\ninst✝ : MulLeftStrictMono α\na b : α\nha : LT.lt a 1\nhb : LT.lt b 1\n⊢ LT.lt (HMul.hMul a b) 1","decl":"alias mul_lt_one := Left.mul_lt_one\n\n"}
{"name":"mul_lt_one'","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : MulOneClass α\ninst✝¹ : Preorder α\ninst✝ : MulLeftMono α\na b : α\nha : LT.lt a 1\nhb : LT.lt b 1\n⊢ LT.lt (HMul.hMul a b) 1","decl":"alias mul_lt_one' := Left.mul_lt_one'\n\n"}
{"name":"add_nonpos","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : AddZeroClass α\ninst✝¹ : Preorder α\ninst✝ : AddLeftMono α\na b : α\nha : LE.le a 0\nhb : LE.le b 0\n⊢ LE.le (HAdd.hAdd a b) 0","decl":"attribute [to_additive add_nonpos \"**Alias** of `Left.add_nonpos`.\"] mul_le_one'\n\n"}
{"name":"add_neg_of_nonpos_of_neg","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : AddZeroClass α\ninst✝¹ : Preorder α\ninst✝ : AddLeftStrictMono α\na b : α\nha : LE.le a 0\nhb : LT.lt b 0\n⊢ LT.lt (HAdd.hAdd a b) 0","decl":"attribute [to_additive add_neg_of_nonpos_of_neg \"**Alias** of `Left.add_neg_of_nonpos_of_neg`.\"]\n  mul_lt_one_of_le_of_lt\n\n"}
{"name":"add_neg_of_neg_of_nonpos","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : AddZeroClass α\ninst✝¹ : Preorder α\ninst✝ : AddLeftMono α\na b : α\nha : LT.lt a 0\nhb : LE.le b 0\n⊢ LT.lt (HAdd.hAdd a b) 0","decl":"attribute [to_additive add_neg_of_neg_of_nonpos \"**Alias** of `Left.add_neg_of_neg_of_nonpos`.\"]\n  mul_lt_one_of_lt_of_le\n\n"}
{"name":"add_neg","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : AddZeroClass α\ninst✝¹ : Preorder α\ninst✝ : AddLeftStrictMono α\na b : α\nha : LT.lt a 0\nhb : LT.lt b 0\n⊢ LT.lt (HAdd.hAdd a b) 0","decl":"attribute [to_additive \"**Alias** of `Left.add_neg`.\"] mul_lt_one\n\n"}
{"name":"add_neg'","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : AddZeroClass α\ninst✝¹ : Preorder α\ninst✝ : AddLeftMono α\na b : α\nha : LT.lt a 0\nhb : LT.lt b 0\n⊢ LT.lt (HAdd.hAdd a b) 0","decl":"attribute [to_additive \"**Alias** of `Left.add_neg'`.\"] mul_lt_one'\n\n"}
{"name":"one_le_mul","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : MulOneClass α\ninst✝¹ : Preorder α\ninst✝ : MulLeftMono α\na b : α\nha : LE.le 1 a\nhb : LE.le 1 b\n⊢ LE.le 1 (HMul.hMul a b)","decl":"alias one_le_mul := Left.one_le_mul\n\n"}
{"name":"one_lt_mul_of_le_of_lt'","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : MulOneClass α\ninst✝¹ : Preorder α\ninst✝ : MulLeftStrictMono α\na b : α\nha : LE.le 1 a\nhb : LT.lt 1 b\n⊢ LT.lt 1 (HMul.hMul a b)","decl":"alias one_lt_mul_of_le_of_lt' := Left.one_lt_mul_of_le_of_lt\n\n"}
{"name":"one_lt_mul_of_lt_of_le'","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : MulOneClass α\ninst✝¹ : Preorder α\ninst✝ : MulLeftMono α\na b : α\nha : LT.lt 1 a\nhb : LE.le 1 b\n⊢ LT.lt 1 (HMul.hMul a b)","decl":"alias one_lt_mul_of_lt_of_le' := Left.one_lt_mul_of_lt_of_le\n\n"}
{"name":"one_lt_mul'","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : MulOneClass α\ninst✝¹ : Preorder α\ninst✝ : MulLeftStrictMono α\na b : α\nha : LT.lt 1 a\nhb : LT.lt 1 b\n⊢ LT.lt 1 (HMul.hMul a b)","decl":"alias one_lt_mul' := Left.one_lt_mul\n\n"}
{"name":"one_lt_mul''","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : MulOneClass α\ninst✝¹ : Preorder α\ninst✝ : MulLeftMono α\na b : α\nha : LT.lt 1 a\nhb : LT.lt 1 b\n⊢ LT.lt 1 (HMul.hMul a b)","decl":"alias one_lt_mul'' := Left.one_lt_mul'\n\n"}
{"name":"add_nonneg","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : AddZeroClass α\ninst✝¹ : Preorder α\ninst✝ : AddLeftMono α\na b : α\nha : LE.le 0 a\nhb : LE.le 0 b\n⊢ LE.le 0 (HAdd.hAdd a b)","decl":"attribute [to_additive add_nonneg \"**Alias** of `Left.add_nonneg`.\"] one_le_mul\n\n"}
{"name":"add_pos_of_nonneg_of_pos","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : AddZeroClass α\ninst✝¹ : Preorder α\ninst✝ : AddLeftStrictMono α\na b : α\nha : LE.le 0 a\nhb : LT.lt 0 b\n⊢ LT.lt 0 (HAdd.hAdd a b)","decl":"attribute [to_additive add_pos_of_nonneg_of_pos \"**Alias** of `Left.add_pos_of_nonneg_of_pos`.\"]\n  one_lt_mul_of_le_of_lt'\n\n"}
{"name":"add_pos_of_pos_of_nonneg","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : AddZeroClass α\ninst✝¹ : Preorder α\ninst✝ : AddLeftMono α\na b : α\nha : LT.lt 0 a\nhb : LE.le 0 b\n⊢ LT.lt 0 (HAdd.hAdd a b)","decl":"attribute [to_additive add_pos_of_pos_of_nonneg \"**Alias** of `Left.add_pos_of_pos_of_nonneg`.\"]\n  one_lt_mul_of_lt_of_le'\n\n"}
{"name":"add_pos","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : AddZeroClass α\ninst✝¹ : Preorder α\ninst✝ : AddLeftStrictMono α\na b : α\nha : LT.lt 0 a\nhb : LT.lt 0 b\n⊢ LT.lt 0 (HAdd.hAdd a b)","decl":"attribute [to_additive add_pos \"**Alias** of `Left.add_pos`.\"] one_lt_mul'\n\n"}
{"name":"add_pos'","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : AddZeroClass α\ninst✝¹ : Preorder α\ninst✝ : AddLeftMono α\na b : α\nha : LT.lt 0 a\nhb : LT.lt 0 b\n⊢ LT.lt 0 (HAdd.hAdd a b)","decl":"attribute [to_additive add_pos' \"**Alias** of `Left.add_pos'`.\"] one_lt_mul''\n\n"}
{"name":"lt_of_mul_lt_of_one_le_left","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : MulOneClass α\ninst✝¹ : Preorder α\ninst✝ : MulLeftMono α\na b c : α\nh : LT.lt (HMul.hMul a b) c\nhle : LE.le 1 b\n⊢ LT.lt a c","decl":"@[to_additive]\ntheorem lt_of_mul_lt_of_one_le_left [MulLeftMono α] {a b c : α} (h : a * b < c)\n    (hle : 1 ≤ b) :\n    a < c :=\n  (le_mul_of_one_le_right' hle).trans_lt h\n\n"}
{"name":"lt_of_add_lt_of_nonneg_left","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : AddZeroClass α\ninst✝¹ : Preorder α\ninst✝ : AddLeftMono α\na b c : α\nh : LT.lt (HAdd.hAdd a b) c\nhle : LE.le 0 b\n⊢ LT.lt a c","decl":"@[to_additive]\ntheorem lt_of_mul_lt_of_one_le_left [MulLeftMono α] {a b c : α} (h : a * b < c)\n    (hle : 1 ≤ b) :\n    a < c :=\n  (le_mul_of_one_le_right' hle).trans_lt h\n\n"}
{"name":"le_of_mul_le_of_one_le_left","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : MulOneClass α\ninst✝¹ : Preorder α\ninst✝ : MulLeftMono α\na b c : α\nh : LE.le (HMul.hMul a b) c\nhle : LE.le 1 b\n⊢ LE.le a c","decl":"@[to_additive]\ntheorem le_of_mul_le_of_one_le_left [MulLeftMono α] {a b c : α} (h : a * b ≤ c)\n    (hle : 1 ≤ b) :\n    a ≤ c :=\n  (le_mul_of_one_le_right' hle).trans h\n\n"}
{"name":"le_of_add_le_of_nonneg_left","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : AddZeroClass α\ninst✝¹ : Preorder α\ninst✝ : AddLeftMono α\na b c : α\nh : LE.le (HAdd.hAdd a b) c\nhle : LE.le 0 b\n⊢ LE.le a c","decl":"@[to_additive]\ntheorem le_of_mul_le_of_one_le_left [MulLeftMono α] {a b c : α} (h : a * b ≤ c)\n    (hle : 1 ≤ b) :\n    a ≤ c :=\n  (le_mul_of_one_le_right' hle).trans h\n\n"}
{"name":"lt_of_lt_mul_of_le_one_left","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : MulOneClass α\ninst✝¹ : Preorder α\ninst✝ : MulLeftMono α\na b c : α\nh : LT.lt a (HMul.hMul b c)\nhle : LE.le c 1\n⊢ LT.lt a b","decl":"@[to_additive]\ntheorem lt_of_lt_mul_of_le_one_left [MulLeftMono α] {a b c : α} (h : a < b * c)\n    (hle : c ≤ 1) :\n    a < b :=\n  h.trans_le (mul_le_of_le_one_right' hle)\n\n"}
{"name":"lt_of_lt_add_of_nonpos_left","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : AddZeroClass α\ninst✝¹ : Preorder α\ninst✝ : AddLeftMono α\na b c : α\nh : LT.lt a (HAdd.hAdd b c)\nhle : LE.le c 0\n⊢ LT.lt a b","decl":"@[to_additive]\ntheorem lt_of_lt_mul_of_le_one_left [MulLeftMono α] {a b c : α} (h : a < b * c)\n    (hle : c ≤ 1) :\n    a < b :=\n  h.trans_le (mul_le_of_le_one_right' hle)\n\n"}
{"name":"le_of_le_mul_of_le_one_left","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : MulOneClass α\ninst✝¹ : Preorder α\ninst✝ : MulLeftMono α\na b c : α\nh : LE.le a (HMul.hMul b c)\nhle : LE.le c 1\n⊢ LE.le a b","decl":"@[to_additive]\ntheorem le_of_le_mul_of_le_one_left [MulLeftMono α] {a b c : α} (h : a ≤ b * c)\n    (hle : c ≤ 1) :\n    a ≤ b :=\n  h.trans (mul_le_of_le_one_right' hle)\n\n"}
{"name":"le_of_le_add_of_nonpos_left","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : AddZeroClass α\ninst✝¹ : Preorder α\ninst✝ : AddLeftMono α\na b c : α\nh : LE.le a (HAdd.hAdd b c)\nhle : LE.le c 0\n⊢ LE.le a b","decl":"@[to_additive]\ntheorem le_of_le_mul_of_le_one_left [MulLeftMono α] {a b c : α} (h : a ≤ b * c)\n    (hle : c ≤ 1) :\n    a ≤ b :=\n  h.trans (mul_le_of_le_one_right' hle)\n\n"}
{"name":"lt_of_mul_lt_of_one_le_right","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : MulOneClass α\ninst✝¹ : Preorder α\ninst✝ : MulRightMono α\na b c : α\nh : LT.lt (HMul.hMul a b) c\nhle : LE.le 1 a\n⊢ LT.lt b c","decl":"@[to_additive]\ntheorem lt_of_mul_lt_of_one_le_right [MulRightMono α] {a b c : α}\n    (h : a * b < c) (hle : 1 ≤ a) :\n    b < c :=\n  (le_mul_of_one_le_left' hle).trans_lt h\n\n"}
{"name":"lt_of_add_lt_of_nonneg_right","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : AddZeroClass α\ninst✝¹ : Preorder α\ninst✝ : AddRightMono α\na b c : α\nh : LT.lt (HAdd.hAdd a b) c\nhle : LE.le 0 a\n⊢ LT.lt b c","decl":"@[to_additive]\ntheorem lt_of_mul_lt_of_one_le_right [MulRightMono α] {a b c : α}\n    (h : a * b < c) (hle : 1 ≤ a) :\n    b < c :=\n  (le_mul_of_one_le_left' hle).trans_lt h\n\n"}
{"name":"le_of_add_le_of_nonneg_right","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : AddZeroClass α\ninst✝¹ : Preorder α\ninst✝ : AddRightMono α\na b c : α\nh : LE.le (HAdd.hAdd a b) c\nhle : LE.le 0 a\n⊢ LE.le b c","decl":"@[to_additive]\ntheorem le_of_mul_le_of_one_le_right [MulRightMono α] {a b c : α}\n    (h : a * b ≤ c) (hle : 1 ≤ a) :\n    b ≤ c :=\n  (le_mul_of_one_le_left' hle).trans h\n\n"}
{"name":"le_of_mul_le_of_one_le_right","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : MulOneClass α\ninst✝¹ : Preorder α\ninst✝ : MulRightMono α\na b c : α\nh : LE.le (HMul.hMul a b) c\nhle : LE.le 1 a\n⊢ LE.le b c","decl":"@[to_additive]\ntheorem le_of_mul_le_of_one_le_right [MulRightMono α] {a b c : α}\n    (h : a * b ≤ c) (hle : 1 ≤ a) :\n    b ≤ c :=\n  (le_mul_of_one_le_left' hle).trans h\n\n"}
{"name":"lt_of_lt_add_of_nonpos_right","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : AddZeroClass α\ninst✝¹ : Preorder α\ninst✝ : AddRightMono α\na b c : α\nh : LT.lt a (HAdd.hAdd b c)\nhle : LE.le b 0\n⊢ LT.lt a c","decl":"@[to_additive]\ntheorem lt_of_lt_mul_of_le_one_right [MulRightMono α] {a b c : α}\n    (h : a < b * c) (hle : b ≤ 1) :\n    a < c :=\n  h.trans_le (mul_le_of_le_one_left' hle)\n\n"}
{"name":"lt_of_lt_mul_of_le_one_right","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : MulOneClass α\ninst✝¹ : Preorder α\ninst✝ : MulRightMono α\na b c : α\nh : LT.lt a (HMul.hMul b c)\nhle : LE.le b 1\n⊢ LT.lt a c","decl":"@[to_additive]\ntheorem lt_of_lt_mul_of_le_one_right [MulRightMono α] {a b c : α}\n    (h : a < b * c) (hle : b ≤ 1) :\n    a < c :=\n  h.trans_le (mul_le_of_le_one_left' hle)\n\n"}
{"name":"le_of_le_add_of_nonpos_right","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : AddZeroClass α\ninst✝¹ : Preorder α\ninst✝ : AddRightMono α\na b c : α\nh : LE.le a (HAdd.hAdd b c)\nhle : LE.le b 0\n⊢ LE.le a c","decl":"@[to_additive]\ntheorem le_of_le_mul_of_le_one_right [MulRightMono α] {a b c : α}\n    (h : a ≤ b * c) (hle : b ≤ 1) :\n    a ≤ c :=\n  h.trans (mul_le_of_le_one_left' hle)\n\n"}
{"name":"le_of_le_mul_of_le_one_right","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : MulOneClass α\ninst✝¹ : Preorder α\ninst✝ : MulRightMono α\na b c : α\nh : LE.le a (HMul.hMul b c)\nhle : LE.le b 1\n⊢ LE.le a c","decl":"@[to_additive]\ntheorem le_of_le_mul_of_le_one_right [MulRightMono α] {a b c : α}\n    (h : a ≤ b * c) (hle : b ≤ 1) :\n    a ≤ c :=\n  h.trans (mul_le_of_le_one_left' hle)\n\n"}
{"name":"mul_eq_one_iff_of_one_le","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝³ : MulOneClass α\ninst✝² : PartialOrder α\ninst✝¹ : MulLeftMono α\ninst✝ : MulRightMono α\na b : α\nha : LE.le 1 a\nhb : LE.le 1 b\n⊢ Iff (Eq (HMul.hMul a b) 1) (And (Eq a 1) (Eq b 1))","decl":"@[to_additive]\ntheorem mul_eq_one_iff_of_one_le [MulLeftMono α]\n    [MulRightMono α] {a b : α} (ha : 1 ≤ a) (hb : 1 ≤ b) :\n    a * b = 1 ↔ a = 1 ∧ b = 1 :=\n  Iff.intro\n    (fun hab : a * b = 1 =>\n      have : a ≤ 1 := hab ▸ le_mul_of_le_of_one_le le_rfl hb\n      have : a = 1 := le_antisymm this ha\n      have : b ≤ 1 := hab ▸ le_mul_of_one_le_of_le ha le_rfl\n      have : b = 1 := le_antisymm this hb\n      And.intro ‹a = 1› ‹b = 1›)\n    (by rintro ⟨rfl, rfl⟩; rw [mul_one])\n\n"}
{"name":"add_eq_zero_iff_of_nonneg","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝³ : AddZeroClass α\ninst✝² : PartialOrder α\ninst✝¹ : AddLeftMono α\ninst✝ : AddRightMono α\na b : α\nha : LE.le 0 a\nhb : LE.le 0 b\n⊢ Iff (Eq (HAdd.hAdd a b) 0) (And (Eq a 0) (Eq b 0))","decl":"@[to_additive]\ntheorem mul_eq_one_iff_of_one_le [MulLeftMono α]\n    [MulRightMono α] {a b : α} (ha : 1 ≤ a) (hb : 1 ≤ b) :\n    a * b = 1 ↔ a = 1 ∧ b = 1 :=\n  Iff.intro\n    (fun hab : a * b = 1 =>\n      have : a ≤ 1 := hab ▸ le_mul_of_le_of_one_le le_rfl hb\n      have : a = 1 := le_antisymm this ha\n      have : b ≤ 1 := hab ▸ le_mul_of_one_le_of_le ha le_rfl\n      have : b = 1 := le_antisymm this hb\n      And.intro ‹a = 1› ‹b = 1›)\n    (by rintro ⟨rfl, rfl⟩; rw [mul_one])\n\n"}
{"name":"eq_one_of_one_le_mul_left","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : MulOneClass α\ninst✝¹ : PartialOrder α\ninst✝ : MulLeftMono α\na b : α\nha : LE.le a 1\nhb : LE.le b 1\nhab : LE.le 1 (HMul.hMul a b)\n⊢ Eq a 1","decl":"@[to_additive eq_zero_of_add_nonneg_left]\ntheorem eq_one_of_one_le_mul_left (ha : a ≤ 1) (hb : b ≤ 1) (hab : 1 ≤ a * b) : a = 1 :=\n  ha.eq_of_not_lt fun h => hab.not_lt <| mul_lt_one_of_lt_of_le h hb\n\n"}
{"name":"eq_zero_of_add_nonneg_left","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : AddZeroClass α\ninst✝¹ : PartialOrder α\ninst✝ : AddLeftMono α\na b : α\nha : LE.le a 0\nhb : LE.le b 0\nhab : LE.le 0 (HAdd.hAdd a b)\n⊢ Eq a 0","decl":"@[to_additive eq_zero_of_add_nonneg_left]\ntheorem eq_one_of_one_le_mul_left (ha : a ≤ 1) (hb : b ≤ 1) (hab : 1 ≤ a * b) : a = 1 :=\n  ha.eq_of_not_lt fun h => hab.not_lt <| mul_lt_one_of_lt_of_le h hb\n\n"}
{"name":"eq_one_of_mul_le_one_left","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : MulOneClass α\ninst✝¹ : PartialOrder α\ninst✝ : MulLeftMono α\na b : α\nha : LE.le 1 a\nhb : LE.le 1 b\nhab : LE.le (HMul.hMul a b) 1\n⊢ Eq a 1","decl":"@[to_additive]\ntheorem eq_one_of_mul_le_one_left (ha : 1 ≤ a) (hb : 1 ≤ b) (hab : a * b ≤ 1) : a = 1 :=\n  ha.eq_of_not_gt fun h => hab.not_lt <| one_lt_mul_of_lt_of_le' h hb\n\n"}
{"name":"eq_zero_of_add_nonpos_left","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : AddZeroClass α\ninst✝¹ : PartialOrder α\ninst✝ : AddLeftMono α\na b : α\nha : LE.le 0 a\nhb : LE.le 0 b\nhab : LE.le (HAdd.hAdd a b) 0\n⊢ Eq a 0","decl":"@[to_additive]\ntheorem eq_one_of_mul_le_one_left (ha : 1 ≤ a) (hb : 1 ≤ b) (hab : a * b ≤ 1) : a = 1 :=\n  ha.eq_of_not_gt fun h => hab.not_lt <| one_lt_mul_of_lt_of_le' h hb\n\n"}
{"name":"eq_one_of_one_le_mul_right","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : MulOneClass α\ninst✝¹ : PartialOrder α\ninst✝ : MulRightMono α\na b : α\nha : LE.le a 1\nhb : LE.le b 1\nhab : LE.le 1 (HMul.hMul a b)\n⊢ Eq b 1","decl":"@[to_additive eq_zero_of_add_nonneg_right]\ntheorem eq_one_of_one_le_mul_right (ha : a ≤ 1) (hb : b ≤ 1) (hab : 1 ≤ a * b) : b = 1 :=\n  hb.eq_of_not_lt fun h => hab.not_lt <| Right.mul_lt_one_of_le_of_lt ha h\n\n"}
{"name":"eq_zero_of_add_nonneg_right","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : AddZeroClass α\ninst✝¹ : PartialOrder α\ninst✝ : AddRightMono α\na b : α\nha : LE.le a 0\nhb : LE.le b 0\nhab : LE.le 0 (HAdd.hAdd a b)\n⊢ Eq b 0","decl":"@[to_additive eq_zero_of_add_nonneg_right]\ntheorem eq_one_of_one_le_mul_right (ha : a ≤ 1) (hb : b ≤ 1) (hab : 1 ≤ a * b) : b = 1 :=\n  hb.eq_of_not_lt fun h => hab.not_lt <| Right.mul_lt_one_of_le_of_lt ha h\n\n"}
{"name":"eq_zero_of_add_nonpos_right","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : AddZeroClass α\ninst✝¹ : PartialOrder α\ninst✝ : AddRightMono α\na b : α\nha : LE.le 0 a\nhb : LE.le 0 b\nhab : LE.le (HAdd.hAdd a b) 0\n⊢ Eq b 0","decl":"@[to_additive]\ntheorem eq_one_of_mul_le_one_right (ha : 1 ≤ a) (hb : 1 ≤ b) (hab : a * b ≤ 1) : b = 1 :=\n  hb.eq_of_not_gt fun h => hab.not_lt <| Right.one_lt_mul_of_le_of_lt ha h\n\n"}
{"name":"eq_one_of_mul_le_one_right","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : MulOneClass α\ninst✝¹ : PartialOrder α\ninst✝ : MulRightMono α\na b : α\nha : LE.le 1 a\nhb : LE.le 1 b\nhab : LE.le (HMul.hMul a b) 1\n⊢ Eq b 1","decl":"@[to_additive]\ntheorem eq_one_of_mul_le_one_right (ha : 1 ≤ a) (hb : 1 ≤ b) (hab : a * b ≤ 1) : b = 1 :=\n  hb.eq_of_not_gt fun h => hab.not_lt <| Right.one_lt_mul_of_le_of_lt ha h\n\n"}
{"name":"exists_square_le","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : MulOneClass α\ninst✝¹ : LinearOrder α\ninst✝ : MulLeftStrictMono α\na : α\n⊢ Exists fun b => LE.le (HMul.hMul b b) a","decl":"theorem exists_square_le [MulLeftStrictMono α] (a : α) : ∃ b : α, b * b ≤ a := by\n  by_cases h : a < 1\n  · use a\n    have : a * a < a * 1 := mul_lt_mul_left' h a\n    rw [mul_one] at this\n    exact le_of_lt this\n  · use 1\n    push_neg at h\n    rwa [mul_one]\n\n"}
{"name":"Monotone.const_mul'","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : Mul α\ninst✝² : Preorder α\ninst✝¹ : Preorder β\nf : β → α\ninst✝ : MulLeftMono α\nhf : Monotone f\na : α\n⊢ Monotone fun x => HMul.hMul a (f x)","decl":"@[to_additive const_add]\ntheorem Monotone.const_mul' [MulLeftMono α] (hf : Monotone f) (a : α) : Monotone fun x ↦ a * f x :=\n  mul_left_mono.comp hf\n\n"}
{"name":"Monotone.const_add","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : Add α\ninst✝² : Preorder α\ninst✝¹ : Preorder β\nf : β → α\ninst✝ : AddLeftMono α\nhf : Monotone f\na : α\n⊢ Monotone fun x => HAdd.hAdd a (f x)","decl":"@[to_additive const_add]\ntheorem Monotone.const_mul' [MulLeftMono α] (hf : Monotone f) (a : α) : Monotone fun x ↦ a * f x :=\n  mul_left_mono.comp hf\n\n"}
{"name":"MonotoneOn.const_add","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : Add α\ninst✝² : Preorder α\ninst✝¹ : Preorder β\nf : β → α\ns : Set β\ninst✝ : AddLeftMono α\nhf : MonotoneOn f s\na : α\n⊢ MonotoneOn (fun x => HAdd.hAdd a (f x)) s","decl":"@[to_additive const_add]\ntheorem MonotoneOn.const_mul' [MulLeftMono α] (hf : MonotoneOn f s) (a : α) :\n    MonotoneOn (fun x => a * f x) s := mul_left_mono.comp_monotoneOn hf\n\n"}
{"name":"MonotoneOn.const_mul'","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : Mul α\ninst✝² : Preorder α\ninst✝¹ : Preorder β\nf : β → α\ns : Set β\ninst✝ : MulLeftMono α\nhf : MonotoneOn f s\na : α\n⊢ MonotoneOn (fun x => HMul.hMul a (f x)) s","decl":"@[to_additive const_add]\ntheorem MonotoneOn.const_mul' [MulLeftMono α] (hf : MonotoneOn f s) (a : α) :\n    MonotoneOn (fun x => a * f x) s := mul_left_mono.comp_monotoneOn hf\n\n"}
{"name":"Antitone.const_add","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : Add α\ninst✝² : Preorder α\ninst✝¹ : Preorder β\nf : β → α\ninst✝ : AddLeftMono α\nhf : Antitone f\na : α\n⊢ Antitone fun x => HAdd.hAdd a (f x)","decl":"@[to_additive const_add]\ntheorem Antitone.const_mul' [MulLeftMono α] (hf : Antitone f) (a : α) : Antitone fun x ↦ a * f x :=\n  mul_left_mono.comp_antitone hf\n\n"}
{"name":"Antitone.const_mul'","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : Mul α\ninst✝² : Preorder α\ninst✝¹ : Preorder β\nf : β → α\ninst✝ : MulLeftMono α\nhf : Antitone f\na : α\n⊢ Antitone fun x => HMul.hMul a (f x)","decl":"@[to_additive const_add]\ntheorem Antitone.const_mul' [MulLeftMono α] (hf : Antitone f) (a : α) : Antitone fun x ↦ a * f x :=\n  mul_left_mono.comp_antitone hf\n\n"}
{"name":"AntitoneOn.const_add","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : Add α\ninst✝² : Preorder α\ninst✝¹ : Preorder β\nf : β → α\ns : Set β\ninst✝ : AddLeftMono α\nhf : AntitoneOn f s\na : α\n⊢ AntitoneOn (fun x => HAdd.hAdd a (f x)) s","decl":"@[to_additive const_add]\ntheorem AntitoneOn.const_mul' [MulLeftMono α] (hf : AntitoneOn f s) (a : α) :\n    AntitoneOn (fun x => a * f x) s := mul_left_mono.comp_antitoneOn hf\n\n"}
{"name":"AntitoneOn.const_mul'","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : Mul α\ninst✝² : Preorder α\ninst✝¹ : Preorder β\nf : β → α\ns : Set β\ninst✝ : MulLeftMono α\nhf : AntitoneOn f s\na : α\n⊢ AntitoneOn (fun x => HMul.hMul a (f x)) s","decl":"@[to_additive const_add]\ntheorem AntitoneOn.const_mul' [MulLeftMono α] (hf : AntitoneOn f s) (a : α) :\n    AntitoneOn (fun x => a * f x) s := mul_left_mono.comp_antitoneOn hf\n\n"}
{"name":"Monotone.mul_const'","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : Mul α\ninst✝² : Preorder α\ninst✝¹ : Preorder β\nf : β → α\ninst✝ : MulRightMono α\nhf : Monotone f\na : α\n⊢ Monotone fun x => HMul.hMul (f x) a","decl":"@[to_additive add_const]\ntheorem Monotone.mul_const' [MulRightMono α] (hf : Monotone f) (a : α) :\n    Monotone fun x => f x * a := mul_right_mono.comp hf\n\n"}
{"name":"Monotone.add_const","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : Add α\ninst✝² : Preorder α\ninst✝¹ : Preorder β\nf : β → α\ninst✝ : AddRightMono α\nhf : Monotone f\na : α\n⊢ Monotone fun x => HAdd.hAdd (f x) a","decl":"@[to_additive add_const]\ntheorem Monotone.mul_const' [MulRightMono α] (hf : Monotone f) (a : α) :\n    Monotone fun x => f x * a := mul_right_mono.comp hf\n\n"}
{"name":"MonotoneOn.add_const","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : Add α\ninst✝² : Preorder α\ninst✝¹ : Preorder β\nf : β → α\ns : Set β\ninst✝ : AddRightMono α\nhf : MonotoneOn f s\na : α\n⊢ MonotoneOn (fun x => HAdd.hAdd (f x) a) s","decl":"@[to_additive add_const]\ntheorem MonotoneOn.mul_const' [MulRightMono α] (hf : MonotoneOn f s) (a : α) :\n    MonotoneOn (fun x => f x * a) s := mul_right_mono.comp_monotoneOn hf\n\n"}
{"name":"MonotoneOn.mul_const'","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : Mul α\ninst✝² : Preorder α\ninst✝¹ : Preorder β\nf : β → α\ns : Set β\ninst✝ : MulRightMono α\nhf : MonotoneOn f s\na : α\n⊢ MonotoneOn (fun x => HMul.hMul (f x) a) s","decl":"@[to_additive add_const]\ntheorem MonotoneOn.mul_const' [MulRightMono α] (hf : MonotoneOn f s) (a : α) :\n    MonotoneOn (fun x => f x * a) s := mul_right_mono.comp_monotoneOn hf\n\n"}
{"name":"Antitone.mul_const'","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : Mul α\ninst✝² : Preorder α\ninst✝¹ : Preorder β\nf : β → α\ninst✝ : MulRightMono α\nhf : Antitone f\na : α\n⊢ Antitone fun x => HMul.hMul (f x) a","decl":"@[to_additive add_const]\ntheorem Antitone.mul_const' [MulRightMono α] (hf : Antitone f) (a : α) : Antitone fun x ↦ f x * a :=\n  mul_right_mono.comp_antitone hf\n\n"}
{"name":"Antitone.add_const","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : Add α\ninst✝² : Preorder α\ninst✝¹ : Preorder β\nf : β → α\ninst✝ : AddRightMono α\nhf : Antitone f\na : α\n⊢ Antitone fun x => HAdd.hAdd (f x) a","decl":"@[to_additive add_const]\ntheorem Antitone.mul_const' [MulRightMono α] (hf : Antitone f) (a : α) : Antitone fun x ↦ f x * a :=\n  mul_right_mono.comp_antitone hf\n\n"}
{"name":"AntitoneOn.mul_const'","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : Mul α\ninst✝² : Preorder α\ninst✝¹ : Preorder β\nf : β → α\ns : Set β\ninst✝ : MulRightMono α\nhf : AntitoneOn f s\na : α\n⊢ AntitoneOn (fun x => HMul.hMul (f x) a) s","decl":"@[to_additive add_const]\ntheorem AntitoneOn.mul_const' [MulRightMono α] (hf : AntitoneOn f s) (a : α) :\n    AntitoneOn (fun x => f x * a) s := mul_right_mono.comp_antitoneOn hf\n\n"}
{"name":"AntitoneOn.add_const","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : Add α\ninst✝² : Preorder α\ninst✝¹ : Preorder β\nf : β → α\ns : Set β\ninst✝ : AddRightMono α\nhf : AntitoneOn f s\na : α\n⊢ AntitoneOn (fun x => HAdd.hAdd (f x) a) s","decl":"@[to_additive add_const]\ntheorem AntitoneOn.mul_const' [MulRightMono α] (hf : AntitoneOn f s) (a : α) :\n    AntitoneOn (fun x => f x * a) s := mul_right_mono.comp_antitoneOn hf\n\n"}
{"name":"Monotone.add","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁴ : Add α\ninst✝³ : Preorder α\ninst✝² : Preorder β\nf g : β → α\ninst✝¹ : AddLeftMono α\ninst✝ : AddRightMono α\nhf : Monotone f\nhg : Monotone g\n⊢ Monotone fun x => HAdd.hAdd (f x) (g x)","decl":"/-- The product of two monotone functions is monotone. -/\n@[to_additive add \"The sum of two monotone functions is monotone.\"]\ntheorem Monotone.mul' [MulLeftMono α]\n    [MulRightMono α] (hf : Monotone f) (hg : Monotone g) :\n    Monotone fun x => f x * g x := fun _ _ h => mul_le_mul' (hf h) (hg h)\n\n"}
{"name":"Monotone.mul'","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁴ : Mul α\ninst✝³ : Preorder α\ninst✝² : Preorder β\nf g : β → α\ninst✝¹ : MulLeftMono α\ninst✝ : MulRightMono α\nhf : Monotone f\nhg : Monotone g\n⊢ Monotone fun x => HMul.hMul (f x) (g x)","decl":"/-- The product of two monotone functions is monotone. -/\n@[to_additive add \"The sum of two monotone functions is monotone.\"]\ntheorem Monotone.mul' [MulLeftMono α]\n    [MulRightMono α] (hf : Monotone f) (hg : Monotone g) :\n    Monotone fun x => f x * g x := fun _ _ h => mul_le_mul' (hf h) (hg h)\n\n"}
{"name":"MonotoneOn.mul'","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁴ : Mul α\ninst✝³ : Preorder α\ninst✝² : Preorder β\nf g : β → α\ns : Set β\ninst✝¹ : MulLeftMono α\ninst✝ : MulRightMono α\nhf : MonotoneOn f s\nhg : MonotoneOn g s\n⊢ MonotoneOn (fun x => HMul.hMul (f x) (g x)) s","decl":"/-- The product of two monotone functions is monotone. -/\n@[to_additive add \"The sum of two monotone functions is monotone.\"]\ntheorem MonotoneOn.mul' [MulLeftMono α]\n    [MulRightMono α] (hf : MonotoneOn f s) (hg : MonotoneOn g s) :\n    MonotoneOn (fun x => f x * g x) s := fun _ hx _ hy h =>\n  mul_le_mul' (hf hx hy h) (hg hx hy h)\n\n"}
{"name":"MonotoneOn.add","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁴ : Add α\ninst✝³ : Preorder α\ninst✝² : Preorder β\nf g : β → α\ns : Set β\ninst✝¹ : AddLeftMono α\ninst✝ : AddRightMono α\nhf : MonotoneOn f s\nhg : MonotoneOn g s\n⊢ MonotoneOn (fun x => HAdd.hAdd (f x) (g x)) s","decl":"/-- The product of two monotone functions is monotone. -/\n@[to_additive add \"The sum of two monotone functions is monotone.\"]\ntheorem MonotoneOn.mul' [MulLeftMono α]\n    [MulRightMono α] (hf : MonotoneOn f s) (hg : MonotoneOn g s) :\n    MonotoneOn (fun x => f x * g x) s := fun _ hx _ hy h =>\n  mul_le_mul' (hf hx hy h) (hg hx hy h)\n\n"}
{"name":"Antitone.add","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁴ : Add α\ninst✝³ : Preorder α\ninst✝² : Preorder β\nf g : β → α\ninst✝¹ : AddLeftMono α\ninst✝ : AddRightMono α\nhf : Antitone f\nhg : Antitone g\n⊢ Antitone fun x => HAdd.hAdd (f x) (g x)","decl":"/-- The product of two antitone functions is antitone. -/\n@[to_additive add \"The sum of two antitone functions is antitone.\"]\ntheorem Antitone.mul' [MulLeftMono α]\n    [MulRightMono α] (hf : Antitone f) (hg : Antitone g) :\n    Antitone fun x => f x * g x := fun _ _ h => mul_le_mul' (hf h) (hg h)\n\n"}
{"name":"Antitone.mul'","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁴ : Mul α\ninst✝³ : Preorder α\ninst✝² : Preorder β\nf g : β → α\ninst✝¹ : MulLeftMono α\ninst✝ : MulRightMono α\nhf : Antitone f\nhg : Antitone g\n⊢ Antitone fun x => HMul.hMul (f x) (g x)","decl":"/-- The product of two antitone functions is antitone. -/\n@[to_additive add \"The sum of two antitone functions is antitone.\"]\ntheorem Antitone.mul' [MulLeftMono α]\n    [MulRightMono α] (hf : Antitone f) (hg : Antitone g) :\n    Antitone fun x => f x * g x := fun _ _ h => mul_le_mul' (hf h) (hg h)\n\n"}
{"name":"AntitoneOn.add","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁴ : Add α\ninst✝³ : Preorder α\ninst✝² : Preorder β\nf g : β → α\ns : Set β\ninst✝¹ : AddLeftMono α\ninst✝ : AddRightMono α\nhf : AntitoneOn f s\nhg : AntitoneOn g s\n⊢ AntitoneOn (fun x => HAdd.hAdd (f x) (g x)) s","decl":"/-- The product of two antitone functions is antitone. -/\n@[to_additive add \"The sum of two antitone functions is antitone.\"]\ntheorem AntitoneOn.mul' [MulLeftMono α]\n    [MulRightMono α] (hf : AntitoneOn f s) (hg : AntitoneOn g s) :\n    AntitoneOn (fun x => f x * g x) s :=\n  fun _ hx _ hy h => mul_le_mul' (hf hx hy h) (hg hx hy h)\n\n"}
{"name":"AntitoneOn.mul'","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁴ : Mul α\ninst✝³ : Preorder α\ninst✝² : Preorder β\nf g : β → α\ns : Set β\ninst✝¹ : MulLeftMono α\ninst✝ : MulRightMono α\nhf : AntitoneOn f s\nhg : AntitoneOn g s\n⊢ AntitoneOn (fun x => HMul.hMul (f x) (g x)) s","decl":"/-- The product of two antitone functions is antitone. -/\n@[to_additive add \"The sum of two antitone functions is antitone.\"]\ntheorem AntitoneOn.mul' [MulLeftMono α]\n    [MulRightMono α] (hf : AntitoneOn f s) (hg : AntitoneOn g s) :\n    AntitoneOn (fun x => f x * g x) s :=\n  fun _ hx _ hy h => mul_le_mul' (hf hx hy h) (hg hx hy h)\n\n"}
{"name":"StrictMono.const_mul'","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : Mul α\ninst✝² : Preorder α\ninst✝¹ : Preorder β\nf : β → α\ninst✝ : MulLeftStrictMono α\nhf : StrictMono f\nc : α\n⊢ StrictMono fun x => HMul.hMul c (f x)","decl":"@[to_additive const_add]\ntheorem StrictMono.const_mul' (hf : StrictMono f) (c : α) : StrictMono fun x => c * f x :=\n  fun _ _ ab => mul_lt_mul_left' (hf ab) c\n\n"}
{"name":"StrictMono.const_add","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : Add α\ninst✝² : Preorder α\ninst✝¹ : Preorder β\nf : β → α\ninst✝ : AddLeftStrictMono α\nhf : StrictMono f\nc : α\n⊢ StrictMono fun x => HAdd.hAdd c (f x)","decl":"@[to_additive const_add]\ntheorem StrictMono.const_mul' (hf : StrictMono f) (c : α) : StrictMono fun x => c * f x :=\n  fun _ _ ab => mul_lt_mul_left' (hf ab) c\n\n"}
{"name":"StrictMonoOn.const_mul'","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : Mul α\ninst✝² : Preorder α\ninst✝¹ : Preorder β\nf : β → α\ns : Set β\ninst✝ : MulLeftStrictMono α\nhf : StrictMonoOn f s\nc : α\n⊢ StrictMonoOn (fun x => HMul.hMul c (f x)) s","decl":"@[to_additive const_add]\ntheorem StrictMonoOn.const_mul' (hf : StrictMonoOn f s) (c : α) :\n    StrictMonoOn (fun x => c * f x) s :=\n  fun _ ha _ hb ab => mul_lt_mul_left' (hf ha hb ab) c\n\n"}
{"name":"StrictMonoOn.const_add","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : Add α\ninst✝² : Preorder α\ninst✝¹ : Preorder β\nf : β → α\ns : Set β\ninst✝ : AddLeftStrictMono α\nhf : StrictMonoOn f s\nc : α\n⊢ StrictMonoOn (fun x => HAdd.hAdd c (f x)) s","decl":"@[to_additive const_add]\ntheorem StrictMonoOn.const_mul' (hf : StrictMonoOn f s) (c : α) :\n    StrictMonoOn (fun x => c * f x) s :=\n  fun _ ha _ hb ab => mul_lt_mul_left' (hf ha hb ab) c\n\n"}
{"name":"StrictAnti.const_mul'","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : Mul α\ninst✝² : Preorder α\ninst✝¹ : Preorder β\nf : β → α\ninst✝ : MulLeftStrictMono α\nhf : StrictAnti f\nc : α\n⊢ StrictAnti fun x => HMul.hMul c (f x)","decl":"@[to_additive const_add]\ntheorem StrictAnti.const_mul' (hf : StrictAnti f) (c : α) : StrictAnti fun x => c * f x :=\n  fun _ _ ab => mul_lt_mul_left' (hf ab) c\n\n"}
{"name":"StrictAnti.const_add","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : Add α\ninst✝² : Preorder α\ninst✝¹ : Preorder β\nf : β → α\ninst✝ : AddLeftStrictMono α\nhf : StrictAnti f\nc : α\n⊢ StrictAnti fun x => HAdd.hAdd c (f x)","decl":"@[to_additive const_add]\ntheorem StrictAnti.const_mul' (hf : StrictAnti f) (c : α) : StrictAnti fun x => c * f x :=\n  fun _ _ ab => mul_lt_mul_left' (hf ab) c\n\n"}
{"name":"StrictAntiOn.const_mul'","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : Mul α\ninst✝² : Preorder α\ninst✝¹ : Preorder β\nf : β → α\ns : Set β\ninst✝ : MulLeftStrictMono α\nhf : StrictAntiOn f s\nc : α\n⊢ StrictAntiOn (fun x => HMul.hMul c (f x)) s","decl":"@[to_additive const_add]\ntheorem StrictAntiOn.const_mul' (hf : StrictAntiOn f s) (c : α) :\n    StrictAntiOn (fun x => c * f x) s :=\n  fun _ ha _ hb ab => mul_lt_mul_left' (hf ha hb ab) c\n\n"}
{"name":"StrictAntiOn.const_add","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : Add α\ninst✝² : Preorder α\ninst✝¹ : Preorder β\nf : β → α\ns : Set β\ninst✝ : AddLeftStrictMono α\nhf : StrictAntiOn f s\nc : α\n⊢ StrictAntiOn (fun x => HAdd.hAdd c (f x)) s","decl":"@[to_additive const_add]\ntheorem StrictAntiOn.const_mul' (hf : StrictAntiOn f s) (c : α) :\n    StrictAntiOn (fun x => c * f x) s :=\n  fun _ ha _ hb ab => mul_lt_mul_left' (hf ha hb ab) c\n\n"}
{"name":"StrictMono.mul_const'","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : Mul α\ninst✝² : Preorder α\ninst✝¹ : Preorder β\nf : β → α\ninst✝ : MulRightStrictMono α\nhf : StrictMono f\nc : α\n⊢ StrictMono fun x => HMul.hMul (f x) c","decl":"@[to_additive add_const]\ntheorem StrictMono.mul_const' (hf : StrictMono f) (c : α) : StrictMono fun x => f x * c :=\n  fun _ _ ab => mul_lt_mul_right' (hf ab) c\n\n"}
{"name":"StrictMono.add_const","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : Add α\ninst✝² : Preorder α\ninst✝¹ : Preorder β\nf : β → α\ninst✝ : AddRightStrictMono α\nhf : StrictMono f\nc : α\n⊢ StrictMono fun x => HAdd.hAdd (f x) c","decl":"@[to_additive add_const]\ntheorem StrictMono.mul_const' (hf : StrictMono f) (c : α) : StrictMono fun x => f x * c :=\n  fun _ _ ab => mul_lt_mul_right' (hf ab) c\n\n"}
{"name":"StrictMonoOn.mul_const'","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : Mul α\ninst✝² : Preorder α\ninst✝¹ : Preorder β\nf : β → α\ns : Set β\ninst✝ : MulRightStrictMono α\nhf : StrictMonoOn f s\nc : α\n⊢ StrictMonoOn (fun x => HMul.hMul (f x) c) s","decl":"@[to_additive add_const]\ntheorem StrictMonoOn.mul_const' (hf : StrictMonoOn f s) (c : α) :\n    StrictMonoOn (fun x => f x * c) s :=\n  fun _ ha _ hb ab => mul_lt_mul_right' (hf ha hb ab) c\n\n"}
{"name":"StrictMonoOn.add_const","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : Add α\ninst✝² : Preorder α\ninst✝¹ : Preorder β\nf : β → α\ns : Set β\ninst✝ : AddRightStrictMono α\nhf : StrictMonoOn f s\nc : α\n⊢ StrictMonoOn (fun x => HAdd.hAdd (f x) c) s","decl":"@[to_additive add_const]\ntheorem StrictMonoOn.mul_const' (hf : StrictMonoOn f s) (c : α) :\n    StrictMonoOn (fun x => f x * c) s :=\n  fun _ ha _ hb ab => mul_lt_mul_right' (hf ha hb ab) c\n\n"}
{"name":"StrictAnti.add_const","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : Add α\ninst✝² : Preorder α\ninst✝¹ : Preorder β\nf : β → α\ninst✝ : AddRightStrictMono α\nhf : StrictAnti f\nc : α\n⊢ StrictAnti fun x => HAdd.hAdd (f x) c","decl":"@[to_additive add_const]\ntheorem StrictAnti.mul_const' (hf : StrictAnti f) (c : α) : StrictAnti fun x => f x * c :=\n  fun _ _ ab => mul_lt_mul_right' (hf ab) c\n\n"}
{"name":"StrictAnti.mul_const'","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : Mul α\ninst✝² : Preorder α\ninst✝¹ : Preorder β\nf : β → α\ninst✝ : MulRightStrictMono α\nhf : StrictAnti f\nc : α\n⊢ StrictAnti fun x => HMul.hMul (f x) c","decl":"@[to_additive add_const]\ntheorem StrictAnti.mul_const' (hf : StrictAnti f) (c : α) : StrictAnti fun x => f x * c :=\n  fun _ _ ab => mul_lt_mul_right' (hf ab) c\n\n"}
{"name":"StrictAntiOn.mul_const'","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : Mul α\ninst✝² : Preorder α\ninst✝¹ : Preorder β\nf : β → α\ns : Set β\ninst✝ : MulRightStrictMono α\nhf : StrictAntiOn f s\nc : α\n⊢ StrictAntiOn (fun x => HMul.hMul (f x) c) s","decl":"@[to_additive add_const]\ntheorem StrictAntiOn.mul_const' (hf : StrictAntiOn f s) (c : α) :\n    StrictAntiOn (fun x => f x * c) s :=\n  fun _ ha _ hb ab => mul_lt_mul_right' (hf ha hb ab) c\n\n"}
{"name":"StrictAntiOn.add_const","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : Add α\ninst✝² : Preorder α\ninst✝¹ : Preorder β\nf : β → α\ns : Set β\ninst✝ : AddRightStrictMono α\nhf : StrictAntiOn f s\nc : α\n⊢ StrictAntiOn (fun x => HAdd.hAdd (f x) c) s","decl":"@[to_additive add_const]\ntheorem StrictAntiOn.mul_const' (hf : StrictAntiOn f s) (c : α) :\n    StrictAntiOn (fun x => f x * c) s :=\n  fun _ ha _ hb ab => mul_lt_mul_right' (hf ha hb ab) c\n\n"}
{"name":"StrictMono.add","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁴ : Add α\ninst✝³ : Preorder α\ninst✝² : Preorder β\nf g : β → α\ninst✝¹ : AddLeftStrictMono α\ninst✝ : AddRightStrictMono α\nhf : StrictMono f\nhg : StrictMono g\n⊢ StrictMono fun x => HAdd.hAdd (f x) (g x)","decl":"/-- The product of two strictly monotone functions is strictly monotone. -/\n@[to_additive add \"The sum of two strictly monotone functions is strictly monotone.\"]\ntheorem StrictMono.mul' [MulLeftStrictMono α]\n    [MulRightStrictMono α] (hf : StrictMono f) (hg : StrictMono g) :\n    StrictMono fun x => f x * g x := fun _ _ ab =>\n  mul_lt_mul_of_lt_of_lt (hf ab) (hg ab)\n\n"}
{"name":"StrictMono.mul'","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁴ : Mul α\ninst✝³ : Preorder α\ninst✝² : Preorder β\nf g : β → α\ninst✝¹ : MulLeftStrictMono α\ninst✝ : MulRightStrictMono α\nhf : StrictMono f\nhg : StrictMono g\n⊢ StrictMono fun x => HMul.hMul (f x) (g x)","decl":"/-- The product of two strictly monotone functions is strictly monotone. -/\n@[to_additive add \"The sum of two strictly monotone functions is strictly monotone.\"]\ntheorem StrictMono.mul' [MulLeftStrictMono α]\n    [MulRightStrictMono α] (hf : StrictMono f) (hg : StrictMono g) :\n    StrictMono fun x => f x * g x := fun _ _ ab =>\n  mul_lt_mul_of_lt_of_lt (hf ab) (hg ab)\n\n"}
{"name":"StrictMonoOn.add","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁴ : Add α\ninst✝³ : Preorder α\ninst✝² : Preorder β\nf g : β → α\ns : Set β\ninst✝¹ : AddLeftStrictMono α\ninst✝ : AddRightStrictMono α\nhf : StrictMonoOn f s\nhg : StrictMonoOn g s\n⊢ StrictMonoOn (fun x => HAdd.hAdd (f x) (g x)) s","decl":"/-- The product of two strictly monotone functions is strictly monotone. -/\n@[to_additive add \"The sum of two strictly monotone functions is strictly monotone.\"]\ntheorem StrictMonoOn.mul' [MulLeftStrictMono α]\n    [MulRightStrictMono α] (hf : StrictMonoOn f s) (hg : StrictMonoOn g s) :\n    StrictMonoOn (fun x => f x * g x) s :=\n  fun _ ha _ hb ab => mul_lt_mul_of_lt_of_lt (hf ha hb ab) (hg ha hb ab)\n\n"}
{"name":"StrictMonoOn.mul'","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁴ : Mul α\ninst✝³ : Preorder α\ninst✝² : Preorder β\nf g : β → α\ns : Set β\ninst✝¹ : MulLeftStrictMono α\ninst✝ : MulRightStrictMono α\nhf : StrictMonoOn f s\nhg : StrictMonoOn g s\n⊢ StrictMonoOn (fun x => HMul.hMul (f x) (g x)) s","decl":"/-- The product of two strictly monotone functions is strictly monotone. -/\n@[to_additive add \"The sum of two strictly monotone functions is strictly monotone.\"]\ntheorem StrictMonoOn.mul' [MulLeftStrictMono α]\n    [MulRightStrictMono α] (hf : StrictMonoOn f s) (hg : StrictMonoOn g s) :\n    StrictMonoOn (fun x => f x * g x) s :=\n  fun _ ha _ hb ab => mul_lt_mul_of_lt_of_lt (hf ha hb ab) (hg ha hb ab)\n\n"}
{"name":"StrictAnti.add","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁴ : Add α\ninst✝³ : Preorder α\ninst✝² : Preorder β\nf g : β → α\ninst✝¹ : AddLeftStrictMono α\ninst✝ : AddRightStrictMono α\nhf : StrictAnti f\nhg : StrictAnti g\n⊢ StrictAnti fun x => HAdd.hAdd (f x) (g x)","decl":"/-- The product of two strictly antitone functions is strictly antitone. -/\n@[to_additive add \"The sum of two strictly antitone functions is strictly antitone.\"]\ntheorem StrictAnti.mul' [MulLeftStrictMono α]\n    [MulRightStrictMono α] (hf : StrictAnti f) (hg : StrictAnti g) :\n    StrictAnti fun x => f x * g x :=\n  fun _ _ ab => mul_lt_mul_of_lt_of_lt (hf ab) (hg ab)\n\n"}
{"name":"StrictAnti.mul'","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁴ : Mul α\ninst✝³ : Preorder α\ninst✝² : Preorder β\nf g : β → α\ninst✝¹ : MulLeftStrictMono α\ninst✝ : MulRightStrictMono α\nhf : StrictAnti f\nhg : StrictAnti g\n⊢ StrictAnti fun x => HMul.hMul (f x) (g x)","decl":"/-- The product of two strictly antitone functions is strictly antitone. -/\n@[to_additive add \"The sum of two strictly antitone functions is strictly antitone.\"]\ntheorem StrictAnti.mul' [MulLeftStrictMono α]\n    [MulRightStrictMono α] (hf : StrictAnti f) (hg : StrictAnti g) :\n    StrictAnti fun x => f x * g x :=\n  fun _ _ ab => mul_lt_mul_of_lt_of_lt (hf ab) (hg ab)\n\n"}
{"name":"StrictAntiOn.add","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁴ : Add α\ninst✝³ : Preorder α\ninst✝² : Preorder β\nf g : β → α\ns : Set β\ninst✝¹ : AddLeftStrictMono α\ninst✝ : AddRightStrictMono α\nhf : StrictAntiOn f s\nhg : StrictAntiOn g s\n⊢ StrictAntiOn (fun x => HAdd.hAdd (f x) (g x)) s","decl":"/-- The product of two strictly antitone functions is strictly antitone. -/\n@[to_additive add \"The sum of two strictly antitone functions is strictly antitone.\"]\ntheorem StrictAntiOn.mul' [MulLeftStrictMono α]\n    [MulRightStrictMono α] (hf : StrictAntiOn f s) (hg : StrictAntiOn g s) :\n    StrictAntiOn (fun x => f x * g x) s :=\n  fun _ ha _ hb ab => mul_lt_mul_of_lt_of_lt (hf ha hb ab) (hg ha hb ab)\n\n"}
{"name":"StrictAntiOn.mul'","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁴ : Mul α\ninst✝³ : Preorder α\ninst✝² : Preorder β\nf g : β → α\ns : Set β\ninst✝¹ : MulLeftStrictMono α\ninst✝ : MulRightStrictMono α\nhf : StrictAntiOn f s\nhg : StrictAntiOn g s\n⊢ StrictAntiOn (fun x => HMul.hMul (f x) (g x)) s","decl":"/-- The product of two strictly antitone functions is strictly antitone. -/\n@[to_additive add \"The sum of two strictly antitone functions is strictly antitone.\"]\ntheorem StrictAntiOn.mul' [MulLeftStrictMono α]\n    [MulRightStrictMono α] (hf : StrictAntiOn f s) (hg : StrictAntiOn g s) :\n    StrictAntiOn (fun x => f x * g x) s :=\n  fun _ ha _ hb ab => mul_lt_mul_of_lt_of_lt (hf ha hb ab) (hg ha hb ab)\n\n"}
{"name":"Monotone.add_strictMono","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁴ : Add α\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : AddLeftStrictMono α\ninst✝ : AddRightMono α\nf g : β → α\nhf : Monotone f\nhg : StrictMono g\n⊢ StrictMono fun x => HAdd.hAdd (f x) (g x)","decl":"/-- The product of a monotone function and a strictly monotone function is strictly monotone. -/\n@[to_additive add_strictMono \"The sum of a monotone function and a strictly monotone function is\nstrictly monotone.\"]\ntheorem Monotone.mul_strictMono' [MulLeftStrictMono α]\n    [MulRightMono α] {f g : β → α} (hf : Monotone f)\n    (hg : StrictMono g) :\n    StrictMono fun x => f x * g x :=\n  fun _ _ h => mul_lt_mul_of_le_of_lt (hf h.le) (hg h)\n\n"}
{"name":"Monotone.mul_strictMono'","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁴ : Mul α\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : MulLeftStrictMono α\ninst✝ : MulRightMono α\nf g : β → α\nhf : Monotone f\nhg : StrictMono g\n⊢ StrictMono fun x => HMul.hMul (f x) (g x)","decl":"/-- The product of a monotone function and a strictly monotone function is strictly monotone. -/\n@[to_additive add_strictMono \"The sum of a monotone function and a strictly monotone function is\nstrictly monotone.\"]\ntheorem Monotone.mul_strictMono' [MulLeftStrictMono α]\n    [MulRightMono α] {f g : β → α} (hf : Monotone f)\n    (hg : StrictMono g) :\n    StrictMono fun x => f x * g x :=\n  fun _ _ h => mul_lt_mul_of_le_of_lt (hf h.le) (hg h)\n\n"}
{"name":"MonotoneOn.mul_strictMono'","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁴ : Mul α\ninst✝³ : Preorder α\ninst✝² : Preorder β\ns : Set β\ninst✝¹ : MulLeftStrictMono α\ninst✝ : MulRightMono α\nf g : β → α\nhf : MonotoneOn f s\nhg : StrictMonoOn g s\n⊢ StrictMonoOn (fun x => HMul.hMul (f x) (g x)) s","decl":"/-- The product of a monotone function and a strictly monotone function is strictly monotone. -/\n@[to_additive add_strictMono \"The sum of a monotone function and a strictly monotone function is\nstrictly monotone.\"]\ntheorem MonotoneOn.mul_strictMono' [MulLeftStrictMono α]\n    [MulRightMono α] {f g : β → α} (hf : MonotoneOn f s)\n    (hg : StrictMonoOn g s) : StrictMonoOn (fun x => f x * g x) s :=\n  fun _ hx _ hy h => mul_lt_mul_of_le_of_lt (hf hx hy h.le) (hg hx hy h)\n\n"}
{"name":"MonotoneOn.add_strictMono","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁴ : Add α\ninst✝³ : Preorder α\ninst✝² : Preorder β\ns : Set β\ninst✝¹ : AddLeftStrictMono α\ninst✝ : AddRightMono α\nf g : β → α\nhf : MonotoneOn f s\nhg : StrictMonoOn g s\n⊢ StrictMonoOn (fun x => HAdd.hAdd (f x) (g x)) s","decl":"/-- The product of a monotone function and a strictly monotone function is strictly monotone. -/\n@[to_additive add_strictMono \"The sum of a monotone function and a strictly monotone function is\nstrictly monotone.\"]\ntheorem MonotoneOn.mul_strictMono' [MulLeftStrictMono α]\n    [MulRightMono α] {f g : β → α} (hf : MonotoneOn f s)\n    (hg : StrictMonoOn g s) : StrictMonoOn (fun x => f x * g x) s :=\n  fun _ hx _ hy h => mul_lt_mul_of_le_of_lt (hf hx hy h.le) (hg hx hy h)\n\n"}
{"name":"Antitone.mul_strictAnti'","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁴ : Mul α\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : MulLeftStrictMono α\ninst✝ : MulRightMono α\nf g : β → α\nhf : Antitone f\nhg : StrictAnti g\n⊢ StrictAnti fun x => HMul.hMul (f x) (g x)","decl":"/-- The product of an antitone function and a strictly antitone function is strictly antitone. -/\n@[to_additive add_strictAnti \"The sum of an antitone function and a strictly antitone function is\nstrictly antitone.\"]\ntheorem Antitone.mul_strictAnti' [MulLeftStrictMono α]\n    [MulRightMono α] {f g : β → α} (hf : Antitone f)\n    (hg : StrictAnti g) :\n    StrictAnti fun x => f x * g x :=\n  fun _ _ h => mul_lt_mul_of_le_of_lt (hf h.le) (hg h)\n\n"}
{"name":"Antitone.add_strictAnti","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁴ : Add α\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : AddLeftStrictMono α\ninst✝ : AddRightMono α\nf g : β → α\nhf : Antitone f\nhg : StrictAnti g\n⊢ StrictAnti fun x => HAdd.hAdd (f x) (g x)","decl":"/-- The product of an antitone function and a strictly antitone function is strictly antitone. -/\n@[to_additive add_strictAnti \"The sum of an antitone function and a strictly antitone function is\nstrictly antitone.\"]\ntheorem Antitone.mul_strictAnti' [MulLeftStrictMono α]\n    [MulRightMono α] {f g : β → α} (hf : Antitone f)\n    (hg : StrictAnti g) :\n    StrictAnti fun x => f x * g x :=\n  fun _ _ h => mul_lt_mul_of_le_of_lt (hf h.le) (hg h)\n\n"}
{"name":"AntitoneOn.add_strictAnti","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁴ : Add α\ninst✝³ : Preorder α\ninst✝² : Preorder β\ns : Set β\ninst✝¹ : AddLeftStrictMono α\ninst✝ : AddRightMono α\nf g : β → α\nhf : AntitoneOn f s\nhg : StrictAntiOn g s\n⊢ StrictAntiOn (fun x => HAdd.hAdd (f x) (g x)) s","decl":"/-- The product of an antitone function and a strictly antitone function is strictly antitone. -/\n@[to_additive add_strictAnti \"The sum of an antitone function and a strictly antitone function is\nstrictly antitone.\"]\ntheorem AntitoneOn.mul_strictAnti' [MulLeftStrictMono α]\n    [MulRightMono α] {f g : β → α} (hf : AntitoneOn f s)\n    (hg : StrictAntiOn g s) :\n    StrictAntiOn (fun x => f x * g x) s :=\n  fun _ hx _ hy h => mul_lt_mul_of_le_of_lt (hf hx hy h.le) (hg hx hy h)\n\n"}
{"name":"AntitoneOn.mul_strictAnti'","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁴ : Mul α\ninst✝³ : Preorder α\ninst✝² : Preorder β\ns : Set β\ninst✝¹ : MulLeftStrictMono α\ninst✝ : MulRightMono α\nf g : β → α\nhf : AntitoneOn f s\nhg : StrictAntiOn g s\n⊢ StrictAntiOn (fun x => HMul.hMul (f x) (g x)) s","decl":"/-- The product of an antitone function and a strictly antitone function is strictly antitone. -/\n@[to_additive add_strictAnti \"The sum of an antitone function and a strictly antitone function is\nstrictly antitone.\"]\ntheorem AntitoneOn.mul_strictAnti' [MulLeftStrictMono α]\n    [MulRightMono α] {f g : β → α} (hf : AntitoneOn f s)\n    (hg : StrictAntiOn g s) :\n    StrictAntiOn (fun x => f x * g x) s :=\n  fun _ hx _ hy h => mul_lt_mul_of_le_of_lt (hf hx hy h.le) (hg hx hy h)\n\n"}
{"name":"StrictMono.mul_monotone'","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁴ : Mul α\ninst✝³ : Preorder α\ninst✝² : Preorder β\nf g : β → α\ninst✝¹ : MulLeftMono α\ninst✝ : MulRightStrictMono α\nhf : StrictMono f\nhg : Monotone g\n⊢ StrictMono fun x => HMul.hMul (f x) (g x)","decl":"/-- The product of a strictly monotone function and a monotone function is strictly monotone. -/\n@[to_additive add_monotone \"The sum of a strictly monotone function and a monotone function is\nstrictly monotone.\"]\ntheorem StrictMono.mul_monotone' (hf : StrictMono f) (hg : Monotone g) :\n    StrictMono fun x => f x * g x :=\n  fun _ _ h => mul_lt_mul_of_lt_of_le (hf h) (hg h.le)\n\n"}
{"name":"StrictMono.add_monotone","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁴ : Add α\ninst✝³ : Preorder α\ninst✝² : Preorder β\nf g : β → α\ninst✝¹ : AddLeftMono α\ninst✝ : AddRightStrictMono α\nhf : StrictMono f\nhg : Monotone g\n⊢ StrictMono fun x => HAdd.hAdd (f x) (g x)","decl":"/-- The product of a strictly monotone function and a monotone function is strictly monotone. -/\n@[to_additive add_monotone \"The sum of a strictly monotone function and a monotone function is\nstrictly monotone.\"]\ntheorem StrictMono.mul_monotone' (hf : StrictMono f) (hg : Monotone g) :\n    StrictMono fun x => f x * g x :=\n  fun _ _ h => mul_lt_mul_of_lt_of_le (hf h) (hg h.le)\n\n"}
{"name":"StrictMonoOn.mul_monotone'","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁴ : Mul α\ninst✝³ : Preorder α\ninst✝² : Preorder β\nf g : β → α\ns : Set β\ninst✝¹ : MulLeftMono α\ninst✝ : MulRightStrictMono α\nhf : StrictMonoOn f s\nhg : MonotoneOn g s\n⊢ StrictMonoOn (fun x => HMul.hMul (f x) (g x)) s","decl":"/-- The product of a strictly monotone function and a monotone function is strictly monotone. -/\n@[to_additive add_monotone \"The sum of a strictly monotone function and a monotone function is\nstrictly monotone.\"]\ntheorem StrictMonoOn.mul_monotone' (hf : StrictMonoOn f s) (hg : MonotoneOn g s) :\n    StrictMonoOn (fun x => f x * g x) s :=\n  fun _ hx _ hy h => mul_lt_mul_of_lt_of_le (hf hx hy h) (hg hx hy h.le)\n\n"}
{"name":"StrictMonoOn.add_monotone","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁴ : Add α\ninst✝³ : Preorder α\ninst✝² : Preorder β\nf g : β → α\ns : Set β\ninst✝¹ : AddLeftMono α\ninst✝ : AddRightStrictMono α\nhf : StrictMonoOn f s\nhg : MonotoneOn g s\n⊢ StrictMonoOn (fun x => HAdd.hAdd (f x) (g x)) s","decl":"/-- The product of a strictly monotone function and a monotone function is strictly monotone. -/\n@[to_additive add_monotone \"The sum of a strictly monotone function and a monotone function is\nstrictly monotone.\"]\ntheorem StrictMonoOn.mul_monotone' (hf : StrictMonoOn f s) (hg : MonotoneOn g s) :\n    StrictMonoOn (fun x => f x * g x) s :=\n  fun _ hx _ hy h => mul_lt_mul_of_lt_of_le (hf hx hy h) (hg hx hy h.le)\n\n"}
{"name":"StrictAnti.add_antitone","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁴ : Add α\ninst✝³ : Preorder α\ninst✝² : Preorder β\nf g : β → α\ninst✝¹ : AddLeftMono α\ninst✝ : AddRightStrictMono α\nhf : StrictAnti f\nhg : Antitone g\n⊢ StrictAnti fun x => HAdd.hAdd (f x) (g x)","decl":"/-- The product of a strictly antitone function and an antitone function is strictly antitone. -/\n@[to_additive add_antitone \"The sum of a strictly antitone function and an antitone function is\nstrictly antitone.\"]\ntheorem StrictAnti.mul_antitone' (hf : StrictAnti f) (hg : Antitone g) :\n    StrictAnti fun x => f x * g x :=\n  fun _ _ h => mul_lt_mul_of_lt_of_le (hf h) (hg h.le)\n\n"}
{"name":"StrictAnti.mul_antitone'","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁴ : Mul α\ninst✝³ : Preorder α\ninst✝² : Preorder β\nf g : β → α\ninst✝¹ : MulLeftMono α\ninst✝ : MulRightStrictMono α\nhf : StrictAnti f\nhg : Antitone g\n⊢ StrictAnti fun x => HMul.hMul (f x) (g x)","decl":"/-- The product of a strictly antitone function and an antitone function is strictly antitone. -/\n@[to_additive add_antitone \"The sum of a strictly antitone function and an antitone function is\nstrictly antitone.\"]\ntheorem StrictAnti.mul_antitone' (hf : StrictAnti f) (hg : Antitone g) :\n    StrictAnti fun x => f x * g x :=\n  fun _ _ h => mul_lt_mul_of_lt_of_le (hf h) (hg h.le)\n\n"}
{"name":"StrictAntiOn.add_antitone","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁴ : Add α\ninst✝³ : Preorder α\ninst✝² : Preorder β\nf g : β → α\ns : Set β\ninst✝¹ : AddLeftMono α\ninst✝ : AddRightStrictMono α\nhf : StrictAntiOn f s\nhg : AntitoneOn g s\n⊢ StrictAntiOn (fun x => HAdd.hAdd (f x) (g x)) s","decl":"/-- The product of a strictly antitone function and an antitone function is strictly antitone. -/\n@[to_additive add_antitone \"The sum of a strictly antitone function and an antitone function is\nstrictly antitone.\"]\ntheorem StrictAntiOn.mul_antitone' (hf : StrictAntiOn f s) (hg : AntitoneOn g s) :\n    StrictAntiOn (fun x => f x * g x) s :=\n  fun _ hx _ hy h => mul_lt_mul_of_lt_of_le (hf hx hy h) (hg hx hy h.le)\n\n"}
{"name":"StrictAntiOn.mul_antitone'","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁴ : Mul α\ninst✝³ : Preorder α\ninst✝² : Preorder β\nf g : β → α\ns : Set β\ninst✝¹ : MulLeftMono α\ninst✝ : MulRightStrictMono α\nhf : StrictAntiOn f s\nhg : AntitoneOn g s\n⊢ StrictAntiOn (fun x => HMul.hMul (f x) (g x)) s","decl":"/-- The product of a strictly antitone function and an antitone function is strictly antitone. -/\n@[to_additive add_antitone \"The sum of a strictly antitone function and an antitone function is\nstrictly antitone.\"]\ntheorem StrictAntiOn.mul_antitone' (hf : StrictAntiOn f s) (hg : AntitoneOn g s) :\n    StrictAntiOn (fun x => f x * g x) s :=\n  fun _ hx _ hy h => mul_lt_mul_of_lt_of_le (hf hx hy h) (hg hx hy h.le)\n\n"}
{"name":"cmp_mul_left'","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_3\ninst✝² : Mul α\ninst✝¹ : LinearOrder α\ninst✝ : MulLeftStrictMono α\na b c : α\n⊢ Eq (cmp (HMul.hMul a b) (HMul.hMul a c)) (cmp b c)","decl":"@[to_additive (attr := simp) cmp_add_left]\ntheorem cmp_mul_left' {α : Type*} [Mul α] [LinearOrder α] [MulLeftStrictMono α]\n    (a b c : α) :\n    cmp (a * b) (a * c) = cmp b c :=\n  (strictMono_id.const_mul' a).cmp_map_eq b c\n\n"}
{"name":"cmp_add_left","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_3\ninst✝² : Add α\ninst✝¹ : LinearOrder α\ninst✝ : AddLeftStrictMono α\na b c : α\n⊢ Eq (cmp (HAdd.hAdd a b) (HAdd.hAdd a c)) (cmp b c)","decl":"@[to_additive (attr := simp) cmp_add_left]\ntheorem cmp_mul_left' {α : Type*} [Mul α] [LinearOrder α] [MulLeftStrictMono α]\n    (a b c : α) :\n    cmp (a * b) (a * c) = cmp b c :=\n  (strictMono_id.const_mul' a).cmp_map_eq b c\n\n"}
{"name":"cmp_mul_right'","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_3\ninst✝² : Mul α\ninst✝¹ : LinearOrder α\ninst✝ : MulRightStrictMono α\na b c : α\n⊢ Eq (cmp (HMul.hMul a c) (HMul.hMul b c)) (cmp a b)","decl":"@[to_additive (attr := simp) cmp_add_right]\ntheorem cmp_mul_right' {α : Type*} [Mul α] [LinearOrder α]\n    [MulRightStrictMono α] (a b c : α) :\n    cmp (a * c) (b * c) = cmp a b :=\n  (strictMono_id.mul_const' c).cmp_map_eq a b\n\n"}
{"name":"cmp_add_right","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_3\ninst✝² : Add α\ninst✝¹ : LinearOrder α\ninst✝ : AddRightStrictMono α\na b c : α\n⊢ Eq (cmp (HAdd.hAdd a c) (HAdd.hAdd b c)) (cmp a b)","decl":"@[to_additive (attr := simp) cmp_add_right]\ntheorem cmp_mul_right' {α : Type*} [Mul α] [LinearOrder α]\n    [MulRightStrictMono α] (a b c : α) :\n    cmp (a * c) (b * c) = cmp a b :=\n  (strictMono_id.mul_const' c).cmp_map_eq a b\n\n"}
{"name":"Contravariant.MulLECancellable","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : Mul α\ninst✝¹ : LE α\ninst✝ : MulLeftReflectLE α\na : α\n⊢ MulLECancellable a","decl":"@[to_additive]\ntheorem Contravariant.MulLECancellable [Mul α] [LE α] [MulLeftReflectLE α]\n    {a : α} :\n    MulLECancellable a :=\n  fun _ _ => le_of_mul_le_mul_left'\n\n"}
{"name":"Contravariant.AddLECancellable","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : Add α\ninst✝¹ : LE α\ninst✝ : AddLeftReflectLE α\na : α\n⊢ AddLECancellable a","decl":"@[to_additive]\ntheorem Contravariant.MulLECancellable [Mul α] [LE α] [MulLeftReflectLE α]\n    {a : α} :\n    MulLECancellable a :=\n  fun _ _ => le_of_mul_le_mul_left'\n\n"}
{"name":"addLECancellable_zero","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝¹ : AddMonoid α\ninst✝ : LE α\n⊢ AddLECancellable 0","decl":"@[to_additive (attr := simp)]\ntheorem mulLECancellable_one [Monoid α] [LE α] : MulLECancellable (1 : α) := fun a b => by\n  simpa only [one_mul] using id\n\n"}
{"name":"mulLECancellable_one","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Monoid α\ninst✝ : LE α\n⊢ MulLECancellable 1","decl":"@[to_additive (attr := simp)]\ntheorem mulLECancellable_one [Monoid α] [LE α] : MulLECancellable (1 : α) := fun a b => by\n  simpa only [one_mul] using id\n\n"}
{"name":"AddLECancellable.Injective","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Add α\ninst✝ : PartialOrder α\na : α\nha : AddLECancellable a\n⊢ Function.Injective fun x => HAdd.hAdd a x","decl":"@[to_additive]\nprotected theorem Injective [Mul α] [PartialOrder α] {a : α} (ha : MulLECancellable a) :\n    Injective (a * ·) :=\n  fun _ _ h => le_antisymm (ha h.le) (ha h.ge)\n\n"}
{"name":"MulLECancellable.Injective","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Mul α\ninst✝ : PartialOrder α\na : α\nha : MulLECancellable a\n⊢ Function.Injective fun x => HMul.hMul a x","decl":"@[to_additive]\nprotected theorem Injective [Mul α] [PartialOrder α] {a : α} (ha : MulLECancellable a) :\n    Injective (a * ·) :=\n  fun _ _ h => le_antisymm (ha h.le) (ha h.ge)\n\n"}
{"name":"MulLECancellable.inj","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Mul α\ninst✝ : PartialOrder α\na b c : α\nha : MulLECancellable a\n⊢ Iff (Eq (HMul.hMul a b) (HMul.hMul a c)) (Eq b c)","decl":"@[to_additive]\nprotected theorem inj [Mul α] [PartialOrder α] {a b c : α} (ha : MulLECancellable a) :\n    a * b = a * c ↔ b = c :=\n  ha.Injective.eq_iff\n\n"}
{"name":"AddLECancellable.inj","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Add α\ninst✝ : PartialOrder α\na b c : α\nha : AddLECancellable a\n⊢ Iff (Eq (HAdd.hAdd a b) (HAdd.hAdd a c)) (Eq b c)","decl":"@[to_additive]\nprotected theorem inj [Mul α] [PartialOrder α] {a b c : α} (ha : MulLECancellable a) :\n    a * b = a * c ↔ b = c :=\n  ha.Injective.eq_iff\n\n"}
{"name":"MulLECancellable.injective_left","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Mul α\ni : Std.Commutative fun x1 x2 => HMul.hMul x1 x2\ninst✝ : PartialOrder α\na : α\nha : MulLECancellable a\n⊢ Function.Injective fun x => HMul.hMul x a","decl":"@[to_additive]\nprotected theorem injective_left [Mul α] [i : @Std.Commutative α (· * ·)] [PartialOrder α] {a : α}\n    (ha : MulLECancellable a) :\n    Injective (· * a) := fun b c h => ha.Injective <| by dsimp; rwa [i.comm a, i.comm a]\n\n"}
{"name":"AddLECancellable.injective_left","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Add α\ni : Std.Commutative fun x1 x2 => HAdd.hAdd x1 x2\ninst✝ : PartialOrder α\na : α\nha : AddLECancellable a\n⊢ Function.Injective fun x => HAdd.hAdd x a","decl":"@[to_additive]\nprotected theorem injective_left [Mul α] [i : @Std.Commutative α (· * ·)] [PartialOrder α] {a : α}\n    (ha : MulLECancellable a) :\n    Injective (· * a) := fun b c h => ha.Injective <| by dsimp; rwa [i.comm a, i.comm a]\n\n"}
{"name":"AddLECancellable.inj_left","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : Add α\ninst✝¹ : Std.Commutative fun x1 x2 => HAdd.hAdd x1 x2\ninst✝ : PartialOrder α\na b c : α\nhc : AddLECancellable c\n⊢ Iff (Eq (HAdd.hAdd a c) (HAdd.hAdd b c)) (Eq a b)","decl":"@[to_additive]\nprotected theorem inj_left [Mul α] [@Std.Commutative α (· * ·)] [PartialOrder α] {a b c : α}\n    (hc : MulLECancellable c) :\n    a * c = b * c ↔ a = b :=\n  hc.injective_left.eq_iff\n\n"}
{"name":"MulLECancellable.inj_left","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : Mul α\ninst✝¹ : Std.Commutative fun x1 x2 => HMul.hMul x1 x2\ninst✝ : PartialOrder α\na b c : α\nhc : MulLECancellable c\n⊢ Iff (Eq (HMul.hMul a c) (HMul.hMul b c)) (Eq a b)","decl":"@[to_additive]\nprotected theorem inj_left [Mul α] [@Std.Commutative α (· * ·)] [PartialOrder α] {a b c : α}\n    (hc : MulLECancellable c) :\n    a * c = b * c ↔ a = b :=\n  hc.injective_left.eq_iff\n\n"}
{"name":"MulLECancellable.mul_le_mul_iff_left","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : LE α\ninst✝¹ : Mul α\ninst✝ : MulLeftMono α\na b c : α\nha : MulLECancellable a\n⊢ Iff (LE.le (HMul.hMul a b) (HMul.hMul a c)) (LE.le b c)","decl":"@[to_additive]\nprotected theorem mul_le_mul_iff_left [Mul α] [MulLeftMono α] {a b c : α}\n    (ha : MulLECancellable a) : a * b ≤ a * c ↔ b ≤ c :=\n  ⟨fun h => ha h, fun h => mul_le_mul_left' h a⟩\n\n"}
{"name":"AddLECancellable.add_le_add_iff_left","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : LE α\ninst✝¹ : Add α\ninst✝ : AddLeftMono α\na b c : α\nha : AddLECancellable a\n⊢ Iff (LE.le (HAdd.hAdd a b) (HAdd.hAdd a c)) (LE.le b c)","decl":"@[to_additive]\nprotected theorem mul_le_mul_iff_left [Mul α] [MulLeftMono α] {a b c : α}\n    (ha : MulLECancellable a) : a * b ≤ a * c ↔ b ≤ c :=\n  ⟨fun h => ha h, fun h => mul_le_mul_left' h a⟩\n\n"}
{"name":"AddLECancellable.add_le_add_iff_right","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : LE α\ninst✝¹ : Add α\ni : Std.Commutative fun x1 x2 => HAdd.hAdd x1 x2\ninst✝ : AddLeftMono α\na b c : α\nha : AddLECancellable a\n⊢ Iff (LE.le (HAdd.hAdd b a) (HAdd.hAdd c a)) (LE.le b c)","decl":"@[to_additive]\nprotected theorem mul_le_mul_iff_right [Mul α] [i : @Std.Commutative α (· * ·)]\n    [MulLeftMono α] {a b c : α} (ha : MulLECancellable a) :\n    b * a ≤ c * a ↔ b ≤ c := by rw [i.comm b, i.comm c, ha.mul_le_mul_iff_left]\n\n"}
{"name":"MulLECancellable.mul_le_mul_iff_right","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : LE α\ninst✝¹ : Mul α\ni : Std.Commutative fun x1 x2 => HMul.hMul x1 x2\ninst✝ : MulLeftMono α\na b c : α\nha : MulLECancellable a\n⊢ Iff (LE.le (HMul.hMul b a) (HMul.hMul c a)) (LE.le b c)","decl":"@[to_additive]\nprotected theorem mul_le_mul_iff_right [Mul α] [i : @Std.Commutative α (· * ·)]\n    [MulLeftMono α] {a b c : α} (ha : MulLECancellable a) :\n    b * a ≤ c * a ↔ b ≤ c := by rw [i.comm b, i.comm c, ha.mul_le_mul_iff_left]\n\n"}
{"name":"AddLECancellable.le_add_iff_nonneg_right","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : LE α\ninst✝¹ : AddZeroClass α\ninst✝ : AddLeftMono α\na b : α\nha : AddLECancellable a\n⊢ Iff (LE.le a (HAdd.hAdd a b)) (LE.le 0 b)","decl":"@[to_additive]\nprotected theorem le_mul_iff_one_le_right [MulOneClass α] [MulLeftMono α]\n    {a b : α} (ha : MulLECancellable a) :\n    a ≤ a * b ↔ 1 ≤ b :=\n  Iff.trans (by rw [mul_one]) ha.mul_le_mul_iff_left\n\n"}
{"name":"MulLECancellable.le_mul_iff_one_le_right","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : LE α\ninst✝¹ : MulOneClass α\ninst✝ : MulLeftMono α\na b : α\nha : MulLECancellable a\n⊢ Iff (LE.le a (HMul.hMul a b)) (LE.le 1 b)","decl":"@[to_additive]\nprotected theorem le_mul_iff_one_le_right [MulOneClass α] [MulLeftMono α]\n    {a b : α} (ha : MulLECancellable a) :\n    a ≤ a * b ↔ 1 ≤ b :=\n  Iff.trans (by rw [mul_one]) ha.mul_le_mul_iff_left\n\n"}
{"name":"AddLECancellable.add_le_iff_nonpos_right","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : LE α\ninst✝¹ : AddZeroClass α\ninst✝ : AddLeftMono α\na b : α\nha : AddLECancellable a\n⊢ Iff (LE.le (HAdd.hAdd a b) a) (LE.le b 0)","decl":"@[to_additive]\nprotected theorem mul_le_iff_le_one_right [MulOneClass α] [MulLeftMono α]\n    {a b : α} (ha : MulLECancellable a) :\n    a * b ≤ a ↔ b ≤ 1 :=\n  Iff.trans (by rw [mul_one]) ha.mul_le_mul_iff_left\n\n"}
{"name":"MulLECancellable.mul_le_iff_le_one_right","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : LE α\ninst✝¹ : MulOneClass α\ninst✝ : MulLeftMono α\na b : α\nha : MulLECancellable a\n⊢ Iff (LE.le (HMul.hMul a b) a) (LE.le b 1)","decl":"@[to_additive]\nprotected theorem mul_le_iff_le_one_right [MulOneClass α] [MulLeftMono α]\n    {a b : α} (ha : MulLECancellable a) :\n    a * b ≤ a ↔ b ≤ 1 :=\n  Iff.trans (by rw [mul_one]) ha.mul_le_mul_iff_left\n\n"}
{"name":"MulLECancellable.le_mul_iff_one_le_left","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : LE α\ninst✝¹ : MulOneClass α\ni : Std.Commutative fun x1 x2 => HMul.hMul x1 x2\ninst✝ : MulLeftMono α\na b : α\nha : MulLECancellable a\n⊢ Iff (LE.le a (HMul.hMul b a)) (LE.le 1 b)","decl":"@[to_additive]\nprotected theorem le_mul_iff_one_le_left [MulOneClass α] [i : @Std.Commutative α (· * ·)]\n    [MulLeftMono α] {a b : α} (ha : MulLECancellable a) :\n    a ≤ b * a ↔ 1 ≤ b := by rw [i.comm, ha.le_mul_iff_one_le_right]\n\n"}
{"name":"AddLECancellable.le_add_iff_nonneg_left","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : LE α\ninst✝¹ : AddZeroClass α\ni : Std.Commutative fun x1 x2 => HAdd.hAdd x1 x2\ninst✝ : AddLeftMono α\na b : α\nha : AddLECancellable a\n⊢ Iff (LE.le a (HAdd.hAdd b a)) (LE.le 0 b)","decl":"@[to_additive]\nprotected theorem le_mul_iff_one_le_left [MulOneClass α] [i : @Std.Commutative α (· * ·)]\n    [MulLeftMono α] {a b : α} (ha : MulLECancellable a) :\n    a ≤ b * a ↔ 1 ≤ b := by rw [i.comm, ha.le_mul_iff_one_le_right]\n\n"}
{"name":"MulLECancellable.mul_le_iff_le_one_left","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : LE α\ninst✝¹ : MulOneClass α\ni : Std.Commutative fun x1 x2 => HMul.hMul x1 x2\ninst✝ : MulLeftMono α\na b : α\nha : MulLECancellable a\n⊢ Iff (LE.le (HMul.hMul b a) a) (LE.le b 1)","decl":"@[to_additive]\nprotected theorem mul_le_iff_le_one_left [MulOneClass α] [i : @Std.Commutative α (· * ·)]\n    [MulLeftMono α] {a b : α} (ha : MulLECancellable a) :\n    b * a ≤ a ↔ b ≤ 1 := by rw [i.comm, ha.mul_le_iff_le_one_right]\n\n"}
{"name":"AddLECancellable.add_le_iff_nonpos_left","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : LE α\ninst✝¹ : AddZeroClass α\ni : Std.Commutative fun x1 x2 => HAdd.hAdd x1 x2\ninst✝ : AddLeftMono α\na b : α\nha : AddLECancellable a\n⊢ Iff (LE.le (HAdd.hAdd b a) a) (LE.le b 0)","decl":"@[to_additive]\nprotected theorem mul_le_iff_le_one_left [MulOneClass α] [i : @Std.Commutative α (· * ·)]\n    [MulLeftMono α] {a b : α} (ha : MulLECancellable a) :\n    b * a ≤ a ↔ b ≤ 1 := by rw [i.comm, ha.mul_le_iff_le_one_right]\n\n"}
{"name":"MulLECancellable.mul","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝¹ : LE α\ninst✝ : Semigroup α\na b : α\nha : MulLECancellable a\nhb : MulLECancellable b\n⊢ MulLECancellable (HMul.hMul a b)","decl":"@[to_additive] lemma mul [Semigroup α] {a b : α} (ha : MulLECancellable a)\n    (hb : MulLECancellable b) : MulLECancellable (a * b) :=\n  fun c d hcd ↦ hb <| ha <| by rwa [← mul_assoc, ← mul_assoc]\n\n"}
{"name":"AddLECancellable.add","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝¹ : LE α\ninst✝ : AddSemigroup α\na b : α\nha : AddLECancellable a\nhb : AddLECancellable b\n⊢ AddLECancellable (HAdd.hAdd a b)","decl":"@[to_additive] lemma mul [Semigroup α] {a b : α} (ha : MulLECancellable a)\n    (hb : MulLECancellable b) : MulLECancellable (a * b) :=\n  fun c d hcd ↦ hb <| ha <| by rwa [← mul_assoc, ← mul_assoc]\n\n"}
{"name":"AddLECancellable.of_add_right","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : LE α\ninst✝¹ : AddSemigroup α\ninst✝ : AddLeftMono α\na b : α\nh : AddLECancellable (HAdd.hAdd a b)\n⊢ AddLECancellable b","decl":"@[to_additive] lemma of_mul_right [Semigroup α] [MulLeftMono α] {a b : α}\n    (h : MulLECancellable (a * b)) : MulLECancellable b :=\n  fun c d hcd ↦ h <| by rw [mul_assoc, mul_assoc]; exact mul_le_mul_left' hcd _\n\n"}
{"name":"MulLECancellable.of_mul_right","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : LE α\ninst✝¹ : Semigroup α\ninst✝ : MulLeftMono α\na b : α\nh : MulLECancellable (HMul.hMul a b)\n⊢ MulLECancellable b","decl":"@[to_additive] lemma of_mul_right [Semigroup α] [MulLeftMono α] {a b : α}\n    (h : MulLECancellable (a * b)) : MulLECancellable b :=\n  fun c d hcd ↦ h <| by rw [mul_assoc, mul_assoc]; exact mul_le_mul_left' hcd _\n\n"}
{"name":"MulLECancellable.of_mul_left","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : LE α\ninst✝¹ : CommSemigroup α\ninst✝ : MulLeftMono α\na b : α\nh : MulLECancellable (HMul.hMul a b)\n⊢ MulLECancellable a","decl":"@[to_additive] lemma of_mul_left [CommSemigroup α] [MulLeftMono α] {a b : α}\n    (h : MulLECancellable (a * b)) : MulLECancellable a := (mul_comm a b ▸ h).of_mul_right\n\n"}
{"name":"AddLECancellable.of_add_left","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : LE α\ninst✝¹ : AddCommSemigroup α\ninst✝ : AddLeftMono α\na b : α\nh : AddLECancellable (HAdd.hAdd a b)\n⊢ AddLECancellable a","decl":"@[to_additive] lemma of_mul_left [CommSemigroup α] [MulLeftMono α] {a b : α}\n    (h : MulLECancellable (a * b)) : MulLECancellable a := (mul_comm a b ▸ h).of_mul_right\n\n"}
{"name":"addLECancellable_add","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : LE α\ninst✝¹ : AddCommSemigroup α\ninst✝ : AddLeftMono α\na b : α\n⊢ Iff (AddLECancellable (HAdd.hAdd a b)) (And (AddLECancellable a) (AddLECancellable b))","decl":"@[to_additive (attr := simp)]\nlemma mulLECancellable_mul [LE α] [CommSemigroup α] [MulLeftMono α] {a b : α} :\n    MulLECancellable (a * b) ↔ MulLECancellable a ∧ MulLECancellable b :=\n  ⟨fun h ↦ ⟨h.of_mul_left, h.of_mul_right⟩, fun h ↦ h.1.mul h.2⟩\n"}
{"name":"mulLECancellable_mul","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Basic","initialProofState":"α : Type u_1\ninst✝² : LE α\ninst✝¹ : CommSemigroup α\ninst✝ : MulLeftMono α\na b : α\n⊢ Iff (MulLECancellable (HMul.hMul a b)) (And (MulLECancellable a) (MulLECancellable b))","decl":"@[to_additive (attr := simp)]\nlemma mulLECancellable_mul [LE α] [CommSemigroup α] [MulLeftMono α] {a b : α} :\n    MulLECancellable (a * b) ↔ MulLECancellable a ∧ MulLECancellable b :=\n  ⟨fun h ↦ ⟨h.of_mul_left, h.of_mul_right⟩, fun h ↦ h.1.mul h.2⟩\n"}
