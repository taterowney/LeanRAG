{"name":"Action.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V✝ : Type (u + 1)\ninst✝¹ : CategoryTheory.LargeCategory V✝\nG : MonCat\ninst✝ : SizeOf V✝\nV : V✝\nρ : Quiver.Hom G (MonCat.of (CategoryTheory.End V))\n⊢ Eq (SizeOf.sizeOf { V := V, ρ := ρ }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf V)) (SizeOf.sizeOf ρ))","decl":"/-- An `Action V G` represents a bundled action of\nthe monoid `G` on an object of some category `V`.\n\nAs an example, when `V = ModuleCat R`, this is an `R`-linear representation of `G`,\nwhile when `V = Type` this is a `G`-action.\n-/\nstructure Action (G : MonCat.{u}) where\n  V : V\n  ρ : G ⟶ MonCat.of (End V)\n\n"}
{"name":"Action.mk.inj","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V✝¹ : Type (u + 1)\ninst✝ : CategoryTheory.LargeCategory V✝¹\nG : MonCat\nV✝ : V✝¹\nρ✝ : Quiver.Hom G (MonCat.of (CategoryTheory.End V✝))\nV : V✝¹\nρ : Quiver.Hom G (MonCat.of (CategoryTheory.End V))\nx✝ : Eq { V := V✝, ρ := ρ✝ } { V := V, ρ := ρ }\n⊢ And (Eq V✝ V) (HEq ρ✝ ρ)","decl":"/-- An `Action V G` represents a bundled action of\nthe monoid `G` on an object of some category `V`.\n\nAs an example, when `V = ModuleCat R`, this is an `R`-linear representation of `G`,\nwhile when `V = Type` this is a `G`-action.\n-/\nstructure Action (G : MonCat.{u}) where\n  V : V\n  ρ : G ⟶ MonCat.of (End V)\n\n"}
{"name":"Action.mk.injEq","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V✝¹ : Type (u + 1)\ninst✝ : CategoryTheory.LargeCategory V✝¹\nG : MonCat\nV✝ : V✝¹\nρ✝ : Quiver.Hom G (MonCat.of (CategoryTheory.End V✝))\nV : V✝¹\nρ : Quiver.Hom G (MonCat.of (CategoryTheory.End V))\n⊢ Eq (Eq { V := V✝, ρ := ρ✝ } { V := V, ρ := ρ }) (And (Eq V✝ V) (HEq ρ✝ ρ))","decl":"/-- An `Action V G` represents a bundled action of\nthe monoid `G` on an object of some category `V`.\n\nAs an example, when `V = ModuleCat R`, this is an `R`-linear representation of `G`,\nwhile when `V = Type` this is a `G`-action.\n-/\nstructure Action (G : MonCat.{u}) where\n  V : V\n  ρ : G ⟶ MonCat.of (End V)\n\n"}
{"name":"Action.ρ_one","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V : Type (u + 1)\ninst✝ : CategoryTheory.LargeCategory V\nG : MonCat\nA : Action V G\n⊢ Eq ((CategoryTheory.ConcreteCategory.hom A.ρ) 1) (CategoryTheory.CategoryStruct.id A.V)","decl":"theorem ρ_one {G : MonCat.{u}} (A : Action V G) : A.ρ 1 = 𝟙 A.V := by simp\n\n"}
{"name":"Action.ρAut_hom_apply_inv","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V : Type (u + 1)\ninst✝ : CategoryTheory.LargeCategory V\nG : Grp\nA : Action V (MonCat.of ↑G)\ng : ↑G\n⊢ Eq ((Grp.Hom.hom A.ρAut) g).inv ((CategoryTheory.ConcreteCategory.hom A.ρ) (Inv.inv g))","decl":"/-- When a group acts, we can lift the action to the group of automorphisms. -/\n@[simps!]\ndef ρAut {G : Grp.{u}} (A : Action V (MonCat.of G)) : G ⟶ Grp.of (Aut A.V) :=\n  Grp.ofHom\n  { toFun g :=\n      { hom := A.ρ g\n        inv := A.ρ (g⁻¹ : G)\n        hom_inv_id := (A.ρ.hom.map_mul (g⁻¹ : G) g).symm.trans (by rw [inv_mul_cancel, ρ_one])\n        inv_hom_id := (A.ρ.hom.map_mul g (g⁻¹ : G)).symm.trans (by rw [mul_inv_cancel, ρ_one]) }\n    map_one' := Aut.ext A.ρ.hom.map_one\n    map_mul' x y := Aut.ext (A.ρ.hom.map_mul x y) }\n\n"}
{"name":"Action.ρAut_hom_apply_hom","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V : Type (u + 1)\ninst✝ : CategoryTheory.LargeCategory V\nG : Grp\nA : Action V (MonCat.of ↑G)\ng : ↑G\n⊢ Eq ((Grp.Hom.hom A.ρAut) g).hom ((CategoryTheory.ConcreteCategory.hom A.ρ) g)","decl":"/-- When a group acts, we can lift the action to the group of automorphisms. -/\n@[simps!]\ndef ρAut {G : Grp.{u}} (A : Action V (MonCat.of G)) : G ⟶ Grp.of (Aut A.V) :=\n  Grp.ofHom\n  { toFun g :=\n      { hom := A.ρ g\n        inv := A.ρ (g⁻¹ : G)\n        hom_inv_id := (A.ρ.hom.map_mul (g⁻¹ : G) g).symm.trans (by rw [inv_mul_cancel, ρ_one])\n        inv_hom_id := (A.ρ.hom.map_mul g (g⁻¹ : G)).symm.trans (by rw [mul_inv_cancel, ρ_one]) }\n    map_one' := Aut.ext A.ρ.hom.map_one\n    map_mul' x y := Aut.ext (A.ρ.hom.map_mul x y) }\n\n"}
{"name":"Action.Hom.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V : Type (u + 1)\ninst✝¹ : CategoryTheory.LargeCategory V\nG : MonCat\nM N : Action V G\ninst✝ : SizeOf V\nhom : Quiver.Hom M.V N.V\ncomm : autoParam (∀ (g : ↑G), Eq (CategoryTheory.CategoryStruct.comp ((MonCat.Hom.hom M.ρ) g) hom) (CategoryTheory.CategoryStruct.comp hom ((CategoryTheory.ConcreteCategory.hom N.ρ) g))) _auto✝\n⊢ Eq (SizeOf.sizeOf { hom := hom, comm := comm }) (HAdd.hAdd 1 (SizeOf.sizeOf hom))","decl":"/-- A homomorphism of `Action V G`s is a morphism between the underlying objects,\ncommuting with the action of `G`.\n-/\n@[ext]\nstructure Hom (M N : Action V G) where\n  hom : M.V ⟶ N.V\n  -- Have to insert type hint for `F`, otherwise it ends up as:\n  -- `(fun α β => ↑α →* β) (MonCat.of (End _)) G`\n  -- which `simp` reduces to `↑(MonCat.of (End _)) →* β` instead of `End _ →* β`.\n  -- Strangely enough, the `@[reassoc]` version works fine.\n  comm : ∀ g : G, DFunLike.coe (F := _ →* End _) M.ρ.hom g ≫ hom = hom ≫ N.ρ g := by aesop_cat\n\n"}
{"name":"Action.Hom.ext","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V : Type (u + 1)\ninst✝ : CategoryTheory.LargeCategory V\nG : MonCat\nM N : Action V G\nx y : M.Hom N\nhom : Eq x.hom y.hom\n⊢ Eq x y","decl":"/-- A homomorphism of `Action V G`s is a morphism between the underlying objects,\ncommuting with the action of `G`.\n-/\n@[ext]\nstructure Hom (M N : Action V G) where\n  hom : M.V ⟶ N.V\n  -- Have to insert type hint for `F`, otherwise it ends up as:\n  -- `(fun α β => ↑α →* β) (MonCat.of (End _)) G`\n  -- which `simp` reduces to `↑(MonCat.of (End _)) →* β` instead of `End _ →* β`.\n  -- Strangely enough, the `@[reassoc]` version works fine.\n  comm : ∀ g : G, DFunLike.coe (F := _ →* End _) M.ρ.hom g ≫ hom = hom ≫ N.ρ g := by aesop_cat\n\n"}
{"name":"Action.Hom.ext_iff","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V : Type (u + 1)\ninst✝ : CategoryTheory.LargeCategory V\nG : MonCat\nM N : Action V G\nx y : M.Hom N\n⊢ Iff (Eq x y) (Eq x.hom y.hom)","decl":"/-- A homomorphism of `Action V G`s is a morphism between the underlying objects,\ncommuting with the action of `G`.\n-/\n@[ext]\nstructure Hom (M N : Action V G) where\n  hom : M.V ⟶ N.V\n  -- Have to insert type hint for `F`, otherwise it ends up as:\n  -- `(fun α β => ↑α →* β) (MonCat.of (End _)) G`\n  -- which `simp` reduces to `↑(MonCat.of (End _)) →* β` instead of `End _ →* β`.\n  -- Strangely enough, the `@[reassoc]` version works fine.\n  comm : ∀ g : G, DFunLike.coe (F := _ →* End _) M.ρ.hom g ≫ hom = hom ≫ N.ρ g := by aesop_cat\n\n"}
{"name":"Action.Hom.mk.inj","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V : Type (u + 1)\ninst✝ : CategoryTheory.LargeCategory V\nG : MonCat\nM N : Action V G\nhom✝ : Quiver.Hom M.V N.V\ncomm✝ : autoParam (∀ (g : ↑G), Eq (CategoryTheory.CategoryStruct.comp ((MonCat.Hom.hom M.ρ) g) hom✝) (CategoryTheory.CategoryStruct.comp hom✝ ((CategoryTheory.ConcreteCategory.hom N.ρ) g))) _auto✝\nhom : Quiver.Hom M.V N.V\ncomm : autoParam (∀ (g : ↑G), Eq (CategoryTheory.CategoryStruct.comp ((MonCat.Hom.hom M.ρ) g) hom) (CategoryTheory.CategoryStruct.comp hom ((CategoryTheory.ConcreteCategory.hom N.ρ) g))) _auto✝\nx✝ : Eq { hom := hom✝, comm := comm✝ } { hom := hom, comm := comm }\n⊢ Eq hom✝ hom","decl":"/-- A homomorphism of `Action V G`s is a morphism between the underlying objects,\ncommuting with the action of `G`.\n-/\n@[ext]\nstructure Hom (M N : Action V G) where\n  hom : M.V ⟶ N.V\n  -- Have to insert type hint for `F`, otherwise it ends up as:\n  -- `(fun α β => ↑α →* β) (MonCat.of (End _)) G`\n  -- which `simp` reduces to `↑(MonCat.of (End _)) →* β` instead of `End _ →* β`.\n  -- Strangely enough, the `@[reassoc]` version works fine.\n  comm : ∀ g : G, DFunLike.coe (F := _ →* End _) M.ρ.hom g ≫ hom = hom ≫ N.ρ g := by aesop_cat\n\n"}
{"name":"Action.Hom.mk.injEq","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V : Type (u + 1)\ninst✝ : CategoryTheory.LargeCategory V\nG : MonCat\nM N : Action V G\nhom✝ : Quiver.Hom M.V N.V\ncomm✝ : autoParam (∀ (g : ↑G), Eq (CategoryTheory.CategoryStruct.comp ((MonCat.Hom.hom M.ρ) g) hom✝) (CategoryTheory.CategoryStruct.comp hom✝ ((CategoryTheory.ConcreteCategory.hom N.ρ) g))) _auto✝\nhom : Quiver.Hom M.V N.V\ncomm : autoParam (∀ (g : ↑G), Eq (CategoryTheory.CategoryStruct.comp ((MonCat.Hom.hom M.ρ) g) hom) (CategoryTheory.CategoryStruct.comp hom ((CategoryTheory.ConcreteCategory.hom N.ρ) g))) _auto✝\n⊢ Eq (Eq { hom := hom✝, comm := comm✝ } { hom := hom, comm := comm }) (Eq hom✝ hom)","decl":"/-- A homomorphism of `Action V G`s is a morphism between the underlying objects,\ncommuting with the action of `G`.\n-/\n@[ext]\nstructure Hom (M N : Action V G) where\n  hom : M.V ⟶ N.V\n  -- Have to insert type hint for `F`, otherwise it ends up as:\n  -- `(fun α β => ↑α →* β) (MonCat.of (End _)) G`\n  -- which `simp` reduces to `↑(MonCat.of (End _)) →* β` instead of `End _ →* β`.\n  -- Strangely enough, the `@[reassoc]` version works fine.\n  comm : ∀ g : G, DFunLike.coe (F := _ →* End _) M.ρ.hom g ≫ hom = hom ≫ N.ρ g := by aesop_cat\n\n"}
{"name":"Action.Hom.comm","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V : Type (u + 1)\ninst✝ : CategoryTheory.LargeCategory V\nG : MonCat\nM N : Action V G\nself : M.Hom N\ng : ↑G\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((MonCat.Hom.hom M.ρ) g) self.hom) (CategoryTheory.CategoryStruct.comp self.hom ((CategoryTheory.ConcreteCategory.hom N.ρ) g))","decl":"/-- A homomorphism of `Action V G`s is a morphism between the underlying objects,\ncommuting with the action of `G`.\n-/\n@[ext]\nstructure Hom (M N : Action V G) where\n  hom : M.V ⟶ N.V\n  -- Have to insert type hint for `F`, otherwise it ends up as:\n  -- `(fun α β => ↑α →* β) (MonCat.of (End _)) G`\n  -- which `simp` reduces to `↑(MonCat.of (End _)) →* β` instead of `End _ →* β`.\n  -- Strangely enough, the `@[reassoc]` version works fine.\n  comm : ∀ g : G, DFunLike.coe (F := _ →* End _) M.ρ.hom g ≫ hom = hom ≫ N.ρ g := by aesop_cat\n\n"}
{"name":"Action.Hom.comm_assoc","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V : Type (u + 1)\ninst✝ : CategoryTheory.LargeCategory V\nG : MonCat\nM N : Action V G\nself : M.Hom N\ng : ↑G\nZ : V\nh : Quiver.Hom N.V Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((MonCat.Hom.hom M.ρ) g) (CategoryTheory.CategoryStruct.comp self.hom h)) (CategoryTheory.CategoryStruct.comp self.hom (CategoryTheory.CategoryStruct.comp ((CategoryTheory.ConcreteCategory.hom N.ρ) g) h))","decl":"attribute [reassoc] comm\n"}
{"name":"Action.Hom.id_hom","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V : Type (u + 1)\ninst✝ : CategoryTheory.LargeCategory V\nG : MonCat\nM : Action V G\n⊢ Eq (Action.Hom.id M).hom (CategoryTheory.CategoryStruct.id M.V)","decl":"/-- The identity morphism on an `Action V G`. -/\n@[simps]\ndef id (M : Action V G) : Action.Hom M M where hom := 𝟙 M.V\n\n"}
{"name":"Action.Hom.comp_hom","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V : Type (u + 1)\ninst✝ : CategoryTheory.LargeCategory V\nG : MonCat\nM N K : Action V G\np : M.Hom N\nq : N.Hom K\n⊢ Eq (p.comp q).hom (CategoryTheory.CategoryStruct.comp p.hom q.hom)","decl":"/-- The composition of two `Action V G` homomorphisms is the composition of the underlying maps.\n-/\n@[simps]\ndef comp {M N K : Action V G} (p : Action.Hom M N) (q : Action.Hom N K) : Action.Hom M K where\n  hom := p.hom ≫ q.hom\n\n"}
{"name":"Action.hom_ext_iff","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V : Type (u + 1)\ninst✝ : CategoryTheory.LargeCategory V\nG : MonCat\nM N : Action V G\nφ₁ φ₂ : Quiver.Hom M N\n⊢ Iff (Eq φ₁ φ₂) (Eq φ₁.hom φ₂.hom)","decl":"@[ext]\nlemma hom_ext {M N : Action V G} (φ₁ φ₂ : M ⟶ N) (h : φ₁.hom = φ₂.hom) : φ₁ = φ₂ :=\n  Hom.ext h\n\n"}
{"name":"Action.hom_ext","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V : Type (u + 1)\ninst✝ : CategoryTheory.LargeCategory V\nG : MonCat\nM N : Action V G\nφ₁ φ₂ : Quiver.Hom M N\nh : Eq φ₁.hom φ₂.hom\n⊢ Eq φ₁ φ₂","decl":"@[ext]\nlemma hom_ext {M N : Action V G} (φ₁ φ₂ : M ⟶ N) (h : φ₁.hom = φ₂.hom) : φ₁ = φ₂ :=\n  Hom.ext h\n\n"}
{"name":"Action.id_hom","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V : Type (u + 1)\ninst✝ : CategoryTheory.LargeCategory V\nG : MonCat\nM : Action V G\n⊢ Eq (CategoryTheory.CategoryStruct.id M).hom (CategoryTheory.CategoryStruct.id M.V)","decl":"@[simp]\ntheorem id_hom (M : Action V G) : (𝟙 M : Hom M M).hom = 𝟙 M.V :=\n  rfl\n\n"}
{"name":"Action.comp_hom","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V : Type (u + 1)\ninst✝ : CategoryTheory.LargeCategory V\nG : MonCat\nM N K : Action V G\nf : Quiver.Hom M N\ng : Quiver.Hom N K\n⊢ Eq (CategoryTheory.CategoryStruct.comp f g).hom (CategoryTheory.CategoryStruct.comp f.hom g.hom)","decl":"@[simp]\ntheorem comp_hom {M N K : Action V G} (f : M ⟶ N) (g : N ⟶ K) :\n    (f ≫ g : Hom M K).hom = f.hom ≫ g.hom :=\n  rfl\n\n"}
{"name":"Action.hom_inv_hom","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V : Type (u + 1)\ninst✝ : CategoryTheory.LargeCategory V\nG : MonCat\nM N : Action V G\nf : CategoryTheory.Iso M N\n⊢ Eq (CategoryTheory.CategoryStruct.comp f.hom.hom f.inv.hom) (CategoryTheory.CategoryStruct.id M.V)","decl":"@[simp]\ntheorem hom_inv_hom {M N : Action V G} (f : M ≅ N) :\n    f.hom.hom ≫ f.inv.hom = 𝟙 M.V := by\n  rw [← comp_hom, Iso.hom_inv_id, id_hom]\n\n"}
{"name":"Action.inv_hom_hom","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V : Type (u + 1)\ninst✝ : CategoryTheory.LargeCategory V\nG : MonCat\nM N : Action V G\nf : CategoryTheory.Iso M N\n⊢ Eq (CategoryTheory.CategoryStruct.comp f.inv.hom f.hom.hom) (CategoryTheory.CategoryStruct.id N.V)","decl":"@[simp]\ntheorem inv_hom_hom {M N : Action V G} (f : M ≅ N) :\n    f.inv.hom ≫ f.hom.hom = 𝟙 N.V := by\n  rw [← comp_hom, Iso.inv_hom_id, id_hom]\n\n"}
{"name":"Action.mkIso_inv_hom","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V : Type (u + 1)\ninst✝ : CategoryTheory.LargeCategory V\nG : MonCat\nM N : Action V G\nf : CategoryTheory.Iso M.V N.V\ncomm : autoParam (∀ (g : ↑G), Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.ConcreteCategory.hom M.ρ) g) f.hom) (CategoryTheory.CategoryStruct.comp f.hom ((CategoryTheory.ConcreteCategory.hom N.ρ) g))) _auto✝\n⊢ Eq (Action.mkIso f comm).inv.hom f.inv","decl":"/-- Construct an isomorphism of `G` actions/representations\nfrom an isomorphism of the underlying objects,\nwhere the forward direction commutes with the group action. -/\n@[simps]\ndef mkIso {M N : Action V G} (f : M.V ≅ N.V)\n    (comm : ∀ g : G, M.ρ g ≫ f.hom = f.hom ≫ N.ρ g := by aesop_cat) : M ≅ N where\n  hom :=\n    { hom := f.hom\n      comm := comm }\n  inv :=\n    { hom := f.inv\n      comm := fun g => by have w := comm g =≫ f.inv; simp at w; simp [w] }\n\n"}
{"name":"Action.mkIso_hom_hom","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V : Type (u + 1)\ninst✝ : CategoryTheory.LargeCategory V\nG : MonCat\nM N : Action V G\nf : CategoryTheory.Iso M.V N.V\ncomm : autoParam (∀ (g : ↑G), Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.ConcreteCategory.hom M.ρ) g) f.hom) (CategoryTheory.CategoryStruct.comp f.hom ((CategoryTheory.ConcreteCategory.hom N.ρ) g))) _auto✝\n⊢ Eq (Action.mkIso f comm).hom.hom f.hom","decl":"/-- Construct an isomorphism of `G` actions/representations\nfrom an isomorphism of the underlying objects,\nwhere the forward direction commutes with the group action. -/\n@[simps]\ndef mkIso {M N : Action V G} (f : M.V ≅ N.V)\n    (comm : ∀ g : G, M.ρ g ≫ f.hom = f.hom ≫ N.ρ g := by aesop_cat) : M ≅ N where\n  hom :=\n    { hom := f.hom\n      comm := comm }\n  inv :=\n    { hom := f.inv\n      comm := fun g => by have w := comm g =≫ f.inv; simp at w; simp [w] }\n\n"}
{"name":"Action.isIso_of_hom_isIso","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V : Type (u + 1)\ninst✝¹ : CategoryTheory.LargeCategory V\nG : MonCat\nM N : Action V G\nf : Quiver.Hom M N\ninst✝ : CategoryTheory.IsIso f.hom\n⊢ CategoryTheory.IsIso f","decl":"instance (priority := 100) isIso_of_hom_isIso {M N : Action V G} (f : M ⟶ N) [IsIso f.hom] :\n    IsIso f := (mkIso (asIso f.hom) f.comm).isIso_hom\n\n"}
{"name":"Action.isIso_hom_mk","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V : Type (u + 1)\ninst✝¹ : CategoryTheory.LargeCategory V\nG : MonCat\nM N : Action V G\nf : Quiver.Hom M.V N.V\ninst✝ : CategoryTheory.IsIso f\nw : ∀ (g : ↑G), Eq (CategoryTheory.CategoryStruct.comp ((MonCat.Hom.hom M.ρ) g) f) (CategoryTheory.CategoryStruct.comp f ((CategoryTheory.ConcreteCategory.hom N.ρ) g))\n⊢ CategoryTheory.IsIso { hom := f, comm := w }","decl":"instance isIso_hom_mk {M N : Action V G} (f : M.V ⟶ N.V) [IsIso f] (w) :\n    @IsIso _ _ M N (Hom.mk f w) :=\n  (mkIso (asIso f) w).isIso_hom\n\n"}
{"name":"Action.instIsIsoHomHom","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V : Type (u + 1)\ninst✝ : CategoryTheory.LargeCategory V\nG : MonCat\nM N : Action V G\nf : CategoryTheory.Iso M N\n⊢ CategoryTheory.IsIso f.hom.hom","decl":"instance {M N : Action V G} (f : M ≅ N) : IsIso f.hom.hom where\n  out := ⟨f.inv.hom, by simp⟩\n\n"}
{"name":"Action.instIsIsoHomInv","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V : Type (u + 1)\ninst✝ : CategoryTheory.LargeCategory V\nG : MonCat\nM N : Action V G\nf : CategoryTheory.Iso M N\n⊢ CategoryTheory.IsIso f.inv.hom","decl":"instance {M N : Action V G} (f : M ≅ N) : IsIso f.inv.hom where\n  out := ⟨f.hom.hom, by simp⟩\n\n"}
{"name":"Action.FunctorCategoryEquivalence.functor_map_app","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V : Type (u + 1)\ninst✝ : CategoryTheory.LargeCategory V\nG : MonCat\nX✝ Y✝ : Action V G\nf : Quiver.Hom X✝ Y✝\nx✝ : CategoryTheory.SingleObj ↑G\n⊢ Eq ((Action.FunctorCategoryEquivalence.functor.map f).app x✝) f.hom","decl":"/-- Auxiliary definition for `functorCategoryEquivalence`. -/\n@[simps]\ndef functor : Action V G ⥤ SingleObj G ⥤ V where\n  obj M :=\n    { obj := fun _ => M.V\n      map := fun g => M.ρ g\n      map_id := fun _ => M.ρ.hom.map_one\n      map_comp := fun g h => M.ρ.hom.map_mul h g }\n  map f :=\n    { app := fun _ => f.hom\n      naturality := fun _ _ g => f.comm g }\n\n"}
{"name":"Action.FunctorCategoryEquivalence.functor_obj_map","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V : Type (u + 1)\ninst✝ : CategoryTheory.LargeCategory V\nG : MonCat\nM : Action V G\nX✝ Y✝ : CategoryTheory.SingleObj ↑G\ng : Quiver.Hom X✝ Y✝\n⊢ Eq ((Action.FunctorCategoryEquivalence.functor.obj M).map g) ((CategoryTheory.ConcreteCategory.hom M.ρ) g)","decl":"/-- Auxiliary definition for `functorCategoryEquivalence`. -/\n@[simps]\ndef functor : Action V G ⥤ SingleObj G ⥤ V where\n  obj M :=\n    { obj := fun _ => M.V\n      map := fun g => M.ρ g\n      map_id := fun _ => M.ρ.hom.map_one\n      map_comp := fun g h => M.ρ.hom.map_mul h g }\n  map f :=\n    { app := fun _ => f.hom\n      naturality := fun _ _ g => f.comm g }\n\n"}
{"name":"Action.FunctorCategoryEquivalence.functor_obj_obj","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V : Type (u + 1)\ninst✝ : CategoryTheory.LargeCategory V\nG : MonCat\nM : Action V G\nx✝ : CategoryTheory.SingleObj ↑G\n⊢ Eq ((Action.FunctorCategoryEquivalence.functor.obj M).obj x✝) M.V","decl":"/-- Auxiliary definition for `functorCategoryEquivalence`. -/\n@[simps]\ndef functor : Action V G ⥤ SingleObj G ⥤ V where\n  obj M :=\n    { obj := fun _ => M.V\n      map := fun g => M.ρ g\n      map_id := fun _ => M.ρ.hom.map_one\n      map_comp := fun g h => M.ρ.hom.map_mul h g }\n  map f :=\n    { app := fun _ => f.hom\n      naturality := fun _ _ g => f.comm g }\n\n"}
{"name":"Action.FunctorCategoryEquivalence.inverse_map_hom","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V : Type (u + 1)\ninst✝ : CategoryTheory.LargeCategory V\nG : MonCat\nX✝ Y✝ : CategoryTheory.Functor (CategoryTheory.SingleObj ↑G) V\nf : Quiver.Hom X✝ Y✝\n⊢ Eq (Action.FunctorCategoryEquivalence.inverse.map f).hom (f.app PUnit.unit)","decl":"/-- Auxiliary definition for `functorCategoryEquivalence`. -/\n@[simps]\ndef inverse : (SingleObj G ⥤ V) ⥤ Action V G where\n  obj F :=\n    { V := F.obj PUnit.unit\n      ρ := MonCat.ofHom\n        { toFun := fun g => F.map g\n          map_one' := F.map_id PUnit.unit\n          map_mul' := fun g h => F.map_comp h g } }\n  map f :=\n    { hom := f.app PUnit.unit\n      comm := fun g => f.naturality g }\n\n"}
{"name":"Action.FunctorCategoryEquivalence.inverse_obj_ρ","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V : Type (u + 1)\ninst✝ : CategoryTheory.LargeCategory V\nG : MonCat\nF : CategoryTheory.Functor (CategoryTheory.SingleObj ↑G) V\n⊢ Eq (Action.FunctorCategoryEquivalence.inverse.obj F).ρ (MonCat.ofHom { toFun := fun g => F.map g, map_one' := ⋯, map_mul' := ⋯ })","decl":"/-- Auxiliary definition for `functorCategoryEquivalence`. -/\n@[simps]\ndef inverse : (SingleObj G ⥤ V) ⥤ Action V G where\n  obj F :=\n    { V := F.obj PUnit.unit\n      ρ := MonCat.ofHom\n        { toFun := fun g => F.map g\n          map_one' := F.map_id PUnit.unit\n          map_mul' := fun g h => F.map_comp h g } }\n  map f :=\n    { hom := f.app PUnit.unit\n      comm := fun g => f.naturality g }\n\n"}
{"name":"Action.FunctorCategoryEquivalence.inverse_obj_V","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V : Type (u + 1)\ninst✝ : CategoryTheory.LargeCategory V\nG : MonCat\nF : CategoryTheory.Functor (CategoryTheory.SingleObj ↑G) V\n⊢ Eq (Action.FunctorCategoryEquivalence.inverse.obj F).V (F.obj PUnit.unit)","decl":"/-- Auxiliary definition for `functorCategoryEquivalence`. -/\n@[simps]\ndef inverse : (SingleObj G ⥤ V) ⥤ Action V G where\n  obj F :=\n    { V := F.obj PUnit.unit\n      ρ := MonCat.ofHom\n        { toFun := fun g => F.map g\n          map_one' := F.map_id PUnit.unit\n          map_mul' := fun g h => F.map_comp h g } }\n  map f :=\n    { hom := f.app PUnit.unit\n      comm := fun g => f.naturality g }\n\n"}
{"name":"Action.FunctorCategoryEquivalence.unitIso_hom_app_hom","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V : Type (u + 1)\ninst✝ : CategoryTheory.LargeCategory V\nG : MonCat\nX : Action V G\n⊢ Eq (Action.FunctorCategoryEquivalence.unitIso.hom.app X).hom (CategoryTheory.CategoryStruct.id X.V)","decl":"/-- Auxiliary definition for `functorCategoryEquivalence`. -/\n@[simps!]\ndef unitIso : 𝟭 (Action V G) ≅ functor ⋙ inverse :=\n  NatIso.ofComponents fun M => mkIso (Iso.refl _)\n\n"}
{"name":"Action.FunctorCategoryEquivalence.unitIso_inv_app_hom","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V : Type (u + 1)\ninst✝ : CategoryTheory.LargeCategory V\nG : MonCat\nX : Action V G\n⊢ Eq (Action.FunctorCategoryEquivalence.unitIso.inv.app X).hom (CategoryTheory.CategoryStruct.id X.V)","decl":"/-- Auxiliary definition for `functorCategoryEquivalence`. -/\n@[simps!]\ndef unitIso : 𝟭 (Action V G) ≅ functor ⋙ inverse :=\n  NatIso.ofComponents fun M => mkIso (Iso.refl _)\n\n"}
{"name":"Action.FunctorCategoryEquivalence.counitIso_inv_app_app","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V : Type (u + 1)\ninst✝ : CategoryTheory.LargeCategory V\nG : MonCat\nX✝ : CategoryTheory.Functor (CategoryTheory.SingleObj ↑G) V\nX : CategoryTheory.SingleObj ↑G\n⊢ Eq ((Action.FunctorCategoryEquivalence.counitIso.inv.app X✝).app X) (CategoryTheory.CategoryStruct.id (X✝.obj PUnit.unit))","decl":"/-- Auxiliary definition for `functorCategoryEquivalence`. -/\n@[simps!]\ndef counitIso : inverse ⋙ functor ≅ 𝟭 (SingleObj G ⥤ V) :=\n  NatIso.ofComponents fun M => NatIso.ofComponents fun _ => Iso.refl _\n\n"}
{"name":"Action.FunctorCategoryEquivalence.counitIso_hom_app_app","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V : Type (u + 1)\ninst✝ : CategoryTheory.LargeCategory V\nG : MonCat\nX✝ : CategoryTheory.Functor (CategoryTheory.SingleObj ↑G) V\nX : CategoryTheory.SingleObj ↑G\n⊢ Eq ((Action.FunctorCategoryEquivalence.counitIso.hom.app X✝).app X) (CategoryTheory.CategoryStruct.id (X✝.obj PUnit.unit))","decl":"/-- Auxiliary definition for `functorCategoryEquivalence`. -/\n@[simps!]\ndef counitIso : inverse ⋙ functor ≅ 𝟭 (SingleObj G ⥤ V) :=\n  NatIso.ofComponents fun M => NatIso.ofComponents fun _ => Iso.refl _\n\n"}
{"name":"Action.functorCategoryEquivalence_functor","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V : Type (u + 1)\ninst✝ : CategoryTheory.LargeCategory V\nG : MonCat\n⊢ Eq (Action.functorCategoryEquivalence V G).functor Action.FunctorCategoryEquivalence.functor","decl":"/-- The category of actions of `G` in the category `V`\nis equivalent to the functor category `singleObj G ⥤ V`.\n-/\n@[simps]\ndef functorCategoryEquivalence : Action V G ≌ SingleObj G ⥤ V where\n  functor := functor\n  inverse := inverse\n  unitIso := unitIso\n  counitIso := counitIso\n\n"}
{"name":"Action.functorCategoryEquivalence_counitIso","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V : Type (u + 1)\ninst✝ : CategoryTheory.LargeCategory V\nG : MonCat\n⊢ Eq (Action.functorCategoryEquivalence V G).counitIso Action.FunctorCategoryEquivalence.counitIso","decl":"/-- The category of actions of `G` in the category `V`\nis equivalent to the functor category `singleObj G ⥤ V`.\n-/\n@[simps]\ndef functorCategoryEquivalence : Action V G ≌ SingleObj G ⥤ V where\n  functor := functor\n  inverse := inverse\n  unitIso := unitIso\n  counitIso := counitIso\n\n"}
{"name":"Action.functorCategoryEquivalence_inverse","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V : Type (u + 1)\ninst✝ : CategoryTheory.LargeCategory V\nG : MonCat\n⊢ Eq (Action.functorCategoryEquivalence V G).inverse Action.FunctorCategoryEquivalence.inverse","decl":"/-- The category of actions of `G` in the category `V`\nis equivalent to the functor category `singleObj G ⥤ V`.\n-/\n@[simps]\ndef functorCategoryEquivalence : Action V G ≌ SingleObj G ⥤ V where\n  functor := functor\n  inverse := inverse\n  unitIso := unitIso\n  counitIso := counitIso\n\n"}
{"name":"Action.functorCategoryEquivalence_unitIso","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V : Type (u + 1)\ninst✝ : CategoryTheory.LargeCategory V\nG : MonCat\n⊢ Eq (Action.functorCategoryEquivalence V G).unitIso Action.FunctorCategoryEquivalence.unitIso","decl":"/-- The category of actions of `G` in the category `V`\nis equivalent to the functor category `singleObj G ⥤ V`.\n-/\n@[simps]\ndef functorCategoryEquivalence : Action V G ≌ SingleObj G ⥤ V where\n  functor := functor\n  inverse := inverse\n  unitIso := unitIso\n  counitIso := counitIso\n\n"}
{"name":"Action.instIsEquivalenceFunctorSingleObjCarrierFunctor","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V : Type (u + 1)\ninst✝ : CategoryTheory.LargeCategory V\nG : MonCat\n⊢ Action.FunctorCategoryEquivalence.functor.IsEquivalence","decl":"instance : (FunctorCategoryEquivalence.functor (V := V) (G := G)).IsEquivalence :=\n  (functorCategoryEquivalence V G).isEquivalence_functor\n\n"}
{"name":"Action.instIsEquivalenceFunctorSingleObjCarrierInverse","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V : Type (u + 1)\ninst✝ : CategoryTheory.LargeCategory V\nG : MonCat\n⊢ Action.FunctorCategoryEquivalence.inverse.IsEquivalence","decl":"instance : (FunctorCategoryEquivalence.inverse (V := V) (G := G)).IsEquivalence :=\n  (functorCategoryEquivalence V G).isEquivalence_inverse\n\n"}
{"name":"Action.forget_map","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V : Type (u + 1)\ninst✝ : CategoryTheory.LargeCategory V\nG : MonCat\nX✝ Y✝ : Action V G\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((Action.forget V G).map f) f.hom","decl":"/-- (implementation) The forgetful functor from bundled actions to the underlying objects.\n\nUse the `CategoryTheory.forget` API provided by the `HasForget` instance below,\nrather than using this directly.\n-/\n@[simps]\ndef forget : Action V G ⥤ V where\n  obj M := M.V\n  map f := f.hom\n\n"}
{"name":"Action.forget_obj","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V : Type (u + 1)\ninst✝ : CategoryTheory.LargeCategory V\nG : MonCat\nM : Action V G\n⊢ Eq ((Action.forget V G).obj M) M.V","decl":"/-- (implementation) The forgetful functor from bundled actions to the underlying objects.\n\nUse the `CategoryTheory.forget` API provided by the `HasForget` instance below,\nrather than using this directly.\n-/\n@[simps]\ndef forget : Action V G ⥤ V where\n  obj M := M.V\n  map f := f.hom\n\n"}
{"name":"Action.instFaithfulForget","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V : Type (u + 1)\ninst✝ : CategoryTheory.LargeCategory V\nG : MonCat\n⊢ (Action.forget V G).Faithful","decl":"instance : (forget V G).Faithful where map_injective w := Hom.ext w\n\n"}
{"name":"Action.preservesLimits_forget","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V : Type (u + 1)\ninst✝¹ : CategoryTheory.LargeCategory V\nG : MonCat\ninst✝ : CategoryTheory.Limits.HasLimits V\n⊢ CategoryTheory.Limits.PreservesLimits (Action.forget V G)","decl":"noncomputable instance preservesLimits_forget [HasLimits V] :\n    PreservesLimits (forget V G) :=\n  Limits.preservesLimits_of_natIso (Action.functorCategoryEquivalenceCompEvaluation V G)\n\n"}
{"name":"Action.preservesColimits_forget","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V : Type (u + 1)\ninst✝¹ : CategoryTheory.LargeCategory V\nG : MonCat\ninst✝ : CategoryTheory.Limits.HasColimits V\n⊢ CategoryTheory.Limits.PreservesColimits (Action.forget V G)","decl":"noncomputable instance preservesColimits_forget [HasColimits V] :\n    PreservesColimits (forget V G) :=\n  preservesColimits_of_natIso (Action.functorCategoryEquivalenceCompEvaluation V G)\n\n-- TODO construct categorical images?\n"}
{"name":"Action.Iso.conj_ρ","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V : Type (u + 1)\ninst✝ : CategoryTheory.LargeCategory V\nG : MonCat\nM N : Action V G\nf : CategoryTheory.Iso M N\ng : ↑G\n⊢ Eq ((CategoryTheory.ConcreteCategory.hom N.ρ) g) (((Action.forget V G).mapIso f).conj ((CategoryTheory.ConcreteCategory.hom M.ρ) g))","decl":"theorem Iso.conj_ρ {M N : Action V G} (f : M ≅ N) (g : G) :\n    N.ρ g = ((forget V G).mapIso f).conj (M.ρ g) := by\n      rw [Iso.conj_apply, Iso.eq_inv_comp]; simp [f.hom.comm]\n\n"}
{"name":"Action.res_obj_ρ","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V : Type (u + 1)\ninst✝ : CategoryTheory.LargeCategory V\nG H : MonCat\nf : Quiver.Hom G H\nM : Action V H\n⊢ Eq ((Action.res V f).obj M).ρ (CategoryTheory.CategoryStruct.comp f M.ρ)","decl":"/-- The \"restriction\" functor along a monoid homomorphism `f : G ⟶ H`,\ntaking actions of `H` to actions of `G`.\n\n(This makes sense for any homomorphism, but the name is natural when `f` is a monomorphism.)\n-/\n@[simps]\ndef res {G H : MonCat} (f : G ⟶ H) : Action V H ⥤ Action V G where\n  obj M :=\n    { V := M.V\n      ρ := f ≫ M.ρ }\n  map p :=\n    { hom := p.hom\n      comm := fun g => p.comm (f g) }\n\n"}
{"name":"Action.res_map_hom","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V : Type (u + 1)\ninst✝ : CategoryTheory.LargeCategory V\nG H : MonCat\nf : Quiver.Hom G H\nX✝ Y✝ : Action V H\np : Quiver.Hom X✝ Y✝\n⊢ Eq ((Action.res V f).map p).hom p.hom","decl":"/-- The \"restriction\" functor along a monoid homomorphism `f : G ⟶ H`,\ntaking actions of `H` to actions of `G`.\n\n(This makes sense for any homomorphism, but the name is natural when `f` is a monomorphism.)\n-/\n@[simps]\ndef res {G H : MonCat} (f : G ⟶ H) : Action V H ⥤ Action V G where\n  obj M :=\n    { V := M.V\n      ρ := f ≫ M.ρ }\n  map p :=\n    { hom := p.hom\n      comm := fun g => p.comm (f g) }\n\n"}
{"name":"Action.res_obj_V","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V : Type (u + 1)\ninst✝ : CategoryTheory.LargeCategory V\nG H : MonCat\nf : Quiver.Hom G H\nM : Action V H\n⊢ Eq ((Action.res V f).obj M).V M.V","decl":"/-- The \"restriction\" functor along a monoid homomorphism `f : G ⟶ H`,\ntaking actions of `H` to actions of `G`.\n\n(This makes sense for any homomorphism, but the name is natural when `f` is a monomorphism.)\n-/\n@[simps]\ndef res {G H : MonCat} (f : G ⟶ H) : Action V H ⥤ Action V G where\n  obj M :=\n    { V := M.V\n      ρ := f ≫ M.ρ }\n  map p :=\n    { hom := p.hom\n      comm := fun g => p.comm (f g) }\n\n"}
{"name":"Action.resId_hom_app_hom","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V : Type (u + 1)\ninst✝ : CategoryTheory.LargeCategory V\nG : MonCat\nX : Action V G\n⊢ Eq ((Action.resId V).hom.app X).hom (CategoryTheory.CategoryStruct.id X.V)","decl":"/-- The natural isomorphism from restriction along the identity homomorphism to\nthe identity functor on `Action V G`.\n-/\n@[simps!]\ndef resId {G : MonCat} : res V (𝟙 G) ≅ 𝟭 (Action V G) :=\n  NatIso.ofComponents fun M => mkIso (Iso.refl _)\n\n"}
{"name":"Action.resId_inv_app_hom","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V : Type (u + 1)\ninst✝ : CategoryTheory.LargeCategory V\nG : MonCat\nX : Action V G\n⊢ Eq ((Action.resId V).inv.app X).hom (CategoryTheory.CategoryStruct.id X.V)","decl":"/-- The natural isomorphism from restriction along the identity homomorphism to\nthe identity functor on `Action V G`.\n-/\n@[simps!]\ndef resId {G : MonCat} : res V (𝟙 G) ≅ 𝟭 (Action V G) :=\n  NatIso.ofComponents fun M => mkIso (Iso.refl _)\n\n"}
{"name":"Action.resComp_inv_app_hom","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V : Type (u + 1)\ninst✝ : CategoryTheory.LargeCategory V\nG H K : MonCat\nf : Quiver.Hom G H\ng : Quiver.Hom H K\nX : Action V K\n⊢ Eq ((Action.resComp V f g).inv.app X).hom (CategoryTheory.CategoryStruct.id X.V)","decl":"/-- The natural isomorphism from the composition of restrictions along homomorphisms\nto the restriction along the composition of homomorphism.\n-/\n@[simps!]\ndef resComp {G H K : MonCat} (f : G ⟶ H) (g : H ⟶ K) : res V g ⋙ res V f ≅ res V (f ≫ g) :=\n  NatIso.ofComponents fun M => mkIso (Iso.refl _)\n\n-- TODO promote `res` to a pseudofunctor from\n-- the locally discrete bicategory constructed from `Monᵒᵖ` to `Cat`, sending `G` to `Action V G`.\n\n"}
{"name":"Action.resComp_hom_app_hom","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V : Type (u + 1)\ninst✝ : CategoryTheory.LargeCategory V\nG H K : MonCat\nf : Quiver.Hom G H\ng : Quiver.Hom H K\nX : Action V K\n⊢ Eq ((Action.resComp V f g).hom.app X).hom (CategoryTheory.CategoryStruct.id X.V)","decl":"/-- The natural isomorphism from the composition of restrictions along homomorphisms\nto the restriction along the composition of homomorphism.\n-/\n@[simps!]\ndef resComp {G H K : MonCat} (f : G ⟶ H) (g : H ⟶ K) : res V g ⋙ res V f ≅ res V (f ≫ g) :=\n  NatIso.ofComponents fun M => mkIso (Iso.refl _)\n\n-- TODO promote `res` to a pseudofunctor from\n-- the locally discrete bicategory constructed from `Monᵒᵖ` to `Cat`, sending `G` to `Action V G`.\n\n"}
{"name":"CategoryTheory.Functor.mapAction_obj_ρ","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V : Type (u + 1)\ninst✝¹ : CategoryTheory.LargeCategory V\nW : Type (u + 1)\ninst✝ : CategoryTheory.LargeCategory W\nF : CategoryTheory.Functor V W\nG : MonCat\nM : Action V G\n⊢ Eq ((F.mapAction G).obj M).ρ (MonCat.ofHom { toFun := fun g => F.map ((CategoryTheory.ConcreteCategory.hom M.ρ) g), map_one' := ⋯, map_mul' := ⋯ })","decl":"/-- A functor between categories induces a functor between\nthe categories of `G`-actions within those categories. -/\n@[simps]\ndef mapAction (F : V ⥤ W) (G : MonCat.{u}) : Action V G ⥤ Action W G where\n  obj M :=\n    { V := F.obj M.V\n      ρ := MonCat.ofHom\n        { toFun := fun g => F.map (M.ρ g)\n          map_one' := by simp\n          map_mul' := fun g h => by\n            dsimp\n            rw [map_mul, MonCat.mul_of, End.mul_def, F.map_comp] } }\n  map f :=\n    { hom := F.map f.hom\n      comm := fun g => by dsimp; rw [← F.map_comp, f.comm, F.map_comp] }\n  map_id M := by ext; simp only [Action.id_hom, F.map_id]\n  map_comp f g := by ext; simp only [Action.comp_hom, F.map_comp]\n\n"}
{"name":"CategoryTheory.Functor.mapAction_map_hom","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V : Type (u + 1)\ninst✝¹ : CategoryTheory.LargeCategory V\nW : Type (u + 1)\ninst✝ : CategoryTheory.LargeCategory W\nF : CategoryTheory.Functor V W\nG : MonCat\nX✝ Y✝ : Action V G\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((F.mapAction G).map f).hom (F.map f.hom)","decl":"/-- A functor between categories induces a functor between\nthe categories of `G`-actions within those categories. -/\n@[simps]\ndef mapAction (F : V ⥤ W) (G : MonCat.{u}) : Action V G ⥤ Action W G where\n  obj M :=\n    { V := F.obj M.V\n      ρ := MonCat.ofHom\n        { toFun := fun g => F.map (M.ρ g)\n          map_one' := by simp\n          map_mul' := fun g h => by\n            dsimp\n            rw [map_mul, MonCat.mul_of, End.mul_def, F.map_comp] } }\n  map f :=\n    { hom := F.map f.hom\n      comm := fun g => by dsimp; rw [← F.map_comp, f.comm, F.map_comp] }\n  map_id M := by ext; simp only [Action.id_hom, F.map_id]\n  map_comp f g := by ext; simp only [Action.comp_hom, F.map_comp]\n\n"}
{"name":"CategoryTheory.Functor.mapAction_obj_V","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V : Type (u + 1)\ninst✝¹ : CategoryTheory.LargeCategory V\nW : Type (u + 1)\ninst✝ : CategoryTheory.LargeCategory W\nF : CategoryTheory.Functor V W\nG : MonCat\nM : Action V G\n⊢ Eq ((F.mapAction G).obj M).V (F.obj M.V)","decl":"/-- A functor between categories induces a functor between\nthe categories of `G`-actions within those categories. -/\n@[simps]\ndef mapAction (F : V ⥤ W) (G : MonCat.{u}) : Action V G ⥤ Action W G where\n  obj M :=\n    { V := F.obj M.V\n      ρ := MonCat.ofHom\n        { toFun := fun g => F.map (M.ρ g)\n          map_one' := by simp\n          map_mul' := fun g h => by\n            dsimp\n            rw [map_mul, MonCat.mul_of, End.mul_def, F.map_comp] } }\n  map f :=\n    { hom := F.map f.hom\n      comm := fun g => by dsimp; rw [← F.map_comp, f.comm, F.map_comp] }\n  map_id M := by ext; simp only [Action.id_hom, F.map_id]\n  map_comp f g := by ext; simp only [Action.comp_hom, F.map_comp]\n\n"}
