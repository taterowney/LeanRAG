{"name":"Action.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V‚úù : Type (u + 1)\ninst‚úù¬π : CategoryTheory.LargeCategory V‚úù\nG : MonCat\ninst‚úù : SizeOf V‚úù\nV : V‚úù\nœÅ : Quiver.Hom G (MonCat.of (CategoryTheory.End V))\n‚ä¢ Eq (SizeOf.sizeOf { V := V, œÅ := œÅ }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf V)) (SizeOf.sizeOf œÅ))","decl":"/-- An `Action V G` represents a bundled action of\nthe monoid `G` on an object of some category `V`.\n\nAs an example, when `V = ModuleCat R`, this is an `R`-linear representation of `G`,\nwhile when `V = Type` this is a `G`-action.\n-/\nstructure Action (G : MonCat.{u}) where\n  V : V\n  œÅ : G ‚ü∂ MonCat.of (End V)\n\n"}
{"name":"Action.mk.inj","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V‚úù¬π : Type (u + 1)\ninst‚úù : CategoryTheory.LargeCategory V‚úù¬π\nG : MonCat\nV‚úù : V‚úù¬π\nœÅ‚úù : Quiver.Hom G (MonCat.of (CategoryTheory.End V‚úù))\nV : V‚úù¬π\nœÅ : Quiver.Hom G (MonCat.of (CategoryTheory.End V))\nx‚úù : Eq { V := V‚úù, œÅ := œÅ‚úù } { V := V, œÅ := œÅ }\n‚ä¢ And (Eq V‚úù V) (HEq œÅ‚úù œÅ)","decl":"/-- An `Action V G` represents a bundled action of\nthe monoid `G` on an object of some category `V`.\n\nAs an example, when `V = ModuleCat R`, this is an `R`-linear representation of `G`,\nwhile when `V = Type` this is a `G`-action.\n-/\nstructure Action (G : MonCat.{u}) where\n  V : V\n  œÅ : G ‚ü∂ MonCat.of (End V)\n\n"}
{"name":"Action.mk.injEq","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V‚úù¬π : Type (u + 1)\ninst‚úù : CategoryTheory.LargeCategory V‚úù¬π\nG : MonCat\nV‚úù : V‚úù¬π\nœÅ‚úù : Quiver.Hom G (MonCat.of (CategoryTheory.End V‚úù))\nV : V‚úù¬π\nœÅ : Quiver.Hom G (MonCat.of (CategoryTheory.End V))\n‚ä¢ Eq (Eq { V := V‚úù, œÅ := œÅ‚úù } { V := V, œÅ := œÅ }) (And (Eq V‚úù V) (HEq œÅ‚úù œÅ))","decl":"/-- An `Action V G` represents a bundled action of\nthe monoid `G` on an object of some category `V`.\n\nAs an example, when `V = ModuleCat R`, this is an `R`-linear representation of `G`,\nwhile when `V = Type` this is a `G`-action.\n-/\nstructure Action (G : MonCat.{u}) where\n  V : V\n  œÅ : G ‚ü∂ MonCat.of (End V)\n\n"}
{"name":"Action.œÅ_one","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V : Type (u + 1)\ninst‚úù : CategoryTheory.LargeCategory V\nG : MonCat\nA : Action V G\n‚ä¢ Eq ((CategoryTheory.ConcreteCategory.hom A.œÅ) 1) (CategoryTheory.CategoryStruct.id A.V)","decl":"theorem œÅ_one {G : MonCat.{u}} (A : Action V G) : A.œÅ 1 = ùüô A.V := by simp\n\n"}
{"name":"Action.œÅAut_hom_apply_inv","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V : Type (u + 1)\ninst‚úù : CategoryTheory.LargeCategory V\nG : Grp\nA : Action V (MonCat.of ‚ÜëG)\ng : ‚ÜëG\n‚ä¢ Eq ((Grp.Hom.hom A.œÅAut) g).inv ((CategoryTheory.ConcreteCategory.hom A.œÅ) (Inv.inv g))","decl":"/-- When a group acts, we can lift the action to the group of automorphisms. -/\n@[simps!]\ndef œÅAut {G : Grp.{u}} (A : Action V (MonCat.of G)) : G ‚ü∂ Grp.of (Aut A.V) :=\n  Grp.ofHom\n  { toFun g :=\n      { hom := A.œÅ g\n        inv := A.œÅ (g‚Åª¬π : G)\n        hom_inv_id := (A.œÅ.hom.map_mul (g‚Åª¬π : G) g).symm.trans (by rw [inv_mul_cancel, œÅ_one])\n        inv_hom_id := (A.œÅ.hom.map_mul g (g‚Åª¬π : G)).symm.trans (by rw [mul_inv_cancel, œÅ_one]) }\n    map_one' := Aut.ext A.œÅ.hom.map_one\n    map_mul' x y := Aut.ext (A.œÅ.hom.map_mul x y) }\n\n"}
{"name":"Action.œÅAut_hom_apply_hom","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V : Type (u + 1)\ninst‚úù : CategoryTheory.LargeCategory V\nG : Grp\nA : Action V (MonCat.of ‚ÜëG)\ng : ‚ÜëG\n‚ä¢ Eq ((Grp.Hom.hom A.œÅAut) g).hom ((CategoryTheory.ConcreteCategory.hom A.œÅ) g)","decl":"/-- When a group acts, we can lift the action to the group of automorphisms. -/\n@[simps!]\ndef œÅAut {G : Grp.{u}} (A : Action V (MonCat.of G)) : G ‚ü∂ Grp.of (Aut A.V) :=\n  Grp.ofHom\n  { toFun g :=\n      { hom := A.œÅ g\n        inv := A.œÅ (g‚Åª¬π : G)\n        hom_inv_id := (A.œÅ.hom.map_mul (g‚Åª¬π : G) g).symm.trans (by rw [inv_mul_cancel, œÅ_one])\n        inv_hom_id := (A.œÅ.hom.map_mul g (g‚Åª¬π : G)).symm.trans (by rw [mul_inv_cancel, œÅ_one]) }\n    map_one' := Aut.ext A.œÅ.hom.map_one\n    map_mul' x y := Aut.ext (A.œÅ.hom.map_mul x y) }\n\n"}
{"name":"Action.Hom.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V : Type (u + 1)\ninst‚úù¬π : CategoryTheory.LargeCategory V\nG : MonCat\nM N : Action V G\ninst‚úù : SizeOf V\nhom : Quiver.Hom M.V N.V\ncomm : autoParam (‚àÄ (g : ‚ÜëG), Eq (CategoryTheory.CategoryStruct.comp ((MonCat.Hom.hom M.œÅ) g) hom) (CategoryTheory.CategoryStruct.comp hom ((CategoryTheory.ConcreteCategory.hom N.œÅ) g))) _auto‚úù\n‚ä¢ Eq (SizeOf.sizeOf { hom := hom, comm := comm }) (HAdd.hAdd 1 (SizeOf.sizeOf hom))","decl":"/-- A homomorphism of `Action V G`s is a morphism between the underlying objects,\ncommuting with the action of `G`.\n-/\n@[ext]\nstructure Hom (M N : Action V G) where\n  hom : M.V ‚ü∂ N.V\n  -- Have to insert type hint for `F`, otherwise it ends up as:\n  -- `(fun Œ± Œ≤ => ‚ÜëŒ± ‚Üí* Œ≤) (MonCat.of (End _)) G`\n  -- which `simp` reduces to `‚Üë(MonCat.of (End _)) ‚Üí* Œ≤` instead of `End _ ‚Üí* Œ≤`.\n  -- Strangely enough, the `@[reassoc]` version works fine.\n  comm : ‚àÄ g : G, DFunLike.coe (F := _ ‚Üí* End _) M.œÅ.hom g ‚â´ hom = hom ‚â´ N.œÅ g := by aesop_cat\n\n"}
{"name":"Action.Hom.ext","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V : Type (u + 1)\ninst‚úù : CategoryTheory.LargeCategory V\nG : MonCat\nM N : Action V G\nx y : M.Hom N\nhom : Eq x.hom y.hom\n‚ä¢ Eq x y","decl":"/-- A homomorphism of `Action V G`s is a morphism between the underlying objects,\ncommuting with the action of `G`.\n-/\n@[ext]\nstructure Hom (M N : Action V G) where\n  hom : M.V ‚ü∂ N.V\n  -- Have to insert type hint for `F`, otherwise it ends up as:\n  -- `(fun Œ± Œ≤ => ‚ÜëŒ± ‚Üí* Œ≤) (MonCat.of (End _)) G`\n  -- which `simp` reduces to `‚Üë(MonCat.of (End _)) ‚Üí* Œ≤` instead of `End _ ‚Üí* Œ≤`.\n  -- Strangely enough, the `@[reassoc]` version works fine.\n  comm : ‚àÄ g : G, DFunLike.coe (F := _ ‚Üí* End _) M.œÅ.hom g ‚â´ hom = hom ‚â´ N.œÅ g := by aesop_cat\n\n"}
{"name":"Action.Hom.ext_iff","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V : Type (u + 1)\ninst‚úù : CategoryTheory.LargeCategory V\nG : MonCat\nM N : Action V G\nx y : M.Hom N\n‚ä¢ Iff (Eq x y) (Eq x.hom y.hom)","decl":"/-- A homomorphism of `Action V G`s is a morphism between the underlying objects,\ncommuting with the action of `G`.\n-/\n@[ext]\nstructure Hom (M N : Action V G) where\n  hom : M.V ‚ü∂ N.V\n  -- Have to insert type hint for `F`, otherwise it ends up as:\n  -- `(fun Œ± Œ≤ => ‚ÜëŒ± ‚Üí* Œ≤) (MonCat.of (End _)) G`\n  -- which `simp` reduces to `‚Üë(MonCat.of (End _)) ‚Üí* Œ≤` instead of `End _ ‚Üí* Œ≤`.\n  -- Strangely enough, the `@[reassoc]` version works fine.\n  comm : ‚àÄ g : G, DFunLike.coe (F := _ ‚Üí* End _) M.œÅ.hom g ‚â´ hom = hom ‚â´ N.œÅ g := by aesop_cat\n\n"}
{"name":"Action.Hom.mk.inj","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V : Type (u + 1)\ninst‚úù : CategoryTheory.LargeCategory V\nG : MonCat\nM N : Action V G\nhom‚úù : Quiver.Hom M.V N.V\ncomm‚úù : autoParam (‚àÄ (g : ‚ÜëG), Eq (CategoryTheory.CategoryStruct.comp ((MonCat.Hom.hom M.œÅ) g) hom‚úù) (CategoryTheory.CategoryStruct.comp hom‚úù ((CategoryTheory.ConcreteCategory.hom N.œÅ) g))) _auto‚úù\nhom : Quiver.Hom M.V N.V\ncomm : autoParam (‚àÄ (g : ‚ÜëG), Eq (CategoryTheory.CategoryStruct.comp ((MonCat.Hom.hom M.œÅ) g) hom) (CategoryTheory.CategoryStruct.comp hom ((CategoryTheory.ConcreteCategory.hom N.œÅ) g))) _auto‚úù\nx‚úù : Eq { hom := hom‚úù, comm := comm‚úù } { hom := hom, comm := comm }\n‚ä¢ Eq hom‚úù hom","decl":"/-- A homomorphism of `Action V G`s is a morphism between the underlying objects,\ncommuting with the action of `G`.\n-/\n@[ext]\nstructure Hom (M N : Action V G) where\n  hom : M.V ‚ü∂ N.V\n  -- Have to insert type hint for `F`, otherwise it ends up as:\n  -- `(fun Œ± Œ≤ => ‚ÜëŒ± ‚Üí* Œ≤) (MonCat.of (End _)) G`\n  -- which `simp` reduces to `‚Üë(MonCat.of (End _)) ‚Üí* Œ≤` instead of `End _ ‚Üí* Œ≤`.\n  -- Strangely enough, the `@[reassoc]` version works fine.\n  comm : ‚àÄ g : G, DFunLike.coe (F := _ ‚Üí* End _) M.œÅ.hom g ‚â´ hom = hom ‚â´ N.œÅ g := by aesop_cat\n\n"}
{"name":"Action.Hom.mk.injEq","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V : Type (u + 1)\ninst‚úù : CategoryTheory.LargeCategory V\nG : MonCat\nM N : Action V G\nhom‚úù : Quiver.Hom M.V N.V\ncomm‚úù : autoParam (‚àÄ (g : ‚ÜëG), Eq (CategoryTheory.CategoryStruct.comp ((MonCat.Hom.hom M.œÅ) g) hom‚úù) (CategoryTheory.CategoryStruct.comp hom‚úù ((CategoryTheory.ConcreteCategory.hom N.œÅ) g))) _auto‚úù\nhom : Quiver.Hom M.V N.V\ncomm : autoParam (‚àÄ (g : ‚ÜëG), Eq (CategoryTheory.CategoryStruct.comp ((MonCat.Hom.hom M.œÅ) g) hom) (CategoryTheory.CategoryStruct.comp hom ((CategoryTheory.ConcreteCategory.hom N.œÅ) g))) _auto‚úù\n‚ä¢ Eq (Eq { hom := hom‚úù, comm := comm‚úù } { hom := hom, comm := comm }) (Eq hom‚úù hom)","decl":"/-- A homomorphism of `Action V G`s is a morphism between the underlying objects,\ncommuting with the action of `G`.\n-/\n@[ext]\nstructure Hom (M N : Action V G) where\n  hom : M.V ‚ü∂ N.V\n  -- Have to insert type hint for `F`, otherwise it ends up as:\n  -- `(fun Œ± Œ≤ => ‚ÜëŒ± ‚Üí* Œ≤) (MonCat.of (End _)) G`\n  -- which `simp` reduces to `‚Üë(MonCat.of (End _)) ‚Üí* Œ≤` instead of `End _ ‚Üí* Œ≤`.\n  -- Strangely enough, the `@[reassoc]` version works fine.\n  comm : ‚àÄ g : G, DFunLike.coe (F := _ ‚Üí* End _) M.œÅ.hom g ‚â´ hom = hom ‚â´ N.œÅ g := by aesop_cat\n\n"}
{"name":"Action.Hom.comm","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V : Type (u + 1)\ninst‚úù : CategoryTheory.LargeCategory V\nG : MonCat\nM N : Action V G\nself : M.Hom N\ng : ‚ÜëG\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((MonCat.Hom.hom M.œÅ) g) self.hom) (CategoryTheory.CategoryStruct.comp self.hom ((CategoryTheory.ConcreteCategory.hom N.œÅ) g))","decl":"/-- A homomorphism of `Action V G`s is a morphism between the underlying objects,\ncommuting with the action of `G`.\n-/\n@[ext]\nstructure Hom (M N : Action V G) where\n  hom : M.V ‚ü∂ N.V\n  -- Have to insert type hint for `F`, otherwise it ends up as:\n  -- `(fun Œ± Œ≤ => ‚ÜëŒ± ‚Üí* Œ≤) (MonCat.of (End _)) G`\n  -- which `simp` reduces to `‚Üë(MonCat.of (End _)) ‚Üí* Œ≤` instead of `End _ ‚Üí* Œ≤`.\n  -- Strangely enough, the `@[reassoc]` version works fine.\n  comm : ‚àÄ g : G, DFunLike.coe (F := _ ‚Üí* End _) M.œÅ.hom g ‚â´ hom = hom ‚â´ N.œÅ g := by aesop_cat\n\n"}
{"name":"Action.Hom.comm_assoc","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V : Type (u + 1)\ninst‚úù : CategoryTheory.LargeCategory V\nG : MonCat\nM N : Action V G\nself : M.Hom N\ng : ‚ÜëG\nZ : V\nh : Quiver.Hom N.V Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((MonCat.Hom.hom M.œÅ) g) (CategoryTheory.CategoryStruct.comp self.hom h)) (CategoryTheory.CategoryStruct.comp self.hom (CategoryTheory.CategoryStruct.comp ((CategoryTheory.ConcreteCategory.hom N.œÅ) g) h))","decl":"attribute [reassoc] comm\n"}
{"name":"Action.Hom.id_hom","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V : Type (u + 1)\ninst‚úù : CategoryTheory.LargeCategory V\nG : MonCat\nM : Action V G\n‚ä¢ Eq (Action.Hom.id M).hom (CategoryTheory.CategoryStruct.id M.V)","decl":"/-- The identity morphism on an `Action V G`. -/\n@[simps]\ndef id (M : Action V G) : Action.Hom M M where hom := ùüô M.V\n\n"}
{"name":"Action.Hom.comp_hom","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V : Type (u + 1)\ninst‚úù : CategoryTheory.LargeCategory V\nG : MonCat\nM N K : Action V G\np : M.Hom N\nq : N.Hom K\n‚ä¢ Eq (p.comp q).hom (CategoryTheory.CategoryStruct.comp p.hom q.hom)","decl":"/-- The composition of two `Action V G` homomorphisms is the composition of the underlying maps.\n-/\n@[simps]\ndef comp {M N K : Action V G} (p : Action.Hom M N) (q : Action.Hom N K) : Action.Hom M K where\n  hom := p.hom ‚â´ q.hom\n\n"}
{"name":"Action.hom_ext_iff","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V : Type (u + 1)\ninst‚úù : CategoryTheory.LargeCategory V\nG : MonCat\nM N : Action V G\nœÜ‚ÇÅ œÜ‚ÇÇ : Quiver.Hom M N\n‚ä¢ Iff (Eq œÜ‚ÇÅ œÜ‚ÇÇ) (Eq œÜ‚ÇÅ.hom œÜ‚ÇÇ.hom)","decl":"@[ext]\nlemma hom_ext {M N : Action V G} (œÜ‚ÇÅ œÜ‚ÇÇ : M ‚ü∂ N) (h : œÜ‚ÇÅ.hom = œÜ‚ÇÇ.hom) : œÜ‚ÇÅ = œÜ‚ÇÇ :=\n  Hom.ext h\n\n"}
{"name":"Action.hom_ext","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V : Type (u + 1)\ninst‚úù : CategoryTheory.LargeCategory V\nG : MonCat\nM N : Action V G\nœÜ‚ÇÅ œÜ‚ÇÇ : Quiver.Hom M N\nh : Eq œÜ‚ÇÅ.hom œÜ‚ÇÇ.hom\n‚ä¢ Eq œÜ‚ÇÅ œÜ‚ÇÇ","decl":"@[ext]\nlemma hom_ext {M N : Action V G} (œÜ‚ÇÅ œÜ‚ÇÇ : M ‚ü∂ N) (h : œÜ‚ÇÅ.hom = œÜ‚ÇÇ.hom) : œÜ‚ÇÅ = œÜ‚ÇÇ :=\n  Hom.ext h\n\n"}
{"name":"Action.id_hom","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V : Type (u + 1)\ninst‚úù : CategoryTheory.LargeCategory V\nG : MonCat\nM : Action V G\n‚ä¢ Eq (CategoryTheory.CategoryStruct.id M).hom (CategoryTheory.CategoryStruct.id M.V)","decl":"@[simp]\ntheorem id_hom (M : Action V G) : (ùüô M : Hom M M).hom = ùüô M.V :=\n  rfl\n\n"}
{"name":"Action.comp_hom","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V : Type (u + 1)\ninst‚úù : CategoryTheory.LargeCategory V\nG : MonCat\nM N K : Action V G\nf : Quiver.Hom M N\ng : Quiver.Hom N K\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f g).hom (CategoryTheory.CategoryStruct.comp f.hom g.hom)","decl":"@[simp]\ntheorem comp_hom {M N K : Action V G} (f : M ‚ü∂ N) (g : N ‚ü∂ K) :\n    (f ‚â´ g : Hom M K).hom = f.hom ‚â´ g.hom :=\n  rfl\n\n"}
{"name":"Action.hom_inv_hom","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V : Type (u + 1)\ninst‚úù : CategoryTheory.LargeCategory V\nG : MonCat\nM N : Action V G\nf : CategoryTheory.Iso M N\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f.hom.hom f.inv.hom) (CategoryTheory.CategoryStruct.id M.V)","decl":"@[simp]\ntheorem hom_inv_hom {M N : Action V G} (f : M ‚âÖ N) :\n    f.hom.hom ‚â´ f.inv.hom = ùüô M.V := by\n  rw [‚Üê comp_hom, Iso.hom_inv_id, id_hom]\n\n"}
{"name":"Action.inv_hom_hom","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V : Type (u + 1)\ninst‚úù : CategoryTheory.LargeCategory V\nG : MonCat\nM N : Action V G\nf : CategoryTheory.Iso M N\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f.inv.hom f.hom.hom) (CategoryTheory.CategoryStruct.id N.V)","decl":"@[simp]\ntheorem inv_hom_hom {M N : Action V G} (f : M ‚âÖ N) :\n    f.inv.hom ‚â´ f.hom.hom = ùüô N.V := by\n  rw [‚Üê comp_hom, Iso.inv_hom_id, id_hom]\n\n"}
{"name":"Action.mkIso_inv_hom","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V : Type (u + 1)\ninst‚úù : CategoryTheory.LargeCategory V\nG : MonCat\nM N : Action V G\nf : CategoryTheory.Iso M.V N.V\ncomm : autoParam (‚àÄ (g : ‚ÜëG), Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.ConcreteCategory.hom M.œÅ) g) f.hom) (CategoryTheory.CategoryStruct.comp f.hom ((CategoryTheory.ConcreteCategory.hom N.œÅ) g))) _auto‚úù\n‚ä¢ Eq (Action.mkIso f comm).inv.hom f.inv","decl":"/-- Construct an isomorphism of `G` actions/representations\nfrom an isomorphism of the underlying objects,\nwhere the forward direction commutes with the group action. -/\n@[simps]\ndef mkIso {M N : Action V G} (f : M.V ‚âÖ N.V)\n    (comm : ‚àÄ g : G, M.œÅ g ‚â´ f.hom = f.hom ‚â´ N.œÅ g := by aesop_cat) : M ‚âÖ N where\n  hom :=\n    { hom := f.hom\n      comm := comm }\n  inv :=\n    { hom := f.inv\n      comm := fun g => by have w := comm g =‚â´ f.inv; simp at w; simp [w] }\n\n"}
{"name":"Action.mkIso_hom_hom","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V : Type (u + 1)\ninst‚úù : CategoryTheory.LargeCategory V\nG : MonCat\nM N : Action V G\nf : CategoryTheory.Iso M.V N.V\ncomm : autoParam (‚àÄ (g : ‚ÜëG), Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.ConcreteCategory.hom M.œÅ) g) f.hom) (CategoryTheory.CategoryStruct.comp f.hom ((CategoryTheory.ConcreteCategory.hom N.œÅ) g))) _auto‚úù\n‚ä¢ Eq (Action.mkIso f comm).hom.hom f.hom","decl":"/-- Construct an isomorphism of `G` actions/representations\nfrom an isomorphism of the underlying objects,\nwhere the forward direction commutes with the group action. -/\n@[simps]\ndef mkIso {M N : Action V G} (f : M.V ‚âÖ N.V)\n    (comm : ‚àÄ g : G, M.œÅ g ‚â´ f.hom = f.hom ‚â´ N.œÅ g := by aesop_cat) : M ‚âÖ N where\n  hom :=\n    { hom := f.hom\n      comm := comm }\n  inv :=\n    { hom := f.inv\n      comm := fun g => by have w := comm g =‚â´ f.inv; simp at w; simp [w] }\n\n"}
{"name":"Action.isIso_of_hom_isIso","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V : Type (u + 1)\ninst‚úù¬π : CategoryTheory.LargeCategory V\nG : MonCat\nM N : Action V G\nf : Quiver.Hom M N\ninst‚úù : CategoryTheory.IsIso f.hom\n‚ä¢ CategoryTheory.IsIso f","decl":"instance (priority := 100) isIso_of_hom_isIso {M N : Action V G} (f : M ‚ü∂ N) [IsIso f.hom] :\n    IsIso f := (mkIso (asIso f.hom) f.comm).isIso_hom\n\n"}
{"name":"Action.isIso_hom_mk","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V : Type (u + 1)\ninst‚úù¬π : CategoryTheory.LargeCategory V\nG : MonCat\nM N : Action V G\nf : Quiver.Hom M.V N.V\ninst‚úù : CategoryTheory.IsIso f\nw : ‚àÄ (g : ‚ÜëG), Eq (CategoryTheory.CategoryStruct.comp ((MonCat.Hom.hom M.œÅ) g) f) (CategoryTheory.CategoryStruct.comp f ((CategoryTheory.ConcreteCategory.hom N.œÅ) g))\n‚ä¢ CategoryTheory.IsIso { hom := f, comm := w }","decl":"instance isIso_hom_mk {M N : Action V G} (f : M.V ‚ü∂ N.V) [IsIso f] (w) :\n    @IsIso _ _ M N (Hom.mk f w) :=\n  (mkIso (asIso f) w).isIso_hom\n\n"}
{"name":"Action.instIsIsoHomHom","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V : Type (u + 1)\ninst‚úù : CategoryTheory.LargeCategory V\nG : MonCat\nM N : Action V G\nf : CategoryTheory.Iso M N\n‚ä¢ CategoryTheory.IsIso f.hom.hom","decl":"instance {M N : Action V G} (f : M ‚âÖ N) : IsIso f.hom.hom where\n  out := ‚ü®f.inv.hom, by simp‚ü©\n\n"}
{"name":"Action.instIsIsoHomInv","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V : Type (u + 1)\ninst‚úù : CategoryTheory.LargeCategory V\nG : MonCat\nM N : Action V G\nf : CategoryTheory.Iso M N\n‚ä¢ CategoryTheory.IsIso f.inv.hom","decl":"instance {M N : Action V G} (f : M ‚âÖ N) : IsIso f.inv.hom where\n  out := ‚ü®f.hom.hom, by simp‚ü©\n\n"}
{"name":"Action.FunctorCategoryEquivalence.functor_map_app","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V : Type (u + 1)\ninst‚úù : CategoryTheory.LargeCategory V\nG : MonCat\nX‚úù Y‚úù : Action V G\nf : Quiver.Hom X‚úù Y‚úù\nx‚úù : CategoryTheory.SingleObj ‚ÜëG\n‚ä¢ Eq ((Action.FunctorCategoryEquivalence.functor.map f).app x‚úù) f.hom","decl":"/-- Auxiliary definition for `functorCategoryEquivalence`. -/\n@[simps]\ndef functor : Action V G ‚•§ SingleObj G ‚•§ V where\n  obj M :=\n    { obj := fun _ => M.V\n      map := fun g => M.œÅ g\n      map_id := fun _ => M.œÅ.hom.map_one\n      map_comp := fun g h => M.œÅ.hom.map_mul h g }\n  map f :=\n    { app := fun _ => f.hom\n      naturality := fun _ _ g => f.comm g }\n\n"}
{"name":"Action.FunctorCategoryEquivalence.functor_obj_map","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V : Type (u + 1)\ninst‚úù : CategoryTheory.LargeCategory V\nG : MonCat\nM : Action V G\nX‚úù Y‚úù : CategoryTheory.SingleObj ‚ÜëG\ng : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((Action.FunctorCategoryEquivalence.functor.obj M).map g) ((CategoryTheory.ConcreteCategory.hom M.œÅ) g)","decl":"/-- Auxiliary definition for `functorCategoryEquivalence`. -/\n@[simps]\ndef functor : Action V G ‚•§ SingleObj G ‚•§ V where\n  obj M :=\n    { obj := fun _ => M.V\n      map := fun g => M.œÅ g\n      map_id := fun _ => M.œÅ.hom.map_one\n      map_comp := fun g h => M.œÅ.hom.map_mul h g }\n  map f :=\n    { app := fun _ => f.hom\n      naturality := fun _ _ g => f.comm g }\n\n"}
{"name":"Action.FunctorCategoryEquivalence.functor_obj_obj","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V : Type (u + 1)\ninst‚úù : CategoryTheory.LargeCategory V\nG : MonCat\nM : Action V G\nx‚úù : CategoryTheory.SingleObj ‚ÜëG\n‚ä¢ Eq ((Action.FunctorCategoryEquivalence.functor.obj M).obj x‚úù) M.V","decl":"/-- Auxiliary definition for `functorCategoryEquivalence`. -/\n@[simps]\ndef functor : Action V G ‚•§ SingleObj G ‚•§ V where\n  obj M :=\n    { obj := fun _ => M.V\n      map := fun g => M.œÅ g\n      map_id := fun _ => M.œÅ.hom.map_one\n      map_comp := fun g h => M.œÅ.hom.map_mul h g }\n  map f :=\n    { app := fun _ => f.hom\n      naturality := fun _ _ g => f.comm g }\n\n"}
{"name":"Action.FunctorCategoryEquivalence.inverse_map_hom","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V : Type (u + 1)\ninst‚úù : CategoryTheory.LargeCategory V\nG : MonCat\nX‚úù Y‚úù : CategoryTheory.Functor (CategoryTheory.SingleObj ‚ÜëG) V\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (Action.FunctorCategoryEquivalence.inverse.map f).hom (f.app PUnit.unit)","decl":"/-- Auxiliary definition for `functorCategoryEquivalence`. -/\n@[simps]\ndef inverse : (SingleObj G ‚•§ V) ‚•§ Action V G where\n  obj F :=\n    { V := F.obj PUnit.unit\n      œÅ := MonCat.ofHom\n        { toFun := fun g => F.map g\n          map_one' := F.map_id PUnit.unit\n          map_mul' := fun g h => F.map_comp h g } }\n  map f :=\n    { hom := f.app PUnit.unit\n      comm := fun g => f.naturality g }\n\n"}
{"name":"Action.FunctorCategoryEquivalence.inverse_obj_œÅ","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V : Type (u + 1)\ninst‚úù : CategoryTheory.LargeCategory V\nG : MonCat\nF : CategoryTheory.Functor (CategoryTheory.SingleObj ‚ÜëG) V\n‚ä¢ Eq (Action.FunctorCategoryEquivalence.inverse.obj F).œÅ (MonCat.ofHom { toFun := fun g => F.map g, map_one' := ‚ãØ, map_mul' := ‚ãØ })","decl":"/-- Auxiliary definition for `functorCategoryEquivalence`. -/\n@[simps]\ndef inverse : (SingleObj G ‚•§ V) ‚•§ Action V G where\n  obj F :=\n    { V := F.obj PUnit.unit\n      œÅ := MonCat.ofHom\n        { toFun := fun g => F.map g\n          map_one' := F.map_id PUnit.unit\n          map_mul' := fun g h => F.map_comp h g } }\n  map f :=\n    { hom := f.app PUnit.unit\n      comm := fun g => f.naturality g }\n\n"}
{"name":"Action.FunctorCategoryEquivalence.inverse_obj_V","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V : Type (u + 1)\ninst‚úù : CategoryTheory.LargeCategory V\nG : MonCat\nF : CategoryTheory.Functor (CategoryTheory.SingleObj ‚ÜëG) V\n‚ä¢ Eq (Action.FunctorCategoryEquivalence.inverse.obj F).V (F.obj PUnit.unit)","decl":"/-- Auxiliary definition for `functorCategoryEquivalence`. -/\n@[simps]\ndef inverse : (SingleObj G ‚•§ V) ‚•§ Action V G where\n  obj F :=\n    { V := F.obj PUnit.unit\n      œÅ := MonCat.ofHom\n        { toFun := fun g => F.map g\n          map_one' := F.map_id PUnit.unit\n          map_mul' := fun g h => F.map_comp h g } }\n  map f :=\n    { hom := f.app PUnit.unit\n      comm := fun g => f.naturality g }\n\n"}
{"name":"Action.FunctorCategoryEquivalence.unitIso_hom_app_hom","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V : Type (u + 1)\ninst‚úù : CategoryTheory.LargeCategory V\nG : MonCat\nX : Action V G\n‚ä¢ Eq (Action.FunctorCategoryEquivalence.unitIso.hom.app X).hom (CategoryTheory.CategoryStruct.id X.V)","decl":"/-- Auxiliary definition for `functorCategoryEquivalence`. -/\n@[simps!]\ndef unitIso : ùü≠ (Action V G) ‚âÖ functor ‚ãô inverse :=\n  NatIso.ofComponents fun M => mkIso (Iso.refl _)\n\n"}
{"name":"Action.FunctorCategoryEquivalence.unitIso_inv_app_hom","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V : Type (u + 1)\ninst‚úù : CategoryTheory.LargeCategory V\nG : MonCat\nX : Action V G\n‚ä¢ Eq (Action.FunctorCategoryEquivalence.unitIso.inv.app X).hom (CategoryTheory.CategoryStruct.id X.V)","decl":"/-- Auxiliary definition for `functorCategoryEquivalence`. -/\n@[simps!]\ndef unitIso : ùü≠ (Action V G) ‚âÖ functor ‚ãô inverse :=\n  NatIso.ofComponents fun M => mkIso (Iso.refl _)\n\n"}
{"name":"Action.FunctorCategoryEquivalence.counitIso_inv_app_app","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V : Type (u + 1)\ninst‚úù : CategoryTheory.LargeCategory V\nG : MonCat\nX‚úù : CategoryTheory.Functor (CategoryTheory.SingleObj ‚ÜëG) V\nX : CategoryTheory.SingleObj ‚ÜëG\n‚ä¢ Eq ((Action.FunctorCategoryEquivalence.counitIso.inv.app X‚úù).app X) (CategoryTheory.CategoryStruct.id (X‚úù.obj PUnit.unit))","decl":"/-- Auxiliary definition for `functorCategoryEquivalence`. -/\n@[simps!]\ndef counitIso : inverse ‚ãô functor ‚âÖ ùü≠ (SingleObj G ‚•§ V) :=\n  NatIso.ofComponents fun M => NatIso.ofComponents fun _ => Iso.refl _\n\n"}
{"name":"Action.FunctorCategoryEquivalence.counitIso_hom_app_app","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V : Type (u + 1)\ninst‚úù : CategoryTheory.LargeCategory V\nG : MonCat\nX‚úù : CategoryTheory.Functor (CategoryTheory.SingleObj ‚ÜëG) V\nX : CategoryTheory.SingleObj ‚ÜëG\n‚ä¢ Eq ((Action.FunctorCategoryEquivalence.counitIso.hom.app X‚úù).app X) (CategoryTheory.CategoryStruct.id (X‚úù.obj PUnit.unit))","decl":"/-- Auxiliary definition for `functorCategoryEquivalence`. -/\n@[simps!]\ndef counitIso : inverse ‚ãô functor ‚âÖ ùü≠ (SingleObj G ‚•§ V) :=\n  NatIso.ofComponents fun M => NatIso.ofComponents fun _ => Iso.refl _\n\n"}
{"name":"Action.functorCategoryEquivalence_functor","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V : Type (u + 1)\ninst‚úù : CategoryTheory.LargeCategory V\nG : MonCat\n‚ä¢ Eq (Action.functorCategoryEquivalence V G).functor Action.FunctorCategoryEquivalence.functor","decl":"/-- The category of actions of `G` in the category `V`\nis equivalent to the functor category `singleObj G ‚•§ V`.\n-/\n@[simps]\ndef functorCategoryEquivalence : Action V G ‚âå SingleObj G ‚•§ V where\n  functor := functor\n  inverse := inverse\n  unitIso := unitIso\n  counitIso := counitIso\n\n"}
{"name":"Action.functorCategoryEquivalence_counitIso","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V : Type (u + 1)\ninst‚úù : CategoryTheory.LargeCategory V\nG : MonCat\n‚ä¢ Eq (Action.functorCategoryEquivalence V G).counitIso Action.FunctorCategoryEquivalence.counitIso","decl":"/-- The category of actions of `G` in the category `V`\nis equivalent to the functor category `singleObj G ‚•§ V`.\n-/\n@[simps]\ndef functorCategoryEquivalence : Action V G ‚âå SingleObj G ‚•§ V where\n  functor := functor\n  inverse := inverse\n  unitIso := unitIso\n  counitIso := counitIso\n\n"}
{"name":"Action.functorCategoryEquivalence_inverse","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V : Type (u + 1)\ninst‚úù : CategoryTheory.LargeCategory V\nG : MonCat\n‚ä¢ Eq (Action.functorCategoryEquivalence V G).inverse Action.FunctorCategoryEquivalence.inverse","decl":"/-- The category of actions of `G` in the category `V`\nis equivalent to the functor category `singleObj G ‚•§ V`.\n-/\n@[simps]\ndef functorCategoryEquivalence : Action V G ‚âå SingleObj G ‚•§ V where\n  functor := functor\n  inverse := inverse\n  unitIso := unitIso\n  counitIso := counitIso\n\n"}
{"name":"Action.functorCategoryEquivalence_unitIso","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V : Type (u + 1)\ninst‚úù : CategoryTheory.LargeCategory V\nG : MonCat\n‚ä¢ Eq (Action.functorCategoryEquivalence V G).unitIso Action.FunctorCategoryEquivalence.unitIso","decl":"/-- The category of actions of `G` in the category `V`\nis equivalent to the functor category `singleObj G ‚•§ V`.\n-/\n@[simps]\ndef functorCategoryEquivalence : Action V G ‚âå SingleObj G ‚•§ V where\n  functor := functor\n  inverse := inverse\n  unitIso := unitIso\n  counitIso := counitIso\n\n"}
{"name":"Action.instIsEquivalenceFunctorSingleObjCarrierFunctor","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V : Type (u + 1)\ninst‚úù : CategoryTheory.LargeCategory V\nG : MonCat\n‚ä¢ Action.FunctorCategoryEquivalence.functor.IsEquivalence","decl":"instance : (FunctorCategoryEquivalence.functor (V := V) (G := G)).IsEquivalence :=\n  (functorCategoryEquivalence V G).isEquivalence_functor\n\n"}
{"name":"Action.instIsEquivalenceFunctorSingleObjCarrierInverse","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V : Type (u + 1)\ninst‚úù : CategoryTheory.LargeCategory V\nG : MonCat\n‚ä¢ Action.FunctorCategoryEquivalence.inverse.IsEquivalence","decl":"instance : (FunctorCategoryEquivalence.inverse (V := V) (G := G)).IsEquivalence :=\n  (functorCategoryEquivalence V G).isEquivalence_inverse\n\n"}
{"name":"Action.forget_map","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V : Type (u + 1)\ninst‚úù : CategoryTheory.LargeCategory V\nG : MonCat\nX‚úù Y‚úù : Action V G\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((Action.forget V G).map f) f.hom","decl":"/-- (implementation) The forgetful functor from bundled actions to the underlying objects.\n\nUse the `CategoryTheory.forget` API provided by the `HasForget` instance below,\nrather than using this directly.\n-/\n@[simps]\ndef forget : Action V G ‚•§ V where\n  obj M := M.V\n  map f := f.hom\n\n"}
{"name":"Action.forget_obj","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V : Type (u + 1)\ninst‚úù : CategoryTheory.LargeCategory V\nG : MonCat\nM : Action V G\n‚ä¢ Eq ((Action.forget V G).obj M) M.V","decl":"/-- (implementation) The forgetful functor from bundled actions to the underlying objects.\n\nUse the `CategoryTheory.forget` API provided by the `HasForget` instance below,\nrather than using this directly.\n-/\n@[simps]\ndef forget : Action V G ‚•§ V where\n  obj M := M.V\n  map f := f.hom\n\n"}
{"name":"Action.instFaithfulForget","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V : Type (u + 1)\ninst‚úù : CategoryTheory.LargeCategory V\nG : MonCat\n‚ä¢ (Action.forget V G).Faithful","decl":"instance : (forget V G).Faithful where map_injective w := Hom.ext w\n\n"}
{"name":"Action.preservesLimits_forget","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V : Type (u + 1)\ninst‚úù¬π : CategoryTheory.LargeCategory V\nG : MonCat\ninst‚úù : CategoryTheory.Limits.HasLimits V\n‚ä¢ CategoryTheory.Limits.PreservesLimits (Action.forget V G)","decl":"noncomputable instance preservesLimits_forget [HasLimits V] :\n    PreservesLimits (forget V G) :=\n  Limits.preservesLimits_of_natIso (Action.functorCategoryEquivalenceCompEvaluation V G)\n\n"}
{"name":"Action.preservesColimits_forget","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V : Type (u + 1)\ninst‚úù¬π : CategoryTheory.LargeCategory V\nG : MonCat\ninst‚úù : CategoryTheory.Limits.HasColimits V\n‚ä¢ CategoryTheory.Limits.PreservesColimits (Action.forget V G)","decl":"noncomputable instance preservesColimits_forget [HasColimits V] :\n    PreservesColimits (forget V G) :=\n  preservesColimits_of_natIso (Action.functorCategoryEquivalenceCompEvaluation V G)\n\n-- TODO construct categorical images?\n"}
{"name":"Action.Iso.conj_œÅ","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V : Type (u + 1)\ninst‚úù : CategoryTheory.LargeCategory V\nG : MonCat\nM N : Action V G\nf : CategoryTheory.Iso M N\ng : ‚ÜëG\n‚ä¢ Eq ((CategoryTheory.ConcreteCategory.hom N.œÅ) g) (((Action.forget V G).mapIso f).conj ((CategoryTheory.ConcreteCategory.hom M.œÅ) g))","decl":"theorem Iso.conj_œÅ {M N : Action V G} (f : M ‚âÖ N) (g : G) :\n    N.œÅ g = ((forget V G).mapIso f).conj (M.œÅ g) := by\n      rw [Iso.conj_apply, Iso.eq_inv_comp]; simp [f.hom.comm]\n\n"}
{"name":"Action.res_obj_œÅ","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V : Type (u + 1)\ninst‚úù : CategoryTheory.LargeCategory V\nG H : MonCat\nf : Quiver.Hom G H\nM : Action V H\n‚ä¢ Eq ((Action.res V f).obj M).œÅ (CategoryTheory.CategoryStruct.comp f M.œÅ)","decl":"/-- The \"restriction\" functor along a monoid homomorphism `f : G ‚ü∂ H`,\ntaking actions of `H` to actions of `G`.\n\n(This makes sense for any homomorphism, but the name is natural when `f` is a monomorphism.)\n-/\n@[simps]\ndef res {G H : MonCat} (f : G ‚ü∂ H) : Action V H ‚•§ Action V G where\n  obj M :=\n    { V := M.V\n      œÅ := f ‚â´ M.œÅ }\n  map p :=\n    { hom := p.hom\n      comm := fun g => p.comm (f g) }\n\n"}
{"name":"Action.res_map_hom","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V : Type (u + 1)\ninst‚úù : CategoryTheory.LargeCategory V\nG H : MonCat\nf : Quiver.Hom G H\nX‚úù Y‚úù : Action V H\np : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((Action.res V f).map p).hom p.hom","decl":"/-- The \"restriction\" functor along a monoid homomorphism `f : G ‚ü∂ H`,\ntaking actions of `H` to actions of `G`.\n\n(This makes sense for any homomorphism, but the name is natural when `f` is a monomorphism.)\n-/\n@[simps]\ndef res {G H : MonCat} (f : G ‚ü∂ H) : Action V H ‚•§ Action V G where\n  obj M :=\n    { V := M.V\n      œÅ := f ‚â´ M.œÅ }\n  map p :=\n    { hom := p.hom\n      comm := fun g => p.comm (f g) }\n\n"}
{"name":"Action.res_obj_V","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V : Type (u + 1)\ninst‚úù : CategoryTheory.LargeCategory V\nG H : MonCat\nf : Quiver.Hom G H\nM : Action V H\n‚ä¢ Eq ((Action.res V f).obj M).V M.V","decl":"/-- The \"restriction\" functor along a monoid homomorphism `f : G ‚ü∂ H`,\ntaking actions of `H` to actions of `G`.\n\n(This makes sense for any homomorphism, but the name is natural when `f` is a monomorphism.)\n-/\n@[simps]\ndef res {G H : MonCat} (f : G ‚ü∂ H) : Action V H ‚•§ Action V G where\n  obj M :=\n    { V := M.V\n      œÅ := f ‚â´ M.œÅ }\n  map p :=\n    { hom := p.hom\n      comm := fun g => p.comm (f g) }\n\n"}
{"name":"Action.resId_hom_app_hom","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V : Type (u + 1)\ninst‚úù : CategoryTheory.LargeCategory V\nG : MonCat\nX : Action V G\n‚ä¢ Eq ((Action.resId V).hom.app X).hom (CategoryTheory.CategoryStruct.id X.V)","decl":"/-- The natural isomorphism from restriction along the identity homomorphism to\nthe identity functor on `Action V G`.\n-/\n@[simps!]\ndef resId {G : MonCat} : res V (ùüô G) ‚âÖ ùü≠ (Action V G) :=\n  NatIso.ofComponents fun M => mkIso (Iso.refl _)\n\n"}
{"name":"Action.resId_inv_app_hom","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V : Type (u + 1)\ninst‚úù : CategoryTheory.LargeCategory V\nG : MonCat\nX : Action V G\n‚ä¢ Eq ((Action.resId V).inv.app X).hom (CategoryTheory.CategoryStruct.id X.V)","decl":"/-- The natural isomorphism from restriction along the identity homomorphism to\nthe identity functor on `Action V G`.\n-/\n@[simps!]\ndef resId {G : MonCat} : res V (ùüô G) ‚âÖ ùü≠ (Action V G) :=\n  NatIso.ofComponents fun M => mkIso (Iso.refl _)\n\n"}
{"name":"Action.resComp_inv_app_hom","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V : Type (u + 1)\ninst‚úù : CategoryTheory.LargeCategory V\nG H K : MonCat\nf : Quiver.Hom G H\ng : Quiver.Hom H K\nX : Action V K\n‚ä¢ Eq ((Action.resComp V f g).inv.app X).hom (CategoryTheory.CategoryStruct.id X.V)","decl":"/-- The natural isomorphism from the composition of restrictions along homomorphisms\nto the restriction along the composition of homomorphism.\n-/\n@[simps!]\ndef resComp {G H K : MonCat} (f : G ‚ü∂ H) (g : H ‚ü∂ K) : res V g ‚ãô res V f ‚âÖ res V (f ‚â´ g) :=\n  NatIso.ofComponents fun M => mkIso (Iso.refl _)\n\n-- TODO promote `res` to a pseudofunctor from\n-- the locally discrete bicategory constructed from `Mon·µí·µñ` to `Cat`, sending `G` to `Action V G`.\n\n"}
{"name":"Action.resComp_hom_app_hom","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V : Type (u + 1)\ninst‚úù : CategoryTheory.LargeCategory V\nG H K : MonCat\nf : Quiver.Hom G H\ng : Quiver.Hom H K\nX : Action V K\n‚ä¢ Eq ((Action.resComp V f g).hom.app X).hom (CategoryTheory.CategoryStruct.id X.V)","decl":"/-- The natural isomorphism from the composition of restrictions along homomorphisms\nto the restriction along the composition of homomorphism.\n-/\n@[simps!]\ndef resComp {G H K : MonCat} (f : G ‚ü∂ H) (g : H ‚ü∂ K) : res V g ‚ãô res V f ‚âÖ res V (f ‚â´ g) :=\n  NatIso.ofComponents fun M => mkIso (Iso.refl _)\n\n-- TODO promote `res` to a pseudofunctor from\n-- the locally discrete bicategory constructed from `Mon·µí·µñ` to `Cat`, sending `G` to `Action V G`.\n\n"}
{"name":"CategoryTheory.Functor.mapAction_obj_œÅ","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V : Type (u + 1)\ninst‚úù¬π : CategoryTheory.LargeCategory V\nW : Type (u + 1)\ninst‚úù : CategoryTheory.LargeCategory W\nF : CategoryTheory.Functor V W\nG : MonCat\nM : Action V G\n‚ä¢ Eq ((F.mapAction G).obj M).œÅ (MonCat.ofHom { toFun := fun g => F.map ((CategoryTheory.ConcreteCategory.hom M.œÅ) g), map_one' := ‚ãØ, map_mul' := ‚ãØ })","decl":"/-- A functor between categories induces a functor between\nthe categories of `G`-actions within those categories. -/\n@[simps]\ndef mapAction (F : V ‚•§ W) (G : MonCat.{u}) : Action V G ‚•§ Action W G where\n  obj M :=\n    { V := F.obj M.V\n      œÅ := MonCat.ofHom\n        { toFun := fun g => F.map (M.œÅ g)\n          map_one' := by simp\n          map_mul' := fun g h => by\n            dsimp\n            rw [map_mul, MonCat.mul_of, End.mul_def, F.map_comp] } }\n  map f :=\n    { hom := F.map f.hom\n      comm := fun g => by dsimp; rw [‚Üê F.map_comp, f.comm, F.map_comp] }\n  map_id M := by ext; simp only [Action.id_hom, F.map_id]\n  map_comp f g := by ext; simp only [Action.comp_hom, F.map_comp]\n\n"}
{"name":"CategoryTheory.Functor.mapAction_map_hom","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V : Type (u + 1)\ninst‚úù¬π : CategoryTheory.LargeCategory V\nW : Type (u + 1)\ninst‚úù : CategoryTheory.LargeCategory W\nF : CategoryTheory.Functor V W\nG : MonCat\nX‚úù Y‚úù : Action V G\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((F.mapAction G).map f).hom (F.map f.hom)","decl":"/-- A functor between categories induces a functor between\nthe categories of `G`-actions within those categories. -/\n@[simps]\ndef mapAction (F : V ‚•§ W) (G : MonCat.{u}) : Action V G ‚•§ Action W G where\n  obj M :=\n    { V := F.obj M.V\n      œÅ := MonCat.ofHom\n        { toFun := fun g => F.map (M.œÅ g)\n          map_one' := by simp\n          map_mul' := fun g h => by\n            dsimp\n            rw [map_mul, MonCat.mul_of, End.mul_def, F.map_comp] } }\n  map f :=\n    { hom := F.map f.hom\n      comm := fun g => by dsimp; rw [‚Üê F.map_comp, f.comm, F.map_comp] }\n  map_id M := by ext; simp only [Action.id_hom, F.map_id]\n  map_comp f g := by ext; simp only [Action.comp_hom, F.map_comp]\n\n"}
{"name":"CategoryTheory.Functor.mapAction_obj_V","module":"Mathlib.CategoryTheory.Action.Basic","initialProofState":"V : Type (u + 1)\ninst‚úù¬π : CategoryTheory.LargeCategory V\nW : Type (u + 1)\ninst‚úù : CategoryTheory.LargeCategory W\nF : CategoryTheory.Functor V W\nG : MonCat\nM : Action V G\n‚ä¢ Eq ((F.mapAction G).obj M).V (F.obj M.V)","decl":"/-- A functor between categories induces a functor between\nthe categories of `G`-actions within those categories. -/\n@[simps]\ndef mapAction (F : V ‚•§ W) (G : MonCat.{u}) : Action V G ‚•§ Action W G where\n  obj M :=\n    { V := F.obj M.V\n      œÅ := MonCat.ofHom\n        { toFun := fun g => F.map (M.œÅ g)\n          map_one' := by simp\n          map_mul' := fun g h => by\n            dsimp\n            rw [map_mul, MonCat.mul_of, End.mul_def, F.map_comp] } }\n  map f :=\n    { hom := F.map f.hom\n      comm := fun g => by dsimp; rw [‚Üê F.map_comp, f.comm, F.map_comp] }\n  map_id M := by ext; simp only [Action.id_hom, F.map_id]\n  map_comp f g := by ext; simp only [Action.comp_hom, F.map_comp]\n\n"}
