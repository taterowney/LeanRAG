{"name":"le_add_ciInf","module":"Mathlib.Order.ConditionallyCompleteLattice.Group","initialProofState":"α : Type u_1\nι : Sort u_2\ninst✝³ : Nonempty ι\ninst✝² : ConditionallyCompleteLattice α\ninst✝¹ : AddGroup α\ninst✝ : AddLeftMono α\na g : α\nh : ι → α\nH : ∀ (j : ι), LE.le a (HAdd.hAdd g (h j))\n⊢ LE.le a (HAdd.hAdd g (iInf h))","decl":"@[to_additive]\ntheorem le_mul_ciInf [MulLeftMono α] {a : α} {g : α} {h : ι → α}\n    (H : ∀ j, a ≤ g * h j) : a ≤ g * iInf h :=\n  inv_mul_le_iff_le_mul.mp <| le_ciInf fun _ => inv_mul_le_iff_le_mul.mpr <| H _\n\n"}
{"name":"le_mul_ciInf","module":"Mathlib.Order.ConditionallyCompleteLattice.Group","initialProofState":"α : Type u_1\nι : Sort u_2\ninst✝³ : Nonempty ι\ninst✝² : ConditionallyCompleteLattice α\ninst✝¹ : Group α\ninst✝ : MulLeftMono α\na g : α\nh : ι → α\nH : ∀ (j : ι), LE.le a (HMul.hMul g (h j))\n⊢ LE.le a (HMul.hMul g (iInf h))","decl":"@[to_additive]\ntheorem le_mul_ciInf [MulLeftMono α] {a : α} {g : α} {h : ι → α}\n    (H : ∀ j, a ≤ g * h j) : a ≤ g * iInf h :=\n  inv_mul_le_iff_le_mul.mp <| le_ciInf fun _ => inv_mul_le_iff_le_mul.mpr <| H _\n\n"}
{"name":"mul_ciSup_le","module":"Mathlib.Order.ConditionallyCompleteLattice.Group","initialProofState":"α : Type u_1\nι : Sort u_2\ninst✝³ : Nonempty ι\ninst✝² : ConditionallyCompleteLattice α\ninst✝¹ : Group α\ninst✝ : MulLeftMono α\na g : α\nh : ι → α\nH : ∀ (j : ι), LE.le (HMul.hMul g (h j)) a\n⊢ LE.le (HMul.hMul g (iSup h)) a","decl":"@[to_additive]\ntheorem mul_ciSup_le [MulLeftMono α] {a : α} {g : α} {h : ι → α}\n    (H : ∀ j, g * h j ≤ a) : g * iSup h ≤ a :=\n  le_mul_ciInf (α := αᵒᵈ) H\n\n"}
{"name":"add_ciSup_le","module":"Mathlib.Order.ConditionallyCompleteLattice.Group","initialProofState":"α : Type u_1\nι : Sort u_2\ninst✝³ : Nonempty ι\ninst✝² : ConditionallyCompleteLattice α\ninst✝¹ : AddGroup α\ninst✝ : AddLeftMono α\na g : α\nh : ι → α\nH : ∀ (j : ι), LE.le (HAdd.hAdd g (h j)) a\n⊢ LE.le (HAdd.hAdd g (iSup h)) a","decl":"@[to_additive]\ntheorem mul_ciSup_le [MulLeftMono α] {a : α} {g : α} {h : ι → α}\n    (H : ∀ j, g * h j ≤ a) : g * iSup h ≤ a :=\n  le_mul_ciInf (α := αᵒᵈ) H\n\n"}
{"name":"le_ciInf_add","module":"Mathlib.Order.ConditionallyCompleteLattice.Group","initialProofState":"α : Type u_1\nι : Sort u_2\ninst✝³ : Nonempty ι\ninst✝² : ConditionallyCompleteLattice α\ninst✝¹ : AddGroup α\ninst✝ : AddRightMono α\na : α\ng : ι → α\nh : α\nH : ∀ (i : ι), LE.le a (HAdd.hAdd (g i) h)\n⊢ LE.le a (HAdd.hAdd (iInf g) h)","decl":"@[to_additive]\ntheorem le_ciInf_mul [MulRightMono α] {a : α} {g : ι → α}\n    {h : α} (H : ∀ i, a ≤ g i * h) : a ≤ iInf g * h :=\n  mul_inv_le_iff_le_mul.mp <| le_ciInf fun _ => mul_inv_le_iff_le_mul.mpr <| H _\n\n"}
{"name":"le_ciInf_mul","module":"Mathlib.Order.ConditionallyCompleteLattice.Group","initialProofState":"α : Type u_1\nι : Sort u_2\ninst✝³ : Nonempty ι\ninst✝² : ConditionallyCompleteLattice α\ninst✝¹ : Group α\ninst✝ : MulRightMono α\na : α\ng : ι → α\nh : α\nH : ∀ (i : ι), LE.le a (HMul.hMul (g i) h)\n⊢ LE.le a (HMul.hMul (iInf g) h)","decl":"@[to_additive]\ntheorem le_ciInf_mul [MulRightMono α] {a : α} {g : ι → α}\n    {h : α} (H : ∀ i, a ≤ g i * h) : a ≤ iInf g * h :=\n  mul_inv_le_iff_le_mul.mp <| le_ciInf fun _ => mul_inv_le_iff_le_mul.mpr <| H _\n\n"}
{"name":"ciSup_mul_le","module":"Mathlib.Order.ConditionallyCompleteLattice.Group","initialProofState":"α : Type u_1\nι : Sort u_2\ninst✝³ : Nonempty ι\ninst✝² : ConditionallyCompleteLattice α\ninst✝¹ : Group α\ninst✝ : MulRightMono α\na : α\ng : ι → α\nh : α\nH : ∀ (i : ι), LE.le (HMul.hMul (g i) h) a\n⊢ LE.le (HMul.hMul (iSup g) h) a","decl":"@[to_additive]\ntheorem ciSup_mul_le [MulRightMono α] {a : α} {g : ι → α}\n    {h : α} (H : ∀ i, g i * h ≤ a) : iSup g * h ≤ a :=\n  le_ciInf_mul (α := αᵒᵈ) H\n\n"}
{"name":"ciSup_add_le","module":"Mathlib.Order.ConditionallyCompleteLattice.Group","initialProofState":"α : Type u_1\nι : Sort u_2\ninst✝³ : Nonempty ι\ninst✝² : ConditionallyCompleteLattice α\ninst✝¹ : AddGroup α\ninst✝ : AddRightMono α\na : α\ng : ι → α\nh : α\nH : ∀ (i : ι), LE.le (HAdd.hAdd (g i) h) a\n⊢ LE.le (HAdd.hAdd (iSup g) h) a","decl":"@[to_additive]\ntheorem ciSup_mul_le [MulRightMono α] {a : α} {g : ι → α}\n    {h : α} (H : ∀ i, g i * h ≤ a) : iSup g * h ≤ a :=\n  le_ciInf_mul (α := αᵒᵈ) H\n\n"}
{"name":"le_ciInf_add_ciInf","module":"Mathlib.Order.ConditionallyCompleteLattice.Group","initialProofState":"α : Type u_1\nι : Sort u_2\nι' : Sort u_3\ninst✝⁵ : Nonempty ι\ninst✝⁴ : Nonempty ι'\ninst✝³ : ConditionallyCompleteLattice α\ninst✝² : AddGroup α\ninst✝¹ : AddLeftMono α\ninst✝ : AddRightMono α\na : α\ng : ι → α\nh : ι' → α\nH : ∀ (i : ι) (j : ι'), LE.le a (HAdd.hAdd (g i) (h j))\n⊢ LE.le a (HAdd.hAdd (iInf g) (iInf h))","decl":"@[to_additive]\ntheorem le_ciInf_mul_ciInf [MulLeftMono α] [MulRightMono α] {a : α} {g : ι → α} {h : ι' → α}\n    (H : ∀ i j, a ≤ g i * h j) : a ≤ iInf g * iInf h :=\n  le_ciInf_mul fun _ => le_mul_ciInf <| H _\n\n"}
{"name":"le_ciInf_mul_ciInf","module":"Mathlib.Order.ConditionallyCompleteLattice.Group","initialProofState":"α : Type u_1\nι : Sort u_2\nι' : Sort u_3\ninst✝⁵ : Nonempty ι\ninst✝⁴ : Nonempty ι'\ninst✝³ : ConditionallyCompleteLattice α\ninst✝² : Group α\ninst✝¹ : MulLeftMono α\ninst✝ : MulRightMono α\na : α\ng : ι → α\nh : ι' → α\nH : ∀ (i : ι) (j : ι'), LE.le a (HMul.hMul (g i) (h j))\n⊢ LE.le a (HMul.hMul (iInf g) (iInf h))","decl":"@[to_additive]\ntheorem le_ciInf_mul_ciInf [MulLeftMono α] [MulRightMono α] {a : α} {g : ι → α} {h : ι' → α}\n    (H : ∀ i j, a ≤ g i * h j) : a ≤ iInf g * iInf h :=\n  le_ciInf_mul fun _ => le_mul_ciInf <| H _\n\n"}
{"name":"ciSup_mul_ciSup_le","module":"Mathlib.Order.ConditionallyCompleteLattice.Group","initialProofState":"α : Type u_1\nι : Sort u_2\nι' : Sort u_3\ninst✝⁵ : Nonempty ι\ninst✝⁴ : Nonempty ι'\ninst✝³ : ConditionallyCompleteLattice α\ninst✝² : Group α\ninst✝¹ : MulLeftMono α\ninst✝ : MulRightMono α\na : α\ng : ι → α\nh : ι' → α\nH : ∀ (i : ι) (j : ι'), LE.le (HMul.hMul (g i) (h j)) a\n⊢ LE.le (HMul.hMul (iSup g) (iSup h)) a","decl":"@[to_additive]\ntheorem ciSup_mul_ciSup_le [MulLeftMono α] [MulRightMono α] {a : α} {g : ι → α} {h : ι' → α}\n    (H : ∀ i j, g i * h j ≤ a) : iSup g * iSup h ≤ a :=\n  ciSup_mul_le fun _ => mul_ciSup_le <| H _\n\n"}
{"name":"ciSup_add_ciSup_le","module":"Mathlib.Order.ConditionallyCompleteLattice.Group","initialProofState":"α : Type u_1\nι : Sort u_2\nι' : Sort u_3\ninst✝⁵ : Nonempty ι\ninst✝⁴ : Nonempty ι'\ninst✝³ : ConditionallyCompleteLattice α\ninst✝² : AddGroup α\ninst✝¹ : AddLeftMono α\ninst✝ : AddRightMono α\na : α\ng : ι → α\nh : ι' → α\nH : ∀ (i : ι) (j : ι'), LE.le (HAdd.hAdd (g i) (h j)) a\n⊢ LE.le (HAdd.hAdd (iSup g) (iSup h)) a","decl":"@[to_additive]\ntheorem ciSup_mul_ciSup_le [MulLeftMono α] [MulRightMono α] {a : α} {g : ι → α} {h : ι' → α}\n    (H : ∀ i j, g i * h j ≤ a) : iSup g * iSup h ≤ a :=\n  ciSup_mul_le fun _ => mul_ciSup_le <| H _\n\n"}
