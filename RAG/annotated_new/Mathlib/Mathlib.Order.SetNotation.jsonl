{"name":"infSet_to_nonempty","module":"Mathlib.Order.SetNotation","initialProofState":"α : Type u_1\ninst✝ : InfSet α\n⊢ Nonempty α","decl":"instance (priority := 50) infSet_to_nonempty (α) [InfSet α] : Nonempty α :=\n  ⟨sInf ∅⟩\n\n"}
{"name":"supSet_to_nonempty","module":"Mathlib.Order.SetNotation","initialProofState":"α : Type u_1\ninst✝ : SupSet α\n⊢ Nonempty α","decl":"instance (priority := 50) supSet_to_nonempty (α) [SupSet α] : Nonempty α :=\n  ⟨sSup ∅⟩\n\n/-\nPorting note: the code below could replace the `notation3` command\nopen Batteries.ExtendedBinder in\nsyntax \"⨆ \" extBinder \", \" term:51 : term\n\nmacro_rules\n  | `(⨆ $x:ident, $p) => `(iSup fun $x:ident ↦ $p)\n  | `(⨆ $x:ident : $t, $p) => `(iSup fun $x:ident : $t ↦ $p)\n  | `(⨆ $x:ident $b:binderPred, $p) =>\n    `(iSup fun $x:ident ↦ satisfies_binder_pred% $x $b ∧ $p) -/\n\n"}
{"name":"Set.mem_sInter","module":"Mathlib.Order.SetNotation","initialProofState":"α : Type u\nx : α\nS : Set (Set α)\n⊢ Iff (Membership.mem S.sInter x) (∀ (t : Set α), Membership.mem S t → Membership.mem t x)","decl":"@[simp]\ntheorem mem_sInter {x : α} {S : Set (Set α)} : x ∈ ⋂₀ S ↔ ∀ t ∈ S, x ∈ t :=\n  Iff.rfl\n\n"}
{"name":"Set.mem_sUnion","module":"Mathlib.Order.SetNotation","initialProofState":"α : Type u\nx : α\nS : Set (Set α)\n⊢ Iff (Membership.mem S.sUnion x) (Exists fun t => And (Membership.mem S t) (Membership.mem t x))","decl":"@[simp]\ntheorem mem_sUnion {x : α} {S : Set (Set α)} : x ∈ ⋃₀ S ↔ ∃ t ∈ S, x ∈ t :=\n  Iff.rfl\n\n"}
{"name":"Set.mem_iUnion","module":"Mathlib.Order.SetNotation","initialProofState":"α : Type u\nι : Sort v\nx : α\ns : ι → Set α\n⊢ Iff (Membership.mem (Set.iUnion fun i => s i) x) (Exists fun i => Membership.mem (s i) x)","decl":"@[simp]\ntheorem mem_iUnion {x : α} {s : ι → Set α} : (x ∈ ⋃ i, s i) ↔ ∃ i, x ∈ s i :=\n  ⟨fun ⟨_, ⟨⟨a, (t_eq : s a = _)⟩, (h : x ∈ _)⟩⟩ => ⟨a, t_eq.symm ▸ h⟩, fun ⟨a, h⟩ =>\n    ⟨s a, ⟨⟨a, rfl⟩, h⟩⟩⟩\n\n"}
{"name":"Set.mem_iInter","module":"Mathlib.Order.SetNotation","initialProofState":"α : Type u\nι : Sort v\nx : α\ns : ι → Set α\n⊢ Iff (Membership.mem (Set.iInter fun i => s i) x) (∀ (i : ι), Membership.mem (s i) x)","decl":"@[simp]\ntheorem mem_iInter {x : α} {s : ι → Set α} : (x ∈ ⋂ i, s i) ↔ ∀ i, x ∈ s i :=\n  ⟨fun (h : ∀ a ∈ { a : Set α | ∃ i, s i = a }, x ∈ a) a => h (s a) ⟨a, rfl⟩,\n    fun h _ ⟨a, (eq : s a = _)⟩ => eq ▸ h a⟩\n\n"}
{"name":"Set.sSup_eq_sUnion","module":"Mathlib.Order.SetNotation","initialProofState":"α : Type u\nS : Set (Set α)\n⊢ Eq (SupSet.sSup S) S.sUnion","decl":"@[simp]\ntheorem sSup_eq_sUnion (S : Set (Set α)) : sSup S = ⋃₀S :=\n  rfl\n\n"}
{"name":"Set.sInf_eq_sInter","module":"Mathlib.Order.SetNotation","initialProofState":"α : Type u\nS : Set (Set α)\n⊢ Eq (InfSet.sInf S) S.sInter","decl":"@[simp]\ntheorem sInf_eq_sInter (S : Set (Set α)) : sInf S = ⋂₀ S :=\n  rfl\n\n"}
{"name":"Set.iSup_eq_iUnion","module":"Mathlib.Order.SetNotation","initialProofState":"α : Type u\nι : Sort v\ns : ι → Set α\n⊢ Eq (iSup s) (Set.iUnion s)","decl":"@[simp]\ntheorem iSup_eq_iUnion (s : ι → Set α) : iSup s = iUnion s :=\n  rfl\n\n"}
{"name":"Set.iInf_eq_iInter","module":"Mathlib.Order.SetNotation","initialProofState":"α : Type u\nι : Sort v\ns : ι → Set α\n⊢ Eq (iInf s) (Set.iInter s)","decl":"@[simp]\ntheorem iInf_eq_iInter (s : ι → Set α) : iInf s = iInter s :=\n  rfl\n\n"}
