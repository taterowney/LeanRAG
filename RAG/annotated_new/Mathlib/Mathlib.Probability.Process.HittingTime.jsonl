{"name":"MeasureTheory.hitting_def","module":"Mathlib.Probability.Process.HittingTime","initialProofState":"Ω : Type u_1\nβ : Type u_2\nι : Type u_3\ninst✝¹ : Preorder ι\ninst✝ : InfSet ι\nu : ι → Ω → β\ns : Set β\nn m : ι\n⊢ Eq (MeasureTheory.hitting u s n m) fun x => ite (Exists fun j => And (Membership.mem (Set.Icc n m) j) (Membership.mem s (u j x))) (InfSet.sInf (Inter.inter (Set.Icc n m) (setOf fun i => Membership.mem s (u i x)))) m","decl":"open scoped Classical in\ntheorem hitting_def [Preorder ι] [InfSet ι] (u : ι → Ω → β) (s : Set β) (n m : ι) :\n    hitting u s n m =\n    fun x => if ∃ j ∈ Set.Icc n m, u j x ∈ s then sInf (Set.Icc n m ∩ {i : ι | u i x ∈ s}) else m :=\n  rfl\n\n"}
{"name":"MeasureTheory.hitting_of_lt","module":"Mathlib.Probability.Process.HittingTime","initialProofState":"Ω : Type u_1\nβ : Type u_2\nι : Type u_3\ninst✝ : ConditionallyCompleteLinearOrder ι\nu : ι → Ω → β\ns : Set β\nn : ι\nω : Ω\nm : ι\nh : LT.lt m n\n⊢ Eq (MeasureTheory.hitting u s n m ω) m","decl":"/-- This lemma is strictly weaker than `hitting_of_le`. -/\ntheorem hitting_of_lt {m : ι} (h : m < n) : hitting u s n m ω = m := by\n  simp_rw [hitting]\n  have h_not : ¬∃ (j : ι) (_ : j ∈ Set.Icc n m), u j ω ∈ s := by\n    push_neg\n    intro j\n    rw [Set.Icc_eq_empty_of_lt h]\n    simp only [Set.mem_empty_iff_false, IsEmpty.forall_iff]\n  simp only [exists_prop] at h_not\n  simp only [h_not, if_false]\n\n"}
{"name":"MeasureTheory.hitting_le","module":"Mathlib.Probability.Process.HittingTime","initialProofState":"Ω : Type u_1\nβ : Type u_2\nι : Type u_3\ninst✝ : ConditionallyCompleteLinearOrder ι\nu : ι → Ω → β\ns : Set β\nn m : ι\nω : Ω\n⊢ LE.le (MeasureTheory.hitting u s n m ω) m","decl":"theorem hitting_le {m : ι} (ω : Ω) : hitting u s n m ω ≤ m := by\n  simp only [hitting]\n  split_ifs with h\n  · obtain ⟨j, hj₁, hj₂⟩ := h\n    change j ∈ {i | u i ω ∈ s} at hj₂\n    exact (csInf_le (BddBelow.inter_of_left bddBelow_Icc) (Set.mem_inter hj₁ hj₂)).trans hj₁.2\n  · exact le_rfl\n\n"}
{"name":"MeasureTheory.not_mem_of_lt_hitting","module":"Mathlib.Probability.Process.HittingTime","initialProofState":"Ω : Type u_1\nβ : Type u_2\nι : Type u_3\ninst✝ : ConditionallyCompleteLinearOrder ι\nu : ι → Ω → β\ns : Set β\nn : ι\nω : Ω\nm k : ι\nhk₁ : LT.lt k (MeasureTheory.hitting u s n m ω)\nhk₂ : LE.le n k\n⊢ Not (Membership.mem s (u k ω))","decl":"theorem not_mem_of_lt_hitting {m k : ι} (hk₁ : k < hitting u s n m ω) (hk₂ : n ≤ k) :\n    u k ω ∉ s := by\n  classical\n  intro h\n  have hexists : ∃ j ∈ Set.Icc n m, u j ω ∈ s := ⟨k, ⟨hk₂, le_trans hk₁.le <| hitting_le _⟩, h⟩\n  refine not_le.2 hk₁ ?_\n  simp_rw [hitting, if_pos hexists]\n  exact csInf_le bddBelow_Icc.inter_of_left ⟨⟨hk₂, le_trans hk₁.le <| hitting_le _⟩, h⟩\n\n"}
{"name":"MeasureTheory.hitting_eq_end_iff","module":"Mathlib.Probability.Process.HittingTime","initialProofState":"Ω : Type u_1\nβ : Type u_2\nι : Type u_3\ninst✝ : ConditionallyCompleteLinearOrder ι\nu : ι → Ω → β\ns : Set β\nn : ι\nω : Ω\nm : ι\n⊢ Iff (Eq (MeasureTheory.hitting u s n m ω) m) ((Exists fun j => And (Membership.mem (Set.Icc n m) j) (Membership.mem s (u j ω))) → Eq (InfSet.sInf (Inter.inter (Set.Icc n m) (setOf fun i => Membership.mem s (u i ω)))) m)","decl":"theorem hitting_eq_end_iff {m : ι} : hitting u s n m ω = m ↔\n    (∃ j ∈ Set.Icc n m, u j ω ∈ s) → sInf (Set.Icc n m ∩ {i : ι | u i ω ∈ s}) = m := by\n  classical\n  rw [hitting, ite_eq_right_iff]\n\n"}
{"name":"MeasureTheory.hitting_of_le","module":"Mathlib.Probability.Process.HittingTime","initialProofState":"Ω : Type u_1\nβ : Type u_2\nι : Type u_3\ninst✝ : ConditionallyCompleteLinearOrder ι\nu : ι → Ω → β\ns : Set β\nn : ι\nω : Ω\nm : ι\nhmn : LE.le m n\n⊢ Eq (MeasureTheory.hitting u s n m ω) m","decl":"theorem hitting_of_le {m : ι} (hmn : m ≤ n) : hitting u s n m ω = m := by\n  obtain rfl | h := le_iff_eq_or_lt.1 hmn\n  · classical\n    rw [hitting, ite_eq_right_iff, forall_exists_index]\n    conv => intro; rw [Set.mem_Icc, Set.Icc_self, and_imp, and_imp]\n    intro i hi₁ hi₂ hi\n    rw [Set.inter_eq_left.2, csInf_singleton]\n    exact Set.singleton_subset_iff.2 (le_antisymm hi₂ hi₁ ▸ hi)\n  · exact hitting_of_lt h\n\n"}
{"name":"MeasureTheory.le_hitting","module":"Mathlib.Probability.Process.HittingTime","initialProofState":"Ω : Type u_1\nβ : Type u_2\nι : Type u_3\ninst✝ : ConditionallyCompleteLinearOrder ι\nu : ι → Ω → β\ns : Set β\nn m : ι\nhnm : LE.le n m\nω : Ω\n⊢ LE.le n (MeasureTheory.hitting u s n m ω)","decl":"theorem le_hitting {m : ι} (hnm : n ≤ m) (ω : Ω) : n ≤ hitting u s n m ω := by\n  simp only [hitting]\n  split_ifs with h\n  · refine le_csInf ?_ fun b hb => ?_\n    · obtain ⟨k, hk_Icc, hk_s⟩ := h\n      exact ⟨k, hk_Icc, hk_s⟩\n    · rw [Set.mem_inter_iff] at hb\n      exact hb.1.1\n  · exact hnm\n\n"}
{"name":"MeasureTheory.le_hitting_of_exists","module":"Mathlib.Probability.Process.HittingTime","initialProofState":"Ω : Type u_1\nβ : Type u_2\nι : Type u_3\ninst✝ : ConditionallyCompleteLinearOrder ι\nu : ι → Ω → β\ns : Set β\nn : ι\nω : Ω\nm : ι\nh_exists : Exists fun j => And (Membership.mem (Set.Icc n m) j) (Membership.mem s (u j ω))\n⊢ LE.le n (MeasureTheory.hitting u s n m ω)","decl":"theorem le_hitting_of_exists {m : ι} (h_exists : ∃ j ∈ Set.Icc n m, u j ω ∈ s) :\n    n ≤ hitting u s n m ω := by\n  refine le_hitting ?_ ω\n  by_contra h\n  rw [Set.Icc_eq_empty_of_lt (not_le.mp h)] at h_exists\n  simp at h_exists\n\n"}
{"name":"MeasureTheory.hitting_mem_Icc","module":"Mathlib.Probability.Process.HittingTime","initialProofState":"Ω : Type u_1\nβ : Type u_2\nι : Type u_3\ninst✝ : ConditionallyCompleteLinearOrder ι\nu : ι → Ω → β\ns : Set β\nn m : ι\nhnm : LE.le n m\nω : Ω\n⊢ Membership.mem (Set.Icc n m) (MeasureTheory.hitting u s n m ω)","decl":"theorem hitting_mem_Icc {m : ι} (hnm : n ≤ m) (ω : Ω) : hitting u s n m ω ∈ Set.Icc n m :=\n  ⟨le_hitting hnm ω, hitting_le ω⟩\n\n"}
{"name":"MeasureTheory.hitting_mem_set","module":"Mathlib.Probability.Process.HittingTime","initialProofState":"Ω : Type u_1\nβ : Type u_2\nι : Type u_3\ninst✝¹ : ConditionallyCompleteLinearOrder ι\nu : ι → Ω → β\ns : Set β\nn : ι\nω : Ω\ninst✝ : WellFoundedLT ι\nm : ι\nh_exists : Exists fun j => And (Membership.mem (Set.Icc n m) j) (Membership.mem s (u j ω))\n⊢ Membership.mem s (u (MeasureTheory.hitting u s n m ω) ω)","decl":"theorem hitting_mem_set [WellFoundedLT ι] {m : ι} (h_exists : ∃ j ∈ Set.Icc n m, u j ω ∈ s) :\n    u (hitting u s n m ω) ω ∈ s := by\n  simp_rw [hitting, if_pos h_exists]\n  have h_nonempty : (Set.Icc n m ∩ {i : ι | u i ω ∈ s}).Nonempty := by\n    obtain ⟨k, hk₁, hk₂⟩ := h_exists\n    exact ⟨k, Set.mem_inter hk₁ hk₂⟩\n  have h_mem := csInf_mem h_nonempty\n  rw [Set.mem_inter_iff] at h_mem\n  exact h_mem.2\n\n"}
{"name":"MeasureTheory.hitting_mem_set_of_hitting_lt","module":"Mathlib.Probability.Process.HittingTime","initialProofState":"Ω : Type u_1\nβ : Type u_2\nι : Type u_3\ninst✝¹ : ConditionallyCompleteLinearOrder ι\nu : ι → Ω → β\ns : Set β\nn : ι\nω : Ω\ninst✝ : WellFoundedLT ι\nm : ι\nhl : LT.lt (MeasureTheory.hitting u s n m ω) m\n⊢ Membership.mem s (u (MeasureTheory.hitting u s n m ω) ω)","decl":"theorem hitting_mem_set_of_hitting_lt [WellFoundedLT ι] {m : ι} (hl : hitting u s n m ω < m) :\n    u (hitting u s n m ω) ω ∈ s := by\n  by_cases h : ∃ j ∈ Set.Icc n m, u j ω ∈ s\n  · exact hitting_mem_set h\n  · simp_rw [hitting, if_neg h] at hl\n    exact False.elim (hl.ne rfl)\n\n"}
{"name":"MeasureTheory.hitting_le_of_mem","module":"Mathlib.Probability.Process.HittingTime","initialProofState":"Ω : Type u_1\nβ : Type u_2\nι : Type u_3\ninst✝ : ConditionallyCompleteLinearOrder ι\nu : ι → Ω → β\ns : Set β\nn i : ι\nω : Ω\nm : ι\nhin : LE.le n i\nhim : LE.le i m\nhis : Membership.mem s (u i ω)\n⊢ LE.le (MeasureTheory.hitting u s n m ω) i","decl":"theorem hitting_le_of_mem {m : ι} (hin : n ≤ i) (him : i ≤ m) (his : u i ω ∈ s) :\n    hitting u s n m ω ≤ i := by\n  have h_exists : ∃ k ∈ Set.Icc n m, u k ω ∈ s := ⟨i, ⟨hin, him⟩, his⟩\n  simp_rw [hitting, if_pos h_exists]\n  exact csInf_le (BddBelow.inter_of_left bddBelow_Icc) (Set.mem_inter ⟨hin, him⟩ his)\n\n"}
{"name":"MeasureTheory.hitting_le_iff_of_exists","module":"Mathlib.Probability.Process.HittingTime","initialProofState":"Ω : Type u_1\nβ : Type u_2\nι : Type u_3\ninst✝¹ : ConditionallyCompleteLinearOrder ι\nu : ι → Ω → β\ns : Set β\nn i : ι\nω : Ω\ninst✝ : WellFoundedLT ι\nm : ι\nh_exists : Exists fun j => And (Membership.mem (Set.Icc n m) j) (Membership.mem s (u j ω))\n⊢ Iff (LE.le (MeasureTheory.hitting u s n m ω) i) (Exists fun j => And (Membership.mem (Set.Icc n i) j) (Membership.mem s (u j ω)))","decl":"theorem hitting_le_iff_of_exists [WellFoundedLT ι] {m : ι}\n    (h_exists : ∃ j ∈ Set.Icc n m, u j ω ∈ s) :\n    hitting u s n m ω ≤ i ↔ ∃ j ∈ Set.Icc n i, u j ω ∈ s := by\n  constructor <;> intro h'\n  · exact ⟨hitting u s n m ω, ⟨le_hitting_of_exists h_exists, h'⟩, hitting_mem_set h_exists⟩\n  · have h'' : ∃ k ∈ Set.Icc n (min m i), u k ω ∈ s := by\n      obtain ⟨k₁, hk₁_mem, hk₁_s⟩ := h_exists\n      obtain ⟨k₂, hk₂_mem, hk₂_s⟩ := h'\n      refine ⟨min k₁ k₂, ⟨le_min hk₁_mem.1 hk₂_mem.1, min_le_min hk₁_mem.2 hk₂_mem.2⟩, ?_⟩\n      exact min_rec' (fun j => u j ω ∈ s) hk₁_s hk₂_s\n    obtain ⟨k, hk₁, hk₂⟩ := h''\n    refine le_trans ?_ (hk₁.2.trans (min_le_right _ _))\n    exact hitting_le_of_mem hk₁.1 (hk₁.2.trans (min_le_left _ _)) hk₂\n\n"}
{"name":"MeasureTheory.hitting_le_iff_of_lt","module":"Mathlib.Probability.Process.HittingTime","initialProofState":"Ω : Type u_1\nβ : Type u_2\nι : Type u_3\ninst✝¹ : ConditionallyCompleteLinearOrder ι\nu : ι → Ω → β\ns : Set β\nn : ι\nω : Ω\ninst✝ : WellFoundedLT ι\nm i : ι\nhi : LT.lt i m\n⊢ Iff (LE.le (MeasureTheory.hitting u s n m ω) i) (Exists fun j => And (Membership.mem (Set.Icc n i) j) (Membership.mem s (u j ω)))","decl":"theorem hitting_le_iff_of_lt [WellFoundedLT ι] {m : ι} (i : ι) (hi : i < m) :\n    hitting u s n m ω ≤ i ↔ ∃ j ∈ Set.Icc n i, u j ω ∈ s := by\n  by_cases h_exists : ∃ j ∈ Set.Icc n m, u j ω ∈ s\n  · rw [hitting_le_iff_of_exists h_exists]\n  · simp_rw [hitting, if_neg h_exists]\n    push_neg at h_exists\n    simp only [not_le.mpr hi, Set.mem_Icc, false_iff, not_exists, not_and, and_imp]\n    exact fun k hkn hki => h_exists k ⟨hkn, hki.trans hi.le⟩\n\n"}
{"name":"MeasureTheory.hitting_lt_iff","module":"Mathlib.Probability.Process.HittingTime","initialProofState":"Ω : Type u_1\nβ : Type u_2\nι : Type u_3\ninst✝¹ : ConditionallyCompleteLinearOrder ι\nu : ι → Ω → β\ns : Set β\nn : ι\nω : Ω\ninst✝ : WellFoundedLT ι\nm i : ι\nhi : LE.le i m\n⊢ Iff (LT.lt (MeasureTheory.hitting u s n m ω) i) (Exists fun j => And (Membership.mem (Set.Ico n i) j) (Membership.mem s (u j ω)))","decl":"theorem hitting_lt_iff [WellFoundedLT ι] {m : ι} (i : ι) (hi : i ≤ m) :\n    hitting u s n m ω < i ↔ ∃ j ∈ Set.Ico n i, u j ω ∈ s := by\n  constructor <;> intro h'\n  · have h : ∃ j ∈ Set.Icc n m, u j ω ∈ s := by\n      by_contra h\n      simp_rw [hitting, if_neg h, ← not_le] at h'\n      exact h' hi\n    exact ⟨hitting u s n m ω, ⟨le_hitting_of_exists h, h'⟩, hitting_mem_set h⟩\n  · obtain ⟨k, hk₁, hk₂⟩ := h'\n    refine lt_of_le_of_lt ?_ hk₁.2\n    exact hitting_le_of_mem hk₁.1 (hk₁.2.le.trans hi) hk₂\n\n"}
{"name":"MeasureTheory.hitting_eq_hitting_of_exists","module":"Mathlib.Probability.Process.HittingTime","initialProofState":"Ω : Type u_1\nβ : Type u_2\nι : Type u_3\ninst✝ : ConditionallyCompleteLinearOrder ι\nu : ι → Ω → β\ns : Set β\nn : ι\nω : Ω\nm₁ m₂ : ι\nh : LE.le m₁ m₂\nh' : Exists fun j => And (Membership.mem (Set.Icc n m₁) j) (Membership.mem s (u j ω))\n⊢ Eq (MeasureTheory.hitting u s n m₁ ω) (MeasureTheory.hitting u s n m₂ ω)","decl":"theorem hitting_eq_hitting_of_exists {m₁ m₂ : ι} (h : m₁ ≤ m₂)\n    (h' : ∃ j ∈ Set.Icc n m₁, u j ω ∈ s) : hitting u s n m₁ ω = hitting u s n m₂ ω := by\n  simp only [hitting, if_pos h']\n  obtain ⟨j, hj₁, hj₂⟩ := h'\n  rw [if_pos]\n  · refine le_antisymm ?_ (csInf_le_csInf bddBelow_Icc.inter_of_left ⟨j, hj₁, hj₂⟩\n      (Set.inter_subset_inter_left _ (Set.Icc_subset_Icc_right h)))\n    refine le_csInf ⟨j, Set.Icc_subset_Icc_right h hj₁, hj₂⟩ fun i hi => ?_\n    by_cases hi' : i ≤ m₁\n    · exact csInf_le bddBelow_Icc.inter_of_left ⟨⟨hi.1.1, hi'⟩, hi.2⟩\n    · change j ∈ {i | u i ω ∈ s} at hj₂\n      exact ((csInf_le bddBelow_Icc.inter_of_left ⟨hj₁, hj₂⟩).trans (hj₁.2.trans le_rfl)).trans\n        (le_of_lt (not_le.1 hi'))\n  exact ⟨j, ⟨hj₁.1, hj₁.2.trans h⟩, hj₂⟩\n\n"}
{"name":"MeasureTheory.hitting_mono","module":"Mathlib.Probability.Process.HittingTime","initialProofState":"Ω : Type u_1\nβ : Type u_2\nι : Type u_3\ninst✝ : ConditionallyCompleteLinearOrder ι\nu : ι → Ω → β\ns : Set β\nn : ι\nω : Ω\nm₁ m₂ : ι\nhm : LE.le m₁ m₂\n⊢ LE.le (MeasureTheory.hitting u s n m₁ ω) (MeasureTheory.hitting u s n m₂ ω)","decl":"theorem hitting_mono {m₁ m₂ : ι} (hm : m₁ ≤ m₂) : hitting u s n m₁ ω ≤ hitting u s n m₂ ω := by\n  by_cases h : ∃ j ∈ Set.Icc n m₁, u j ω ∈ s\n  · exact (hitting_eq_hitting_of_exists hm h).le\n  · simp_rw [hitting, if_neg h]\n    split_ifs with h'\n    · obtain ⟨j, hj₁, hj₂⟩ := h'\n      refine le_csInf ⟨j, hj₁, hj₂⟩ ?_\n      by_contra hneg; push_neg at hneg\n      obtain ⟨i, hi₁, hi₂⟩ := hneg\n      exact h ⟨i, ⟨hi₁.1.1, hi₂.le⟩, hi₁.2⟩\n    · exact hm\n\n"}
{"name":"MeasureTheory.hitting_isStoppingTime","module":"Mathlib.Probability.Process.HittingTime","initialProofState":"Ω : Type u_1\nβ : Type u_2\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝⁶ : ConditionallyCompleteLinearOrder ι\ninst✝⁵ : WellFoundedLT ι\ninst✝⁴ : Countable ι\ninst✝³ : TopologicalSpace β\ninst✝² : TopologicalSpace.PseudoMetrizableSpace β\ninst✝¹ : MeasurableSpace β\ninst✝ : BorelSpace β\nf : MeasureTheory.Filtration ι m\nu : ι → Ω → β\ns : Set β\nn n' : ι\nhu : MeasureTheory.Adapted f u\nhs : MeasurableSet s\n⊢ MeasureTheory.IsStoppingTime f (MeasureTheory.hitting u s n n')","decl":"/-- A discrete hitting time is a stopping time. -/\ntheorem hitting_isStoppingTime [ConditionallyCompleteLinearOrder ι] [WellFoundedLT ι]\n    [Countable ι] [TopologicalSpace β] [PseudoMetrizableSpace β] [MeasurableSpace β] [BorelSpace β]\n    {f : Filtration ι m} {u : ι → Ω → β} {s : Set β} {n n' : ι} (hu : Adapted f u)\n    (hs : MeasurableSet s) : IsStoppingTime f (hitting u s n n') := by\n  intro i\n  rcases le_or_lt n' i with hi | hi\n  · have h_le : ∀ ω, hitting u s n n' ω ≤ i := fun x => (hitting_le x).trans hi\n    simp [h_le]\n  · have h_set_eq_Union : {ω | hitting u s n n' ω ≤ i} = ⋃ j ∈ Set.Icc n i, u j ⁻¹' s := by\n      ext x\n      rw [Set.mem_setOf_eq, hitting_le_iff_of_lt _ hi]\n      simp only [Set.mem_Icc, exists_prop, Set.mem_iUnion, Set.mem_preimage]\n    rw [h_set_eq_Union]\n    exact MeasurableSet.iUnion fun j =>\n      MeasurableSet.iUnion fun hj => f.mono hj.2 _ ((hu j).measurable hs)\n\n"}
{"name":"MeasureTheory.stoppedValue_hitting_mem","module":"Mathlib.Probability.Process.HittingTime","initialProofState":"Ω : Type u_1\nβ : Type u_2\nι : Type u_3\ninst✝¹ : ConditionallyCompleteLinearOrder ι\ninst✝ : WellFoundedLT ι\nu : ι → Ω → β\ns : Set β\nn m : ι\nω : Ω\nh : Exists fun j => And (Membership.mem (Set.Icc n m) j) (Membership.mem s (u j ω))\n⊢ Membership.mem s (MeasureTheory.stoppedValue u (MeasureTheory.hitting u s n m) ω)","decl":"theorem stoppedValue_hitting_mem [ConditionallyCompleteLinearOrder ι] [WellFoundedLT ι]\n    {u : ι → Ω → β} {s : Set β} {n m : ι} {ω : Ω} (h : ∃ j ∈ Set.Icc n m, u j ω ∈ s) :\n    stoppedValue u (hitting u s n m) ω ∈ s := by\n  simp only [stoppedValue, hitting, if_pos h]\n  obtain ⟨j, hj₁, hj₂⟩ := h\n  have : sInf (Set.Icc n m ∩ {i | u i ω ∈ s}) ∈ Set.Icc n m ∩ {i | u i ω ∈ s} :=\n    csInf_mem (Set.nonempty_of_mem ⟨hj₁, hj₂⟩)\n  exact this.2\n\n"}
{"name":"MeasureTheory.isStoppingTime_hitting_isStoppingTime","module":"Mathlib.Probability.Process.HittingTime","initialProofState":"Ω : Type u_1\nβ : Type u_2\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝⁹ : ConditionallyCompleteLinearOrder ι\ninst✝⁸ : WellFoundedLT ι\ninst✝⁷ : Countable ι\ninst✝⁶ : TopologicalSpace ι\ninst✝⁵ : OrderTopology ι\ninst✝⁴ : FirstCountableTopology ι\ninst✝³ : TopologicalSpace β\ninst✝² : TopologicalSpace.PseudoMetrizableSpace β\ninst✝¹ : MeasurableSpace β\ninst✝ : BorelSpace β\nf : MeasureTheory.Filtration ι m\nu : ι → Ω → β\nτ : Ω → ι\nhτ : MeasureTheory.IsStoppingTime f τ\nN : ι\nhτbdd : ∀ (x : Ω), LE.le (τ x) N\ns : Set β\nhs : MeasurableSet s\nhf : MeasureTheory.Adapted f u\n⊢ MeasureTheory.IsStoppingTime f fun x => MeasureTheory.hitting u s (τ x) N x","decl":"/-- The hitting time of a discrete process with the starting time indexed by a stopping time\nis a stopping time. -/\ntheorem isStoppingTime_hitting_isStoppingTime [ConditionallyCompleteLinearOrder ι]\n    [WellFoundedLT ι] [Countable ι] [TopologicalSpace ι] [OrderTopology ι]\n    [FirstCountableTopology ι] [TopologicalSpace β] [PseudoMetrizableSpace β] [MeasurableSpace β]\n    [BorelSpace β] {f : Filtration ι m} {u : ι → Ω → β} {τ : Ω → ι} (hτ : IsStoppingTime f τ)\n    {N : ι} (hτbdd : ∀ x, τ x ≤ N) {s : Set β} (hs : MeasurableSet s) (hf : Adapted f u) :\n    IsStoppingTime f fun x => hitting u s (τ x) N x := by\n  intro n\n  have h₁ : {x | hitting u s (τ x) N x ≤ n} =\n    (⋃ i ≤ n, {x | τ x = i} ∩ {x | hitting u s i N x ≤ n}) ∪\n      ⋃ i > n, {x | τ x = i} ∩ {x | hitting u s i N x ≤ n} := by\n    ext x\n    simp [← exists_or, ← or_and_right, le_or_lt]\n  have h₂ : ⋃ i > n, {x | τ x = i} ∩ {x | hitting u s i N x ≤ n} = ∅ := by\n    ext x\n    simp only [gt_iff_lt, Set.mem_iUnion, Set.mem_inter_iff, Set.mem_setOf_eq, exists_prop,\n      Set.mem_empty_iff_false, iff_false, not_exists, not_and, not_le]\n    rintro m hm rfl\n    exact lt_of_lt_of_le hm (le_hitting (hτbdd _) _)\n  rw [h₁, h₂, Set.union_empty]\n  exact MeasurableSet.iUnion fun i => MeasurableSet.iUnion fun hi =>\n    (f.mono hi _ (hτ.measurableSet_eq i)).inter (hitting_isStoppingTime hf hs n)\n\n"}
{"name":"MeasureTheory.hitting_eq_sInf","module":"Mathlib.Probability.Process.HittingTime","initialProofState":"Ω : Type u_1\nβ : Type u_2\nι : Type u_3\ninst✝ : CompleteLattice ι\nu : ι → Ω → β\ns : Set β\nω : Ω\n⊢ Eq (MeasureTheory.hitting u s Bot.bot Top.top ω) (InfSet.sInf (setOf fun i => Membership.mem s (u i ω)))","decl":"theorem hitting_eq_sInf (ω : Ω) : hitting u s ⊥ ⊤ ω = sInf {i : ι | u i ω ∈ s} := by\n  simp only [hitting, Set.mem_Icc, bot_le, le_top, and_self_iff, exists_true_left, Set.Icc_bot,\n    Set.Iic_top, Set.univ_inter, ite_eq_left_iff, not_exists]\n  intro h_nmem_s\n  symm\n  rw [sInf_eq_top]\n  simp only [Set.mem_univ, true_and] at h_nmem_s\n  exact fun i hi_mem_s => absurd hi_mem_s (h_nmem_s i)\n\n"}
{"name":"MeasureTheory.hitting_bot_le_iff","module":"Mathlib.Probability.Process.HittingTime","initialProofState":"Ω : Type u_1\nβ : Type u_2\nι : Type u_3\ninst✝¹ : ConditionallyCompleteLinearOrderBot ι\ninst✝ : WellFoundedLT ι\nu : ι → Ω → β\ns : Set β\ni n : ι\nω : Ω\nhx : Exists fun j => And (LE.le j n) (Membership.mem s (u j ω))\n⊢ Iff (LE.le (MeasureTheory.hitting u s Bot.bot n ω) i) (Exists fun j => And (LE.le j i) (Membership.mem s (u j ω)))","decl":"theorem hitting_bot_le_iff {i n : ι} {ω : Ω} (hx : ∃ j, j ≤ n ∧ u j ω ∈ s) :\n    hitting u s ⊥ n ω ≤ i ↔ ∃ j ≤ i, u j ω ∈ s := by\n  cases' lt_or_le i n with hi hi\n  · rw [hitting_le_iff_of_lt _ hi]\n    simp\n  · simp only [(hitting_le ω).trans hi, true_iff]\n    obtain ⟨j, hj₁, hj₂⟩ := hx\n    exact ⟨j, hj₁.trans hi, hj₂⟩\n\n"}
