{"name":"lipschitzGroup.conjAct_smul_ι_mem_range_ι","module":"Mathlib.LinearAlgebra.CliffordAlgebra.SpinGroup","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\nM : Type u_2\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\nQ : QuadraticForm R M\nx : Units (CliffordAlgebra Q)\nhx : Membership.mem (lipschitzGroup Q) x\ninst✝ : Invertible 2\nm : M\n⊢ Membership.mem (LinearMap.range (CliffordAlgebra.ι Q)) (HSMul.hSMul (ConjAct.toConjAct x) ((CliffordAlgebra.ι Q) m))","decl":"/-- The conjugation action by elements of the Lipschitz group keeps vectors as vectors. -/\ntheorem conjAct_smul_ι_mem_range_ι {x : (CliffordAlgebra Q)ˣ} (hx : x ∈ lipschitzGroup Q)\n    [Invertible (2 : R)] (m : M) :\n    ConjAct.toConjAct x • ι Q m ∈ LinearMap.range (ι Q) := by\n  unfold lipschitzGroup at hx\n  rw [ConjAct.units_smul_def, ConjAct.ofConjAct_toConjAct]\n  induction hx using Subgroup.closure_induction'' generalizing m with\n  | mem x hx =>\n    obtain ⟨a, ha⟩ := hx\n    letI := x.invertible\n    letI : Invertible (ι Q a) := by rwa [ha]\n    letI : Invertible (Q a) := invertibleOfInvertibleι Q a\n    simp_rw [← invOf_units x, ← ha, ι_mul_ι_mul_invOf_ι, LinearMap.mem_range_self]\n  | inv_mem x hx =>\n    obtain ⟨a, ha⟩ := hx\n    letI := x.invertible\n    letI : Invertible (ι Q a) := by rwa [ha]\n    letI : Invertible (Q a) := invertibleOfInvertibleι Q a\n    letI := invertibleNeg (ι Q a)\n    letI := Invertible.map involute (ι Q a)\n    simp_rw [← invOf_units x, inv_inv, ← ha, invOf_ι_mul_ι_mul_ι, LinearMap.mem_range_self]\n  | one => simp_rw [inv_one, Units.val_one, one_mul, mul_one, LinearMap.mem_range_self]\n  | mul y z _ _ hy hz =>\n    simp_rw [mul_inv_rev, Units.val_mul]\n    suffices ↑y * (↑z * ι Q m * ↑z⁻¹) * ↑y⁻¹ ∈ _ by\n      simpa only [mul_assoc] using this\n    obtain ⟨z', hz'⟩ := hz m\n    obtain ⟨y', hy'⟩ := hy z'\n    simp_rw [← hz', ← hy', LinearMap.mem_range_self]\n\n"}
{"name":"lipschitzGroup.involute_act_ι_mem_range_ι","module":"Mathlib.LinearAlgebra.CliffordAlgebra.SpinGroup","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\nM : Type u_2\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\nQ : QuadraticForm R M\ninst✝ : Invertible 2\nx : Units (CliffordAlgebra Q)\nhx : Membership.mem (lipschitzGroup Q) x\nb : M\n⊢ Membership.mem (LinearMap.range (CliffordAlgebra.ι Q)) (HMul.hMul (HMul.hMul (CliffordAlgebra.involute ↑x) ((CliffordAlgebra.ι Q) b)) ↑(Inv.inv x))","decl":"/-- This is another version of `lipschitzGroup.conjAct_smul_ι_mem_range_ι` which uses `involute`. -/\ntheorem involute_act_ι_mem_range_ι [Invertible (2 : R)]\n    {x : (CliffordAlgebra Q)ˣ} (hx : x ∈ lipschitzGroup Q) (b : M) :\n      involute (Q := Q) ↑x * ι Q b * ↑x⁻¹ ∈ LinearMap.range (ι Q) := by\n  unfold lipschitzGroup at hx\n  induction hx using Subgroup.closure_induction'' generalizing b with\n  | mem x hx =>\n    obtain ⟨a, ha⟩ := hx\n    letI := x.invertible\n    letI : Invertible (ι Q a) := by rwa [ha]\n    letI : Invertible (Q a) := invertibleOfInvertibleι Q a\n    simp_rw [← invOf_units x, ← ha, involute_ι, neg_mul, ι_mul_ι_mul_invOf_ι Q a b, ← map_neg,\n      LinearMap.mem_range_self]\n  | inv_mem x hx =>\n    obtain ⟨a, ha⟩ := hx\n    letI := x.invertible\n    letI : Invertible (ι Q a) := by rwa [ha]\n    letI : Invertible (Q a) := invertibleOfInvertibleι Q a\n    letI := invertibleNeg (ι Q a)\n    letI := Invertible.map involute (ι Q a)\n    simp_rw [← invOf_units x, inv_inv, ← ha, map_invOf, involute_ι, invOf_neg, neg_mul,\n      invOf_ι_mul_ι_mul_ι, ← map_neg, LinearMap.mem_range_self]\n  | one => simp_rw [inv_one, Units.val_one, map_one, one_mul, mul_one, LinearMap.mem_range_self]\n  | mul y z _ _ hy hz =>\n    simp_rw [mul_inv_rev, Units.val_mul, map_mul]\n    suffices involute (Q := Q) ↑y * (involute (Q := Q) ↑z * ι Q b * ↑z⁻¹) * ↑y⁻¹ ∈ _ by\n      simpa only [mul_assoc] using this\n    obtain ⟨z', hz'⟩ := hz b\n    obtain ⟨y', hy'⟩ := hy z'\n    simp_rw [← hz', ← hy', LinearMap.mem_range_self]\n\n"}
{"name":"lipschitzGroup.conjAct_smul_range_ι","module":"Mathlib.LinearAlgebra.CliffordAlgebra.SpinGroup","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\nM : Type u_2\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\nQ : QuadraticForm R M\nx : Units (CliffordAlgebra Q)\nhx : Membership.mem (lipschitzGroup Q) x\ninst✝ : Invertible 2\n⊢ Eq (HSMul.hSMul (ConjAct.toConjAct x) (LinearMap.range (CliffordAlgebra.ι Q))) (LinearMap.range (CliffordAlgebra.ι Q))","decl":"/-- If x is in `lipschitzGroup Q`, then `(ι Q).range` is closed under twisted conjugation.\nThe reverse statement presumably is true only in finite dimensions.-/\ntheorem conjAct_smul_range_ι {x : (CliffordAlgebra Q)ˣ} (hx : x ∈ lipschitzGroup Q)\n    [Invertible (2 : R)] :\n    ConjAct.toConjAct x • LinearMap.range (ι Q) = LinearMap.range (ι Q) := by\n  suffices ∀ x ∈ lipschitzGroup Q,\n      ConjAct.toConjAct x • LinearMap.range (ι Q) ≤ LinearMap.range (ι Q) by\n    apply le_antisymm\n    · exact this _ hx\n    · have := smul_mono_right (ConjAct.toConjAct x) <| this _ (inv_mem hx)\n      refine Eq.trans_le ?_ this\n      simp only [map_inv, smul_inv_smul]\n  intro x hx\n  erw [Submodule.map_le_iff_le_comap]\n  rintro _ ⟨m, rfl⟩\n  exact conjAct_smul_ι_mem_range_ι hx _\n\n"}
{"name":"lipschitzGroup.coe_mem_iff_mem","module":"Mathlib.LinearAlgebra.CliffordAlgebra.SpinGroup","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\nx : Units (CliffordAlgebra Q)\n⊢ Iff (Membership.mem (Submonoid.map (Units.coeHom (CliffordAlgebra Q)) (lipschitzGroup Q).toSubmonoid) ↑x) (Membership.mem (lipschitzGroup Q) x)","decl":"theorem coe_mem_iff_mem {x : (CliffordAlgebra Q)ˣ} :\n    ↑x ∈ (lipschitzGroup Q).toSubmonoid.map (Units.coeHom <| CliffordAlgebra Q) ↔\n    x ∈ lipschitzGroup Q := by\n  simp only [Submonoid.mem_map, Subgroup.mem_toSubmonoid, Units.coeHom_apply, exists_prop]\n  norm_cast\n  exact exists_eq_right\n\n"}
{"name":"pinGroup.mem_iff","module":"Mathlib.LinearAlgebra.CliffordAlgebra.SpinGroup","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\nx : CliffordAlgebra Q\n⊢ Iff (Membership.mem (pinGroup Q) x) (And (Membership.mem (Submonoid.map (Units.coeHom (CliffordAlgebra Q)) (lipschitzGroup Q).toSubmonoid) x) (Membership.mem (unitary (CliffordAlgebra Q)) x))","decl":"/-- An element is in `pinGroup Q` if and only if it is in `lipschitzGroup Q` and `unitary`. -/\ntheorem mem_iff {x : CliffordAlgebra Q} :\n    x ∈ pinGroup Q ↔\n      x ∈ (lipschitzGroup Q).toSubmonoid.map (Units.coeHom <| CliffordAlgebra Q) ∧\n        x ∈ unitary (CliffordAlgebra Q) :=\n  Iff.rfl\n\n"}
{"name":"pinGroup.mem_lipschitzGroup","module":"Mathlib.LinearAlgebra.CliffordAlgebra.SpinGroup","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\nx : CliffordAlgebra Q\nhx : Membership.mem (pinGroup Q) x\n⊢ Membership.mem (Submonoid.map (Units.coeHom (CliffordAlgebra Q)) (lipschitzGroup Q).toSubmonoid) x","decl":"theorem mem_lipschitzGroup {x : CliffordAlgebra Q} (hx : x ∈ pinGroup Q) :\n    x ∈ (lipschitzGroup Q).toSubmonoid.map (Units.coeHom <| CliffordAlgebra Q) :=\n  hx.1\n\n"}
{"name":"pinGroup.mem_unitary","module":"Mathlib.LinearAlgebra.CliffordAlgebra.SpinGroup","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\nx : CliffordAlgebra Q\nhx : Membership.mem (pinGroup Q) x\n⊢ Membership.mem (unitary (CliffordAlgebra Q)) x","decl":"theorem mem_unitary {x : CliffordAlgebra Q} (hx : x ∈ pinGroup Q) :\n    x ∈ unitary (CliffordAlgebra Q) :=\n  hx.2\n\n"}
{"name":"pinGroup.units_mem_iff","module":"Mathlib.LinearAlgebra.CliffordAlgebra.SpinGroup","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\nx : Units (CliffordAlgebra Q)\n⊢ Iff (Membership.mem (pinGroup Q) ↑x) (And (Membership.mem (lipschitzGroup Q) x) (Membership.mem (unitary (CliffordAlgebra Q)) ↑x))","decl":"theorem units_mem_iff {x : (CliffordAlgebra Q)ˣ} :\n    ↑x ∈ pinGroup Q ↔ x ∈ lipschitzGroup Q ∧ ↑x ∈ unitary (CliffordAlgebra Q) := by\n  rw [mem_iff, lipschitzGroup.coe_mem_iff_mem]\n\n"}
{"name":"pinGroup.units_mem_lipschitzGroup","module":"Mathlib.LinearAlgebra.CliffordAlgebra.SpinGroup","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\nx : Units (CliffordAlgebra Q)\nhx : Membership.mem (pinGroup Q) ↑x\n⊢ Membership.mem (lipschitzGroup Q) x","decl":"theorem units_mem_lipschitzGroup {x : (CliffordAlgebra Q)ˣ} (hx : ↑x ∈ pinGroup Q) :\n    x ∈ lipschitzGroup Q :=\n  (units_mem_iff.1 hx).1\n\n"}
{"name":"pinGroup.conjAct_smul_ι_mem_range_ι","module":"Mathlib.LinearAlgebra.CliffordAlgebra.SpinGroup","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\nM : Type u_2\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\nQ : QuadraticForm R M\nx : Units (CliffordAlgebra Q)\nhx : Membership.mem (pinGroup Q) ↑x\ninst✝ : Invertible 2\ny : M\n⊢ Membership.mem (LinearMap.range (CliffordAlgebra.ι Q)) (HSMul.hSMul (ConjAct.toConjAct x) ((CliffordAlgebra.ι Q) y))","decl":"/-- The conjugation action by elements of the spin group keeps vectors as vectors. -/\ntheorem conjAct_smul_ι_mem_range_ι {x : (CliffordAlgebra Q)ˣ} (hx : ↑x ∈ pinGroup Q)\n    [Invertible (2 : R)] (y : M) : ConjAct.toConjAct x • ι Q y ∈ LinearMap.range (ι Q) :=\n  lipschitzGroup.conjAct_smul_ι_mem_range_ι (units_mem_lipschitzGroup hx) y\n\n"}
{"name":"pinGroup.involute_act_ι_mem_range_ι","module":"Mathlib.LinearAlgebra.CliffordAlgebra.SpinGroup","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\nM : Type u_2\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\nQ : QuadraticForm R M\nx : Units (CliffordAlgebra Q)\nhx : Membership.mem (pinGroup Q) ↑x\ninst✝ : Invertible 2\ny : M\n⊢ Membership.mem (LinearMap.range (CliffordAlgebra.ι Q)) (HMul.hMul (HMul.hMul (CliffordAlgebra.involute ↑x) ((CliffordAlgebra.ι Q) y)) ↑(Inv.inv x))","decl":"/-- This is another version of `conjAct_smul_ι_mem_range_ι` which uses `involute`. -/\ntheorem involute_act_ι_mem_range_ι {x : (CliffordAlgebra Q)ˣ} (hx : ↑x ∈ pinGroup Q)\n    [Invertible (2 : R)] (y : M) : involute (Q := Q) ↑x * ι Q y * ↑x⁻¹ ∈ LinearMap.range (ι Q) :=\n  lipschitzGroup.involute_act_ι_mem_range_ι (units_mem_lipschitzGroup hx) y\n\n"}
{"name":"pinGroup.conjAct_smul_range_ι","module":"Mathlib.LinearAlgebra.CliffordAlgebra.SpinGroup","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\nM : Type u_2\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\nQ : QuadraticForm R M\nx : Units (CliffordAlgebra Q)\nhx : Membership.mem (pinGroup Q) ↑x\ninst✝ : Invertible 2\n⊢ Eq (HSMul.hSMul (ConjAct.toConjAct x) (LinearMap.range (CliffordAlgebra.ι Q))) (LinearMap.range (CliffordAlgebra.ι Q))","decl":"/-- If x is in `pinGroup Q`, then `(ι Q).range` is closed under twisted conjugation. The reverse\nstatement presumably being true only in finite dimensions.-/\ntheorem conjAct_smul_range_ι {x : (CliffordAlgebra Q)ˣ} (hx : ↑x ∈ pinGroup Q)\n    [Invertible (2 : R)] : ConjAct.toConjAct x • LinearMap.range (ι Q) = LinearMap.range (ι Q) :=\n  lipschitzGroup.conjAct_smul_range_ι (units_mem_lipschitzGroup hx)\n\n"}
{"name":"pinGroup.star_mul_self_of_mem","module":"Mathlib.LinearAlgebra.CliffordAlgebra.SpinGroup","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\nx : CliffordAlgebra Q\nhx : Membership.mem (pinGroup Q) x\n⊢ Eq (HMul.hMul (Star.star x) x) 1","decl":"@[simp]\ntheorem star_mul_self_of_mem {x : CliffordAlgebra Q} (hx : x ∈ pinGroup Q) : star x * x = 1 :=\n  hx.2.1\n\n"}
{"name":"pinGroup.mul_star_self_of_mem","module":"Mathlib.LinearAlgebra.CliffordAlgebra.SpinGroup","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\nx : CliffordAlgebra Q\nhx : Membership.mem (pinGroup Q) x\n⊢ Eq (HMul.hMul x (Star.star x)) 1","decl":"@[simp]\ntheorem mul_star_self_of_mem {x : CliffordAlgebra Q} (hx : x ∈ pinGroup Q) : x * star x = 1 :=\n  hx.2.2\n\n"}
{"name":"pinGroup.star_mem","module":"Mathlib.LinearAlgebra.CliffordAlgebra.SpinGroup","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\nx : CliffordAlgebra Q\nhx : Membership.mem (pinGroup Q) x\n⊢ Membership.mem (pinGroup Q) (Star.star x)","decl":"/-- See `star_mem_iff` for both directions. -/\ntheorem star_mem {x : CliffordAlgebra Q} (hx : x ∈ pinGroup Q) : star x ∈ pinGroup Q := by\n  rw [mem_iff] at hx ⊢\n  refine ⟨?_, unitary.star_mem hx.2⟩\n  rcases hx with ⟨⟨y, hy₁, hy₂⟩, _hx₂, hx₃⟩\n  simp only [Subgroup.coe_toSubmonoid, SetLike.mem_coe] at hy₁\n  simp only [Units.coeHom_apply] at hy₂\n  simp only [Submonoid.mem_map, Subgroup.mem_toSubmonoid, Units.coeHom_apply, exists_prop]\n  refine ⟨star y, ?_, by simp only [hy₂, Units.coe_star]⟩\n  rw [← hy₂] at hx₃\n  have hy₃ : y * star y = 1 := by\n    rw [← Units.eq_iff]\n    simp only [hx₃, Units.val_mul, Units.coe_star, Units.val_one]\n  apply_fun fun x => y⁻¹ * x at hy₃\n  simp only [inv_mul_cancel_left, mul_one] at hy₃\n  simp only [hy₃, hy₁, inv_mem_iff]\n\n"}
{"name":"pinGroup.star_mem_iff","module":"Mathlib.LinearAlgebra.CliffordAlgebra.SpinGroup","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\nx : CliffordAlgebra Q\n⊢ Iff (Membership.mem (pinGroup Q) (Star.star x)) (Membership.mem (pinGroup Q) x)","decl":"/-- An element is in `pinGroup Q` if and only if `star x` is in `pinGroup Q`.\nSee `star_mem` for only one direction. -/\n@[simp]\ntheorem star_mem_iff {x : CliffordAlgebra Q} : star x ∈ pinGroup Q ↔ x ∈ pinGroup Q := by\n  refine ⟨?_, star_mem⟩\n  intro hx\n  convert star_mem hx\n  exact (star_star x).symm\n\n"}
{"name":"pinGroup.coe_star","module":"Mathlib.LinearAlgebra.CliffordAlgebra.SpinGroup","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\nx : Subtype fun x => Membership.mem (pinGroup Q) x\n⊢ Eq (↑(Star.star x)) (Star.star ↑x)","decl":"@[simp, norm_cast]\ntheorem coe_star {x : pinGroup Q} : ↑(star x) = (star x : CliffordAlgebra Q) :=\n  rfl\n\n"}
{"name":"pinGroup.coe_star_mul_self","module":"Mathlib.LinearAlgebra.CliffordAlgebra.SpinGroup","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\nx : Subtype fun x => Membership.mem (pinGroup Q) x\n⊢ Eq (HMul.hMul (Star.star ↑x) ↑x) 1","decl":"theorem coe_star_mul_self (x : pinGroup Q) : (star x : CliffordAlgebra Q) * x = 1 :=\n  star_mul_self_of_mem x.prop\n\n"}
{"name":"pinGroup.coe_mul_star_self","module":"Mathlib.LinearAlgebra.CliffordAlgebra.SpinGroup","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\nx : Subtype fun x => Membership.mem (pinGroup Q) x\n⊢ Eq (HMul.hMul ↑x ↑(Star.star x)) 1","decl":"theorem coe_mul_star_self (x : pinGroup Q) : (x : CliffordAlgebra Q) * star x = 1 :=\n  mul_star_self_of_mem x.prop\n\n"}
{"name":"pinGroup.star_mul_self","module":"Mathlib.LinearAlgebra.CliffordAlgebra.SpinGroup","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\nx : Subtype fun x => Membership.mem (pinGroup Q) x\n⊢ Eq (HMul.hMul (Star.star x) x) 1","decl":"@[simp]\ntheorem star_mul_self (x : pinGroup Q) : star x * x = 1 :=\n  Subtype.ext <| coe_star_mul_self x\n\n"}
{"name":"pinGroup.mul_star_self","module":"Mathlib.LinearAlgebra.CliffordAlgebra.SpinGroup","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\nx : Subtype fun x => Membership.mem (pinGroup Q) x\n⊢ Eq (HMul.hMul x (Star.star x)) 1","decl":"@[simp]\ntheorem mul_star_self (x : pinGroup Q) : x * star x = 1 :=\n  Subtype.ext <| coe_mul_star_self x\n\n"}
{"name":"pinGroup.star_eq_inv","module":"Mathlib.LinearAlgebra.CliffordAlgebra.SpinGroup","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\nx : Subtype fun x => Membership.mem (pinGroup Q) x\n⊢ Eq (Star.star x) (Inv.inv x)","decl":"theorem star_eq_inv (x : pinGroup Q) : star x = x⁻¹ :=\n  rfl\n\n"}
{"name":"pinGroup.star_eq_inv'","module":"Mathlib.LinearAlgebra.CliffordAlgebra.SpinGroup","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\n⊢ Eq Star.star Inv.inv","decl":"theorem star_eq_inv' : (star : pinGroup Q → pinGroup Q) = Inv.inv :=\n  rfl\n\n"}
{"name":"pinGroup.val_toUnits_apply","module":"Mathlib.LinearAlgebra.CliffordAlgebra.SpinGroup","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\nx : Subtype fun x => Membership.mem (pinGroup Q) x\n⊢ Eq ↑(pinGroup.toUnits x) ↑x","decl":"/-- The elements in `pinGroup Q` embed into (CliffordAlgebra Q)ˣ. -/\n@[simps]\ndef toUnits : pinGroup Q →* (CliffordAlgebra Q)ˣ where\n  toFun x := ⟨x, ↑x⁻¹, coe_mul_star_self x, coe_star_mul_self x⟩\n  map_one' := Units.ext rfl\n  map_mul' _x _y := Units.ext rfl\n\n"}
{"name":"pinGroup.val_inv_toUnits_apply","module":"Mathlib.LinearAlgebra.CliffordAlgebra.SpinGroup","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\nx : Subtype fun x => Membership.mem (pinGroup Q) x\n⊢ Eq ↑(Inv.inv (pinGroup.toUnits x)) ↑(Inv.inv x)","decl":"/-- The elements in `pinGroup Q` embed into (CliffordAlgebra Q)ˣ. -/\n@[simps]\ndef toUnits : pinGroup Q →* (CliffordAlgebra Q)ˣ where\n  toFun x := ⟨x, ↑x⁻¹, coe_mul_star_self x, coe_star_mul_self x⟩\n  map_one' := Units.ext rfl\n  map_mul' _x _y := Units.ext rfl\n\n"}
{"name":"pinGroup.toUnits_injective","module":"Mathlib.LinearAlgebra.CliffordAlgebra.SpinGroup","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\n⊢ Function.Injective ⇑pinGroup.toUnits","decl":"theorem toUnits_injective : Function.Injective (toUnits : pinGroup Q → (CliffordAlgebra Q)ˣ) :=\n  fun _x _y h => Subtype.ext <| Units.ext_iff.mp h\n\n"}
{"name":"spinGroup.mem_iff","module":"Mathlib.LinearAlgebra.CliffordAlgebra.SpinGroup","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\nx : CliffordAlgebra Q\n⊢ Iff (Membership.mem (spinGroup Q) x) (And (Membership.mem (pinGroup Q) x) (Membership.mem (CliffordAlgebra.even Q) x))","decl":"/-- An element is in `spinGroup Q` if and only if it is in `pinGroup Q` and `even Q`. -/\ntheorem mem_iff {x : CliffordAlgebra Q} : x ∈ spinGroup Q ↔ x ∈ pinGroup Q ∧ x ∈ even Q :=\n  Iff.rfl\n\n"}
{"name":"spinGroup.mem_pin","module":"Mathlib.LinearAlgebra.CliffordAlgebra.SpinGroup","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\nx : CliffordAlgebra Q\nhx : Membership.mem (spinGroup Q) x\n⊢ Membership.mem (pinGroup Q) x","decl":"theorem mem_pin {x : CliffordAlgebra Q} (hx : x ∈ spinGroup Q) : x ∈ pinGroup Q :=\n  hx.1\n\n"}
{"name":"spinGroup.mem_even","module":"Mathlib.LinearAlgebra.CliffordAlgebra.SpinGroup","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\nx : CliffordAlgebra Q\nhx : Membership.mem (spinGroup Q) x\n⊢ Membership.mem (CliffordAlgebra.even Q) x","decl":"theorem mem_even {x : CliffordAlgebra Q} (hx : x ∈ spinGroup Q) : x ∈ even Q :=\n  hx.2\n\n"}
{"name":"spinGroup.units_mem_lipschitzGroup","module":"Mathlib.LinearAlgebra.CliffordAlgebra.SpinGroup","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\nx : Units (CliffordAlgebra Q)\nhx : Membership.mem (spinGroup Q) ↑x\n⊢ Membership.mem (lipschitzGroup Q) x","decl":"theorem units_mem_lipschitzGroup {x : (CliffordAlgebra Q)ˣ} (hx : ↑x ∈ spinGroup Q) :\n    x ∈ lipschitzGroup Q :=\n  pinGroup.units_mem_lipschitzGroup (mem_pin hx)\n\n"}
{"name":"spinGroup.involute_eq","module":"Mathlib.LinearAlgebra.CliffordAlgebra.SpinGroup","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\nx : CliffordAlgebra Q\nhx : Membership.mem (spinGroup Q) x\n⊢ Eq (CliffordAlgebra.involute x) x","decl":"/-- If x is in `spinGroup Q`, then `involute x` is equal to x.-/\ntheorem involute_eq {x : CliffordAlgebra Q} (hx : x ∈ spinGroup Q) : involute x = x :=\n  involute_eq_of_mem_even (mem_even hx)\n\n"}
{"name":"spinGroup.units_involute_act_eq_conjAct","module":"Mathlib.LinearAlgebra.CliffordAlgebra.SpinGroup","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\nx : Units (CliffordAlgebra Q)\nhx : Membership.mem (spinGroup Q) ↑x\ny : M\n⊢ Eq (HMul.hMul (HMul.hMul (CliffordAlgebra.involute ↑x) ((CliffordAlgebra.ι Q) y)) ↑(Inv.inv x)) (HSMul.hSMul (ConjAct.toConjAct x) ((CliffordAlgebra.ι Q) y))","decl":"theorem units_involute_act_eq_conjAct {x : (CliffordAlgebra Q)ˣ} (hx : ↑x ∈ spinGroup Q) (y : M) :\n    involute (Q := Q) ↑x * ι Q y * ↑x⁻¹ = ConjAct.toConjAct x • (ι Q y) := by\n  rw [involute_eq hx, @ConjAct.units_smul_def, @ConjAct.ofConjAct_toConjAct]\n\n"}
{"name":"spinGroup.conjAct_smul_ι_mem_range_ι","module":"Mathlib.LinearAlgebra.CliffordAlgebra.SpinGroup","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\nM : Type u_2\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\nQ : QuadraticForm R M\nx : Units (CliffordAlgebra Q)\nhx : Membership.mem (spinGroup Q) ↑x\ninst✝ : Invertible 2\ny : M\n⊢ Membership.mem (LinearMap.range (CliffordAlgebra.ι Q)) (HSMul.hSMul (ConjAct.toConjAct x) ((CliffordAlgebra.ι Q) y))","decl":"/-- The conjugation action by elements of the spin group keeps vectors as vectors. -/\ntheorem conjAct_smul_ι_mem_range_ι {x : (CliffordAlgebra Q)ˣ} (hx : ↑x ∈ spinGroup Q)\n    [Invertible (2 : R)] (y : M) : ConjAct.toConjAct x • ι Q y ∈ LinearMap.range (ι Q) :=\n  lipschitzGroup.conjAct_smul_ι_mem_range_ι (units_mem_lipschitzGroup hx) y\n\n/- This is another version of `conjAct_smul_ι_mem_range_ι` which uses `involute`.-/\n"}
{"name":"spinGroup.involute_act_ι_mem_range_ι","module":"Mathlib.LinearAlgebra.CliffordAlgebra.SpinGroup","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\nM : Type u_2\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\nQ : QuadraticForm R M\nx : Units (CliffordAlgebra Q)\nhx : Membership.mem (spinGroup Q) ↑x\ninst✝ : Invertible 2\ny : M\n⊢ Membership.mem (LinearMap.range (CliffordAlgebra.ι Q)) (HMul.hMul (HMul.hMul (CliffordAlgebra.involute ↑x) ((CliffordAlgebra.ι Q) y)) ↑(Inv.inv x))","decl":"theorem involute_act_ι_mem_range_ι {x : (CliffordAlgebra Q)ˣ} (hx : ↑x ∈ spinGroup Q)\n    [Invertible (2 : R)] (y : M) : involute (Q := Q) ↑x * ι Q y * ↑x⁻¹ ∈ LinearMap.range (ι Q) :=\n  lipschitzGroup.involute_act_ι_mem_range_ι (units_mem_lipschitzGroup hx) y\n\n/- If x is in `spinGroup Q`, then `(ι Q).range` is closed under twisted conjugation. The reverse\nstatement presumably being true only in finite dimensions.-/\n"}
{"name":"spinGroup.conjAct_smul_range_ι","module":"Mathlib.LinearAlgebra.CliffordAlgebra.SpinGroup","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\nM : Type u_2\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\nQ : QuadraticForm R M\nx : Units (CliffordAlgebra Q)\nhx : Membership.mem (spinGroup Q) ↑x\ninst✝ : Invertible 2\n⊢ Eq (HSMul.hSMul (ConjAct.toConjAct x) (LinearMap.range (CliffordAlgebra.ι Q))) (LinearMap.range (CliffordAlgebra.ι Q))","decl":"theorem conjAct_smul_range_ι {x : (CliffordAlgebra Q)ˣ} (hx : ↑x ∈ spinGroup Q)\n    [Invertible (2 : R)] : ConjAct.toConjAct x • LinearMap.range (ι Q) = LinearMap.range (ι Q) :=\n  lipschitzGroup.conjAct_smul_range_ι (units_mem_lipschitzGroup hx)\n\n"}
{"name":"spinGroup.star_mul_self_of_mem","module":"Mathlib.LinearAlgebra.CliffordAlgebra.SpinGroup","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\nx : CliffordAlgebra Q\nhx : Membership.mem (spinGroup Q) x\n⊢ Eq (HMul.hMul (Star.star x) x) 1","decl":"@[simp]\ntheorem star_mul_self_of_mem {x : CliffordAlgebra Q} (hx : x ∈ spinGroup Q) : star x * x = 1 :=\n  hx.1.2.1\n\n"}
{"name":"spinGroup.mul_star_self_of_mem","module":"Mathlib.LinearAlgebra.CliffordAlgebra.SpinGroup","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\nx : CliffordAlgebra Q\nhx : Membership.mem (spinGroup Q) x\n⊢ Eq (HMul.hMul x (Star.star x)) 1","decl":"@[simp]\ntheorem mul_star_self_of_mem {x : CliffordAlgebra Q} (hx : x ∈ spinGroup Q) : x * star x = 1 :=\n  hx.1.2.2\n\n"}
{"name":"spinGroup.star_mem","module":"Mathlib.LinearAlgebra.CliffordAlgebra.SpinGroup","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\nx : CliffordAlgebra Q\nhx : Membership.mem (spinGroup Q) x\n⊢ Membership.mem (spinGroup Q) (Star.star x)","decl":"/-- See `star_mem_iff` for both directions. -/\ntheorem star_mem {x : CliffordAlgebra Q} (hx : x ∈ spinGroup Q) : star x ∈ spinGroup Q := by\n  rw [mem_iff] at hx ⊢\n  cases' hx with hx₁ hx₂\n  refine ⟨pinGroup.star_mem hx₁, ?_⟩\n  dsimp only [CliffordAlgebra.even] at hx₂ ⊢\n  simp only [Submodule.mem_toSubalgebra] at hx₂ ⊢\n  simp only [star_def, reverse_mem_evenOdd_iff, involute_mem_evenOdd_iff, hx₂]\n\n"}
{"name":"spinGroup.star_mem_iff","module":"Mathlib.LinearAlgebra.CliffordAlgebra.SpinGroup","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\nx : CliffordAlgebra Q\n⊢ Iff (Membership.mem (spinGroup Q) (Star.star x)) (Membership.mem (spinGroup Q) x)","decl":"/-- An element is in `spinGroup Q` if and only if `star x` is in `spinGroup Q`.\nSee `star_mem` for only one direction.\n-/\n@[simp]\ntheorem star_mem_iff {x : CliffordAlgebra Q} : star x ∈ spinGroup Q ↔ x ∈ spinGroup Q := by\n  refine ⟨?_, star_mem⟩\n  intro hx\n  convert star_mem hx\n  exact (star_star x).symm\n\n"}
{"name":"spinGroup.coe_star","module":"Mathlib.LinearAlgebra.CliffordAlgebra.SpinGroup","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\nx : Subtype fun x => Membership.mem (spinGroup Q) x\n⊢ Eq (↑(Star.star x)) (Star.star ↑x)","decl":"@[simp, norm_cast]\ntheorem coe_star {x : spinGroup Q} : ↑(star x) = (star x : CliffordAlgebra Q) :=\n  rfl\n\n"}
{"name":"spinGroup.coe_star_mul_self","module":"Mathlib.LinearAlgebra.CliffordAlgebra.SpinGroup","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\nx : Subtype fun x => Membership.mem (spinGroup Q) x\n⊢ Eq (HMul.hMul (Star.star ↑x) ↑x) 1","decl":"theorem coe_star_mul_self (x : spinGroup Q) : (star x : CliffordAlgebra Q) * x = 1 :=\n  star_mul_self_of_mem x.prop\n\n"}
{"name":"spinGroup.coe_mul_star_self","module":"Mathlib.LinearAlgebra.CliffordAlgebra.SpinGroup","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\nx : Subtype fun x => Membership.mem (spinGroup Q) x\n⊢ Eq (HMul.hMul ↑x ↑(Star.star x)) 1","decl":"theorem coe_mul_star_self (x : spinGroup Q) : (x : CliffordAlgebra Q) * star x = 1 :=\n  mul_star_self_of_mem x.prop\n\n"}
{"name":"spinGroup.star_mul_self","module":"Mathlib.LinearAlgebra.CliffordAlgebra.SpinGroup","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\nx : Subtype fun x => Membership.mem (spinGroup Q) x\n⊢ Eq (HMul.hMul (Star.star x) x) 1","decl":"@[simp]\ntheorem star_mul_self (x : spinGroup Q) : star x * x = 1 :=\n  Subtype.ext <| coe_star_mul_self x\n\n"}
{"name":"spinGroup.mul_star_self","module":"Mathlib.LinearAlgebra.CliffordAlgebra.SpinGroup","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\nx : Subtype fun x => Membership.mem (spinGroup Q) x\n⊢ Eq (HMul.hMul x (Star.star x)) 1","decl":"@[simp]\ntheorem mul_star_self (x : spinGroup Q) : x * star x = 1 :=\n  Subtype.ext <| coe_mul_star_self x\n\n"}
{"name":"spinGroup.star_eq_inv","module":"Mathlib.LinearAlgebra.CliffordAlgebra.SpinGroup","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\nx : Subtype fun x => Membership.mem (spinGroup Q) x\n⊢ Eq (Star.star x) (Inv.inv x)","decl":"theorem star_eq_inv (x : spinGroup Q) : star x = x⁻¹ :=\n  rfl\n\n"}
{"name":"spinGroup.star_eq_inv'","module":"Mathlib.LinearAlgebra.CliffordAlgebra.SpinGroup","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\n⊢ Eq Star.star Inv.inv","decl":"theorem star_eq_inv' : (star : spinGroup Q → spinGroup Q) = Inv.inv :=\n  rfl\n\n"}
{"name":"spinGroup.val_inv_toUnits_apply","module":"Mathlib.LinearAlgebra.CliffordAlgebra.SpinGroup","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\nx : Subtype fun x => Membership.mem (spinGroup Q) x\n⊢ Eq ↑(Inv.inv (spinGroup.toUnits x)) ↑(Inv.inv x)","decl":"/-- The elements in `spinGroup Q` embed into (CliffordAlgebra Q)ˣ. -/\n@[simps]\ndef toUnits : spinGroup Q →* (CliffordAlgebra Q)ˣ where\n  toFun x := ⟨x, ↑x⁻¹, coe_mul_star_self x, coe_star_mul_self x⟩\n  map_one' := Units.ext rfl\n  map_mul' _x _y := Units.ext rfl\n\n"}
{"name":"spinGroup.val_toUnits_apply","module":"Mathlib.LinearAlgebra.CliffordAlgebra.SpinGroup","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\nx : Subtype fun x => Membership.mem (spinGroup Q) x\n⊢ Eq ↑(spinGroup.toUnits x) ↑x","decl":"/-- The elements in `spinGroup Q` embed into (CliffordAlgebra Q)ˣ. -/\n@[simps]\ndef toUnits : spinGroup Q →* (CliffordAlgebra Q)ˣ where\n  toFun x := ⟨x, ↑x⁻¹, coe_mul_star_self x, coe_star_mul_self x⟩\n  map_one' := Units.ext rfl\n  map_mul' _x _y := Units.ext rfl\n\n"}
{"name":"spinGroup.toUnits_injective","module":"Mathlib.LinearAlgebra.CliffordAlgebra.SpinGroup","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\n⊢ Function.Injective ⇑spinGroup.toUnits","decl":"theorem toUnits_injective : Function.Injective (toUnits : spinGroup Q → (CliffordAlgebra Q)ˣ) :=\n  fun _x _y h => Subtype.ext <| Units.ext_iff.mp h\n\n"}
