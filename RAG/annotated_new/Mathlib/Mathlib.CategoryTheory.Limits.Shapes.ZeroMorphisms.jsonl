{"name":"CategoryTheory.Limits.HasZeroMorphisms.zero_comp","module":"Mathlib.CategoryTheory.Limits.Shapes.ZeroMorphisms","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.Limits.HasZeroMorphisms C\nX Y Z : C\nf : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp 0 f) 0","decl":"/-- A category \"has zero morphisms\" if there is a designated \"zero morphism\" in each morphism space,\nand compositions of zero morphisms with anything give the zero morphism. -/\nclass HasZeroMorphisms where\n  /-- Every morphism space has zero -/\n  [zero : ‚àÄ X Y : C, Zero (X ‚ü∂ Y)]\n  /-- `f` composed with `0` is `0` -/\n  comp_zero : ‚àÄ {X Y : C} (f : X ‚ü∂ Y) (Z : C), f ‚â´ (0 : Y ‚ü∂ Z) = (0 : X ‚ü∂ Z) := by aesop_cat\n  /-- `0` composed with `f` is `0` -/\n  zero_comp : ‚àÄ (X : C) {Y Z : C} (f : Y ‚ü∂ Z), (0 : X ‚ü∂ Y) ‚â´ f = (0 : X ‚ü∂ Z) := by aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.HasZeroMorphisms.comp_zero","module":"Mathlib.CategoryTheory.Limits.Shapes.ZeroMorphisms","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\nZ : C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f 0) 0","decl":"/-- A category \"has zero morphisms\" if there is a designated \"zero morphism\" in each morphism space,\nand compositions of zero morphisms with anything give the zero morphism. -/\nclass HasZeroMorphisms where\n  /-- Every morphism space has zero -/\n  [zero : ‚àÄ X Y : C, Zero (X ‚ü∂ Y)]\n  /-- `f` composed with `0` is `0` -/\n  comp_zero : ‚àÄ {X Y : C} (f : X ‚ü∂ Y) (Z : C), f ‚â´ (0 : Y ‚ü∂ Z) = (0 : X ‚ü∂ Z) := by aesop_cat\n  /-- `0` composed with `f` is `0` -/\n  zero_comp : ‚àÄ (X : C) {Y Z : C} (f : Y ‚ü∂ Z), (0 : X ‚ü∂ Y) ‚â´ f = (0 : X ‚ü∂ Z) := by aesop_cat\n\n"}
{"name":"CategoryTheory.Limits.comp_zero","module":"Mathlib.CategoryTheory.Limits.Shapes.ZeroMorphisms","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\nZ : C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f 0) 0","decl":"@[simp]\ntheorem comp_zero [HasZeroMorphisms C] {X Y : C} {f : X ‚ü∂ Y} {Z : C} :\n    f ‚â´ (0 : Y ‚ü∂ Z) = (0 : X ‚ü∂ Z) :=\n  HasZeroMorphisms.comp_zero f Z\n\n"}
{"name":"CategoryTheory.Limits.zero_comp","module":"Mathlib.CategoryTheory.Limits.Shapes.ZeroMorphisms","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nX Y Z : C\nf : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp 0 f) 0","decl":"@[simp]\ntheorem zero_comp [HasZeroMorphisms C] {X : C} {Y Z : C} {f : Y ‚ü∂ Z} :\n    (0 : X ‚ü∂ Y) ‚â´ f = (0 : X ‚ü∂ Z) :=\n  HasZeroMorphisms.zero_comp X f\n\n"}
{"name":"CategoryTheory.Limits.HasZeroMorphisms.ext","module":"Mathlib.CategoryTheory.Limits.Shapes.ZeroMorphisms","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nI J : CategoryTheory.Limits.HasZeroMorphisms C\n‚ä¢ Eq I J","decl":"/-- If you're tempted to use this lemma \"in the wild\", you should probably\ncarefully consider whether you've made a mistake in allowing two\ninstances of `HasZeroMorphisms` to exist at all.\n\nSee, particularly, the note on `zeroMorphismsOfZeroObject` below.\n-/\ntheorem ext (I J : HasZeroMorphisms C) : I = J := by\n  apply ext_aux\n  intro X Y\n  have : (I.zero X Y).zero ‚â´ (J.zero Y Y).zero = (I.zero X Y).zero := by\n    apply I.zero_comp X (J.zero Y Y).zero\n  have that : (I.zero X Y).zero ‚â´ (J.zero Y Y).zero = (J.zero X Y).zero := by\n    apply J.comp_zero (I.zero X Y).zero Y\n  rw [‚Üê this, ‚Üê that]\n\n"}
{"name":"CategoryTheory.Limits.HasZeroMorphisms.instSubsingleton","module":"Mathlib.CategoryTheory.Limits.Shapes.ZeroMorphisms","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\n‚ä¢ Subsingleton (CategoryTheory.Limits.HasZeroMorphisms C)","decl":"instance : Subsingleton (HasZeroMorphisms C) :=\n  ‚ü®ext‚ü©\n\n"}
{"name":"CategoryTheory.Limits.op_zero","module":"Mathlib.CategoryTheory.Limits.Shapes.ZeroMorphisms","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\n‚ä¢ Eq (Quiver.Hom.op 0) 0","decl":"@[simp] lemma op_zero (X Y : C) : (0 : X ‚ü∂ Y).op = 0 := rfl\n\n"}
{"name":"CategoryTheory.Limits.unop_zero","module":"Mathlib.CategoryTheory.Limits.Shapes.ZeroMorphisms","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : Opposite C\n‚ä¢ Eq (Quiver.Hom.unop 0) 0","decl":"@[simp] lemma unop_zero (X Y : C·µí·µñ) : (0 : X ‚ü∂ Y).unop = 0 := rfl\n\n"}
{"name":"CategoryTheory.Limits.zero_of_comp_mono","module":"Mathlib.CategoryTheory.Limits.Shapes.ZeroMorphisms","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\ninst‚úù : CategoryTheory.Mono g\nh : Eq (CategoryTheory.CategoryStruct.comp f g) 0\n‚ä¢ Eq f 0","decl":"theorem zero_of_comp_mono {X Y Z : C} {f : X ‚ü∂ Y} (g : Y ‚ü∂ Z) [Mono g] (h : f ‚â´ g = 0) : f = 0 := by\n  rw [‚Üê zero_comp, cancel_mono] at h\n  exact h\n\n"}
{"name":"CategoryTheory.Limits.zero_of_epi_comp","module":"Mathlib.CategoryTheory.Limits.Shapes.ZeroMorphisms","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\ninst‚úù : CategoryTheory.Epi f\nh : Eq (CategoryTheory.CategoryStruct.comp f g) 0\n‚ä¢ Eq g 0","decl":"theorem zero_of_epi_comp {X Y Z : C} (f : X ‚ü∂ Y) {g : Y ‚ü∂ Z} [Epi f] (h : f ‚â´ g = 0) : g = 0 := by\n  rw [‚Üê comp_zero, cancel_epi] at h\n  exact h\n\n"}
{"name":"CategoryTheory.Limits.eq_zero_of_image_eq_zero","module":"Mathlib.CategoryTheory.Limits.Shapes.ZeroMorphisms","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Limits.HasImage f\nw : Eq (CategoryTheory.Limits.image.Œπ f) 0\n‚ä¢ Eq f 0","decl":"theorem eq_zero_of_image_eq_zero {X Y : C} {f : X ‚ü∂ Y} [HasImage f] (w : image.Œπ f = 0) :\n    f = 0 := by rw [‚Üê image.fac f, w, HasZeroMorphisms.comp_zero]\n\n"}
{"name":"CategoryTheory.Limits.nonzero_image_of_nonzero","module":"Mathlib.CategoryTheory.Limits.Shapes.ZeroMorphisms","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Limits.HasImage f\nw : Ne f 0\n‚ä¢ Ne (CategoryTheory.Limits.image.Œπ f) 0","decl":"theorem nonzero_image_of_nonzero {X Y : C} {f : X ‚ü∂ Y} [HasImage f] (w : f ‚â† 0) : image.Œπ f ‚â† 0 :=\n  fun h => w (eq_zero_of_image_eq_zero h)\n\n"}
{"name":"CategoryTheory.Limits.zero_app","module":"Mathlib.CategoryTheory.Limits.Shapes.ZeroMorphisms","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst‚úù¬π : CategoryTheory.Category.{v', u'} D\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms D\nF G : CategoryTheory.Functor C D\nj : C\n‚ä¢ Eq (CategoryTheory.NatTrans.app 0 j) 0","decl":"@[simp]\ntheorem zero_app (F G : C ‚•§ D) (j : C) : (0 : F ‚ü∂ G).app j = 0 := rfl\n\n"}
{"name":"CategoryTheory.Limits.IsZero.eq_zero_of_src","module":"Mathlib.CategoryTheory.Limits.Shapes.ZeroMorphisms","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\no : CategoryTheory.Limits.IsZero X\nf : Quiver.Hom X Y\n‚ä¢ Eq f 0","decl":"theorem eq_zero_of_src {X Y : C} (o : IsZero X) (f : X ‚ü∂ Y) : f = 0 :=\n  o.eq_of_src _ _\n\n"}
{"name":"CategoryTheory.Limits.IsZero.eq_zero_of_tgt","module":"Mathlib.CategoryTheory.Limits.Shapes.ZeroMorphisms","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\no : CategoryTheory.Limits.IsZero Y\nf : Quiver.Hom X Y\n‚ä¢ Eq f 0","decl":"theorem eq_zero_of_tgt {X Y : C} (o : IsZero Y) (f : X ‚ü∂ Y) : f = 0 :=\n  o.eq_of_tgt _ _\n\n"}
{"name":"CategoryTheory.Limits.IsZero.iff_id_eq_zero","module":"Mathlib.CategoryTheory.Limits.Shapes.ZeroMorphisms","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nX : C\n‚ä¢ Iff (CategoryTheory.Limits.IsZero X) (Eq (CategoryTheory.CategoryStruct.id X) 0)","decl":"theorem iff_id_eq_zero (X : C) : IsZero X ‚Üî ùüô X = 0 :=\n  ‚ü®fun h => h.eq_of_src _ _, fun h =>\n    ‚ü®fun Y => ‚ü®‚ü®‚ü®0‚ü©, fun f => by\n        rw [‚Üê id_comp f, ‚Üê id_comp (0 : X ‚ü∂ Y), h, zero_comp, zero_comp]; simp only‚ü©‚ü©,\n    fun Y => ‚ü®‚ü®‚ü®0‚ü©, fun f => by\n        rw [‚Üê comp_id f, ‚Üê comp_id (0 : Y ‚ü∂ X), h, comp_zero, comp_zero]; simp only ‚ü©‚ü©‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.Limits.IsZero.of_mono_zero","module":"Mathlib.CategoryTheory.Limits.Shapes.ZeroMorphisms","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\ninst‚úù : CategoryTheory.Mono 0\n‚ä¢ CategoryTheory.Limits.IsZero X","decl":"theorem of_mono_zero (X Y : C) [Mono (0 : X ‚ü∂ Y)] : IsZero X :=\n  (iff_id_eq_zero X).mpr ((cancel_mono (0 : X ‚ü∂ Y)).1 (by simp))\n\n"}
{"name":"CategoryTheory.Limits.IsZero.of_epi_zero","module":"Mathlib.CategoryTheory.Limits.Shapes.ZeroMorphisms","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\ninst‚úù : CategoryTheory.Epi 0\n‚ä¢ CategoryTheory.Limits.IsZero Y","decl":"theorem of_epi_zero (X Y : C) [Epi (0 : X ‚ü∂ Y)] : IsZero Y :=\n  (iff_id_eq_zero Y).mpr ((cancel_epi (0 : X ‚ü∂ Y)).1 (by simp))\n\n"}
{"name":"CategoryTheory.Limits.IsZero.of_mono_eq_zero","module":"Mathlib.CategoryTheory.Limits.Shapes.ZeroMorphisms","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Mono f\nh : Eq f 0\n‚ä¢ CategoryTheory.Limits.IsZero X","decl":"theorem of_mono_eq_zero {X Y : C} (f : X ‚ü∂ Y) [Mono f] (h : f = 0) : IsZero X := by\n  subst h\n  apply of_mono_zero X Y\n\n"}
{"name":"CategoryTheory.Limits.IsZero.of_epi_eq_zero","module":"Mathlib.CategoryTheory.Limits.Shapes.ZeroMorphisms","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Epi f\nh : Eq f 0\n‚ä¢ CategoryTheory.Limits.IsZero Y","decl":"theorem of_epi_eq_zero {X Y : C} (f : X ‚ü∂ Y) [Epi f] (h : f = 0) : IsZero Y := by\n  subst h\n  apply of_epi_zero X Y\n\n"}
{"name":"CategoryTheory.Limits.IsZero.iff_isSplitMono_eq_zero","module":"Mathlib.CategoryTheory.Limits.Shapes.ZeroMorphisms","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.IsSplitMono f\n‚ä¢ Iff (CategoryTheory.Limits.IsZero X) (Eq f 0)","decl":"theorem iff_isSplitMono_eq_zero {X Y : C} (f : X ‚ü∂ Y) [IsSplitMono f] : IsZero X ‚Üî f = 0 := by\n  rw [iff_id_eq_zero]\n  constructor\n  ¬∑ intro h\n    rw [‚Üê Category.id_comp f, h, zero_comp]\n  ¬∑ intro h\n    rw [‚Üê IsSplitMono.id f]\n    simp only [h, zero_comp]\n\n"}
{"name":"CategoryTheory.Limits.IsZero.iff_isSplitEpi_eq_zero","module":"Mathlib.CategoryTheory.Limits.Shapes.ZeroMorphisms","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.IsSplitEpi f\n‚ä¢ Iff (CategoryTheory.Limits.IsZero Y) (Eq f 0)","decl":"theorem iff_isSplitEpi_eq_zero {X Y : C} (f : X ‚ü∂ Y) [IsSplitEpi f] : IsZero Y ‚Üî f = 0 := by\n  rw [iff_id_eq_zero]\n  constructor\n  ¬∑ intro h\n    rw [‚Üê Category.comp_id f, h, comp_zero]\n  ¬∑ intro h\n    rw [‚Üê IsSplitEpi.id f]\n    simp [h]\n\n"}
{"name":"CategoryTheory.Limits.IsZero.of_mono","module":"Mathlib.CategoryTheory.Limits.Shapes.ZeroMorphisms","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Mono f\ni : CategoryTheory.Limits.IsZero Y\n‚ä¢ CategoryTheory.Limits.IsZero X","decl":"theorem of_mono {X Y : C} (f : X ‚ü∂ Y) [Mono f] (i : IsZero Y) : IsZero X := by\n  have hf := i.eq_zero_of_tgt f\n  subst hf\n  exact IsZero.of_mono_zero X Y\n\n"}
{"name":"CategoryTheory.Limits.IsZero.of_epi","module":"Mathlib.CategoryTheory.Limits.Shapes.ZeroMorphisms","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Epi f\ni : CategoryTheory.Limits.IsZero X\n‚ä¢ CategoryTheory.Limits.IsZero Y","decl":"theorem of_epi {X Y : C} (f : X ‚ü∂ Y) [Epi f] (i : IsZero X) : IsZero Y := by\n  have hf := i.eq_zero_of_src f\n  subst hf\n  exact IsZero.of_epi_zero X Y\n\n"}
{"name":"CategoryTheory.Limits.HasZeroObject.zeroIsoIsInitial_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.ZeroMorphisms","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroObject C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nX : C\nt : CategoryTheory.Limits.IsInitial X\n‚ä¢ Eq (CategoryTheory.Limits.HasZeroObject.zeroIsoIsInitial t).hom 0","decl":"@[simp]\ntheorem zeroIsoIsInitial_hom {X : C} (t : IsInitial X) : (zeroIsoIsInitial t).hom = 0 := by ext\n\n"}
{"name":"CategoryTheory.Limits.HasZeroObject.zeroIsoIsInitial_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.ZeroMorphisms","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroObject C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nX : C\nt : CategoryTheory.Limits.IsInitial X\n‚ä¢ Eq (CategoryTheory.Limits.HasZeroObject.zeroIsoIsInitial t).inv 0","decl":"@[simp]\ntheorem zeroIsoIsInitial_inv {X : C} (t : IsInitial X) : (zeroIsoIsInitial t).inv = 0 := by ext\n\n"}
{"name":"CategoryTheory.Limits.HasZeroObject.zeroIsoIsTerminal_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.ZeroMorphisms","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroObject C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nX : C\nt : CategoryTheory.Limits.IsTerminal X\n‚ä¢ Eq (CategoryTheory.Limits.HasZeroObject.zeroIsoIsTerminal t).hom 0","decl":"@[simp]\ntheorem zeroIsoIsTerminal_hom {X : C} (t : IsTerminal X) : (zeroIsoIsTerminal t).hom = 0 := by ext\n\n"}
{"name":"CategoryTheory.Limits.HasZeroObject.zeroIsoIsTerminal_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.ZeroMorphisms","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroObject C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nX : C\nt : CategoryTheory.Limits.IsTerminal X\n‚ä¢ Eq (CategoryTheory.Limits.HasZeroObject.zeroIsoIsTerminal t).inv 0","decl":"@[simp]\ntheorem zeroIsoIsTerminal_inv {X : C} (t : IsTerminal X) : (zeroIsoIsTerminal t).inv = 0 := by ext\n\n"}
{"name":"CategoryTheory.Limits.HasZeroObject.zeroIsoInitial_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.ZeroMorphisms","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroObject C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\ninst‚úù : CategoryTheory.Limits.HasInitial C\n‚ä¢ Eq CategoryTheory.Limits.HasZeroObject.zeroIsoInitial.hom 0","decl":"@[simp]\ntheorem zeroIsoInitial_hom [HasInitial C] : zeroIsoInitial.hom = (0 : 0 ‚ü∂ ‚ä•_ C) := by ext\n\n"}
{"name":"CategoryTheory.Limits.HasZeroObject.zeroIsoInitial_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.ZeroMorphisms","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroObject C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\ninst‚úù : CategoryTheory.Limits.HasInitial C\n‚ä¢ Eq CategoryTheory.Limits.HasZeroObject.zeroIsoInitial.inv 0","decl":"@[simp]\ntheorem zeroIsoInitial_inv [HasInitial C] : zeroIsoInitial.inv = (0 : ‚ä•_ C ‚ü∂ 0) := by ext\n\n"}
{"name":"CategoryTheory.Limits.HasZeroObject.zeroIsoTerminal_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.ZeroMorphisms","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroObject C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\ninst‚úù : CategoryTheory.Limits.HasTerminal C\n‚ä¢ Eq CategoryTheory.Limits.HasZeroObject.zeroIsoTerminal.hom 0","decl":"@[simp]\ntheorem zeroIsoTerminal_hom [HasTerminal C] : zeroIsoTerminal.hom = (0 : 0 ‚ü∂ ‚ä§_ C) := by ext\n\n"}
{"name":"CategoryTheory.Limits.HasZeroObject.zeroIsoTerminal_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.ZeroMorphisms","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroObject C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\ninst‚úù : CategoryTheory.Limits.HasTerminal C\n‚ä¢ Eq CategoryTheory.Limits.HasZeroObject.zeroIsoTerminal.inv 0","decl":"@[simp]\ntheorem zeroIsoTerminal_inv [HasTerminal C] : zeroIsoTerminal.inv = (0 : ‚ä§_ C ‚ü∂ 0) := by ext\n\n"}
{"name":"CategoryTheory.Limits.HasZeroObject.instFunctor","module":"Mathlib.CategoryTheory.Limits.Shapes.ZeroMorphisms","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroObject C\nB : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} B\n‚ä¢ CategoryTheory.Limits.HasZeroObject (CategoryTheory.Functor B C)","decl":"instance {B : Type*} [Category B] : HasZeroObject (B ‚•§ C) :=\n  (((CategoryTheory.Functor.const B).obj (0 : C)).isZero fun _ => isZero_zero _).hasZeroObject\n\n"}
{"name":"CategoryTheory.Limits.IsZero.map","module":"Mathlib.CategoryTheory.Limits.Shapes.ZeroMorphisms","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst‚úù¬≤ : CategoryTheory.Category.{v', u'} D\ninst‚úù¬π : CategoryTheory.Limits.HasZeroObject D\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms D\nF : CategoryTheory.Functor C D\nhF : CategoryTheory.Limits.IsZero F\nX Y : C\nf : Quiver.Hom X Y\n‚ä¢ Eq (F.map f) 0","decl":"@[simp]\ntheorem IsZero.map [HasZeroObject D] [HasZeroMorphisms D] {F : C ‚•§ D} (hF : IsZero F) {X Y : C}\n    (f : X ‚ü∂ Y) : F.map f = 0 :=\n  (hF.obj _).eq_of_src _ _\n\n"}
{"name":"CategoryTheory.Functor.zero_obj","module":"Mathlib.CategoryTheory.Limits.Shapes.ZeroMorphisms","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst‚úù¬π : CategoryTheory.Category.{v', u'} D\ninst‚úù : CategoryTheory.Limits.HasZeroObject D\nX : C\n‚ä¢ CategoryTheory.Limits.IsZero ((CategoryTheory.Functor.toPrefunctor 0).obj X)","decl":"@[simp]\ntheorem _root_.CategoryTheory.Functor.zero_obj [HasZeroObject D] (X : C) :\n    IsZero ((0 : C ‚•§ D).obj X) :=\n  (isZero_zero _).obj _\n\n"}
{"name":"CategoryTheory.zero_map","module":"Mathlib.CategoryTheory.Limits.Shapes.ZeroMorphisms","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst‚úù¬≤ : CategoryTheory.Category.{v', u'} D\ninst‚úù¬π : CategoryTheory.Limits.HasZeroObject D\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms D\nX Y : C\nf : Quiver.Hom X Y\n‚ä¢ Eq ((CategoryTheory.Functor.toPrefunctor 0).map f) 0","decl":"@[simp]\ntheorem _root_.CategoryTheory.zero_map [HasZeroObject D] [HasZeroMorphisms D] {X Y : C}\n    (f : X ‚ü∂ Y) : (0 : C ‚•§ D).map f = 0 :=\n  (isZero_zero _).map _\n\n"}
{"name":"CategoryTheory.Limits.id_zero","module":"Mathlib.CategoryTheory.Limits.Shapes.ZeroMorphisms","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroObject C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.id 0) 0","decl":"@[simp]\ntheorem id_zero : ùüô (0 : C) = (0 : (0 : C) ‚ü∂ 0) := by apply HasZeroObject.from_zero_ext\n\n-- This can't be a `simp` lemma because the left hand side would be a metavariable.\n"}
{"name":"CategoryTheory.Limits.zero_of_to_zero","module":"Mathlib.CategoryTheory.Limits.Shapes.ZeroMorphisms","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroObject C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nX : C\nf : Quiver.Hom X 0\n‚ä¢ Eq f 0","decl":"/-- An arrow ending in the zero object is zero -/\ntheorem zero_of_to_zero {X : C} (f : X ‚ü∂ 0) : f = 0 := by ext\n\n"}
{"name":"CategoryTheory.Limits.zero_of_target_iso_zero","module":"Mathlib.CategoryTheory.Limits.Shapes.ZeroMorphisms","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroObject C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\ni : CategoryTheory.Iso Y 0\n‚ä¢ Eq f 0","decl":"theorem zero_of_target_iso_zero {X Y : C} (f : X ‚ü∂ Y) (i : Y ‚âÖ 0) : f = 0 := by\n  have h : f = f ‚â´ i.hom ‚â´ ùüô 0 ‚â´ i.inv := by simp only [Iso.hom_inv_id, id_comp, comp_id]\n  simpa using h\n\n"}
{"name":"CategoryTheory.Limits.zero_of_from_zero","module":"Mathlib.CategoryTheory.Limits.Shapes.ZeroMorphisms","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroObject C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nX : C\nf : Quiver.Hom 0 X\n‚ä¢ Eq f 0","decl":"/-- An arrow starting at the zero object is zero -/\ntheorem zero_of_from_zero {X : C} (f : 0 ‚ü∂ X) : f = 0 := by ext\n\n"}
{"name":"CategoryTheory.Limits.zero_of_source_iso_zero","module":"Mathlib.CategoryTheory.Limits.Shapes.ZeroMorphisms","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroObject C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\ni : CategoryTheory.Iso X 0\n‚ä¢ Eq f 0","decl":"theorem zero_of_source_iso_zero {X Y : C} (f : X ‚ü∂ Y) (i : X ‚âÖ 0) : f = 0 := by\n  have h : f = i.hom ‚â´ ùüô 0 ‚â´ i.inv ‚â´ f := by simp only [Iso.hom_inv_id_assoc, id_comp, comp_id]\n  simpa using h\n\n"}
{"name":"CategoryTheory.Limits.zero_of_source_iso_zero'","module":"Mathlib.CategoryTheory.Limits.Shapes.ZeroMorphisms","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroObject C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\ni : CategoryTheory.IsIsomorphic X 0\n‚ä¢ Eq f 0","decl":"theorem zero_of_source_iso_zero' {X Y : C} (f : X ‚ü∂ Y) (i : IsIsomorphic X 0) : f = 0 :=\n  zero_of_source_iso_zero f (Nonempty.some i)\n\n"}
{"name":"CategoryTheory.Limits.zero_of_target_iso_zero'","module":"Mathlib.CategoryTheory.Limits.Shapes.ZeroMorphisms","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroObject C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\ni : CategoryTheory.IsIsomorphic Y 0\n‚ä¢ Eq f 0","decl":"theorem zero_of_target_iso_zero' {X Y : C} (f : X ‚ü∂ Y) (i : IsIsomorphic Y 0) : f = 0 :=\n  zero_of_target_iso_zero f (Nonempty.some i)\n\n"}
{"name":"CategoryTheory.Limits.mono_of_source_iso_zero","module":"Mathlib.CategoryTheory.Limits.Shapes.ZeroMorphisms","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroObject C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\ni : CategoryTheory.Iso X 0\n‚ä¢ CategoryTheory.Mono f","decl":"theorem mono_of_source_iso_zero {X Y : C} (f : X ‚ü∂ Y) (i : X ‚âÖ 0) : Mono f :=\n  ‚ü®fun {Z} g h _ => by rw [zero_of_target_iso_zero g i, zero_of_target_iso_zero h i]‚ü©\n\n"}
{"name":"CategoryTheory.Limits.epi_of_target_iso_zero","module":"Mathlib.CategoryTheory.Limits.Shapes.ZeroMorphisms","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroObject C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\ni : CategoryTheory.Iso Y 0\n‚ä¢ CategoryTheory.Epi f","decl":"theorem epi_of_target_iso_zero {X Y : C} (f : X ‚ü∂ Y) (i : Y ‚âÖ 0) : Epi f :=\n  ‚ü®fun {Z} g h _ => by rw [zero_of_source_iso_zero g i, zero_of_source_iso_zero h i]‚ü©\n\n"}
{"name":"CategoryTheory.Limits.idZeroEquivIsoZero_apply_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.ZeroMorphisms","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroObject C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nX : C\nh : Eq (CategoryTheory.CategoryStruct.id X) 0\n‚ä¢ Eq ((CategoryTheory.Limits.idZeroEquivIsoZero X) h).hom 0","decl":"@[simp]\ntheorem idZeroEquivIsoZero_apply_hom (X : C) (h : ùüô X = 0) : ((idZeroEquivIsoZero X) h).hom = 0 :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.idZeroEquivIsoZero_apply_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.ZeroMorphisms","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroObject C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nX : C\nh : Eq (CategoryTheory.CategoryStruct.id X) 0\n‚ä¢ Eq ((CategoryTheory.Limits.idZeroEquivIsoZero X) h).inv 0","decl":"@[simp]\ntheorem idZeroEquivIsoZero_apply_inv (X : C) (h : ùüô X = 0) : ((idZeroEquivIsoZero X) h).inv = 0 :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.isoZeroOfMonoZero_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.ZeroMorphisms","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroObject C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nx‚úù : CategoryTheory.Mono 0\n‚ä¢ Eq (CategoryTheory.Limits.isoZeroOfMonoZero x‚úù).hom 0","decl":"/-- If `0 : X ‚ü∂ Y` is a monomorphism, then `X ‚âÖ 0`. -/\n@[simps]\ndef isoZeroOfMonoZero {X Y : C} (_ : Mono (0 : X ‚ü∂ Y)) : X ‚âÖ 0 where\n  hom := 0\n  inv := 0\n  hom_inv_id := (cancel_mono (0 : X ‚ü∂ Y)).mp (by simp)\n\n"}
{"name":"CategoryTheory.Limits.isoZeroOfMonoZero_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.ZeroMorphisms","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroObject C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nx‚úù : CategoryTheory.Mono 0\n‚ä¢ Eq (CategoryTheory.Limits.isoZeroOfMonoZero x‚úù).inv 0","decl":"/-- If `0 : X ‚ü∂ Y` is a monomorphism, then `X ‚âÖ 0`. -/\n@[simps]\ndef isoZeroOfMonoZero {X Y : C} (_ : Mono (0 : X ‚ü∂ Y)) : X ‚âÖ 0 where\n  hom := 0\n  inv := 0\n  hom_inv_id := (cancel_mono (0 : X ‚ü∂ Y)).mp (by simp)\n\n"}
{"name":"CategoryTheory.Limits.isoZeroOfEpiZero_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.ZeroMorphisms","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroObject C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nx‚úù : CategoryTheory.Epi 0\n‚ä¢ Eq (CategoryTheory.Limits.isoZeroOfEpiZero x‚úù).inv 0","decl":"/-- If `0 : X ‚ü∂ Y` is an epimorphism, then `Y ‚âÖ 0`. -/\n@[simps]\ndef isoZeroOfEpiZero {X Y : C} (_ : Epi (0 : X ‚ü∂ Y)) : Y ‚âÖ 0 where\n  hom := 0\n  inv := 0\n  hom_inv_id := (cancel_epi (0 : X ‚ü∂ Y)).mp (by simp)\n\n"}
{"name":"CategoryTheory.Limits.isoZeroOfEpiZero_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.ZeroMorphisms","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroObject C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nx‚úù : CategoryTheory.Epi 0\n‚ä¢ Eq (CategoryTheory.Limits.isoZeroOfEpiZero x‚úù).hom 0","decl":"/-- If `0 : X ‚ü∂ Y` is an epimorphism, then `Y ‚âÖ 0`. -/\n@[simps]\ndef isoZeroOfEpiZero {X Y : C} (_ : Epi (0 : X ‚ü∂ Y)) : Y ‚âÖ 0 where\n  hom := 0\n  inv := 0\n  hom_inv_id := (cancel_epi (0 : X ‚ü∂ Y)).mp (by simp)\n\n"}
{"name":"CategoryTheory.Limits.isIso_of_source_target_iso_zero","module":"Mathlib.CategoryTheory.Limits.Shapes.ZeroMorphisms","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\ninst‚úù : CategoryTheory.Limits.HasZeroObject C\nX Y : C\nf : Quiver.Hom X Y\ni : CategoryTheory.Iso X 0\nj : CategoryTheory.Iso Y 0\n‚ä¢ CategoryTheory.IsIso f","decl":"theorem isIso_of_source_target_iso_zero {X Y : C} (f : X ‚ü∂ Y) (i : X ‚âÖ 0) (j : Y ‚âÖ 0) :\n    IsIso f := by\n  rw [zero_of_source_iso_zero f i]\n  exact (isIsoZeroEquivIsoZero _ _).invFun ‚ü®i, j‚ü©\n\n"}
{"name":"CategoryTheory.Limits.hasZeroObject_of_hasInitial_object","module":"Mathlib.CategoryTheory.Limits.Shapes.ZeroMorphisms","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\ninst‚úù : CategoryTheory.Limits.HasInitial C\n‚ä¢ CategoryTheory.Limits.HasZeroObject C","decl":"/-- If there are zero morphisms, any initial object is a zero object. -/\ntheorem hasZeroObject_of_hasInitial_object [HasZeroMorphisms C] [HasInitial C] :\n    HasZeroObject C := by\n  refine ‚ü®‚ü®‚ä•_ C, fun X => ‚ü®‚ü®‚ü®0‚ü©, by aesop_cat‚ü©‚ü©, fun X => ‚ü®‚ü®‚ü®0‚ü©, fun f => ?_‚ü©‚ü©‚ü©‚ü©\n  calc\n    f = f ‚â´ ùüô _ := (Category.comp_id _).symm\n    _ = f ‚â´ 0 := by congr!; subsingleton\n    _ = 0 := HasZeroMorphisms.comp_zero _ _\n\n"}
{"name":"CategoryTheory.Limits.hasZeroObject_of_hasTerminal_object","module":"Mathlib.CategoryTheory.Limits.Shapes.ZeroMorphisms","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\ninst‚úù : CategoryTheory.Limits.HasTerminal C\n‚ä¢ CategoryTheory.Limits.HasZeroObject C","decl":"/-- If there are zero morphisms, any terminal object is a zero object. -/\ntheorem hasZeroObject_of_hasTerminal_object [HasZeroMorphisms C] [HasTerminal C] :\n    HasZeroObject C := by\n  refine ‚ü®‚ü®‚ä§_ C, fun X => ‚ü®‚ü®‚ü®0‚ü©, fun f => ?_‚ü©‚ü©, fun X => ‚ü®‚ü®‚ü®0‚ü©, by aesop_cat‚ü©‚ü©‚ü©‚ü©\n  calc\n    f = ùüô _ ‚â´ f := (Category.id_comp _).symm\n    _ = 0 ‚â´ f := by congr!; subsingleton\n    _ = 0 := zero_comp\n\n"}
{"name":"CategoryTheory.Limits.image_Œπ_comp_eq_zero","module":"Mathlib.CategoryTheory.Limits.Shapes.ZeroMorphisms","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\ninst‚úù¬π : CategoryTheory.Limits.HasImage f\ninst‚úù : CategoryTheory.Epi (CategoryTheory.Limits.factorThruImage f)\nh : Eq (CategoryTheory.CategoryStruct.comp f g) 0\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.image.Œπ f) g) 0","decl":"theorem image_Œπ_comp_eq_zero {X Y Z : C} {f : X ‚ü∂ Y} {g : Y ‚ü∂ Z} [HasImage f]\n    [Epi (factorThruImage f)] (h : f ‚â´ g = 0) : image.Œπ f ‚â´ g = 0 :=\n  zero_of_epi_comp (factorThruImage f) <| by simp [h]\n\n"}
{"name":"CategoryTheory.Limits.comp_factorThruImage_eq_zero","module":"Mathlib.CategoryTheory.Limits.Shapes.ZeroMorphisms","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\ninst‚úù : CategoryTheory.Limits.HasImage g\nh : Eq (CategoryTheory.CategoryStruct.comp f g) 0\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.Limits.factorThruImage g)) 0","decl":"theorem comp_factorThruImage_eq_zero {X Y Z : C} {f : X ‚ü∂ Y} {g : Y ‚ü∂ Z} [HasImage g]\n    (h : f ‚â´ g = 0) : f ‚â´ factorThruImage g = 0 :=\n  zero_of_comp_mono (image.Œπ g) <| by simp [h]\n\n"}
{"name":"CategoryTheory.Limits.monoFactorisationZero_m","module":"Mathlib.CategoryTheory.Limits.Shapes.ZeroMorphisms","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\ninst‚úù : CategoryTheory.Limits.HasZeroObject C\nX Y : C\n‚ä¢ Eq (CategoryTheory.Limits.monoFactorisationZero X Y).m 0","decl":"/-- The zero morphism has a `MonoFactorisation` through the zero object.\n-/\n@[simps]\ndef monoFactorisationZero (X Y : C) : MonoFactorisation (0 : X ‚ü∂ Y) where\n  I := 0\n  m := 0\n  e := 0\n\n"}
{"name":"CategoryTheory.Limits.monoFactorisationZero_I","module":"Mathlib.CategoryTheory.Limits.Shapes.ZeroMorphisms","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\ninst‚úù : CategoryTheory.Limits.HasZeroObject C\nX Y : C\n‚ä¢ Eq (CategoryTheory.Limits.monoFactorisationZero X Y).I 0","decl":"/-- The zero morphism has a `MonoFactorisation` through the zero object.\n-/\n@[simps]\ndef monoFactorisationZero (X Y : C) : MonoFactorisation (0 : X ‚ü∂ Y) where\n  I := 0\n  m := 0\n  e := 0\n\n"}
{"name":"CategoryTheory.Limits.monoFactorisationZero_e","module":"Mathlib.CategoryTheory.Limits.Shapes.ZeroMorphisms","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\ninst‚úù : CategoryTheory.Limits.HasZeroObject C\nX Y : C\n‚ä¢ Eq (CategoryTheory.Limits.monoFactorisationZero X Y).e 0","decl":"/-- The zero morphism has a `MonoFactorisation` through the zero object.\n-/\n@[simps]\ndef monoFactorisationZero (X Y : C) : MonoFactorisation (0 : X ‚ü∂ Y) where\n  I := 0\n  m := 0\n  e := 0\n\n"}
{"name":"CategoryTheory.Limits.hasImage_zero","module":"Mathlib.CategoryTheory.Limits.Shapes.ZeroMorphisms","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\ninst‚úù : CategoryTheory.Limits.HasZeroObject C\nX Y : C\n‚ä¢ CategoryTheory.Limits.HasImage 0","decl":"instance hasImage_zero {X Y : C} : HasImage (0 : X ‚ü∂ Y) :=\n  HasImage.mk <| imageFactorisationZero _ _\n\n"}
{"name":"CategoryTheory.Limits.image.Œπ_zero","module":"Mathlib.CategoryTheory.Limits.Shapes.ZeroMorphisms","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroObject C\nX Y : C\ninst‚úù : CategoryTheory.Limits.HasImage 0\n‚ä¢ Eq (CategoryTheory.Limits.image.Œπ 0) 0","decl":"@[simp]\ntheorem image.Œπ_zero {X Y : C} [HasImage (0 : X ‚ü∂ Y)] : image.Œπ (0 : X ‚ü∂ Y) = 0 := by\n  rw [‚Üê image.lift_fac (monoFactorisationZero X Y)]\n  simp\n\n"}
{"name":"CategoryTheory.Limits.image.Œπ_zero'","module":"Mathlib.CategoryTheory.Limits.Shapes.ZeroMorphisms","initialProofState":"C : Type u\ninst‚úù‚Å¥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroMorphisms C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroObject C\ninst‚úù¬π : CategoryTheory.Limits.HasEqualizers C\nX Y : C\nf : Quiver.Hom X Y\nh : Eq f 0\ninst‚úù : CategoryTheory.Limits.HasImage f\n‚ä¢ Eq (CategoryTheory.Limits.image.Œπ f) 0","decl":"/-- If we know `f = 0`,\nit requires a little work to conclude `image.Œπ f = 0`,\nbecause `f = g` only implies `image f ‚âÖ image g`.\n-/\n@[simp]\ntheorem image.Œπ_zero' [HasEqualizers C] {X Y : C} {f : X ‚ü∂ Y} (h : f = 0) [HasImage f] :\n    image.Œπ f = 0 := by\n  rw [image.eq_fac h]\n  simp\n\n"}
{"name":"CategoryTheory.Limits.isSplitMono_sigma_Œπ","module":"Mathlib.CategoryTheory.Limits.Shapes.ZeroMorphisms","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nŒ≤ : Type u'\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nf : Œ≤ ‚Üí C\ninst‚úù : CategoryTheory.Limits.HasColimit (CategoryTheory.Discrete.functor f)\nb : Œ≤\n‚ä¢ CategoryTheory.IsSplitMono (CategoryTheory.Limits.Sigma.Œπ f b)","decl":"/-- In the presence of zero morphisms, coprojections into a coproduct are (split) monomorphisms. -/\ninstance isSplitMono_sigma_Œπ {Œ≤ : Type u'} [HasZeroMorphisms C] (f : Œ≤ ‚Üí C)\n    [HasColimit (Discrete.functor f)] (b : Œ≤) : IsSplitMono (Sigma.Œπ f b) := by\n  classical exact IsSplitMono.mk' { retraction := Sigma.desc <| Pi.single b (ùüô _) }\n\n"}
{"name":"CategoryTheory.Limits.isSplitEpi_pi_œÄ","module":"Mathlib.CategoryTheory.Limits.Shapes.ZeroMorphisms","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nŒ≤ : Type u'\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nf : Œ≤ ‚Üí C\ninst‚úù : CategoryTheory.Limits.HasLimit (CategoryTheory.Discrete.functor f)\nb : Œ≤\n‚ä¢ CategoryTheory.IsSplitEpi (CategoryTheory.Limits.Pi.œÄ f b)","decl":"/-- In the presence of zero morphisms, projections into a product are (split) epimorphisms. -/\ninstance isSplitEpi_pi_œÄ {Œ≤ : Type u'} [HasZeroMorphisms C] (f : Œ≤ ‚Üí C)\n    [HasLimit (Discrete.functor f)] (b : Œ≤) : IsSplitEpi (Pi.œÄ f b) := by\n  classical exact IsSplitEpi.mk' { section_ := Pi.lift <| Pi.single b (ùüô _) }\n\n"}
{"name":"CategoryTheory.Limits.isSplitMono_coprod_inl","module":"Mathlib.CategoryTheory.Limits.Shapes.ZeroMorphisms","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\ninst‚úù : CategoryTheory.Limits.HasColimit (CategoryTheory.Limits.pair X Y)\n‚ä¢ CategoryTheory.IsSplitMono CategoryTheory.Limits.coprod.inl","decl":"/-- In the presence of zero morphisms, coprojections into a coproduct are (split) monomorphisms. -/\ninstance isSplitMono_coprod_inl [HasZeroMorphisms C] {X Y : C} [HasColimit (pair X Y)] :\n    IsSplitMono (coprod.inl : X ‚ü∂ X ‚®ø Y) :=\n  IsSplitMono.mk' { retraction := coprod.desc (ùüô X) 0 }\n\n"}
{"name":"CategoryTheory.Limits.isSplitMono_coprod_inr","module":"Mathlib.CategoryTheory.Limits.Shapes.ZeroMorphisms","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\ninst‚úù : CategoryTheory.Limits.HasColimit (CategoryTheory.Limits.pair X Y)\n‚ä¢ CategoryTheory.IsSplitMono CategoryTheory.Limits.coprod.inr","decl":"/-- In the presence of zero morphisms, coprojections into a coproduct are (split) monomorphisms. -/\ninstance isSplitMono_coprod_inr [HasZeroMorphisms C] {X Y : C} [HasColimit (pair X Y)] :\n    IsSplitMono (coprod.inr : Y ‚ü∂ X ‚®ø Y) :=\n  IsSplitMono.mk' { retraction := coprod.desc 0 (ùüô Y) }\n\n"}
{"name":"CategoryTheory.Limits.isSplitEpi_prod_fst","module":"Mathlib.CategoryTheory.Limits.Shapes.ZeroMorphisms","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\ninst‚úù : CategoryTheory.Limits.HasLimit (CategoryTheory.Limits.pair X Y)\n‚ä¢ CategoryTheory.IsSplitEpi CategoryTheory.Limits.prod.fst","decl":"/-- In the presence of zero morphisms, projections into a product are (split) epimorphisms. -/\ninstance isSplitEpi_prod_fst [HasZeroMorphisms C] {X Y : C} [HasLimit (pair X Y)] :\n    IsSplitEpi (prod.fst : X ‚®Ø Y ‚ü∂ X) :=\n  IsSplitEpi.mk' { section_ := prod.lift (ùüô X) 0 }\n\n"}
{"name":"CategoryTheory.Limits.isSplitEpi_prod_snd","module":"Mathlib.CategoryTheory.Limits.Shapes.ZeroMorphisms","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\ninst‚úù : CategoryTheory.Limits.HasLimit (CategoryTheory.Limits.pair X Y)\n‚ä¢ CategoryTheory.IsSplitEpi CategoryTheory.Limits.prod.snd","decl":"/-- In the presence of zero morphisms, projections into a product are (split) epimorphisms. -/\ninstance isSplitEpi_prod_snd [HasZeroMorphisms C] {X Y : C} [HasLimit (pair X Y)] :\n    IsSplitEpi (prod.snd : X ‚®Ø Y ‚ü∂ Y) :=\n  IsSplitEpi.mk' { section_ := prod.lift 0 (ùüô Y) }\n\n\n"}
{"name":"CategoryTheory.Limits.IsLimit.isZero_pt","module":"Mathlib.CategoryTheory.Limits.Shapes.ZeroMorphisms","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst‚úù¬≤ : CategoryTheory.Category.{v', u'} D\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\ninst‚úù : CategoryTheory.Limits.HasZeroObject C\nF : CategoryTheory.Functor D C\nc : CategoryTheory.Limits.Cone F\nhc : CategoryTheory.Limits.IsLimit c\nhF : CategoryTheory.Limits.IsZero F\n‚ä¢ CategoryTheory.Limits.IsZero c.pt","decl":"lemma IsLimit.isZero_pt {c : Cone F} (hc : IsLimit c) (hF : IsZero F) : IsZero c.pt :=\n  (isZero_zero C).of_iso (IsLimit.conePointUniqueUpToIso hc\n    (IsLimit.ofIsZero (Cone.mk 0 0) hF (isZero_zero C)))\n\n"}
{"name":"CategoryTheory.Limits.IsColimit.isZero_pt","module":"Mathlib.CategoryTheory.Limits.Shapes.ZeroMorphisms","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst‚úù¬≤ : CategoryTheory.Category.{v', u'} D\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\ninst‚úù : CategoryTheory.Limits.HasZeroObject C\nF : CategoryTheory.Functor D C\nc : CategoryTheory.Limits.Cocone F\nhc : CategoryTheory.Limits.IsColimit c\nhF : CategoryTheory.Limits.IsZero F\n‚ä¢ CategoryTheory.Limits.IsZero c.pt","decl":"lemma IsColimit.isZero_pt {c : Cocone F} (hc : IsColimit c) (hF : IsZero F) : IsZero c.pt :=\n  (isZero_zero C).of_iso (IsColimit.coconePointUniqueUpToIso hc\n    (IsColimit.ofIsZero (Cocone.mk 0 0) hF (isZero_zero C)))\n\n"}
{"name":"CategoryTheory.Limits.IsTerminal.isZero","module":"Mathlib.CategoryTheory.Limits.Shapes.ZeroMorphisms","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nX : C\nhX : CategoryTheory.Limits.IsTerminal X\n‚ä¢ CategoryTheory.Limits.IsZero X","decl":"lemma IsTerminal.isZero {X : C} (hX : IsTerminal X) : IsZero X := by\n  rw [IsZero.iff_id_eq_zero]\n  apply hX.hom_ext\n\n"}
{"name":"CategoryTheory.Limits.IsInitial.isZero","module":"Mathlib.CategoryTheory.Limits.Shapes.ZeroMorphisms","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nX : C\nhX : CategoryTheory.Limits.IsInitial X\n‚ä¢ CategoryTheory.Limits.IsZero X","decl":"lemma IsInitial.isZero {X : C} (hX : IsInitial X) : IsZero X := by\n  rw [IsZero.iff_id_eq_zero]\n  apply hX.hom_ext\n\n"}
