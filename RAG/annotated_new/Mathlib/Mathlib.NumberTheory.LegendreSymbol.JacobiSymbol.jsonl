{"name":"jacobiSym.zero_right","module":"Mathlib.NumberTheory.LegendreSymbol.JacobiSymbol","initialProofState":"a : Int\n⊢ Eq (jacobiSym a 0) 1","decl":"/-- The symbol `J(a | 0)` has the value `1`. -/\n@[simp]\ntheorem zero_right (a : ℤ) : J(a | 0) = 1 := by\n  simp only [jacobiSym, primeFactorsList_zero, List.prod_nil, List.pmap]\n\n"}
{"name":"jacobiSym.one_right","module":"Mathlib.NumberTheory.LegendreSymbol.JacobiSymbol","initialProofState":"a : Int\n⊢ Eq (jacobiSym a 1) 1","decl":"/-- The symbol `J(a | 1)` has the value `1`. -/\n@[simp]\ntheorem one_right (a : ℤ) : J(a | 1) = 1 := by\n  simp only [jacobiSym, primeFactorsList_one, List.prod_nil, List.pmap]\n\n"}
{"name":"jacobiSym.legendreSym.to_jacobiSym","module":"Mathlib.NumberTheory.LegendreSymbol.JacobiSymbol","initialProofState":"p : Nat\nfp : Fact (Nat.Prime p)\na : Int\n⊢ Eq (legendreSym p a) (jacobiSym a p)","decl":"/-- The Legendre symbol `legendreSym p a` with an integer `a` and a prime number `p`\nis the same as the Jacobi symbol `J(a | p)`. -/\ntheorem legendreSym.to_jacobiSym (p : ℕ) [fp : Fact p.Prime] (a : ℤ) :\n    legendreSym p a = J(a | p) := by\n  simp only [jacobiSym, primeFactorsList_prime fp.1, List.prod_cons, List.prod_nil, mul_one,\n    List.pmap]\n\n"}
{"name":"jacobiSym.mul_right'","module":"Mathlib.NumberTheory.LegendreSymbol.JacobiSymbol","initialProofState":"a : Int\nb₁ b₂ : Nat\nhb₁ : Ne b₁ 0\nhb₂ : Ne b₂ 0\n⊢ Eq (jacobiSym a (HMul.hMul b₁ b₂)) (HMul.hMul (jacobiSym a b₁) (jacobiSym a b₂))","decl":"/-- The Jacobi symbol is multiplicative in its second argument. -/\ntheorem mul_right' (a : ℤ) {b₁ b₂ : ℕ} (hb₁ : b₁ ≠ 0) (hb₂ : b₂ ≠ 0) :\n    J(a | b₁ * b₂) = J(a | b₁) * J(a | b₂) := by\n  rw [jacobiSym, ((perm_primeFactorsList_mul hb₁ hb₂).pmap _).prod_eq, List.pmap_append,\n    List.prod_append]\n  case h => exact fun p hp =>\n    (List.mem_append.mp hp).elim prime_of_mem_primeFactorsList prime_of_mem_primeFactorsList\n  case _ => rfl\n\n"}
{"name":"jacobiSym.mul_right","module":"Mathlib.NumberTheory.LegendreSymbol.JacobiSymbol","initialProofState":"a : Int\nb₁ b₂ : Nat\ninst✝¹ : NeZero b₁\ninst✝ : NeZero b₂\n⊢ Eq (jacobiSym a (HMul.hMul b₁ b₂)) (HMul.hMul (jacobiSym a b₁) (jacobiSym a b₂))","decl":"/-- The Jacobi symbol is multiplicative in its second argument. -/\ntheorem mul_right (a : ℤ) (b₁ b₂ : ℕ) [NeZero b₁] [NeZero b₂] :\n    J(a | b₁ * b₂) = J(a | b₁) * J(a | b₂) :=\n  mul_right' a (NeZero.ne b₁) (NeZero.ne b₂)\n\n"}
{"name":"jacobiSym.trichotomy","module":"Mathlib.NumberTheory.LegendreSymbol.JacobiSymbol","initialProofState":"a : Int\nb : Nat\n⊢ Or (Eq (jacobiSym a b) 0) (Or (Eq (jacobiSym a b) 1) (Eq (jacobiSym a b) (-1)))","decl":"/-- The Jacobi symbol takes only the values `0`, `1` and `-1`. -/\ntheorem trichotomy (a : ℤ) (b : ℕ) : J(a | b) = 0 ∨ J(a | b) = 1 ∨ J(a | b) = -1 :=\n  ((@SignType.castHom ℤ _ _).toMonoidHom.mrange.copy {0, 1, -1} <| by\n    rw [Set.pair_comm]\n    exact (SignType.range_eq SignType.castHom).symm).list_prod_mem\n      (by\n        intro _ ha'\n        rcases List.mem_pmap.mp ha' with ⟨p, hp, rfl⟩\n        haveI : Fact p.Prime := ⟨prime_of_mem_primeFactorsList hp⟩\n        exact quadraticChar_isQuadratic (ZMod p) a)\n\n"}
{"name":"jacobiSym.one_left","module":"Mathlib.NumberTheory.LegendreSymbol.JacobiSymbol","initialProofState":"b : Nat\n⊢ Eq (jacobiSym 1 b) 1","decl":"/-- The symbol `J(1 | b)` has the value `1`. -/\n@[simp]\ntheorem one_left (b : ℕ) : J(1 | b) = 1 :=\n  List.prod_eq_one fun z hz => by\n    let ⟨p, hp, he⟩ := List.mem_pmap.1 hz\n    -- Porting note: The line 150 was added because Lean does not synthesize the instance\n    -- `[Fact (Nat.Prime p)]` automatically (it is needed for `legendreSym.at_one`)\n    letI : Fact p.Prime := ⟨prime_of_mem_primeFactorsList hp⟩\n    rw [← he, legendreSym.at_one]\n\n"}
{"name":"jacobiSym.mul_left","module":"Mathlib.NumberTheory.LegendreSymbol.JacobiSymbol","initialProofState":"a₁ a₂ : Int\nb : Nat\n⊢ Eq (jacobiSym (HMul.hMul a₁ a₂) b) (HMul.hMul (jacobiSym a₁ b) (jacobiSym a₂ b))","decl":"/-- The Jacobi symbol is multiplicative in its first argument. -/\ntheorem mul_left (a₁ a₂ : ℤ) (b : ℕ) : J(a₁ * a₂ | b) = J(a₁ | b) * J(a₂ | b) := by\n  simp_rw [jacobiSym, List.pmap_eq_map_attach, legendreSym.mul _ _ _]\n  exact List.prod_map_mul (α := ℤ) (l := (primeFactorsList b).attach)\n    (f := fun x ↦ @legendreSym x {out := prime_of_mem_primeFactorsList x.2} a₁)\n    (g := fun x ↦ @legendreSym x {out := prime_of_mem_primeFactorsList x.2} a₂)\n\n"}
{"name":"jacobiSym.eq_zero_iff_not_coprime","module":"Mathlib.NumberTheory.LegendreSymbol.JacobiSymbol","initialProofState":"a : Int\nb : Nat\ninst✝ : NeZero b\n⊢ Iff (Eq (jacobiSym a b) 0) (Ne (a.gcd ↑b) 1)","decl":"/-- The symbol `J(a | b)` vanishes iff `a` and `b` are not coprime (assuming `b ≠ 0`). -/\ntheorem eq_zero_iff_not_coprime {a : ℤ} {b : ℕ} [NeZero b] : J(a | b) = 0 ↔ a.gcd b ≠ 1 :=\n  List.prod_eq_zero_iff.trans\n    (by\n      rw [List.mem_pmap, Int.gcd_eq_natAbs, Ne, Prime.not_coprime_iff_dvd]\n      simp_rw [legendreSym.eq_zero_iff _ _, intCast_zmod_eq_zero_iff_dvd,\n        mem_primeFactorsList (NeZero.ne b), ← Int.natCast_dvd, Int.natCast_dvd_natCast, exists_prop,\n        and_assoc, _root_.and_comm])\n\n"}
{"name":"jacobiSym.ne_zero","module":"Mathlib.NumberTheory.LegendreSymbol.JacobiSymbol","initialProofState":"a : Int\nb : Nat\nh : Eq (a.gcd ↑b) 1\n⊢ Ne (jacobiSym a b) 0","decl":"/-- The symbol `J(a | b)` is nonzero when `a` and `b` are coprime. -/\nprotected theorem ne_zero {a : ℤ} {b : ℕ} (h : a.gcd b = 1) : J(a | b) ≠ 0 := by\n  cases' eq_zero_or_neZero b with hb\n  · rw [hb, zero_right]\n    exact one_ne_zero\n  · contrapose! h; exact eq_zero_iff_not_coprime.1 h\n\n"}
{"name":"jacobiSym.eq_zero_iff","module":"Mathlib.NumberTheory.LegendreSymbol.JacobiSymbol","initialProofState":"a : Int\nb : Nat\n⊢ Iff (Eq (jacobiSym a b) 0) (And (Ne b 0) (Ne (a.gcd ↑b) 1))","decl":"/-- The symbol `J(a | b)` vanishes if and only if `b ≠ 0` and `a` and `b` are not coprime. -/\ntheorem eq_zero_iff {a : ℤ} {b : ℕ} : J(a | b) = 0 ↔ b ≠ 0 ∧ a.gcd b ≠ 1 :=\n  ⟨fun h => by\n    rcases eq_or_ne b 0 with hb | hb\n    · rw [hb, zero_right] at h; cases h\n    exact ⟨hb, mt jacobiSym.ne_zero <| Classical.not_not.2 h⟩, fun ⟨hb, h⟩ => by\n    rw [← neZero_iff] at hb; exact eq_zero_iff_not_coprime.2 h⟩\n\n"}
{"name":"jacobiSym.zero_left","module":"Mathlib.NumberTheory.LegendreSymbol.JacobiSymbol","initialProofState":"b : Nat\nhb : LT.lt 1 b\n⊢ Eq (jacobiSym 0 b) 0","decl":"/-- The symbol `J(0 | b)` vanishes when `b > 1`. -/\ntheorem zero_left {b : ℕ} (hb : 1 < b) : J(0 | b) = 0 :=\n  (@eq_zero_iff_not_coprime 0 b ⟨ne_zero_of_lt hb⟩).mpr <| by\n    rw [Int.gcd_zero_left, Int.natAbs_ofNat]; exact hb.ne'\n\n"}
{"name":"jacobiSym.eq_one_or_neg_one","module":"Mathlib.NumberTheory.LegendreSymbol.JacobiSymbol","initialProofState":"a : Int\nb : Nat\nh : Eq (a.gcd ↑b) 1\n⊢ Or (Eq (jacobiSym a b) 1) (Eq (jacobiSym a b) (-1))","decl":"/-- The symbol `J(a | b)` takes the value `1` or `-1` if `a` and `b` are coprime. -/\ntheorem eq_one_or_neg_one {a : ℤ} {b : ℕ} (h : a.gcd b = 1) : J(a | b) = 1 ∨ J(a | b) = -1 :=\n  (trichotomy a b).resolve_left <| jacobiSym.ne_zero h\n\n"}
{"name":"jacobiSym.pow_left","module":"Mathlib.NumberTheory.LegendreSymbol.JacobiSymbol","initialProofState":"a : Int\ne b : Nat\n⊢ Eq (jacobiSym (HPow.hPow a e) b) (HPow.hPow (jacobiSym a b) e)","decl":"/-- We have that `J(a^e | b) = J(a | b)^e`. -/\ntheorem pow_left (a : ℤ) (e b : ℕ) : J(a ^ e | b) = J(a | b) ^ e :=\n  Nat.recOn e (by rw [_root_.pow_zero, _root_.pow_zero, one_left]) fun _ ih => by\n    rw [_root_.pow_succ, _root_.pow_succ, mul_left, ih]\n\n"}
{"name":"jacobiSym.pow_right","module":"Mathlib.NumberTheory.LegendreSymbol.JacobiSymbol","initialProofState":"a : Int\nb e : Nat\n⊢ Eq (jacobiSym a (HPow.hPow b e)) (HPow.hPow (jacobiSym a b) e)","decl":"/-- We have that `J(a | b^e) = J(a | b)^e`. -/\ntheorem pow_right (a : ℤ) (b e : ℕ) : J(a | b ^ e) = J(a | b) ^ e := by\n  induction' e with e ih\n  · rw [Nat.pow_zero, _root_.pow_zero, one_right]\n  · cases' eq_zero_or_neZero b with hb\n    · rw [hb, zero_pow e.succ_ne_zero, zero_right, one_pow]\n    · rw [_root_.pow_succ, _root_.pow_succ, mul_right, ih]\n\n"}
{"name":"jacobiSym.sq_one","module":"Mathlib.NumberTheory.LegendreSymbol.JacobiSymbol","initialProofState":"a : Int\nb : Nat\nh : Eq (a.gcd ↑b) 1\n⊢ Eq (HPow.hPow (jacobiSym a b) 2) 1","decl":"/-- The square of `J(a | b)` is `1` when `a` and `b` are coprime. -/\ntheorem sq_one {a : ℤ} {b : ℕ} (h : a.gcd b = 1) : J(a | b) ^ 2 = 1 := by\n  cases' eq_one_or_neg_one h with h₁ h₁ <;> rw [h₁] <;> rfl\n\n"}
{"name":"jacobiSym.sq_one'","module":"Mathlib.NumberTheory.LegendreSymbol.JacobiSymbol","initialProofState":"a : Int\nb : Nat\nh : Eq (a.gcd ↑b) 1\n⊢ Eq (jacobiSym (HPow.hPow a 2) b) 1","decl":"/-- The symbol `J(a^2 | b)` is `1` when `a` and `b` are coprime. -/\ntheorem sq_one' {a : ℤ} {b : ℕ} (h : a.gcd b = 1) : J(a ^ 2 | b) = 1 := by rw [pow_left, sq_one h]\n\n"}
{"name":"jacobiSym.mod_left","module":"Mathlib.NumberTheory.LegendreSymbol.JacobiSymbol","initialProofState":"a : Int\nb : Nat\n⊢ Eq (jacobiSym a b) (jacobiSym (HMod.hMod a ↑b) b)","decl":"/-- The symbol `J(a | b)` depends only on `a` mod `b`. -/\ntheorem mod_left (a : ℤ) (b : ℕ) : J(a | b) = J(a % b | b) :=\n  congr_arg List.prod <|\n    List.pmap_congr_left _\n      (by\n        -- Porting note: Lean does not synthesize the instance [Fact (Nat.Prime p)] automatically\n        -- (it is needed for `legendreSym.mod` on line 227). Thus, we name the hypothesis\n        -- `Nat.Prime p` explicitly on line 224 and prove `Fact (Nat.Prime p)` on line 225.\n        rintro p hp _ h₂\n        letI : Fact p.Prime := ⟨h₂⟩\n        conv_rhs =>\n          rw [legendreSym.mod, Int.emod_emod_of_dvd _ (Int.natCast_dvd_natCast.2 <|\n            dvd_of_mem_primeFactorsList hp), ← legendreSym.mod])\n\n"}
{"name":"jacobiSym.mod_left'","module":"Mathlib.NumberTheory.LegendreSymbol.JacobiSymbol","initialProofState":"a₁ a₂ : Int\nb : Nat\nh : Eq (HMod.hMod a₁ ↑b) (HMod.hMod a₂ ↑b)\n⊢ Eq (jacobiSym a₁ b) (jacobiSym a₂ b)","decl":"/-- The symbol `J(a | b)` depends only on `a` mod `b`. -/\ntheorem mod_left' {a₁ a₂ : ℤ} {b : ℕ} (h : a₁ % b = a₂ % b) : J(a₁ | b) = J(a₂ | b) := by\n  rw [mod_left, h, ← mod_left]\n\n"}
{"name":"jacobiSym.prime_dvd_of_eq_neg_one","module":"Mathlib.NumberTheory.LegendreSymbol.JacobiSymbol","initialProofState":"p : Nat\ninst✝ : Fact (Nat.Prime p)\na : Int\nh : Eq (jacobiSym a p) (-1)\nx y : Int\nhxy : Dvd.dvd (↑p) (HSub.hSub (HPow.hPow x 2) (HMul.hMul a (HPow.hPow y 2)))\n⊢ And (Dvd.dvd (↑p) x) (Dvd.dvd (↑p) y)","decl":"/-- If `p` is prime, `J(a | p) = -1` and `p` divides `x^2 - a*y^2`, then `p` must divide\n`x` and `y`. -/\ntheorem prime_dvd_of_eq_neg_one {p : ℕ} [Fact p.Prime] {a : ℤ} (h : J(a | p) = -1) {x y : ℤ}\n    (hxy : ↑p ∣ (x ^ 2 - a * y ^ 2 : ℤ)) : ↑p ∣ x ∧ ↑p ∣ y := by\n  rw [← legendreSym.to_jacobiSym] at h\n  exact legendreSym.prime_dvd_of_eq_neg_one h hxy\n\n"}
{"name":"jacobiSym.list_prod_left","module":"Mathlib.NumberTheory.LegendreSymbol.JacobiSymbol","initialProofState":"l : List Int\nn : Nat\n⊢ Eq (jacobiSym l.prod n) (List.map (fun a => jacobiSym a n) l).prod","decl":"/-- We can pull out a product over a list in the first argument of the Jacobi symbol. -/\ntheorem list_prod_left {l : List ℤ} {n : ℕ} : J(l.prod | n) = (l.map fun a => J(a | n)).prod := by\n  induction' l with n l' ih\n  · simp only [List.prod_nil, List.map_nil, one_left]\n  · rw [List.map, List.prod_cons, List.prod_cons, mul_left, ih]\n\n"}
{"name":"jacobiSym.list_prod_right","module":"Mathlib.NumberTheory.LegendreSymbol.JacobiSymbol","initialProofState":"a : Int\nl : List Nat\nhl : ∀ (n : Nat), Membership.mem l n → Ne n 0\n⊢ Eq (jacobiSym a l.prod) (List.map (fun n => jacobiSym a n) l).prod","decl":"/-- We can pull out a product over a list in the second argument of the Jacobi symbol. -/\ntheorem list_prod_right {a : ℤ} {l : List ℕ} (hl : ∀ n ∈ l, n ≠ 0) :\n    J(a | l.prod) = (l.map fun n => J(a | n)).prod := by\n  induction' l with n l' ih\n  · simp only [List.prod_nil, one_right, List.map_nil]\n  · have hn := hl n (List.mem_cons_self n l')\n    -- `n ≠ 0`\n    have hl' := List.prod_ne_zero fun hf => hl 0 (List.mem_cons_of_mem _ hf) rfl\n    -- `l'.prod ≠ 0`\n    have h := fun m hm => hl m (List.mem_cons_of_mem _ hm)\n    -- `∀ (m : ℕ), m ∈ l' → m ≠ 0`\n    rw [List.map, List.prod_cons, List.prod_cons, mul_right' a hn hl', ih h]\n\n"}
{"name":"jacobiSym.eq_neg_one_at_prime_divisor_of_eq_neg_one","module":"Mathlib.NumberTheory.LegendreSymbol.JacobiSymbol","initialProofState":"a : Int\nn : Nat\nh : Eq (jacobiSym a n) (-1)\n⊢ Exists fun p => And (Nat.Prime p) (And (Dvd.dvd p n) (Eq (jacobiSym a p) (-1)))","decl":"/-- If `J(a | n) = -1`, then `n` has a prime divisor `p` such that `J(a | p) = -1`. -/\ntheorem eq_neg_one_at_prime_divisor_of_eq_neg_one {a : ℤ} {n : ℕ} (h : J(a | n) = -1) :\n    ∃ p : ℕ, p.Prime ∧ p ∣ n ∧ J(a | p) = -1 := by\n  have hn₀ : n ≠ 0 := by\n    rintro rfl\n    rw [zero_right, CharZero.eq_neg_self_iff] at h\n    exact one_ne_zero h\n  have hf₀ (p) (hp : p ∈ n.primeFactorsList) : p ≠ 0 := (Nat.pos_of_mem_primeFactorsList hp).ne.symm\n  rw [← Nat.prod_primeFactorsList hn₀, list_prod_right hf₀] at h\n  obtain ⟨p, hmem, hj⟩ := List.mem_map.mp (List.neg_one_mem_of_prod_eq_neg_one h)\n  exact ⟨p, Nat.prime_of_mem_primeFactorsList hmem, Nat.dvd_of_mem_primeFactorsList hmem, hj⟩\n\n"}
{"name":"ZMod.nonsquare_of_jacobiSym_eq_neg_one","module":"Mathlib.NumberTheory.LegendreSymbol.JacobiSymbol","initialProofState":"a : Int\nb : Nat\nh : Eq (jacobiSym a b) (-1)\n⊢ Not (IsSquare ↑a)","decl":"/-- If `J(a | b)` is `-1`, then `a` is not a square modulo `b`. -/\ntheorem nonsquare_of_jacobiSym_eq_neg_one {a : ℤ} {b : ℕ} (h : J(a | b) = -1) :\n    ¬IsSquare (a : ZMod b) := fun ⟨r, ha⟩ => by\n  rw [← r.coe_valMinAbs, ← Int.cast_mul, intCast_eq_intCast_iff', ← sq] at ha\n  apply (by norm_num : ¬(0 : ℤ) ≤ -1)\n  rw [← h, mod_left, ha, ← mod_left, pow_left]\n  apply sq_nonneg\n\n"}
{"name":"ZMod.nonsquare_iff_jacobiSym_eq_neg_one","module":"Mathlib.NumberTheory.LegendreSymbol.JacobiSymbol","initialProofState":"a : Int\np : Nat\ninst✝ : Fact (Nat.Prime p)\n⊢ Iff (Eq (jacobiSym a p) (-1)) (Not (IsSquare ↑a))","decl":"/-- If `p` is prime, then `J(a | p)` is `-1` iff `a` is not a square modulo `p`. -/\ntheorem nonsquare_iff_jacobiSym_eq_neg_one {a : ℤ} {p : ℕ} [Fact p.Prime] :\n    J(a | p) = -1 ↔ ¬IsSquare (a : ZMod p) := by\n  rw [← legendreSym.to_jacobiSym]\n  exact legendreSym.eq_neg_one_iff p\n\n"}
{"name":"ZMod.isSquare_of_jacobiSym_eq_one","module":"Mathlib.NumberTheory.LegendreSymbol.JacobiSymbol","initialProofState":"a : Int\np : Nat\ninst✝ : Fact (Nat.Prime p)\nh : Eq (jacobiSym a p) 1\n⊢ IsSquare ↑a","decl":"/-- If `p` is prime and `J(a | p) = 1`, then `a` is a square mod `p`. -/\ntheorem isSquare_of_jacobiSym_eq_one {a : ℤ} {p : ℕ} [Fact p.Prime] (h : J(a | p) = 1) :\n    IsSquare (a : ZMod p) :=\n  Classical.not_not.mp <| by rw [← nonsquare_iff_jacobiSym_eq_neg_one, h]; decide\n\n"}
{"name":"jacobiSym.value_at","module":"Mathlib.NumberTheory.LegendreSymbol.JacobiSymbol","initialProofState":"a : Int\nR : Type u_1\ninst✝ : CommSemiring R\nχ : MonoidHom R Int\nhp : ∀ (p : Nat) (pp : Nat.Prime p), Ne p 2 → Eq (legendreSym p a) (χ ↑p)\nb : Nat\nhb : Odd b\n⊢ Eq (jacobiSym a b) (χ ↑b)","decl":"/-- If `χ` is a multiplicative function such that `J(a | p) = χ p` for all odd primes `p`,\nthen `J(a | b)` equals `χ b` for all odd natural numbers `b`. -/\ntheorem value_at (a : ℤ) {R : Type*} [CommSemiring R] (χ : R →* ℤ)\n    (hp : ∀ (p : ℕ) (pp : p.Prime), p ≠ 2 → @legendreSym p ⟨pp⟩ a = χ p) {b : ℕ} (hb : Odd b) :\n    J(a | b) = χ b := by\n  conv_rhs => rw [← prod_primeFactorsList hb.pos.ne', cast_list_prod, map_list_prod χ]\n  rw [jacobiSym, List.map_map, ← List.pmap_eq_map Nat.Prime _ _\n    fun _ => prime_of_mem_primeFactorsList]\n  congr 1; apply List.pmap_congr_left\n  exact fun p h pp _ => hp p pp (hb.ne_two_of_dvd_nat <| dvd_of_mem_primeFactorsList h)\n\n"}
{"name":"jacobiSym.at_neg_one","module":"Mathlib.NumberTheory.LegendreSymbol.JacobiSymbol","initialProofState":"b : Nat\nhb : Odd b\n⊢ Eq (jacobiSym (-1) b) (ZMod.χ₄ ↑b)","decl":"/-- If `b` is odd, then `J(-1 | b)` is given by `χ₄ b`. -/\ntheorem at_neg_one {b : ℕ} (hb : Odd b) : J(-1 | b) = χ₄ b :=\n  -- Porting note: In mathlib3, it was written `χ₄` and Lean could guess that it had to use\n  -- `χ₄.to_monoid_hom`. This is not the case with Lean 4.\n  value_at (-1) χ₄.toMonoidHom (fun p pp => @legendreSym.at_neg_one p ⟨pp⟩) hb\n\n"}
{"name":"jacobiSym.neg","module":"Mathlib.NumberTheory.LegendreSymbol.JacobiSymbol","initialProofState":"a : Int\nb : Nat\nhb : Odd b\n⊢ Eq (jacobiSym (Neg.neg a) b) (HMul.hMul (ZMod.χ₄ ↑b) (jacobiSym a b))","decl":"/-- If `b` is odd, then `J(-a | b) = χ₄ b * J(a | b)`. -/\nprotected theorem neg (a : ℤ) {b : ℕ} (hb : Odd b) : J(-a | b) = χ₄ b * J(a | b) := by\n  rw [neg_eq_neg_one_mul, mul_left, at_neg_one hb]\n\n"}
{"name":"jacobiSym.at_two","module":"Mathlib.NumberTheory.LegendreSymbol.JacobiSymbol","initialProofState":"b : Nat\nhb : Odd b\n⊢ Eq (jacobiSym 2 b) (ZMod.χ₈ ↑b)","decl":"/-- If `b` is odd, then `J(2 | b)` is given by `χ₈ b`. -/\ntheorem at_two {b : ℕ} (hb : Odd b) : J(2 | b) = χ₈ b :=\n  value_at 2 χ₈.toMonoidHom (fun p pp => @legendreSym.at_two p ⟨pp⟩) hb\n\n"}
{"name":"jacobiSym.at_neg_two","module":"Mathlib.NumberTheory.LegendreSymbol.JacobiSymbol","initialProofState":"b : Nat\nhb : Odd b\n⊢ Eq (jacobiSym (-2) b) (ZMod.χ₈' ↑b)","decl":"/-- If `b` is odd, then `J(-2 | b)` is given by `χ₈' b`. -/\ntheorem at_neg_two {b : ℕ} (hb : Odd b) : J(-2 | b) = χ₈' b :=\n  value_at (-2) χ₈'.toMonoidHom (fun p pp => @legendreSym.at_neg_two p ⟨pp⟩) hb\n\n"}
{"name":"jacobiSym.div_four_left","module":"Mathlib.NumberTheory.LegendreSymbol.JacobiSymbol","initialProofState":"a : Int\nb : Nat\nha4 : Eq (HMod.hMod a 4) 0\nhb2 : Eq (HMod.hMod b 2) 1\n⊢ Eq (jacobiSym (HDiv.hDiv a 4) b) (jacobiSym a b)","decl":"theorem div_four_left {a : ℤ} {b : ℕ} (ha4 : a % 4 = 0) (hb2 : b % 2 = 1) :\n    J(a / 4 | b) = J(a | b) := by\n  obtain ⟨a, rfl⟩ := Int.dvd_of_emod_eq_zero ha4\n  have : Int.gcd (2 : ℕ) b = 1 := by\n    rw [Int.gcd_natCast_natCast, ← b.mod_add_div 2, hb2, Nat.gcd_add_mul_left_right,\n      Nat.gcd_one_right]\n  rw [Int.mul_ediv_cancel_left _ (by decide), jacobiSym.mul_left,\n    (by decide : (4 : ℤ) = (2 : ℕ) ^ 2), jacobiSym.sq_one' this, one_mul]\n\n"}
{"name":"jacobiSym.even_odd","module":"Mathlib.NumberTheory.LegendreSymbol.JacobiSymbol","initialProofState":"a : Int\nb : Nat\nha2 : Eq (HMod.hMod a 2) 0\nhb2 : Eq (HMod.hMod b 2) 1\n⊢ Eq (ite (Or (Eq (HMod.hMod b 8) 3) (Eq (HMod.hMod b 8) 5)) (Neg.neg (jacobiSym (HDiv.hDiv a 2) b)) (jacobiSym (HDiv.hDiv a 2) b)) (jacobiSym a b)","decl":"theorem even_odd {a : ℤ} {b : ℕ} (ha2 : a % 2 = 0) (hb2 : b % 2 = 1) :\n    (if b % 8 = 3 ∨ b % 8 = 5 then -J(a / 2 | b) else J(a / 2 | b)) = J(a | b) := by\n  obtain ⟨a, rfl⟩ := Int.dvd_of_emod_eq_zero ha2\n  rw [Int.mul_ediv_cancel_left _ (by decide), jacobiSym.mul_left,\n    jacobiSym.at_two (Nat.odd_iff.mpr hb2), ZMod.χ₈_nat_eq_if_mod_eight,\n    if_neg (Nat.mod_two_ne_zero.mpr hb2)]\n  have := Nat.mod_lt b (by decide : 0 < 8)\n  interval_cases h : b % 8 <;> simp_all <;>\n  · have := hb2 ▸ h ▸ Nat.mod_mod_of_dvd b (by decide : 2 ∣ 8)\n    simp_all\n\n"}
{"name":"qrSign.neg_one_pow","module":"Mathlib.NumberTheory.LegendreSymbol.JacobiSymbol","initialProofState":"m n : Nat\nhm : Odd m\nhn : Odd n\n⊢ Eq (qrSign m n) (HPow.hPow (-1) (HMul.hMul (HDiv.hDiv m 2) (HDiv.hDiv n 2)))","decl":"/-- We can express `qrSign m n` as a power of `-1` when `m` and `n` are odd. -/\ntheorem neg_one_pow {m n : ℕ} (hm : Odd m) (hn : Odd n) :\n    qrSign m n = (-1) ^ (m / 2 * (n / 2)) := by\n  rw [qrSign, pow_mul, ← χ₄_eq_neg_one_pow (odd_iff.mp hm)]\n  cases' odd_mod_four_iff.mp (odd_iff.mp hm) with h h\n  · rw [χ₄_nat_one_mod_four h, jacobiSym.one_left, one_pow]\n  · rw [χ₄_nat_three_mod_four h, ← χ₄_eq_neg_one_pow (odd_iff.mp hn), jacobiSym.at_neg_one hn]\n\n"}
{"name":"qrSign.sq_eq_one","module":"Mathlib.NumberTheory.LegendreSymbol.JacobiSymbol","initialProofState":"m n : Nat\nhm : Odd m\nhn : Odd n\n⊢ Eq (HPow.hPow (qrSign m n) 2) 1","decl":"/-- When `m` and `n` are odd, then the square of `qrSign m n` is `1`. -/\ntheorem sq_eq_one {m n : ℕ} (hm : Odd m) (hn : Odd n) : qrSign m n ^ 2 = 1 := by\n  rw [neg_one_pow hm hn, ← pow_mul, mul_comm, pow_mul, neg_one_sq, one_pow]\n\n"}
{"name":"qrSign.mul_left","module":"Mathlib.NumberTheory.LegendreSymbol.JacobiSymbol","initialProofState":"m₁ m₂ n : Nat\n⊢ Eq (qrSign (HMul.hMul m₁ m₂) n) (HMul.hMul (qrSign m₁ n) (qrSign m₂ n))","decl":"/-- `qrSign` is multiplicative in the first argument. -/\ntheorem mul_left (m₁ m₂ n : ℕ) : qrSign (m₁ * m₂) n = qrSign m₁ n * qrSign m₂ n := by\n  simp_rw [qrSign, Nat.cast_mul, map_mul, jacobiSym.mul_left]\n\n"}
{"name":"qrSign.mul_right","module":"Mathlib.NumberTheory.LegendreSymbol.JacobiSymbol","initialProofState":"m n₁ n₂ : Nat\ninst✝¹ : NeZero n₁\ninst✝ : NeZero n₂\n⊢ Eq (qrSign m (HMul.hMul n₁ n₂)) (HMul.hMul (qrSign m n₁) (qrSign m n₂))","decl":"/-- `qrSign` is multiplicative in the second argument. -/\ntheorem mul_right (m n₁ n₂ : ℕ) [NeZero n₁] [NeZero n₂] :\n    qrSign m (n₁ * n₂) = qrSign m n₁ * qrSign m n₂ :=\n  jacobiSym.mul_right (χ₄ m) n₁ n₂\n\n"}
{"name":"qrSign.symm","module":"Mathlib.NumberTheory.LegendreSymbol.JacobiSymbol","initialProofState":"m n : Nat\nhm : Odd m\nhn : Odd n\n⊢ Eq (qrSign m n) (qrSign n m)","decl":"/-- `qrSign` is symmetric when both arguments are odd. -/\nprotected theorem symm {m n : ℕ} (hm : Odd m) (hn : Odd n) : qrSign m n = qrSign n m := by\n  rw [neg_one_pow hm hn, neg_one_pow hn hm, mul_comm (m / 2)]\n\n"}
{"name":"qrSign.eq_iff_eq","module":"Mathlib.NumberTheory.LegendreSymbol.JacobiSymbol","initialProofState":"m n : Nat\nhm : Odd m\nhn : Odd n\nx y : Int\n⊢ Iff (Eq (HMul.hMul (qrSign m n) x) y) (Eq x (HMul.hMul (qrSign m n) y))","decl":"/-- We can move `qrSign m n` from one side of an equality to the other when `m` and `n` are odd. -/\ntheorem eq_iff_eq {m n : ℕ} (hm : Odd m) (hn : Odd n) (x y : ℤ) :\n    qrSign m n * x = y ↔ x = qrSign m n * y := by\n  refine\n      ⟨fun h' =>\n        let h := h'.symm\n        ?_,\n        fun h => ?_⟩ <;>\n    rw [h, ← mul_assoc, ← pow_two, sq_eq_one hm hn, one_mul]\n\n"}
{"name":"jacobiSym.quadratic_reciprocity'","module":"Mathlib.NumberTheory.LegendreSymbol.JacobiSymbol","initialProofState":"a b : Nat\nha : Odd a\nhb : Odd b\n⊢ Eq (jacobiSym (↑a) b) (HMul.hMul (qrSign b a) (jacobiSym (↑b) a))","decl":"/-- The **Law of Quadratic Reciprocity for the Jacobi symbol**, version with `qrSign` -/\ntheorem quadratic_reciprocity' {a b : ℕ} (ha : Odd a) (hb : Odd b) :\n    J(a | b) = qrSign b a * J(b | a) := by\n  -- define the right hand side for fixed `a` as a `ℕ →* ℤ`\n  let rhs : ℕ → ℕ →* ℤ := fun a =>\n    { toFun := fun x => qrSign x a * J(x | a)\n      map_one' := by convert ← mul_one (M := ℤ) _; (on_goal 1 => symm); all_goals apply one_left\n      map_mul' := fun x y => by\n        -- Porting note: `simp_rw` on line 423 replaces `rw` to allow the rewrite rules to be\n        -- applied under the binder `fun ↦ ...`\n        simp_rw [qrSign.mul_left x y a, Nat.cast_mul, mul_left, mul_mul_mul_comm] }\n  have rhs_apply : ∀ a b : ℕ, rhs a b = qrSign b a * J(b | a) := fun a b => rfl\n  refine value_at a (rhs a) (fun p pp hp => Eq.symm ?_) hb\n  have hpo := pp.eq_two_or_odd'.resolve_left hp\n  rw [@legendreSym.to_jacobiSym p ⟨pp⟩, rhs_apply, Nat.cast_id, qrSign.eq_iff_eq hpo ha,\n    qrSign.symm hpo ha]\n  refine value_at p (rhs p) (fun q pq hq => ?_) ha\n  have hqo := pq.eq_two_or_odd'.resolve_left hq\n  rw [rhs_apply, Nat.cast_id, ← @legendreSym.to_jacobiSym p ⟨pp⟩, qrSign.symm hqo hpo,\n    qrSign.neg_one_pow hpo hqo, @legendreSym.quadratic_reciprocity' p q ⟨pp⟩ ⟨pq⟩ hp hq]\n\n"}
{"name":"jacobiSym.quadratic_reciprocity","module":"Mathlib.NumberTheory.LegendreSymbol.JacobiSymbol","initialProofState":"a b : Nat\nha : Odd a\nhb : Odd b\n⊢ Eq (jacobiSym (↑a) b) (HMul.hMul (HPow.hPow (-1) (HMul.hMul (HDiv.hDiv a 2) (HDiv.hDiv b 2))) (jacobiSym (↑b) a))","decl":"/-- The Law of Quadratic Reciprocity for the Jacobi symbol -/\ntheorem quadratic_reciprocity {a b : ℕ} (ha : Odd a) (hb : Odd b) :\n    J(a | b) = (-1) ^ (a / 2 * (b / 2)) * J(b | a) := by\n  rw [← qrSign.neg_one_pow ha hb, qrSign.symm ha hb, quadratic_reciprocity' ha hb]\n\n"}
{"name":"jacobiSym.quadratic_reciprocity_one_mod_four","module":"Mathlib.NumberTheory.LegendreSymbol.JacobiSymbol","initialProofState":"a b : Nat\nha : Eq (HMod.hMod a 4) 1\nhb : Odd b\n⊢ Eq (jacobiSym (↑a) b) (jacobiSym (↑b) a)","decl":"/-- The Law of Quadratic Reciprocity for the Jacobi symbol: if `a` and `b` are natural numbers\nwith `a % 4 = 1` and `b` odd, then `J(a | b) = J(b | a)`. -/\ntheorem quadratic_reciprocity_one_mod_four {a b : ℕ} (ha : a % 4 = 1) (hb : Odd b) :\n    J(a | b) = J(b | a) := by\n  rw [quadratic_reciprocity (odd_iff.mpr (odd_of_mod_four_eq_one ha)) hb, pow_mul,\n    neg_one_pow_div_two_of_one_mod_four ha, one_pow, one_mul]\n\n"}
{"name":"jacobiSym.quadratic_reciprocity_one_mod_four'","module":"Mathlib.NumberTheory.LegendreSymbol.JacobiSymbol","initialProofState":"a b : Nat\nha : Odd a\nhb : Eq (HMod.hMod b 4) 1\n⊢ Eq (jacobiSym (↑a) b) (jacobiSym (↑b) a)","decl":"/-- The Law of Quadratic Reciprocity for the Jacobi symbol: if `a` and `b` are natural numbers\nwith `a` odd and `b % 4 = 1`, then `J(a | b) = J(b | a)`. -/\ntheorem quadratic_reciprocity_one_mod_four' {a b : ℕ} (ha : Odd a) (hb : b % 4 = 1) :\n    J(a | b) = J(b | a) :=\n  (quadratic_reciprocity_one_mod_four hb ha).symm\n\n"}
{"name":"jacobiSym.quadratic_reciprocity_three_mod_four","module":"Mathlib.NumberTheory.LegendreSymbol.JacobiSymbol","initialProofState":"a b : Nat\nha : Eq (HMod.hMod a 4) 3\nhb : Eq (HMod.hMod b 4) 3\n⊢ Eq (jacobiSym (↑a) b) (Neg.neg (jacobiSym (↑b) a))","decl":"/-- The Law of Quadratic Reciprocity for the Jacobi symbol: if `a` and `b` are natural numbers\nboth congruent to `3` mod `4`, then `J(a | b) = -J(b | a)`. -/\ntheorem quadratic_reciprocity_three_mod_four {a b : ℕ} (ha : a % 4 = 3) (hb : b % 4 = 3) :\n    J(a | b) = -J(b | a) := by\n  let nop := @neg_one_pow_div_two_of_three_mod_four\n  rw [quadratic_reciprocity, pow_mul, nop ha, nop hb, neg_one_mul] <;>\n    rwa [odd_iff, odd_of_mod_four_eq_three]\n\n"}
{"name":"jacobiSym.quadratic_reciprocity_if","module":"Mathlib.NumberTheory.LegendreSymbol.JacobiSymbol","initialProofState":"a b : Nat\nha2 : Eq (HMod.hMod a 2) 1\nhb2 : Eq (HMod.hMod b 2) 1\n⊢ Eq (ite (And (Eq (HMod.hMod a 4) 3) (Eq (HMod.hMod b 4) 3)) (Neg.neg (jacobiSym (↑b) a)) (jacobiSym (↑b) a)) (jacobiSym (↑a) b)","decl":"theorem quadratic_reciprocity_if {a b : ℕ} (ha2 : a % 2 = 1) (hb2 : b % 2 = 1) :\n    (if a % 4 = 3 ∧ b % 4 = 3 then -J(b | a) else J(b | a)) = J(a | b) := by\n  rcases Nat.odd_mod_four_iff.mp ha2 with ha1 | ha3\n  · simpa [ha1] using jacobiSym.quadratic_reciprocity_one_mod_four' (Nat.odd_iff.mpr hb2) ha1\n  rcases Nat.odd_mod_four_iff.mp hb2 with hb1 | hb3\n  · simpa [hb1] using jacobiSym.quadratic_reciprocity_one_mod_four hb1 (Nat.odd_iff.mpr ha2)\n  simpa [ha3, hb3] using (jacobiSym.quadratic_reciprocity_three_mod_four ha3 hb3).symm\n\n"}
{"name":"jacobiSym.mod_right'","module":"Mathlib.NumberTheory.LegendreSymbol.JacobiSymbol","initialProofState":"a b : Nat\nhb : Odd b\n⊢ Eq (jacobiSym (↑a) b) (jacobiSym (↑a) (HMod.hMod b (HMul.hMul 4 a)))","decl":"/-- The Jacobi symbol `J(a | b)` depends only on `b` mod `4*a` (version for `a : ℕ`). -/\ntheorem mod_right' (a : ℕ) {b : ℕ} (hb : Odd b) : J(a | b) = J(a | b % (4 * a)) := by\n  rcases eq_or_ne a 0 with (rfl | ha₀)\n  · rw [mul_zero, mod_zero]\n  have hb' : Odd (b % (4 * a)) := hb.mod_even (Even.mul_right (by decide) _)\n  rcases exists_eq_pow_mul_and_not_dvd ha₀ 2 (by norm_num) with ⟨e, a', ha₁', ha₂⟩\n  have ha₁ := odd_iff.mpr (two_dvd_ne_zero.mp ha₁')\n  nth_rw 2 [ha₂]; nth_rw 1 [ha₂]\n  rw [Nat.cast_mul, mul_left, mul_left, quadratic_reciprocity' ha₁ hb,\n    quadratic_reciprocity' ha₁ hb', Nat.cast_pow, pow_left, pow_left, Nat.cast_two, at_two hb,\n    at_two hb']\n  congr 1; swap\n  · congr 1\n    · simp_rw [qrSign]\n      rw [χ₄_nat_mod_four, χ₄_nat_mod_four (b % (4 * a)), mod_mod_of_dvd b (dvd_mul_right 4 a)]\n    · rw [mod_left ↑(b % _), mod_left b, Int.natCast_mod, Int.emod_emod_of_dvd b]\n      simp only [ha₂, Nat.cast_mul, ← mul_assoc]\n      apply dvd_mul_left\n  -- Porting note: In mathlib3, it was written `cases' e`. In Lean 4, this resulted in the choice\n  -- of a name other than e (for the case distinction of line 482) so we indicate the name\n  -- to use explicitly.\n  cases' e with e; · rfl\n  · rw [χ₈_nat_mod_eight, χ₈_nat_mod_eight (b % (4 * a)), mod_mod_of_dvd b]\n    use 2 ^ e * a'; rw [ha₂, Nat.pow_succ]; ring\n\n"}
{"name":"jacobiSym.mod_right","module":"Mathlib.NumberTheory.LegendreSymbol.JacobiSymbol","initialProofState":"a : Int\nb : Nat\nhb : Odd b\n⊢ Eq (jacobiSym a b) (jacobiSym a (HMod.hMod b (HMul.hMul 4 a.natAbs)))","decl":"/-- The Jacobi symbol `J(a | b)` depends only on `b` mod `4*a`. -/\ntheorem mod_right (a : ℤ) {b : ℕ} (hb : Odd b) : J(a | b) = J(a | b % (4 * a.natAbs)) := by\n  cases' Int.natAbs_eq a with ha ha <;> nth_rw 2 [ha] <;> nth_rw 1 [ha]\n  · exact mod_right' a.natAbs hb\n  · have hb' : Odd (b % (4 * a.natAbs)) := hb.mod_even (Even.mul_right (by decide) _)\n    rw [jacobiSym.neg _ hb, jacobiSym.neg _ hb', mod_right' _ hb, χ₄_nat_mod_four,\n      χ₄_nat_mod_four (b % (4 * _)), mod_mod_of_dvd b (dvd_mul_right 4 _)]\n\n"}
