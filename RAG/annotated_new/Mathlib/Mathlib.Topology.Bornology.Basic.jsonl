{"name":"Bornology.le_cofinite'","module":"Mathlib.Topology.Bornology.Basic","initialProofState":"α : Type u_4\nself : Bornology α\n⊢ LE.le Bornology.cobounded' Filter.cofinite","decl":"/-- A **bornology** on a type `α` is a filter of cobounded sets which contains the cofinite filter.\nSuch spaces are equivalently specified by their bounded sets, see `Bornology.ofBounded`\nand `Bornology.ext_iff_isBounded`-/\nclass Bornology (α : Type*) where\n  /-- The filter of cobounded sets in a bornology. This is a field of the structure, but one\n  should always prefer `Bornology.cobounded` because it makes the `α` argument explicit. -/\n  cobounded' : Filter α\n  /-- The cobounded filter in a bornology is smaller than the cofinite filter. This is a field of\n  the structure, but one should always prefer `Bornology.le_cofinite` because it makes the `α`\n  argument explicit. -/\n  le_cofinite' : cobounded' ≤ cofinite\n\n/- porting note: Because Lean 4 doesn't accept the `[]` syntax to make arguments of structure\nfields explicit, we have to define these separately, prove the `ext` lemmas manually, and\ninitialize new `simps` projections. -/\n\n"}
{"name":"Bornology.le_cofinite","module":"Mathlib.Topology.Bornology.Basic","initialProofState":"α : Type u_4\ninst✝ : Bornology α\n⊢ LE.le (Bornology.cobounded α) Filter.cofinite","decl":"lemma Bornology.le_cofinite (α : Type*) [Bornology α] : cobounded α ≤ cofinite :=\nBornology.le_cofinite'\n\n"}
{"name":"Bornology.ext","module":"Mathlib.Topology.Bornology.Basic","initialProofState":"α : Type u_2\nt t' : Bornology α\nh_cobounded : Eq (Bornology.cobounded α) (Bornology.cobounded α)\n⊢ Eq t t'","decl":"@[ext]\nlemma Bornology.ext (t t' : Bornology α)\n    (h_cobounded : @Bornology.cobounded α t = @Bornology.cobounded α t') :\n    t = t' := by\n  cases t\n  cases t'\n  congr\n\n"}
{"name":"Bornology.ext_iff","module":"Mathlib.Topology.Bornology.Basic","initialProofState":"α : Type u_2\nt t' : Bornology α\n⊢ Iff (Eq t t') (Eq (Bornology.cobounded α) (Bornology.cobounded α))","decl":"@[ext]\nlemma Bornology.ext (t t' : Bornology α)\n    (h_cobounded : @Bornology.cobounded α t = @Bornology.cobounded α t') :\n    t = t' := by\n  cases t\n  cases t'\n  congr\n\n"}
{"name":"Bornology.ofBounded_cobounded","module":"Mathlib.Topology.Bornology.Basic","initialProofState":"α : Type u_4\nB : Set (Set α)\nempty_mem : Membership.mem B EmptyCollection.emptyCollection\nsubset_mem : ∀ (s₁ : Set α), Membership.mem B s₁ → ∀ (s₂ : Set α), HasSubset.Subset s₂ s₁ → Membership.mem B s₂\nunion_mem : ∀ (s₁ : Set α), Membership.mem B s₁ → ∀ (s₂ : Set α), Membership.mem B s₂ → Membership.mem B (Union.union s₁ s₂)\nsingleton_mem : ∀ (x : α), Membership.mem B (Singleton.singleton x)\n⊢ Eq (Bornology.cobounded α) (Filter.comk (fun x => Membership.mem B x) empty_mem subset_mem union_mem)","decl":"/-- A constructor for bornologies by specifying the bounded sets,\nand showing that they satisfy the appropriate conditions. -/\n@[simps]\ndef Bornology.ofBounded {α : Type*} (B : Set (Set α))\n    (empty_mem : ∅ ∈ B)\n    (subset_mem : ∀ s₁ ∈ B, ∀ s₂ ⊆ s₁, s₂ ∈ B)\n    (union_mem : ∀ s₁ ∈ B, ∀ s₂ ∈ B, s₁ ∪ s₂ ∈ B)\n    (singleton_mem : ∀ x, {x} ∈ B) : Bornology α where\n  cobounded' := comk (· ∈ B) empty_mem subset_mem union_mem\n  le_cofinite' := by simpa [le_cofinite_iff_compl_singleton_mem]\n\n"}
{"name":"Bornology.ofBounded'_cobounded","module":"Mathlib.Topology.Bornology.Basic","initialProofState":"α : Type u_4\nB : Set (Set α)\nempty_mem : Membership.mem B EmptyCollection.emptyCollection\nsubset_mem : ∀ (s₁ : Set α), Membership.mem B s₁ → ∀ (s₂ : Set α), HasSubset.Subset s₂ s₁ → Membership.mem B s₂\nunion_mem : ∀ (s₁ : Set α), Membership.mem B s₁ → ∀ (s₂ : Set α), Membership.mem B s₂ → Membership.mem B (Union.union s₁ s₂)\nsUnion_univ : Eq B.sUnion Set.univ\n⊢ Eq (Bornology.cobounded α) (Filter.comk (fun x => Membership.mem B x) empty_mem subset_mem union_mem)","decl":"/-- A constructor for bornologies by specifying the bounded sets,\nand showing that they satisfy the appropriate conditions. -/\n@[simps! cobounded]\ndef Bornology.ofBounded' {α : Type*} (B : Set (Set α))\n    (empty_mem : ∅ ∈ B)\n    (subset_mem : ∀ s₁ ∈ B, ∀ s₂ ⊆ s₁, s₂ ∈ B)\n    (union_mem : ∀ s₁ ∈ B, ∀ s₂ ∈ B, s₁ ∪ s₂ ∈ B)\n    (sUnion_univ : ⋃₀ B = univ) :\n    Bornology α :=\n  Bornology.ofBounded B empty_mem subset_mem union_mem fun x => by\n    rw [sUnion_eq_univ_iff] at sUnion_univ\n    rcases sUnion_univ x with ⟨s, hs, hxs⟩\n    exact subset_mem s hs {x} (singleton_subset_iff.mpr hxs)\n"}
{"name":"Bornology.isCobounded_def","module":"Mathlib.Topology.Bornology.Basic","initialProofState":"α : Type u_2\nx✝ : Bornology α\ns : Set α\n⊢ Iff (Bornology.IsCobounded s) (Membership.mem (Bornology.cobounded α) s)","decl":"theorem isCobounded_def {s : Set α} : IsCobounded s ↔ s ∈ cobounded α :=\n  Iff.rfl\n\n"}
{"name":"Bornology.isBounded_def","module":"Mathlib.Topology.Bornology.Basic","initialProofState":"α : Type u_2\nx✝ : Bornology α\ns : Set α\n⊢ Iff (Bornology.IsBounded s) (Membership.mem (Bornology.cobounded α) (HasCompl.compl s))","decl":"theorem isBounded_def {s : Set α} : IsBounded s ↔ sᶜ ∈ cobounded α :=\n  Iff.rfl\n\n"}
{"name":"Bornology.isBounded_compl_iff","module":"Mathlib.Topology.Bornology.Basic","initialProofState":"α : Type u_2\nx✝ : Bornology α\ns : Set α\n⊢ Iff (Bornology.IsBounded (HasCompl.compl s)) (Bornology.IsCobounded s)","decl":"@[simp]\ntheorem isBounded_compl_iff : IsBounded sᶜ ↔ IsCobounded s := by\n  rw [isBounded_def, isCobounded_def, compl_compl]\n\n"}
{"name":"Bornology.isCobounded_compl_iff","module":"Mathlib.Topology.Bornology.Basic","initialProofState":"α : Type u_2\nx✝ : Bornology α\ns : Set α\n⊢ Iff (Bornology.IsCobounded (HasCompl.compl s)) (Bornology.IsBounded s)","decl":"@[simp]\ntheorem isCobounded_compl_iff : IsCobounded sᶜ ↔ IsBounded s :=\n  Iff.rfl\n\n"}
{"name":"Bornology.IsCobounded.compl","module":"Mathlib.Topology.Bornology.Basic","initialProofState":"α : Type u_2\nx✝ : Bornology α\ns : Set α\na✝ : Bornology.IsCobounded s\n⊢ Bornology.IsBounded (HasCompl.compl s)","decl":"alias ⟨IsBounded.of_compl, IsCobounded.compl⟩ := isBounded_compl_iff\n\n"}
{"name":"Bornology.IsBounded.of_compl","module":"Mathlib.Topology.Bornology.Basic","initialProofState":"α : Type u_2\nx✝ : Bornology α\ns : Set α\na✝ : Bornology.IsBounded (HasCompl.compl s)\n⊢ Bornology.IsCobounded s","decl":"alias ⟨IsBounded.of_compl, IsCobounded.compl⟩ := isBounded_compl_iff\n\n"}
{"name":"Bornology.IsBounded.compl","module":"Mathlib.Topology.Bornology.Basic","initialProofState":"α : Type u_2\nx✝ : Bornology α\ns : Set α\na✝ : Bornology.IsBounded s\n⊢ Bornology.IsCobounded (HasCompl.compl s)","decl":"alias ⟨IsCobounded.of_compl, IsBounded.compl⟩ := isCobounded_compl_iff\n\n"}
{"name":"Bornology.IsCobounded.of_compl","module":"Mathlib.Topology.Bornology.Basic","initialProofState":"α : Type u_2\nx✝ : Bornology α\ns : Set α\na✝ : Bornology.IsCobounded (HasCompl.compl s)\n⊢ Bornology.IsBounded s","decl":"alias ⟨IsCobounded.of_compl, IsBounded.compl⟩ := isCobounded_compl_iff\n\n"}
{"name":"Bornology.isBounded_empty","module":"Mathlib.Topology.Bornology.Basic","initialProofState":"α : Type u_2\nx✝ : Bornology α\n⊢ Bornology.IsBounded EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem isBounded_empty : IsBounded (∅ : Set α) := by\n  rw [isBounded_def, compl_empty]\n  exact univ_mem\n\n"}
{"name":"Bornology.nonempty_of_not_isBounded","module":"Mathlib.Topology.Bornology.Basic","initialProofState":"α : Type u_2\nx✝ : Bornology α\ns : Set α\nh : Not (Bornology.IsBounded s)\n⊢ s.Nonempty","decl":"theorem nonempty_of_not_isBounded (h : ¬IsBounded s) : s.Nonempty := by\n  rw [nonempty_iff_ne_empty]\n  rintro rfl\n  exact h isBounded_empty\n\n"}
{"name":"Bornology.isBounded_singleton","module":"Mathlib.Topology.Bornology.Basic","initialProofState":"α : Type u_2\nx✝ : Bornology α\nx : α\n⊢ Bornology.IsBounded (Singleton.singleton x)","decl":"@[simp]\ntheorem isBounded_singleton : IsBounded ({x} : Set α) := by\n  rw [isBounded_def]\n  exact le_cofinite _ (finite_singleton x).compl_mem_cofinite\n\n"}
{"name":"Bornology.isBounded_iff_forall_mem","module":"Mathlib.Topology.Bornology.Basic","initialProofState":"α : Type u_2\nx✝ : Bornology α\ns : Set α\n⊢ Iff (Bornology.IsBounded s) (∀ (x : α), Membership.mem s x → Bornology.IsBounded s)","decl":"theorem isBounded_iff_forall_mem : IsBounded s ↔ ∀ x ∈ s, IsBounded s :=\n  ⟨fun h _ _ ↦ h, fun h ↦ by\n    rcases s.eq_empty_or_nonempty with rfl | ⟨x, hx⟩\n    exacts [isBounded_empty, h x hx]⟩\n\n"}
{"name":"Bornology.isCobounded_univ","module":"Mathlib.Topology.Bornology.Basic","initialProofState":"α : Type u_2\nx✝ : Bornology α\n⊢ Bornology.IsCobounded Set.univ","decl":"@[simp]\ntheorem isCobounded_univ : IsCobounded (univ : Set α) :=\n  univ_mem\n\n"}
{"name":"Bornology.isCobounded_inter","module":"Mathlib.Topology.Bornology.Basic","initialProofState":"α : Type u_2\nx✝ : Bornology α\ns t : Set α\n⊢ Iff (Bornology.IsCobounded (Inter.inter s t)) (And (Bornology.IsCobounded s) (Bornology.IsCobounded t))","decl":"@[simp]\ntheorem isCobounded_inter : IsCobounded (s ∩ t) ↔ IsCobounded s ∧ IsCobounded t :=\n  inter_mem_iff\n\n"}
{"name":"Bornology.IsCobounded.inter","module":"Mathlib.Topology.Bornology.Basic","initialProofState":"α : Type u_2\nx✝ : Bornology α\ns t : Set α\nhs : Bornology.IsCobounded s\nht : Bornology.IsCobounded t\n⊢ Bornology.IsCobounded (Inter.inter s t)","decl":"theorem IsCobounded.inter (hs : IsCobounded s) (ht : IsCobounded t) : IsCobounded (s ∩ t) :=\n  isCobounded_inter.2 ⟨hs, ht⟩\n\n"}
{"name":"Bornology.isBounded_union","module":"Mathlib.Topology.Bornology.Basic","initialProofState":"α : Type u_2\nx✝ : Bornology α\ns t : Set α\n⊢ Iff (Bornology.IsBounded (Union.union s t)) (And (Bornology.IsBounded s) (Bornology.IsBounded t))","decl":"@[simp]\ntheorem isBounded_union : IsBounded (s ∪ t) ↔ IsBounded s ∧ IsBounded t := by\n  simp only [← isCobounded_compl_iff, compl_union, isCobounded_inter]\n\n"}
{"name":"Bornology.IsBounded.union","module":"Mathlib.Topology.Bornology.Basic","initialProofState":"α : Type u_2\nx✝ : Bornology α\ns t : Set α\nhs : Bornology.IsBounded s\nht : Bornology.IsBounded t\n⊢ Bornology.IsBounded (Union.union s t)","decl":"theorem IsBounded.union (hs : IsBounded s) (ht : IsBounded t) : IsBounded (s ∪ t) :=\n  isBounded_union.2 ⟨hs, ht⟩\n\n"}
{"name":"Bornology.IsCobounded.superset","module":"Mathlib.Topology.Bornology.Basic","initialProofState":"α : Type u_2\nx✝ : Bornology α\ns t : Set α\nhs : Bornology.IsCobounded s\nht : HasSubset.Subset s t\n⊢ Bornology.IsCobounded t","decl":"theorem IsCobounded.superset (hs : IsCobounded s) (ht : s ⊆ t) : IsCobounded t :=\n  mem_of_superset hs ht\n\n"}
{"name":"Bornology.IsBounded.subset","module":"Mathlib.Topology.Bornology.Basic","initialProofState":"α : Type u_2\nx✝ : Bornology α\ns t : Set α\nht : Bornology.IsBounded t\nhs : HasSubset.Subset s t\n⊢ Bornology.IsBounded s","decl":"theorem IsBounded.subset (ht : IsBounded t) (hs : s ⊆ t) : IsBounded s :=\n  ht.superset (compl_subset_compl.mpr hs)\n\n"}
{"name":"Bornology.sUnion_bounded_univ","module":"Mathlib.Topology.Bornology.Basic","initialProofState":"α : Type u_2\nx✝ : Bornology α\n⊢ Eq (setOf fun s => Bornology.IsBounded s).sUnion Set.univ","decl":"@[simp]\ntheorem sUnion_bounded_univ : ⋃₀ { s : Set α | IsBounded s } = univ :=\n  sUnion_eq_univ_iff.2 fun a => ⟨{a}, isBounded_singleton, mem_singleton a⟩\n\n"}
{"name":"Bornology.IsBounded.insert","module":"Mathlib.Topology.Bornology.Basic","initialProofState":"α : Type u_2\nx✝ : Bornology α\ns : Set α\nh : Bornology.IsBounded s\nx : α\n⊢ Bornology.IsBounded (Insert.insert x s)","decl":"theorem IsBounded.insert (h : IsBounded s) (x : α) : IsBounded (insert x s) :=\n  isBounded_singleton.union h\n\n"}
{"name":"Bornology.isBounded_insert","module":"Mathlib.Topology.Bornology.Basic","initialProofState":"α : Type u_2\nx✝ : Bornology α\ns : Set α\nx : α\n⊢ Iff (Bornology.IsBounded (Insert.insert x s)) (Bornology.IsBounded s)","decl":"@[simp]\ntheorem isBounded_insert : IsBounded (insert x s) ↔ IsBounded s :=\n  ⟨fun h ↦ h.subset (subset_insert _ _), (.insert · x)⟩\n\n"}
{"name":"Bornology.comap_cobounded_le_iff","module":"Mathlib.Topology.Bornology.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\nx✝ : Bornology α\ninst✝ : Bornology β\nf : α → β\n⊢ Iff (LE.le (Filter.comap f (Bornology.cobounded β)) (Bornology.cobounded α)) (∀ ⦃s : Set α⦄, Bornology.IsBounded s → Bornology.IsBounded (Set.image f s))","decl":"theorem comap_cobounded_le_iff [Bornology β] {f : α → β} :\n    (cobounded β).comap f ≤ cobounded α ↔ ∀ ⦃s⦄, IsBounded s → IsBounded (f '' s) := by\n  refine\n    ⟨fun h s hs => ?_, fun h t ht =>\n      ⟨(f '' tᶜ)ᶜ, h <| IsCobounded.compl ht, compl_subset_comm.1 <| subset_preimage_image _ _⟩⟩\n  obtain ⟨t, ht, hts⟩ := h hs.compl\n  rw [subset_compl_comm, ← preimage_compl] at hts\n  exact (IsCobounded.compl ht).subset ((image_subset f hts).trans <| image_preimage_subset _ _)\n\n"}
{"name":"Bornology.ext_iff'","module":"Mathlib.Topology.Bornology.Basic","initialProofState":"α : Type u_2\nt t' : Bornology α\n⊢ Iff (Eq t t') (∀ (s : Set α), Iff (Membership.mem (Bornology.cobounded α) s) (Membership.mem (Bornology.cobounded α) s))","decl":"theorem ext_iff' {t t' : Bornology α} :\n    t = t' ↔ ∀ s, s ∈ @cobounded α t ↔ s ∈ @cobounded α t' :=\n  Bornology.ext_iff.trans Filter.ext_iff\n\n"}
{"name":"Bornology.ext_iff_isBounded","module":"Mathlib.Topology.Bornology.Basic","initialProofState":"α : Type u_2\nt t' : Bornology α\n⊢ Iff (Eq t t') (∀ (s : Set α), Iff (Bornology.IsBounded s) (Bornology.IsBounded s))","decl":"theorem ext_iff_isBounded {t t' : Bornology α} :\n    t = t' ↔ ∀ s, @IsBounded α t s ↔ @IsBounded α t' s :=\n  ext_iff'.trans compl_surjective.forall\n\n"}
{"name":"Bornology.isCobounded_ofBounded_iff","module":"Mathlib.Topology.Bornology.Basic","initialProofState":"α : Type u_2\ns : Set α\nB : Set (Set α)\nempty_mem : Membership.mem B EmptyCollection.emptyCollection\nsubset_mem : ∀ (s₁ : Set α), Membership.mem B s₁ → ∀ (s₂ : Set α), HasSubset.Subset s₂ s₁ → Membership.mem B s₂\nunion_mem : ∀ (s₁ : Set α), Membership.mem B s₁ → ∀ (s₂ : Set α), Membership.mem B s₂ → Membership.mem B (Union.union s₁ s₂)\nsUnion_univ : ∀ (x : α), Membership.mem B (Singleton.singleton x)\n⊢ Iff (Bornology.IsCobounded s) (Membership.mem B (HasCompl.compl s))","decl":"theorem isCobounded_ofBounded_iff (B : Set (Set α)) {empty_mem subset_mem union_mem sUnion_univ} :\n    @IsCobounded _ (ofBounded B empty_mem subset_mem union_mem sUnion_univ) s ↔ sᶜ ∈ B :=\n  Iff.rfl\n\n"}
{"name":"Bornology.isBounded_ofBounded_iff","module":"Mathlib.Topology.Bornology.Basic","initialProofState":"α : Type u_2\ns : Set α\nB : Set (Set α)\nempty_mem : Membership.mem B EmptyCollection.emptyCollection\nsubset_mem : ∀ (s₁ : Set α), Membership.mem B s₁ → ∀ (s₂ : Set α), HasSubset.Subset s₂ s₁ → Membership.mem B s₂\nunion_mem : ∀ (s₁ : Set α), Membership.mem B s₁ → ∀ (s₂ : Set α), Membership.mem B s₂ → Membership.mem B (Union.union s₁ s₂)\nsUnion_univ : ∀ (x : α), Membership.mem B (Singleton.singleton x)\n⊢ Iff (Bornology.IsBounded s) (Membership.mem B s)","decl":"theorem isBounded_ofBounded_iff (B : Set (Set α)) {empty_mem subset_mem union_mem sUnion_univ} :\n    @IsBounded _ (ofBounded B empty_mem subset_mem union_mem sUnion_univ) s ↔ s ∈ B := by\n  rw [isBounded_def, ofBounded_cobounded, compl_mem_comk]\n\n"}
{"name":"Bornology.isCobounded_biInter","module":"Mathlib.Topology.Bornology.Basic","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝ : Bornology α\ns : Set ι\nf : ι → Set α\nhs : s.Finite\n⊢ Iff (Bornology.IsCobounded (Set.iInter fun i => Set.iInter fun h => f i)) (∀ (i : ι), Membership.mem s i → Bornology.IsCobounded (f i))","decl":"theorem isCobounded_biInter {s : Set ι} {f : ι → Set α} (hs : s.Finite) :\n    IsCobounded (⋂ i ∈ s, f i) ↔ ∀ i ∈ s, IsCobounded (f i) :=\n  biInter_mem hs\n\n"}
{"name":"Bornology.isCobounded_biInter_finset","module":"Mathlib.Topology.Bornology.Basic","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝ : Bornology α\ns : Finset ι\nf : ι → Set α\n⊢ Iff (Bornology.IsCobounded (Set.iInter fun i => Set.iInter fun h => f i)) (∀ (i : ι), Membership.mem s i → Bornology.IsCobounded (f i))","decl":"@[simp]\ntheorem isCobounded_biInter_finset (s : Finset ι) {f : ι → Set α} :\n    IsCobounded (⋂ i ∈ s, f i) ↔ ∀ i ∈ s, IsCobounded (f i) :=\n  biInter_finset_mem s\n\n"}
{"name":"Bornology.isCobounded_iInter","module":"Mathlib.Topology.Bornology.Basic","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝¹ : Bornology α\ninst✝ : Finite ι\nf : ι → Set α\n⊢ Iff (Bornology.IsCobounded (Set.iInter fun i => f i)) (∀ (i : ι), Bornology.IsCobounded (f i))","decl":"@[simp]\ntheorem isCobounded_iInter [Finite ι] {f : ι → Set α} :\n    IsCobounded (⋂ i, f i) ↔ ∀ i, IsCobounded (f i) :=\n  iInter_mem\n\n"}
{"name":"Bornology.isCobounded_sInter","module":"Mathlib.Topology.Bornology.Basic","initialProofState":"α : Type u_2\ninst✝ : Bornology α\nS : Set (Set α)\nhs : S.Finite\n⊢ Iff (Bornology.IsCobounded S.sInter) (∀ (s : Set α), Membership.mem S s → Bornology.IsCobounded s)","decl":"theorem isCobounded_sInter {S : Set (Set α)} (hs : S.Finite) :\n    IsCobounded (⋂₀ S) ↔ ∀ s ∈ S, IsCobounded s :=\n  sInter_mem hs\n\n"}
{"name":"Bornology.isBounded_biUnion","module":"Mathlib.Topology.Bornology.Basic","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝ : Bornology α\ns : Set ι\nf : ι → Set α\nhs : s.Finite\n⊢ Iff (Bornology.IsBounded (Set.iUnion fun i => Set.iUnion fun h => f i)) (∀ (i : ι), Membership.mem s i → Bornology.IsBounded (f i))","decl":"theorem isBounded_biUnion {s : Set ι} {f : ι → Set α} (hs : s.Finite) :\n    IsBounded (⋃ i ∈ s, f i) ↔ ∀ i ∈ s, IsBounded (f i) := by\n  simp only [← isCobounded_compl_iff, compl_iUnion, isCobounded_biInter hs]\n\n"}
{"name":"Bornology.isBounded_biUnion_finset","module":"Mathlib.Topology.Bornology.Basic","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝ : Bornology α\ns : Finset ι\nf : ι → Set α\n⊢ Iff (Bornology.IsBounded (Set.iUnion fun i => Set.iUnion fun h => f i)) (∀ (i : ι), Membership.mem s i → Bornology.IsBounded (f i))","decl":"theorem isBounded_biUnion_finset (s : Finset ι) {f : ι → Set α} :\n    IsBounded (⋃ i ∈ s, f i) ↔ ∀ i ∈ s, IsBounded (f i) :=\n  isBounded_biUnion s.finite_toSet\n\n"}
{"name":"Bornology.isBounded_sUnion","module":"Mathlib.Topology.Bornology.Basic","initialProofState":"α : Type u_2\ninst✝ : Bornology α\nS : Set (Set α)\nhs : S.Finite\n⊢ Iff (Bornology.IsBounded S.sUnion) (∀ (s : Set α), Membership.mem S s → Bornology.IsBounded s)","decl":"theorem isBounded_sUnion {S : Set (Set α)} (hs : S.Finite) :\n    IsBounded (⋃₀ S) ↔ ∀ s ∈ S, IsBounded s := by rw [sUnion_eq_biUnion, isBounded_biUnion hs]\n\n"}
{"name":"Bornology.isBounded_iUnion","module":"Mathlib.Topology.Bornology.Basic","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝¹ : Bornology α\ninst✝ : Finite ι\ns : ι → Set α\n⊢ Iff (Bornology.IsBounded (Set.iUnion fun i => s i)) (∀ (i : ι), Bornology.IsBounded (s i))","decl":"@[simp]\ntheorem isBounded_iUnion [Finite ι] {s : ι → Set α} :\n    IsBounded (⋃ i, s i) ↔ ∀ i, IsBounded (s i) := by\n  rw [← sUnion_range, isBounded_sUnion (finite_range s), forall_mem_range]\n\n"}
{"name":"Bornology.eventually_ne_cobounded","module":"Mathlib.Topology.Bornology.Basic","initialProofState":"α : Type u_2\ninst✝ : Bornology α\na : α\n⊢ Filter.Eventually (fun x => Ne x a) (Bornology.cobounded α)","decl":"lemma eventually_ne_cobounded (a : α) : ∀ᶠ x in cobounded α, x ≠ a :=\n  le_cofinite_iff_eventually_ne.1 (le_cofinite _) a\n\n"}
{"name":"Filter.HasBasis.disjoint_cobounded_iff","module":"Mathlib.Topology.Bornology.Basic","initialProofState":"α : Type u_2\ninst✝ : Bornology α\nι : Sort u_4\np : ι → Prop\ns : ι → Set α\nl : Filter α\nh : l.HasBasis p s\n⊢ Iff (Disjoint l (Bornology.cobounded α)) (Exists fun i => And (p i) (Bornology.IsBounded (s i)))","decl":"theorem Filter.HasBasis.disjoint_cobounded_iff [Bornology α] {ι : Sort*} {p : ι → Prop}\n    {s : ι → Set α} {l : Filter α} (h : l.HasBasis p s) :\n    Disjoint l (cobounded α) ↔ ∃ i, p i ∧ Bornology.IsBounded (s i) :=\n  h.disjoint_iff_left\n\n"}
{"name":"Set.Finite.isBounded","module":"Mathlib.Topology.Bornology.Basic","initialProofState":"α : Type u_2\ninst✝ : Bornology α\ns : Set α\nhs : s.Finite\n⊢ Bornology.IsBounded s","decl":"theorem Set.Finite.isBounded [Bornology α] {s : Set α} (hs : s.Finite) : IsBounded s :=\n  Bornology.le_cofinite α hs.compl_mem_cofinite\n\n"}
{"name":"Filter.Tendsto.eventually_ne_cobounded","module":"Mathlib.Topology.Bornology.Basic","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝ : Bornology α\nf : β → α\nl : Filter β\nh : Filter.Tendsto f l (Bornology.cobounded α)\na : α\n⊢ Filter.Eventually (fun x => Ne (f x) a) l","decl":"nonrec lemma Filter.Tendsto.eventually_ne_cobounded [Bornology α] {f : β → α} {l : Filter β}\n    (h : Tendsto f l (cobounded α)) (a : α) : ∀ᶠ x in l, f x ≠ a :=\n  h.eventually <| eventually_ne_cobounded a\n\n"}
{"name":"BoundedSpace.bounded_univ","module":"Mathlib.Topology.Bornology.Basic","initialProofState":"α : Type u_4\ninst✝ : Bornology α\nself : BoundedSpace α\n⊢ Bornology.IsBounded Set.univ","decl":"/-- A space with a `Bornology` is a **bounded space** if `Set.univ : Set α` is bounded. -/\nclass BoundedSpace (α : Type*) [Bornology α] : Prop where\n  /-- The `Set.univ` is bounded. -/\n  bounded_univ : Bornology.IsBounded (univ : Set α)\n\n"}
{"name":"BoundedSpace.of_finite","module":"Mathlib.Topology.Bornology.Basic","initialProofState":"α : Type u_4\ninst✝¹ : Bornology α\ninst✝ : Finite α\n⊢ BoundedSpace α","decl":"/-- A finite space is bounded. -/\ninstance (priority := 100) BoundedSpace.of_finite {α : Type*} [Bornology α] [Finite α] :\n    BoundedSpace α where\n  bounded_univ := (toFinite _).isBounded\n\n"}
{"name":"Bornology.isBounded_univ","module":"Mathlib.Topology.Bornology.Basic","initialProofState":"α : Type u_2\ninst✝ : Bornology α\n⊢ Iff (Bornology.IsBounded Set.univ) (BoundedSpace α)","decl":"theorem isBounded_univ : IsBounded (univ : Set α) ↔ BoundedSpace α :=\n  ⟨fun h => ⟨h⟩, fun h => h.1⟩\n\n"}
{"name":"Bornology.cobounded_eq_bot_iff","module":"Mathlib.Topology.Bornology.Basic","initialProofState":"α : Type u_2\ninst✝ : Bornology α\n⊢ Iff (Eq (Bornology.cobounded α) Bot.bot) (BoundedSpace α)","decl":"theorem cobounded_eq_bot_iff : cobounded α = ⊥ ↔ BoundedSpace α := by\n  rw [← isBounded_univ, isBounded_def, compl_univ, empty_mem_iff_bot]\n\n"}
{"name":"Bornology.IsBounded.all","module":"Mathlib.Topology.Bornology.Basic","initialProofState":"α : Type u_2\ninst✝¹ : Bornology α\ninst✝ : BoundedSpace α\ns : Set α\n⊢ Bornology.IsBounded s","decl":"theorem IsBounded.all (s : Set α) : IsBounded s :=\n  BoundedSpace.bounded_univ.subset s.subset_univ\n\n"}
{"name":"Bornology.IsCobounded.all","module":"Mathlib.Topology.Bornology.Basic","initialProofState":"α : Type u_2\ninst✝¹ : Bornology α\ninst✝ : BoundedSpace α\ns : Set α\n⊢ Bornology.IsCobounded s","decl":"theorem IsCobounded.all (s : Set α) : IsCobounded s :=\n  compl_compl s ▸ IsBounded.all sᶜ\n\n"}
{"name":"Bornology.cobounded_eq_bot","module":"Mathlib.Topology.Bornology.Basic","initialProofState":"α : Type u_2\ninst✝¹ : Bornology α\ninst✝ : BoundedSpace α\n⊢ Eq (Bornology.cobounded α) Bot.bot","decl":"@[simp]\ntheorem cobounded_eq_bot : cobounded α = ⊥ :=\n  cobounded_eq_bot_iff.2 ‹_›\n\n"}
{"name":"OrderDual.isCobounded_preimage_ofDual","module":"Mathlib.Topology.Bornology.Basic","initialProofState":"α : Type u_2\ninst✝ : Bornology α\ns : Set α\n⊢ Iff (Bornology.IsCobounded (Set.preimage (⇑OrderDual.ofDual) s)) (Bornology.IsCobounded s)","decl":"@[simp] lemma isCobounded_preimage_ofDual {s : Set α} :\n    IsCobounded (ofDual ⁻¹' s) ↔ IsCobounded s := Iff.rfl\n\n"}
{"name":"OrderDual.isCobounded_preimage_toDual","module":"Mathlib.Topology.Bornology.Basic","initialProofState":"α : Type u_2\ninst✝ : Bornology α\ns : Set (OrderDual α)\n⊢ Iff (Bornology.IsCobounded (Set.preimage (⇑OrderDual.toDual) s)) (Bornology.IsCobounded s)","decl":"@[simp] lemma isCobounded_preimage_toDual {s : Set αᵒᵈ} :\n    IsCobounded (toDual ⁻¹' s) ↔ IsCobounded s := Iff.rfl\n\n"}
{"name":"OrderDual.isBounded_preimage_ofDual","module":"Mathlib.Topology.Bornology.Basic","initialProofState":"α : Type u_2\ninst✝ : Bornology α\ns : Set α\n⊢ Iff (Bornology.IsBounded (Set.preimage (⇑OrderDual.ofDual) s)) (Bornology.IsBounded s)","decl":"@[simp] lemma isBounded_preimage_ofDual {s : Set α} :\n    IsBounded (ofDual ⁻¹' s) ↔ IsBounded s := Iff.rfl\n\n"}
{"name":"OrderDual.isBounded_preimage_toDual","module":"Mathlib.Topology.Bornology.Basic","initialProofState":"α : Type u_2\ninst✝ : Bornology α\ns : Set (OrderDual α)\n⊢ Iff (Bornology.IsBounded (Set.preimage (⇑OrderDual.toDual) s)) (Bornology.IsBounded s)","decl":"@[simp] lemma isBounded_preimage_toDual {s : Set αᵒᵈ} :\n    IsBounded (toDual ⁻¹' s) ↔ IsBounded s := Iff.rfl\n\n"}
