{"name":"HomologicalComplex.single_obj_X_self","module":"Mathlib.Algebra.Homology.Single","initialProofState":"V : Type u\ninst✝³ : CategoryTheory.Category.{v, u} V\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms V\ninst✝¹ : CategoryTheory.Limits.HasZeroObject V\nι : Type u_1\ninst✝ : DecidableEq ι\nc : ComplexShape ι\nj : ι\nA : V\n⊢ Eq (((HomologicalComplex.single V c j).obj A).X j) A","decl":"@[simp]\nlemma single_obj_X_self (j : ι) (A : V) :\n    ((single V c j).obj A).X j = A := if_pos rfl\n\n"}
{"name":"HomologicalComplex.isZero_single_obj_X","module":"Mathlib.Algebra.Homology.Single","initialProofState":"V : Type u\ninst✝³ : CategoryTheory.Category.{v, u} V\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms V\ninst✝¹ : CategoryTheory.Limits.HasZeroObject V\nι : Type u_1\ninst✝ : DecidableEq ι\nc : ComplexShape ι\nj : ι\nA : V\ni : ι\nhi : Ne i j\n⊢ CategoryTheory.Limits.IsZero (((HomologicalComplex.single V c j).obj A).X i)","decl":"lemma isZero_single_obj_X (j : ι) (A : V) (i : ι) (hi : i ≠ j) :\n    IsZero (((single V c j).obj A).X i) := by\n  dsimp [single]\n  rw [if_neg hi]\n  exact Limits.isZero_zero V\n\n"}
{"name":"HomologicalComplex.single_obj_d","module":"Mathlib.Algebra.Homology.Single","initialProofState":"V : Type u\ninst✝³ : CategoryTheory.Category.{v, u} V\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms V\ninst✝¹ : CategoryTheory.Limits.HasZeroObject V\nι : Type u_1\ninst✝ : DecidableEq ι\nc : ComplexShape ι\nj : ι\nA : V\nk l : ι\n⊢ Eq (((HomologicalComplex.single V c j).obj A).d k l) 0","decl":"@[simp]\nlemma single_obj_d (j : ι) (A : V) (k l : ι) :\n    ((single V c j).obj A).d k l = 0 := rfl\n\n"}
{"name":"HomologicalComplex.single_map_f_self","module":"Mathlib.Algebra.Homology.Single","initialProofState":"V : Type u\ninst✝³ : CategoryTheory.Category.{v, u} V\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms V\ninst✝¹ : CategoryTheory.Limits.HasZeroObject V\nι : Type u_1\ninst✝ : DecidableEq ι\nc : ComplexShape ι\nj : ι\nA B : V\nf : Quiver.Hom A B\n⊢ Eq (((HomologicalComplex.single V c j).map f).f j) (CategoryTheory.CategoryStruct.comp (HomologicalComplex.singleObjXSelf c j A).hom (CategoryTheory.CategoryStruct.comp f (HomologicalComplex.singleObjXSelf c j B).inv))","decl":"@[reassoc]\ntheorem single_map_f_self (j : ι) {A B : V} (f : A ⟶ B) :\n    ((single V c j).map f).f j = (singleObjXSelf c j A).hom ≫\n      f ≫ (singleObjXSelf c j B).inv := by\n  dsimp [single]\n  rw [dif_pos rfl]\n  rfl\n\n"}
{"name":"HomologicalComplex.single_map_f_self_assoc","module":"Mathlib.Algebra.Homology.Single","initialProofState":"V : Type u\ninst✝³ : CategoryTheory.Category.{v, u} V\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms V\ninst✝¹ : CategoryTheory.Limits.HasZeroObject V\nι : Type u_1\ninst✝ : DecidableEq ι\nc : ComplexShape ι\nj : ι\nA B : V\nf : Quiver.Hom A B\nZ : V\nh : Quiver.Hom (((HomologicalComplex.single V c j).obj B).X j) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (((HomologicalComplex.single V c j).map f).f j) h) (CategoryTheory.CategoryStruct.comp (HomologicalComplex.singleObjXSelf c j A).hom (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp (HomologicalComplex.singleObjXSelf c j B).inv h)))","decl":"@[reassoc]\ntheorem single_map_f_self (j : ι) {A B : V} (f : A ⟶ B) :\n    ((single V c j).map f).f j = (singleObjXSelf c j A).hom ≫\n      f ≫ (singleObjXSelf c j B).inv := by\n  dsimp [single]\n  rw [dif_pos rfl]\n  rfl\n\n"}
{"name":"HomologicalComplex.singleCompEvalIsoSelf_inv_app","module":"Mathlib.Algebra.Homology.Single","initialProofState":"V : Type u\ninst✝³ : CategoryTheory.Category.{v, u} V\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms V\ninst✝¹ : CategoryTheory.Limits.HasZeroObject V\nι : Type u_1\ninst✝ : DecidableEq ι\nc : ComplexShape ι\nj : ι\nX : V\n⊢ Eq ((HomologicalComplex.singleCompEvalIsoSelf V c j).inv.app X) (HomologicalComplex.singleObjXSelf c j X).inv","decl":"/-- The natural isomorphism `single V c j ⋙ eval V c j ≅ 𝟭 V`. -/\n@[simps!]\nnoncomputable def singleCompEvalIsoSelf (j : ι) : single V c j ⋙ eval V c j ≅ 𝟭 V :=\n  NatIso.ofComponents (singleObjXSelf c j) (fun {A B} f => by simp [single_map_f_self])\n\n"}
{"name":"HomologicalComplex.singleCompEvalIsoSelf_hom_app","module":"Mathlib.Algebra.Homology.Single","initialProofState":"V : Type u\ninst✝³ : CategoryTheory.Category.{v, u} V\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms V\ninst✝¹ : CategoryTheory.Limits.HasZeroObject V\nι : Type u_1\ninst✝ : DecidableEq ι\nc : ComplexShape ι\nj : ι\nX : V\n⊢ Eq ((HomologicalComplex.singleCompEvalIsoSelf V c j).hom.app X) (HomologicalComplex.singleObjXSelf c j X).hom","decl":"/-- The natural isomorphism `single V c j ⋙ eval V c j ≅ 𝟭 V`. -/\n@[simps!]\nnoncomputable def singleCompEvalIsoSelf (j : ι) : single V c j ⋙ eval V c j ≅ 𝟭 V :=\n  NatIso.ofComponents (singleObjXSelf c j) (fun {A B} f => by simp [single_map_f_self])\n\n"}
{"name":"HomologicalComplex.isZero_single_comp_eval","module":"Mathlib.Algebra.Homology.Single","initialProofState":"V : Type u\ninst✝³ : CategoryTheory.Category.{v, u} V\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms V\ninst✝¹ : CategoryTheory.Limits.HasZeroObject V\nι : Type u_1\ninst✝ : DecidableEq ι\nc : ComplexShape ι\nj i : ι\nhi : Ne i j\n⊢ CategoryTheory.Limits.IsZero ((HomologicalComplex.single V c j).comp (HomologicalComplex.eval V c i))","decl":"lemma isZero_single_comp_eval (j i : ι) (hi : i ≠ j) : IsZero (single V c j ⋙ eval V c i) :=\n  Functor.isZero _ (fun _ ↦ isZero_single_obj_X c _ _ _ hi)\n\n"}
{"name":"HomologicalComplex.from_single_hom_ext_iff","module":"Mathlib.Algebra.Homology.Single","initialProofState":"V : Type u\ninst✝³ : CategoryTheory.Category.{v, u} V\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms V\ninst✝¹ : CategoryTheory.Limits.HasZeroObject V\nι : Type u_1\ninst✝ : DecidableEq ι\nc : ComplexShape ι\nK : HomologicalComplex V c\nj : ι\nA : V\nf g : Quiver.Hom ((HomologicalComplex.single V c j).obj A) K\n⊢ Iff (Eq f g) (Eq (f.f j) (g.f j))","decl":"@[ext]\nlemma from_single_hom_ext {K : HomologicalComplex V c} {j : ι} {A : V}\n    {f g : (single V c j).obj A ⟶ K} (hfg : f.f j = g.f j) : f = g := by\n  ext i\n  by_cases h : i = j\n  · subst h\n    exact hfg\n  · apply (isZero_single_obj_X c j A i h).eq_of_src\n\n"}
{"name":"HomologicalComplex.from_single_hom_ext","module":"Mathlib.Algebra.Homology.Single","initialProofState":"V : Type u\ninst✝³ : CategoryTheory.Category.{v, u} V\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms V\ninst✝¹ : CategoryTheory.Limits.HasZeroObject V\nι : Type u_1\ninst✝ : DecidableEq ι\nc : ComplexShape ι\nK : HomologicalComplex V c\nj : ι\nA : V\nf g : Quiver.Hom ((HomologicalComplex.single V c j).obj A) K\nhfg : Eq (f.f j) (g.f j)\n⊢ Eq f g","decl":"@[ext]\nlemma from_single_hom_ext {K : HomologicalComplex V c} {j : ι} {A : V}\n    {f g : (single V c j).obj A ⟶ K} (hfg : f.f j = g.f j) : f = g := by\n  ext i\n  by_cases h : i = j\n  · subst h\n    exact hfg\n  · apply (isZero_single_obj_X c j A i h).eq_of_src\n\n"}
{"name":"HomologicalComplex.to_single_hom_ext_iff","module":"Mathlib.Algebra.Homology.Single","initialProofState":"V : Type u\ninst✝³ : CategoryTheory.Category.{v, u} V\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms V\ninst✝¹ : CategoryTheory.Limits.HasZeroObject V\nι : Type u_1\ninst✝ : DecidableEq ι\nc : ComplexShape ι\nK : HomologicalComplex V c\nj : ι\nA : V\nf g : Quiver.Hom K ((HomologicalComplex.single V c j).obj A)\n⊢ Iff (Eq f g) (Eq (f.f j) (g.f j))","decl":"@[ext]\nlemma to_single_hom_ext {K : HomologicalComplex V c} {j : ι} {A : V}\n    {f g : K ⟶ (single V c j).obj A} (hfg : f.f j = g.f j) : f = g := by\n  ext i\n  by_cases h : i = j\n  · subst h\n    exact hfg\n  · apply (isZero_single_obj_X c j A i h).eq_of_tgt\n\n"}
{"name":"HomologicalComplex.to_single_hom_ext","module":"Mathlib.Algebra.Homology.Single","initialProofState":"V : Type u\ninst✝³ : CategoryTheory.Category.{v, u} V\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms V\ninst✝¹ : CategoryTheory.Limits.HasZeroObject V\nι : Type u_1\ninst✝ : DecidableEq ι\nc : ComplexShape ι\nK : HomologicalComplex V c\nj : ι\nA : V\nf g : Quiver.Hom K ((HomologicalComplex.single V c j).obj A)\nhfg : Eq (f.f j) (g.f j)\n⊢ Eq f g","decl":"@[ext]\nlemma to_single_hom_ext {K : HomologicalComplex V c} {j : ι} {A : V}\n    {f g : K ⟶ (single V c j).obj A} (hfg : f.f j = g.f j) : f = g := by\n  ext i\n  by_cases h : i = j\n  · subst h\n    exact hfg\n  · apply (isZero_single_obj_X c j A i h).eq_of_tgt\n\n"}
{"name":"HomologicalComplex.instFaithfulSingle","module":"Mathlib.Algebra.Homology.Single","initialProofState":"V : Type u\ninst✝³ : CategoryTheory.Category.{v, u} V\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms V\ninst✝¹ : CategoryTheory.Limits.HasZeroObject V\nι : Type u_1\ninst✝ : DecidableEq ι\nc : ComplexShape ι\nj : ι\n⊢ (HomologicalComplex.single V c j).Faithful","decl":"instance (j : ι) : (single V c j).Faithful where\n  map_injective {A B f g} w := by\n    rw [← cancel_mono (singleObjXSelf c j B).inv,\n      ← cancel_epi (singleObjXSelf c j A).hom, ← single_map_f_self,\n      ← single_map_f_self, w]\n\n"}
{"name":"HomologicalComplex.instFullSingle","module":"Mathlib.Algebra.Homology.Single","initialProofState":"V : Type u\ninst✝³ : CategoryTheory.Category.{v, u} V\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms V\ninst✝¹ : CategoryTheory.Limits.HasZeroObject V\nι : Type u_1\ninst✝ : DecidableEq ι\nc : ComplexShape ι\nj : ι\n⊢ (HomologicalComplex.single V c j).Full","decl":"instance (j : ι) : (single V c j).Full where\n  map_surjective {A B} f :=\n    ⟨(singleObjXSelf c j A).inv ≫ f.f j ≫ (singleObjXSelf c j B).hom, by\n      ext\n      simp [single_map_f_self]⟩\n\n"}
{"name":"HomologicalComplex.mkHomToSingle_f","module":"Mathlib.Algebra.Homology.Single","initialProofState":"V : Type u\ninst✝³ : CategoryTheory.Category.{v, u} V\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms V\ninst✝¹ : CategoryTheory.Limits.HasZeroObject V\nι : Type u_1\ninst✝ : DecidableEq ι\nc : ComplexShape ι\nK : HomologicalComplex V c\nj : ι\nA : V\nφ : Quiver.Hom (K.X j) A\nhφ : ∀ (i : ι), c.Rel i j → Eq (CategoryTheory.CategoryStruct.comp (K.d i j) φ) 0\n⊢ Eq ((HomologicalComplex.mkHomToSingle φ hφ).f j) (CategoryTheory.CategoryStruct.comp φ (HomologicalComplex.singleObjXSelf c j A).inv)","decl":"@[simp]\nlemma mkHomToSingle_f {K : HomologicalComplex V c} {j : ι} {A : V} (φ : K.X j ⟶ A)\n    (hφ : ∀ (i : ι), c.Rel i j → K.d i j ≫ φ = 0) :\n    (mkHomToSingle φ hφ).f j = φ ≫ (singleObjXSelf c j A).inv := by\n  dsimp [mkHomToSingle]\n  rw [dif_pos rfl, id_comp]\n  rfl\n\n"}
{"name":"HomologicalComplex.mkHomFromSingle_f","module":"Mathlib.Algebra.Homology.Single","initialProofState":"V : Type u\ninst✝³ : CategoryTheory.Category.{v, u} V\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms V\ninst✝¹ : CategoryTheory.Limits.HasZeroObject V\nι : Type u_1\ninst✝ : DecidableEq ι\nc : ComplexShape ι\nK : HomologicalComplex V c\nj : ι\nA : V\nφ : Quiver.Hom A (K.X j)\nhφ : ∀ (k : ι), c.Rel j k → Eq (CategoryTheory.CategoryStruct.comp φ (K.d j k)) 0\n⊢ Eq ((HomologicalComplex.mkHomFromSingle φ hφ).f j) (CategoryTheory.CategoryStruct.comp (HomologicalComplex.singleObjXSelf c j A).hom φ)","decl":"@[simp]\nlemma mkHomFromSingle_f {K : HomologicalComplex V c} {j : ι} {A : V} (φ : A ⟶ K.X j)\n    (hφ : ∀ (k : ι), c.Rel j k → φ ≫ K.d j k = 0) :\n    (mkHomFromSingle φ hφ).f j = (singleObjXSelf c j A).hom ≫ φ := by\n  dsimp [mkHomFromSingle]\n  rw [dif_pos rfl, comp_id]\n  rfl\n\n"}
{"name":"HomologicalComplex.instPreservesZeroMorphismsSingle","module":"Mathlib.Algebra.Homology.Single","initialProofState":"V : Type u\ninst✝³ : CategoryTheory.Category.{v, u} V\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms V\ninst✝¹ : CategoryTheory.Limits.HasZeroObject V\nι : Type u_1\ninst✝ : DecidableEq ι\nc : ComplexShape ι\nj : ι\n⊢ (HomologicalComplex.single V c j).PreservesZeroMorphisms","decl":"instance (j : ι) : (single V c j).PreservesZeroMorphisms where\n\n"}
{"name":"ChainComplex.single₀_obj_zero","module":"Mathlib.Algebra.Homology.Single","initialProofState":"V : Type u\ninst✝² : CategoryTheory.Category.{v, u} V\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms V\ninst✝ : CategoryTheory.Limits.HasZeroObject V\nA : V\n⊢ Eq (((ChainComplex.single₀ V).obj A).X 0) A","decl":"@[simp]\nlemma single₀_obj_zero (A : V) :\n    ((single₀ V).obj A).X 0 = A := rfl\n\n"}
{"name":"ChainComplex.single₀_map_f_zero","module":"Mathlib.Algebra.Homology.Single","initialProofState":"V : Type u\ninst✝² : CategoryTheory.Category.{v, u} V\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms V\ninst✝ : CategoryTheory.Limits.HasZeroObject V\nA B : V\nf : Quiver.Hom A B\n⊢ Eq (((ChainComplex.single₀ V).map f).f 0) f","decl":"@[simp]\nlemma single₀_map_f_zero {A B : V} (f : A ⟶ B) :\n    ((single₀ V).map f).f 0 = f := by\n  rw [HomologicalComplex.single_map_f_self]\n  dsimp [HomologicalComplex.singleObjXSelf, HomologicalComplex.singleObjXIsoOfEq]\n  rw [comp_id, id_comp]\n\n\n"}
{"name":"ChainComplex.single₀ObjXSelf","module":"Mathlib.Algebra.Homology.Single","initialProofState":"V : Type u\ninst✝² : CategoryTheory.Category.{v, u} V\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms V\ninst✝ : CategoryTheory.Limits.HasZeroObject V\nX : V\n⊢ Eq (HomologicalComplex.singleObjXSelf (ComplexShape.down Nat) 0 X) (CategoryTheory.Iso.refl (((HomologicalComplex.single V (ComplexShape.down Nat) 0).obj X).X 0))","decl":"@[simp]\nlemma single₀ObjXSelf (X : V) :\n    HomologicalComplex.singleObjXSelf (ComplexShape.down ℕ) 0 X = Iso.refl _ := rfl\n\n"}
{"name":"ChainComplex.toSingle₀Equiv_apply_coe","module":"Mathlib.Algebra.Homology.Single","initialProofState":"V : Type u\ninst✝² : CategoryTheory.Category.{v, u} V\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms V\ninst✝ : CategoryTheory.Limits.HasZeroObject V\nC : ChainComplex V Nat\nX : V\nφ : Quiver.Hom C ((ChainComplex.single₀ V).obj X)\n⊢ Eq (↑((C.toSingle₀Equiv X) φ)) (φ.f 0)","decl":"/-- Morphisms from an `ℕ`-indexed chain complex `C`\nto a single object chain complex with `X` concentrated in degree 0\nare the same as morphisms `f : C.X 0 ⟶ X` such that `C.d 1 0 ≫ f = 0`.\n-/\n@[simps apply_coe]\nnoncomputable def toSingle₀Equiv (C : ChainComplex V ℕ) (X : V) :\n    (C ⟶ (single₀ V).obj X) ≃ { f : C.X 0 ⟶ X // C.d 1 0 ≫ f = 0 } where\n  toFun φ := ⟨φ.f 0, by rw [← φ.comm 1 0, HomologicalComplex.single_obj_d, comp_zero]⟩\n  invFun f := HomologicalComplex.mkHomToSingle f.1 (fun i hi => by\n    obtain rfl : i = 1 := by simpa using hi.symm\n    exact f.2)\n  left_inv φ := by aesop_cat\n  right_inv f := by simp\n\n"}
{"name":"ChainComplex.toSingle₀Equiv_symm_apply_f_zero","module":"Mathlib.Algebra.Homology.Single","initialProofState":"V : Type u\ninst✝² : CategoryTheory.Category.{v, u} V\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms V\ninst✝ : CategoryTheory.Limits.HasZeroObject V\nC : ChainComplex V Nat\nX : V\nf : Quiver.Hom (C.X 0) X\nhf : Eq (CategoryTheory.CategoryStruct.comp (C.d 1 0) f) 0\n⊢ Eq (((C.toSingle₀Equiv X).symm ⟨f, hf⟩).f 0) f","decl":"@[simp]\nlemma toSingle₀Equiv_symm_apply_f_zero {C : ChainComplex V ℕ} {X : V}\n    (f : C.X 0 ⟶ X) (hf : C.d 1 0 ≫ f = 0) :\n    ((toSingle₀Equiv C X).symm ⟨f, hf⟩).f 0 = f := by\n  simp [toSingle₀Equiv]\n\n"}
{"name":"ChainComplex.fromSingle₀Equiv_apply","module":"Mathlib.Algebra.Homology.Single","initialProofState":"V : Type u\ninst✝² : CategoryTheory.Category.{v, u} V\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms V\ninst✝ : CategoryTheory.Limits.HasZeroObject V\nC : ChainComplex V Nat\nX : V\nf : Quiver.Hom ((ChainComplex.single₀ V).obj X) C\n⊢ Eq ((C.fromSingle₀Equiv X) f) (f.f 0)","decl":"/-- Morphisms from a single object chain complex with `X` concentrated in degree 0\nto an `ℕ`-indexed chain complex `C` are the same as morphisms `f : X → C.X 0`.\n-/\n@[simps apply]\nnoncomputable def fromSingle₀Equiv (C : ChainComplex V ℕ) (X : V) :\n    ((single₀ V).obj X ⟶ C) ≃ (X ⟶ C.X 0) where\n  toFun f := f.f 0\n  invFun f := HomologicalComplex.mkHomFromSingle f (fun i hi => by simp at hi)\n  left_inv := by aesop_cat\n  right_inv := by aesop_cat\n\n"}
{"name":"ChainComplex.fromSingle₀Equiv_symm_apply_f_zero","module":"Mathlib.Algebra.Homology.Single","initialProofState":"V : Type u\ninst✝² : CategoryTheory.Category.{v, u} V\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms V\ninst✝ : CategoryTheory.Limits.HasZeroObject V\nC : ChainComplex V Nat\nX : V\nf : Quiver.Hom X (C.X 0)\n⊢ Eq (((C.fromSingle₀Equiv X).symm f).f 0) f","decl":"@[simp]\nlemma fromSingle₀Equiv_symm_apply_f_zero\n    {C : ChainComplex V ℕ} {X : V} (f : X ⟶ C.X 0) :\n    ((fromSingle₀Equiv C X).symm f).f 0 = f := by\n  simp [fromSingle₀Equiv]\n\n"}
{"name":"ChainComplex.fromSingle₀Equiv_symm_apply_f_succ","module":"Mathlib.Algebra.Homology.Single","initialProofState":"V : Type u\ninst✝² : CategoryTheory.Category.{v, u} V\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms V\ninst✝ : CategoryTheory.Limits.HasZeroObject V\nC : ChainComplex V Nat\nX : V\nf : Quiver.Hom X (C.X 0)\nn : Nat\n⊢ Eq (((C.fromSingle₀Equiv X).symm f).f (HAdd.hAdd n 1)) 0","decl":"@[simp]\nlemma fromSingle₀Equiv_symm_apply_f_succ\n    {C : ChainComplex V ℕ} {X : V} (f : X ⟶ C.X 0) (n : ℕ) :\n    ((fromSingle₀Equiv C X).symm f).f (n + 1) = 0 := rfl\n\n"}
{"name":"CochainComplex.single₀_obj_zero","module":"Mathlib.Algebra.Homology.Single","initialProofState":"V : Type u\ninst✝² : CategoryTheory.Category.{v, u} V\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms V\ninst✝ : CategoryTheory.Limits.HasZeroObject V\nA : V\n⊢ Eq (((CochainComplex.single₀ V).obj A).X 0) A","decl":"@[simp]\nlemma single₀_obj_zero (A : V) :\n    ((single₀ V).obj A).X 0 = A := rfl\n\n"}
{"name":"CochainComplex.single₀_map_f_zero","module":"Mathlib.Algebra.Homology.Single","initialProofState":"V : Type u\ninst✝² : CategoryTheory.Category.{v, u} V\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms V\ninst✝ : CategoryTheory.Limits.HasZeroObject V\nA B : V\nf : Quiver.Hom A B\n⊢ Eq (((CochainComplex.single₀ V).map f).f 0) f","decl":"@[simp]\nlemma single₀_map_f_zero {A B : V} (f : A ⟶ B) :\n    ((single₀ V).map f).f 0 = f := by\n  rw [HomologicalComplex.single_map_f_self]\n  dsimp [HomologicalComplex.singleObjXSelf, HomologicalComplex.singleObjXIsoOfEq]\n  rw [comp_id, id_comp]\n\n"}
{"name":"CochainComplex.single₀ObjXSelf","module":"Mathlib.Algebra.Homology.Single","initialProofState":"V : Type u\ninst✝² : CategoryTheory.Category.{v, u} V\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms V\ninst✝ : CategoryTheory.Limits.HasZeroObject V\nX : V\n⊢ Eq (HomologicalComplex.singleObjXSelf (ComplexShape.up Nat) 0 X) (CategoryTheory.Iso.refl (((HomologicalComplex.single V (ComplexShape.up Nat) 0).obj X).X 0))","decl":"@[simp]\nlemma single₀ObjXSelf (X : V) :\n    HomologicalComplex.singleObjXSelf (ComplexShape.up ℕ) 0 X = Iso.refl _ := rfl\n\n"}
{"name":"CochainComplex.fromSingle₀Equiv_apply_coe","module":"Mathlib.Algebra.Homology.Single","initialProofState":"V : Type u\ninst✝² : CategoryTheory.Category.{v, u} V\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms V\ninst✝ : CategoryTheory.Limits.HasZeroObject V\nC : CochainComplex V Nat\nX : V\nφ : Quiver.Hom ((CochainComplex.single₀ V).obj X) C\n⊢ Eq (↑((C.fromSingle₀Equiv X) φ)) (φ.f 0)","decl":"/-- Morphisms from a single object cochain complex with `X` concentrated in degree 0\nto an `ℕ`-indexed cochain complex `C`\nare the same as morphisms `f : X ⟶ C.X 0` such that `f ≫ C.d 0 1 = 0`. -/\n@[simps apply_coe]\nnoncomputable def fromSingle₀Equiv (C : CochainComplex V ℕ) (X : V) :\n    ((single₀ V).obj X ⟶ C) ≃ { f : X ⟶ C.X 0 // f ≫ C.d 0 1 = 0 } where\n  toFun φ := ⟨φ.f 0, by rw [φ.comm 0 1, HomologicalComplex.single_obj_d, zero_comp]⟩\n  invFun f := HomologicalComplex.mkHomFromSingle f.1 (fun i hi => by\n    obtain rfl : i = 1 := by simpa using hi.symm\n    exact f.2)\n  left_inv φ := by aesop_cat\n  right_inv := by aesop_cat\n\n"}
{"name":"CochainComplex.fromSingle₀Equiv_symm_apply_f_zero","module":"Mathlib.Algebra.Homology.Single","initialProofState":"V : Type u\ninst✝² : CategoryTheory.Category.{v, u} V\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms V\ninst✝ : CategoryTheory.Limits.HasZeroObject V\nC : CochainComplex V Nat\nX : V\nf : Quiver.Hom X (C.X 0)\nhf : Eq (CategoryTheory.CategoryStruct.comp f (C.d 0 1)) 0\n⊢ Eq (((C.fromSingle₀Equiv X).symm ⟨f, hf⟩).f 0) f","decl":"@[simp]\nlemma fromSingle₀Equiv_symm_apply_f_zero {C : CochainComplex V ℕ} {X : V}\n    (f : X ⟶ C.X 0) (hf : f ≫ C.d 0 1 = 0) :\n    ((fromSingle₀Equiv C X).symm ⟨f, hf⟩).f 0 = f := by\n  simp [fromSingle₀Equiv]\n\n"}
{"name":"CochainComplex.toSingle₀Equiv_apply","module":"Mathlib.Algebra.Homology.Single","initialProofState":"V : Type u\ninst✝² : CategoryTheory.Category.{v, u} V\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms V\ninst✝ : CategoryTheory.Limits.HasZeroObject V\nC : CochainComplex V Nat\nX : V\nf : Quiver.Hom C ((CochainComplex.single₀ V).obj X)\n⊢ Eq ((C.toSingle₀Equiv X) f) (f.f 0)","decl":"/-- Morphisms to a single object cochain complex with `X` concentrated in degree 0\nto an `ℕ`-indexed cochain complex `C` are the same as morphisms `f : C.X 0 ⟶ X`.\n-/\n@[simps apply]\nnoncomputable def toSingle₀Equiv (C : CochainComplex V ℕ) (X : V) :\n    (C ⟶ (single₀ V).obj X) ≃ (C.X 0 ⟶ X) where\n  toFun f := f.f 0\n  invFun f := HomologicalComplex.mkHomToSingle f (fun i hi => by simp at hi)\n  left_inv := by aesop_cat\n  right_inv := by aesop_cat\n\n"}
{"name":"CochainComplex.toSingle₀Equiv_symm_apply_f_zero","module":"Mathlib.Algebra.Homology.Single","initialProofState":"V : Type u\ninst✝² : CategoryTheory.Category.{v, u} V\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms V\ninst✝ : CategoryTheory.Limits.HasZeroObject V\nC : CochainComplex V Nat\nX : V\nf : Quiver.Hom (C.X 0) X\n⊢ Eq (((C.toSingle₀Equiv X).symm f).f 0) f","decl":"@[simp]\nlemma toSingle₀Equiv_symm_apply_f_zero\n    {C : CochainComplex V ℕ} {X : V} (f : C.X 0 ⟶ X) :\n    ((toSingle₀Equiv C X).symm f).f 0 = f := by\n  simp [toSingle₀Equiv]\n\n"}
{"name":"CochainComplex.toSingle₀Equiv_symm_apply_f_succ","module":"Mathlib.Algebra.Homology.Single","initialProofState":"V : Type u\ninst✝² : CategoryTheory.Category.{v, u} V\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms V\ninst✝ : CategoryTheory.Limits.HasZeroObject V\nC : CochainComplex V Nat\nX : V\nf : Quiver.Hom (C.X 0) X\nn : Nat\n⊢ Eq (((C.toSingle₀Equiv X).symm f).f (HAdd.hAdd n 1)) 0","decl":"@[simp]\nlemma toSingle₀Equiv_symm_apply_f_succ\n    {C : CochainComplex V ℕ} {X : V} (f : C.X 0 ⟶ X) (n : ℕ) :\n    ((toSingle₀Equiv C X).symm f).f (n + 1) = 0 := by\n  rfl\n\n"}
