{"name":"List.Disjoint.symm","module":"Mathlib.Data.List.Lattice","initialProofState":"α : Type u_1\nl₁ l₂ : List α\nd : l₁.Disjoint l₂\n⊢ l₂.Disjoint l₁","decl":"@[symm]\ntheorem Disjoint.symm (d : Disjoint l₁ l₂) : Disjoint l₂ l₁ := fun _ i₂ i₁ => d i₁ i₂\n\n"}
{"name":"List.mem_union_left","module":"Mathlib.Data.List.Lattice","initialProofState":"α : Type u_1\nl₁ : List α\na : α\ninst✝ : DecidableEq α\nh : Membership.mem l₁ a\nl₂ : List α\n⊢ Membership.mem (Union.union l₁ l₂) a","decl":"theorem mem_union_left (h : a ∈ l₁) (l₂ : List α) : a ∈ l₁ ∪ l₂ :=\n  mem_union_iff.2 (Or.inl h)\n\n"}
{"name":"List.mem_union_right","module":"Mathlib.Data.List.Lattice","initialProofState":"α : Type u_1\nl₂ : List α\na : α\ninst✝ : DecidableEq α\nl₁ : List α\nh : Membership.mem l₂ a\n⊢ Membership.mem (Union.union l₁ l₂) a","decl":"theorem mem_union_right (l₁ : List α) (h : a ∈ l₂) : a ∈ l₁ ∪ l₂ :=\n  mem_union_iff.2 (Or.inr h)\n\n"}
{"name":"List.sublist_suffix_of_union","module":"Mathlib.Data.List.Lattice","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl₁ l₂ : List α\n⊢ Exists fun t => And (t.Sublist l₁) (Eq (HAppend.hAppend t l₂) (Union.union l₁ l₂))","decl":"theorem sublist_suffix_of_union : ∀ l₁ l₂ : List α, ∃ t, t <+ l₁ ∧ t ++ l₂ = l₁ ∪ l₂\n  | [], _ => ⟨[], by rfl, rfl⟩\n  | a :: l₁, l₂ =>\n    let ⟨t, s, e⟩ := sublist_suffix_of_union l₁ l₂\n    if h : a ∈ l₁ ∪ l₂ then\n      ⟨t, sublist_cons_of_sublist _ s, by\n        simp only [e, cons_union, insert_of_mem h]⟩\n    else\n      ⟨a :: t, s.cons_cons _, by\n        simp only [cons_append, cons_union, e, insert_of_not_mem h]⟩\n\n"}
{"name":"List.suffix_union_right","module":"Mathlib.Data.List.Lattice","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl₁ l₂ : List α\n⊢ l₂.IsSuffix (Union.union l₁ l₂)","decl":"theorem suffix_union_right (l₁ l₂ : List α) : l₂ <:+ l₁ ∪ l₂ :=\n  (sublist_suffix_of_union l₁ l₂).imp fun _ => And.right\n\n"}
{"name":"List.union_sublist_append","module":"Mathlib.Data.List.Lattice","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl₁ l₂ : List α\n⊢ (Union.union l₁ l₂).Sublist (HAppend.hAppend l₁ l₂)","decl":"theorem union_sublist_append (l₁ l₂ : List α) : l₁ ∪ l₂ <+ l₁ ++ l₂ :=\n  let ⟨_, s, e⟩ := sublist_suffix_of_union l₁ l₂\n  e ▸ (append_sublist_append_right _).2 s\n\n"}
{"name":"List.forall_mem_union","module":"Mathlib.Data.List.Lattice","initialProofState":"α : Type u_1\nl₁ l₂ : List α\np : α → Prop\ninst✝ : DecidableEq α\n⊢ Iff (∀ (x : α), Membership.mem (Union.union l₁ l₂) x → p x) (And (∀ (x : α), Membership.mem l₁ x → p x) (∀ (x : α), Membership.mem l₂ x → p x))","decl":"theorem forall_mem_union : (∀ x ∈ l₁ ∪ l₂, p x) ↔ (∀ x ∈ l₁, p x) ∧ ∀ x ∈ l₂, p x := by\n  simp only [mem_union_iff, or_imp, forall_and]\n\n"}
{"name":"List.forall_mem_of_forall_mem_union_left","module":"Mathlib.Data.List.Lattice","initialProofState":"α : Type u_1\nl₁ l₂ : List α\np : α → Prop\ninst✝ : DecidableEq α\nh : ∀ (x : α), Membership.mem (Union.union l₁ l₂) x → p x\nx : α\na✝ : Membership.mem l₁ x\n⊢ p x","decl":"theorem forall_mem_of_forall_mem_union_left (h : ∀ x ∈ l₁ ∪ l₂, p x) : ∀ x ∈ l₁, p x :=\n  (forall_mem_union.1 h).1\n\n"}
{"name":"List.forall_mem_of_forall_mem_union_right","module":"Mathlib.Data.List.Lattice","initialProofState":"α : Type u_1\nl₁ l₂ : List α\np : α → Prop\ninst✝ : DecidableEq α\nh : ∀ (x : α), Membership.mem (Union.union l₁ l₂) x → p x\nx : α\na✝ : Membership.mem l₂ x\n⊢ p x","decl":"theorem forall_mem_of_forall_mem_union_right (h : ∀ x ∈ l₁ ∪ l₂, p x) : ∀ x ∈ l₂, p x :=\n  (forall_mem_union.1 h).2\n\n"}
{"name":"List.Subset.union_eq_right","module":"Mathlib.Data.List.Lattice","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nxs ys : List α\nh : HasSubset.Subset xs ys\n⊢ Eq (Union.union xs ys) ys","decl":"theorem Subset.union_eq_right {xs ys : List α} (h : xs ⊆ ys) : xs ∪ ys = ys := by\n  induction xs with\n  | nil => simp\n  | cons x xs ih =>\n    rw [cons_union, insert_of_mem <| mem_union_right _ <| h <| mem_cons_self _ _,\n      ih <| subset_of_cons_subset h]\n\n"}
{"name":"List.inter_nil","module":"Mathlib.Data.List.Lattice","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl : List α\n⊢ Eq (Inter.inter List.nil l) List.nil","decl":"@[simp]\ntheorem inter_nil (l : List α) : [] ∩ l = [] :=\n  rfl\n\n"}
{"name":"List.inter_cons_of_mem","module":"Mathlib.Data.List.Lattice","initialProofState":"α : Type u_1\nl₂ : List α\na : α\ninst✝ : DecidableEq α\nl₁ : List α\nh : Membership.mem l₂ a\n⊢ Eq (Inter.inter (List.cons a l₁) l₂) (List.cons a (Inter.inter l₁ l₂))","decl":"@[simp]\ntheorem inter_cons_of_mem (l₁ : List α) (h : a ∈ l₂) : (a :: l₁) ∩ l₂ = a :: l₁ ∩ l₂ := by\n  simp [Inter.inter, List.inter, h]\n\n"}
{"name":"List.inter_cons_of_not_mem","module":"Mathlib.Data.List.Lattice","initialProofState":"α : Type u_1\nl₂ : List α\na : α\ninst✝ : DecidableEq α\nl₁ : List α\nh : Not (Membership.mem l₂ a)\n⊢ Eq (Inter.inter (List.cons a l₁) l₂) (Inter.inter l₁ l₂)","decl":"@[simp]\ntheorem inter_cons_of_not_mem (l₁ : List α) (h : a ∉ l₂) : (a :: l₁) ∩ l₂ = l₁ ∩ l₂ := by\n  simp [Inter.inter, List.inter, h]\n\n"}
{"name":"List.inter_nil'","module":"Mathlib.Data.List.Lattice","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl : List α\n⊢ Eq (Inter.inter l List.nil) List.nil","decl":"@[simp]\ntheorem inter_nil' (l : List α) : l ∩ [] = [] := by\n  induction l with\n  | nil => rfl\n  | cons x xs ih => by_cases x ∈ xs <;> simp [ih]\n\n"}
{"name":"List.mem_of_mem_inter_left","module":"Mathlib.Data.List.Lattice","initialProofState":"α : Type u_1\nl₁ l₂ : List α\na : α\ninst✝ : DecidableEq α\na✝ : Membership.mem (Inter.inter l₁ l₂) a\n⊢ Membership.mem l₁ a","decl":"theorem mem_of_mem_inter_left : a ∈ l₁ ∩ l₂ → a ∈ l₁ :=\n  mem_of_mem_filter\n\n"}
{"name":"List.mem_of_mem_inter_right","module":"Mathlib.Data.List.Lattice","initialProofState":"α : Type u_1\nl₁ l₂ : List α\na : α\ninst✝ : DecidableEq α\nh : Membership.mem (Inter.inter l₁ l₂) a\n⊢ Membership.mem l₂ a","decl":"theorem mem_of_mem_inter_right (h : a ∈ l₁ ∩ l₂) : a ∈ l₂ := by simpa using of_mem_filter h\n\n"}
{"name":"List.mem_inter_of_mem_of_mem","module":"Mathlib.Data.List.Lattice","initialProofState":"α : Type u_1\nl₁ l₂ : List α\na : α\ninst✝ : DecidableEq α\nh₁ : Membership.mem l₁ a\nh₂ : Membership.mem l₂ a\n⊢ Membership.mem (Inter.inter l₁ l₂) a","decl":"theorem mem_inter_of_mem_of_mem (h₁ : a ∈ l₁) (h₂ : a ∈ l₂) : a ∈ l₁ ∩ l₂ :=\n  mem_filter_of_mem h₁ <| by simpa using h₂\n\n"}
{"name":"List.inter_subset_left","module":"Mathlib.Data.List.Lattice","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl₁ l₂ : List α\n⊢ HasSubset.Subset (Inter.inter l₁ l₂) l₁","decl":"theorem inter_subset_left {l₁ l₂ : List α} : l₁ ∩ l₂ ⊆ l₁ :=\n  filter_subset' _\n\n"}
{"name":"List.inter_subset_right","module":"Mathlib.Data.List.Lattice","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl₁ l₂ : List α\n⊢ HasSubset.Subset (Inter.inter l₁ l₂) l₂","decl":"theorem inter_subset_right {l₁ l₂ : List α} : l₁ ∩ l₂ ⊆ l₂ := fun _ => mem_of_mem_inter_right\n\n"}
{"name":"List.subset_inter","module":"Mathlib.Data.List.Lattice","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl l₁ l₂ : List α\nh₁ : HasSubset.Subset l l₁\nh₂ : HasSubset.Subset l l₂\n⊢ HasSubset.Subset l (Inter.inter l₁ l₂)","decl":"theorem subset_inter {l l₁ l₂ : List α} (h₁ : l ⊆ l₁) (h₂ : l ⊆ l₂) : l ⊆ l₁ ∩ l₂ := fun _ h =>\n  mem_inter_iff.2 ⟨h₁ h, h₂ h⟩\n\n"}
{"name":"List.inter_eq_nil_iff_disjoint","module":"Mathlib.Data.List.Lattice","initialProofState":"α : Type u_1\nl₁ l₂ : List α\ninst✝ : DecidableEq α\n⊢ Iff (Eq (Inter.inter l₁ l₂) List.nil) (l₁.Disjoint l₂)","decl":"theorem inter_eq_nil_iff_disjoint : l₁ ∩ l₂ = [] ↔ Disjoint l₁ l₂ := by\n  simp only [eq_nil_iff_forall_not_mem, mem_inter_iff, not_and]\n  rfl\n\n"}
{"name":"List.Disjoint.inter_eq_nil","module":"Mathlib.Data.List.Lattice","initialProofState":"α : Type u_1\nl₁ l₂ : List α\ninst✝ : DecidableEq α\na✝ : l₁.Disjoint l₂\n⊢ Eq (Inter.inter l₁ l₂) List.nil","decl":"alias ⟨_, Disjoint.inter_eq_nil⟩ := inter_eq_nil_iff_disjoint\n\n"}
{"name":"List.forall_mem_inter_of_forall_left","module":"Mathlib.Data.List.Lattice","initialProofState":"α : Type u_1\nl₁ : List α\np : α → Prop\ninst✝ : DecidableEq α\nh : ∀ (x : α), Membership.mem l₁ x → p x\nl₂ : List α\nx : α\na✝ : Membership.mem (Inter.inter l₁ l₂) x\n⊢ p x","decl":"theorem forall_mem_inter_of_forall_left (h : ∀ x ∈ l₁, p x) (l₂ : List α) :\n    ∀ x, x ∈ l₁ ∩ l₂ → p x :=\n  BAll.imp_left (fun _ => mem_of_mem_inter_left) h\n\n"}
{"name":"List.forall_mem_inter_of_forall_right","module":"Mathlib.Data.List.Lattice","initialProofState":"α : Type u_1\nl₂ : List α\np : α → Prop\ninst✝ : DecidableEq α\nl₁ : List α\nh : ∀ (x : α), Membership.mem l₂ x → p x\nx : α\na✝ : Membership.mem (Inter.inter l₁ l₂) x\n⊢ p x","decl":"theorem forall_mem_inter_of_forall_right (l₁ : List α) (h : ∀ x ∈ l₂, p x) :\n    ∀ x, x ∈ l₁ ∩ l₂ → p x :=\n  BAll.imp_left (fun _ => mem_of_mem_inter_right) h\n\n"}
{"name":"List.inter_reverse","module":"Mathlib.Data.List.Lattice","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nxs ys : List α\n⊢ Eq (xs.inter ys.reverse) (xs.inter ys)","decl":"@[simp]\ntheorem inter_reverse {xs ys : List α} : xs.inter ys.reverse = xs.inter ys := by\n  simp only [List.inter, elem_eq_mem, mem_reverse]\n\n"}
{"name":"List.Subset.inter_eq_left","module":"Mathlib.Data.List.Lattice","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nxs ys : List α\nh : HasSubset.Subset xs ys\n⊢ Eq (Inter.inter xs ys) xs","decl":"theorem Subset.inter_eq_left {xs ys : List α} (h : xs ⊆ ys) : xs ∩ ys = xs :=\n  List.filter_eq_self.mpr fun _ ha => elem_eq_true_of_mem (h ha)\n\n"}
{"name":"List.nil_bagInter","module":"Mathlib.Data.List.Lattice","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl : List α\n⊢ Eq (List.nil.bagInter l) List.nil","decl":"@[simp]\ntheorem nil_bagInter (l : List α) : [].bagInter l = [] := by cases l <;> rfl\n\n"}
{"name":"List.bagInter_nil","module":"Mathlib.Data.List.Lattice","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl : List α\n⊢ Eq (l.bagInter List.nil) List.nil","decl":"@[simp]\ntheorem bagInter_nil (l : List α) : l.bagInter [] = [] := by cases l <;> rfl\n\n"}
{"name":"List.cons_bagInter_of_pos","module":"Mathlib.Data.List.Lattice","initialProofState":"α : Type u_1\nl₂ : List α\na : α\ninst✝ : DecidableEq α\nl₁ : List α\nh : Membership.mem l₂ a\n⊢ Eq ((List.cons a l₁).bagInter l₂) (List.cons a (l₁.bagInter (l₂.erase a)))","decl":"@[simp]\ntheorem cons_bagInter_of_pos (l₁ : List α) (h : a ∈ l₂) :\n    (a :: l₁).bagInter l₂ = a :: l₁.bagInter (l₂.erase a) := by\n  cases l₂\n  · exact if_pos h\n  · simp only [List.bagInter, if_pos (elem_eq_true_of_mem h)]\n\n"}
{"name":"List.cons_bagInter_of_neg","module":"Mathlib.Data.List.Lattice","initialProofState":"α : Type u_1\nl₂ : List α\na : α\ninst✝ : DecidableEq α\nl₁ : List α\nh : Not (Membership.mem l₂ a)\n⊢ Eq ((List.cons a l₁).bagInter l₂) (l₁.bagInter l₂)","decl":"@[simp]\ntheorem cons_bagInter_of_neg (l₁ : List α) (h : a ∉ l₂) :\n    (a :: l₁).bagInter l₂ = l₁.bagInter l₂ := by\n  cases l₂; · simp only [bagInter_nil]\n  simp only [erase_of_not_mem h, List.bagInter, if_neg (mt mem_of_elem_eq_true h)]\n\n"}
{"name":"List.mem_bagInter","module":"Mathlib.Data.List.Lattice","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\nl₁ l₂ : List α\n⊢ Iff (Membership.mem (l₁.bagInter l₂) a) (And (Membership.mem l₁ a) (Membership.mem l₂ a))","decl":"@[simp]\ntheorem mem_bagInter {a : α} : ∀ {l₁ l₂ : List α}, a ∈ l₁.bagInter l₂ ↔ a ∈ l₁ ∧ a ∈ l₂\n  | [], l₂ => by simp only [nil_bagInter, not_mem_nil, false_and]\n  | b :: l₁, l₂ => by\n    by_cases h : b ∈ l₂\n    · rw [cons_bagInter_of_pos _ h, mem_cons, mem_cons, mem_bagInter]\n      by_cases ba : a = b\n      · simp only [ba, h, eq_self_iff_true, true_or, true_and]\n      · simp only [mem_erase_of_ne ba, ba, false_or]\n    · rw [cons_bagInter_of_neg _ h, mem_bagInter, mem_cons, or_and_right]\n      symm\n      apply or_iff_right_of_imp\n      rintro ⟨rfl, h'⟩\n      exact h.elim h'\n\n"}
{"name":"List.count_bagInter","module":"Mathlib.Data.List.Lattice","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\nl₁ l₂ : List α\n⊢ Eq (List.count a (l₁.bagInter l₂)) (Min.min (List.count a l₁) (List.count a l₂))","decl":"@[simp]\ntheorem count_bagInter {a : α} :\n    ∀ {l₁ l₂ : List α}, count a (l₁.bagInter l₂) = min (count a l₁) (count a l₂)\n  | [], l₂ => by simp\n  | l₁, [] => by simp\n  | b :: l₁, l₂ => by\n    by_cases hb : b ∈ l₂\n    · rw [cons_bagInter_of_pos _ hb, count_cons, count_cons, count_bagInter, count_erase,\n        ← Nat.add_min_add_right]\n      by_cases ba : b = a\n      · simp only [beq_iff_eq]\n        rw [if_pos ba, Nat.sub_add_cancel]\n        rwa [succ_le_iff, count_pos_iff, ← ba]\n      · simp only [beq_iff_eq]\n        rw [if_neg ba, Nat.sub_zero, Nat.add_zero, Nat.add_zero]\n    · rw [cons_bagInter_of_neg _ hb, count_bagInter]\n      by_cases ab : a = b\n      · rw [← ab] at hb\n        rw [count_eq_zero.2 hb, Nat.min_zero, Nat.min_zero]\n      · rw [count_cons_of_ne ab]\n\n"}
{"name":"List.bagInter_sublist_left","module":"Mathlib.Data.List.Lattice","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl₁ l₂ : List α\n⊢ (l₁.bagInter l₂).Sublist l₁","decl":"theorem bagInter_sublist_left : ∀ l₁ l₂ : List α, l₁.bagInter l₂ <+ l₁\n  | [], l₂ => by simp\n  | b :: l₁, l₂ => by\n    by_cases h : b ∈ l₂ <;> simp only [h, cons_bagInter_of_pos, cons_bagInter_of_neg, not_false_iff]\n    · exact (bagInter_sublist_left _ _).cons_cons _\n    · apply sublist_cons_of_sublist\n      apply bagInter_sublist_left\n\n"}
{"name":"List.bagInter_nil_iff_inter_nil","module":"Mathlib.Data.List.Lattice","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl₁ l₂ : List α\n⊢ Iff (Eq (l₁.bagInter l₂) List.nil) (Eq (Inter.inter l₁ l₂) List.nil)","decl":"theorem bagInter_nil_iff_inter_nil : ∀ l₁ l₂ : List α, l₁.bagInter l₂ = [] ↔ l₁ ∩ l₂ = []\n  | [], l₂ => by simp\n  | b :: l₁, l₂ => by\n    by_cases h : b ∈ l₂\n    · simp [h]\n    · simpa [h] using bagInter_nil_iff_inter_nil l₁ l₂\n\n"}
