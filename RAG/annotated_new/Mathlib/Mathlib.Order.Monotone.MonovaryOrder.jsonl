{"name":"instIsStrictTotalOrderMonovaryOrder","module":"Mathlib.Order.Monotone.MonovaryOrder","initialProofState":"ι : Type u_1\nα : Type u_3\nβ : Type u_4\ninst✝¹ : LinearOrder α\ninst✝ : LinearOrder β\nf : ι → α\ng : ι → β\n⊢ IsStrictTotalOrder ι (MonovaryOrder f g)","decl":"instance : IsStrictTotalOrder ι (MonovaryOrder f g)\n    where\n  trichotomous i j := by\n    convert trichotomous_of (Prod.Lex (· < ·) <| Prod.Lex (· < ·) WellOrderingRel) _ _\n    · simp only [Prod.ext_iff, ← and_assoc, imp_and, eq_iff_iff, iff_and_self]\n      exact ⟨congr_arg _, congr_arg _⟩\n    · infer_instance\n  irrefl i := by rw [MonovaryOrder]; exact irrefl _\n  trans i j k := by rw [MonovaryOrder]; exact _root_.trans\n\n"}
{"name":"monovaryOn_iff_exists_monotoneOn","module":"Mathlib.Order.Monotone.MonovaryOrder","initialProofState":"ι : Type u_1\nα : Type u_3\nβ : Type u_4\ninst✝¹ : LinearOrder α\ninst✝ : LinearOrder β\nf : ι → α\ng : ι → β\ns : Set ι\n⊢ Iff (MonovaryOn f g s) (Exists fun x => And (MonotoneOn f s) (MonotoneOn g s))","decl":"lemma monovaryOn_iff_exists_monotoneOn :\n    MonovaryOn f g s ↔ ∃ (_ : LinearOrder ι), MonotoneOn f s ∧ MonotoneOn g s := by\n  classical\n  letI := linearOrderOfSTO (MonovaryOrder f g)\n  refine ⟨fun hfg => ⟨‹_›, monotoneOn_iff_forall_lt.2 fun i hi j hj hij => ?_,\n    monotoneOn_iff_forall_lt.2 fun i hi j hj hij => ?_⟩, ?_⟩\n  · obtain h | ⟨h, -⟩ := Prod.lex_iff.1 hij <;> exact h.le\n  · obtain h | ⟨-, h⟩ := Prod.lex_iff.1 hij\n    · exact hfg.symm hi hj h\n    obtain h | ⟨h, -⟩ := Prod.lex_iff.1 h <;> exact h.le\n  · rintro ⟨_, hf, hg⟩\n    exact hf.monovaryOn hg\n\n"}
{"name":"antivaryOn_iff_exists_monotoneOn_antitoneOn","module":"Mathlib.Order.Monotone.MonovaryOrder","initialProofState":"ι : Type u_1\nα : Type u_3\nβ : Type u_4\ninst✝¹ : LinearOrder α\ninst✝ : LinearOrder β\nf : ι → α\ng : ι → β\ns : Set ι\n⊢ Iff (AntivaryOn f g s) (Exists fun x => And (MonotoneOn f s) (AntitoneOn g s))","decl":"lemma antivaryOn_iff_exists_monotoneOn_antitoneOn :\n    AntivaryOn f g s ↔ ∃ (_ : LinearOrder ι), MonotoneOn f s ∧ AntitoneOn g s := by\n  simp_rw [← monovaryOn_toDual_right, monovaryOn_iff_exists_monotoneOn, monotoneOn_toDual_comp_iff]\n\n"}
{"name":"monovaryOn_iff_exists_antitoneOn","module":"Mathlib.Order.Monotone.MonovaryOrder","initialProofState":"ι : Type u_1\nα : Type u_3\nβ : Type u_4\ninst✝¹ : LinearOrder α\ninst✝ : LinearOrder β\nf : ι → α\ng : ι → β\ns : Set ι\n⊢ Iff (MonovaryOn f g s) (Exists fun x => And (AntitoneOn f s) (AntitoneOn g s))","decl":"lemma monovaryOn_iff_exists_antitoneOn :\n    MonovaryOn f g s ↔ ∃ (_ : LinearOrder ι), AntitoneOn f s ∧ AntitoneOn g s := by\n  simp_rw [← antivaryOn_toDual_left, antivaryOn_iff_exists_monotoneOn_antitoneOn,\n    monotoneOn_toDual_comp_iff]\n\n"}
{"name":"antivaryOn_iff_exists_antitoneOn_monotoneOn","module":"Mathlib.Order.Monotone.MonovaryOrder","initialProofState":"ι : Type u_1\nα : Type u_3\nβ : Type u_4\ninst✝¹ : LinearOrder α\ninst✝ : LinearOrder β\nf : ι → α\ng : ι → β\ns : Set ι\n⊢ Iff (AntivaryOn f g s) (Exists fun x => And (AntitoneOn f s) (MonotoneOn g s))","decl":"lemma antivaryOn_iff_exists_antitoneOn_monotoneOn :\n    AntivaryOn f g s ↔ ∃ (_ : LinearOrder ι), AntitoneOn f s ∧ MonotoneOn g s := by\n  simp_rw [← monovaryOn_toDual_left, monovaryOn_iff_exists_monotoneOn, monotoneOn_toDual_comp_iff]\n\n"}
{"name":"monovary_iff_exists_monotone","module":"Mathlib.Order.Monotone.MonovaryOrder","initialProofState":"ι : Type u_1\nα : Type u_3\nβ : Type u_4\ninst✝¹ : LinearOrder α\ninst✝ : LinearOrder β\nf : ι → α\ng : ι → β\n⊢ Iff (Monovary f g) (Exists fun x => And (Monotone f) (Monotone g))","decl":"lemma monovary_iff_exists_monotone :\n    Monovary f g ↔ ∃ (_ : LinearOrder ι), Monotone f ∧ Monotone g := by\n  simp [← monovaryOn_univ, monovaryOn_iff_exists_monotoneOn]\n\n"}
{"name":"monovary_iff_exists_antitone","module":"Mathlib.Order.Monotone.MonovaryOrder","initialProofState":"ι : Type u_1\nα : Type u_3\nβ : Type u_4\ninst✝¹ : LinearOrder α\ninst✝ : LinearOrder β\nf : ι → α\ng : ι → β\n⊢ Iff (Monovary f g) (Exists fun x => And (Antitone f) (Antitone g))","decl":"lemma monovary_iff_exists_antitone :\n    Monovary f g ↔ ∃ (_ : LinearOrder ι), Antitone f ∧ Antitone g := by\n  simp [← monovaryOn_univ, monovaryOn_iff_exists_antitoneOn]\n\n"}
{"name":"antivary_iff_exists_monotone_antitone","module":"Mathlib.Order.Monotone.MonovaryOrder","initialProofState":"ι : Type u_1\nα : Type u_3\nβ : Type u_4\ninst✝¹ : LinearOrder α\ninst✝ : LinearOrder β\nf : ι → α\ng : ι → β\n⊢ Iff (Antivary f g) (Exists fun x => And (Monotone f) (Antitone g))","decl":"lemma antivary_iff_exists_monotone_antitone :\n    Antivary f g ↔ ∃ (_ : LinearOrder ι), Monotone f ∧ Antitone g := by\n  simp [← antivaryOn_univ, antivaryOn_iff_exists_monotoneOn_antitoneOn]\n\n"}
{"name":"antivary_iff_exists_antitone_monotone","module":"Mathlib.Order.Monotone.MonovaryOrder","initialProofState":"ι : Type u_1\nα : Type u_3\nβ : Type u_4\ninst✝¹ : LinearOrder α\ninst✝ : LinearOrder β\nf : ι → α\ng : ι → β\n⊢ Iff (Antivary f g) (Exists fun x => And (Antitone f) (Monotone g))","decl":"lemma antivary_iff_exists_antitone_monotone :\n    Antivary f g ↔ ∃ (_ : LinearOrder ι), Antitone f ∧ Monotone g := by\n  simp [← antivaryOn_univ, antivaryOn_iff_exists_antitoneOn_monotoneOn]\n\n"}
{"name":"MonovaryOn.exists_monotoneOn","module":"Mathlib.Order.Monotone.MonovaryOrder","initialProofState":"ι : Type u_1\nα : Type u_3\nβ : Type u_4\ninst✝¹ : LinearOrder α\ninst✝ : LinearOrder β\nf : ι → α\ng : ι → β\ns : Set ι\na✝ : MonovaryOn f g s\n⊢ Exists fun x => And (MonotoneOn f s) (MonotoneOn g s)","decl":"alias ⟨MonovaryOn.exists_monotoneOn, _⟩ := monovaryOn_iff_exists_monotoneOn\n"}
{"name":"MonovaryOn.exists_antitoneOn","module":"Mathlib.Order.Monotone.MonovaryOrder","initialProofState":"ι : Type u_1\nα : Type u_3\nβ : Type u_4\ninst✝¹ : LinearOrder α\ninst✝ : LinearOrder β\nf : ι → α\ng : ι → β\ns : Set ι\na✝ : MonovaryOn f g s\n⊢ Exists fun x => And (AntitoneOn f s) (AntitoneOn g s)","decl":"alias ⟨MonovaryOn.exists_antitoneOn, _⟩ := monovaryOn_iff_exists_antitoneOn\n"}
{"name":"AntivaryOn.exists_monotoneOn_antitoneOn","module":"Mathlib.Order.Monotone.MonovaryOrder","initialProofState":"ι : Type u_1\nα : Type u_3\nβ : Type u_4\ninst✝¹ : LinearOrder α\ninst✝ : LinearOrder β\nf : ι → α\ng : ι → β\ns : Set ι\na✝ : AntivaryOn f g s\n⊢ Exists fun x => And (MonotoneOn f s) (AntitoneOn g s)","decl":"alias ⟨AntivaryOn.exists_monotoneOn_antitoneOn, _⟩ := antivaryOn_iff_exists_monotoneOn_antitoneOn\n"}
{"name":"AntivaryOn.exists_antitoneOn_monotoneOn","module":"Mathlib.Order.Monotone.MonovaryOrder","initialProofState":"ι : Type u_1\nα : Type u_3\nβ : Type u_4\ninst✝¹ : LinearOrder α\ninst✝ : LinearOrder β\nf : ι → α\ng : ι → β\ns : Set ι\na✝ : AntivaryOn f g s\n⊢ Exists fun x => And (AntitoneOn f s) (MonotoneOn g s)","decl":"alias ⟨AntivaryOn.exists_antitoneOn_monotoneOn, _⟩ := antivaryOn_iff_exists_antitoneOn_monotoneOn\n"}
{"name":"Monovary.exists_monotone","module":"Mathlib.Order.Monotone.MonovaryOrder","initialProofState":"ι : Type u_1\nα : Type u_3\nβ : Type u_4\ninst✝¹ : LinearOrder α\ninst✝ : LinearOrder β\nf : ι → α\ng : ι → β\na✝ : Monovary f g\n⊢ Exists fun x => And (Monotone f) (Monotone g)","decl":"alias ⟨Monovary.exists_monotone, _⟩ := monovary_iff_exists_monotone\n"}
{"name":"Monovary.exists_antitone","module":"Mathlib.Order.Monotone.MonovaryOrder","initialProofState":"ι : Type u_1\nα : Type u_3\nβ : Type u_4\ninst✝¹ : LinearOrder α\ninst✝ : LinearOrder β\nf : ι → α\ng : ι → β\na✝ : Monovary f g\n⊢ Exists fun x => And (Antitone f) (Antitone g)","decl":"alias ⟨Monovary.exists_antitone, _⟩ := monovary_iff_exists_antitone\n"}
{"name":"Antivary.exists_monotone_antitone","module":"Mathlib.Order.Monotone.MonovaryOrder","initialProofState":"ι : Type u_1\nα : Type u_3\nβ : Type u_4\ninst✝¹ : LinearOrder α\ninst✝ : LinearOrder β\nf : ι → α\ng : ι → β\na✝ : Antivary f g\n⊢ Exists fun x => And (Monotone f) (Antitone g)","decl":"alias ⟨Antivary.exists_monotone_antitone, _⟩ := antivary_iff_exists_monotone_antitone\n"}
{"name":"Antivary.exists_antitone_monotone","module":"Mathlib.Order.Monotone.MonovaryOrder","initialProofState":"ι : Type u_1\nα : Type u_3\nβ : Type u_4\ninst✝¹ : LinearOrder α\ninst✝ : LinearOrder β\nf : ι → α\ng : ι → β\na✝ : Antivary f g\n⊢ Exists fun x => And (Antitone f) (Monotone g)","decl":"alias ⟨Antivary.exists_antitone_monotone, _⟩ := antivary_iff_exists_antitone_monotone\n\n"}
