{"name":"PolishSpace.toSecondCountableTopology","module":"Mathlib.Topology.MetricSpace.Polish","initialProofState":"Œ± : Type u_3\nh : TopologicalSpace Œ±\nself : PolishSpace Œ±\n‚ä¢ SecondCountableTopology Œ±","decl":"/-- A Polish space is a topological space with second countable topology, that can be endowed\nwith a metric for which it is complete.\nWe register an instance from complete second countable metric space to polish space, and not the\nother way around as this is the most common use case.\n\nTo endow a Polish space with a complete metric space structure, do `letI := upgradePolishSpace Œ±`.\n-/\nclass PolishSpace (Œ± : Type*) [h : TopologicalSpace Œ±]\n    extends SecondCountableTopology Œ± : Prop where\n  complete : ‚àÉ m : MetricSpace Œ±, m.toUniformSpace.toTopologicalSpace = h ‚àß\n    @CompleteSpace Œ± m.toUniformSpace\n\n"}
{"name":"PolishSpace.complete","module":"Mathlib.Topology.MetricSpace.Polish","initialProofState":"Œ± : Type u_3\nh : TopologicalSpace Œ±\nself : PolishSpace Œ±\n‚ä¢ Exists fun m => And (Eq UniformSpace.toTopologicalSpace h) (CompleteSpace Œ±)","decl":"/-- A Polish space is a topological space with second countable topology, that can be endowed\nwith a metric for which it is complete.\nWe register an instance from complete second countable metric space to polish space, and not the\nother way around as this is the most common use case.\n\nTo endow a Polish space with a complete metric space structure, do `letI := upgradePolishSpace Œ±`.\n-/\nclass PolishSpace (Œ± : Type*) [h : TopologicalSpace Œ±]\n    extends SecondCountableTopology Œ± : Prop where\n  complete : ‚àÉ m : MetricSpace Œ±, m.toUniformSpace.toTopologicalSpace = h ‚àß\n    @CompleteSpace Œ± m.toUniformSpace\n\n"}
{"name":"UpgradedPolishSpace.toCompleteSpace","module":"Mathlib.Topology.MetricSpace.Polish","initialProofState":"Œ± : Type u_3\nself : UpgradedPolishSpace Œ±\n‚ä¢ CompleteSpace Œ±","decl":"/-- A convenience class, for a Polish space endowed with a complete metric. No instance of this\nclass should be registered: It should be used as `letI := upgradePolishSpace Œ±` to endow a Polish\nspace with a complete metric. -/\nclass UpgradedPolishSpace (Œ± : Type*) extends MetricSpace Œ±, SecondCountableTopology Œ±,\n  CompleteSpace Œ±\n\n"}
{"name":"UpgradedPolishSpace.toSecondCountableTopology","module":"Mathlib.Topology.MetricSpace.Polish","initialProofState":"Œ± : Type u_3\nself : UpgradedPolishSpace Œ±\n‚ä¢ SecondCountableTopology Œ±","decl":"/-- A convenience class, for a Polish space endowed with a complete metric. No instance of this\nclass should be registered: It should be used as `letI := upgradePolishSpace Œ±` to endow a Polish\nspace with a complete metric. -/\nclass UpgradedPolishSpace (Œ± : Type*) extends MetricSpace Œ±, SecondCountableTopology Œ±,\n  CompleteSpace Œ±\n\n"}
{"name":"PolishSpace.of_separableSpace_completeSpace_metrizable","module":"Mathlib.Topology.MetricSpace.Polish","initialProofState":"Œ± : Type u_1\ninst‚úù‚Å¥ : UniformSpace Œ±\ninst‚úù¬≥ : TopologicalSpace.SeparableSpace Œ±\ninst‚úù¬≤ : CompleteSpace Œ±\ninst‚úù¬π : (uniformity Œ±).IsCountablyGenerated\ninst‚úù : T0Space Œ±\n‚ä¢ PolishSpace Œ±","decl":"instance (priority := 100) PolishSpace.of_separableSpace_completeSpace_metrizable [UniformSpace Œ±]\n    [SeparableSpace Œ±] [CompleteSpace Œ±] [(ùì§ Œ±).IsCountablyGenerated] [T0Space Œ±] :\n    PolishSpace Œ± where\n  toSecondCountableTopology := UniformSpace.secondCountable_of_separable Œ±\n  complete := ‚ü®UniformSpace.metricSpace Œ±, rfl, ‚Äπ_‚Ä∫‚ü©\n\n"}
{"name":"complete_polishSpaceMetric","module":"Mathlib.Topology.MetricSpace.Polish","initialProofState":"Œ± : Type u_3\nht : TopologicalSpace Œ±\nh : PolishSpace Œ±\n‚ä¢ CompleteSpace Œ±","decl":"theorem complete_polishSpaceMetric (Œ± : Type*) [ht : TopologicalSpace Œ±] [h : PolishSpace Œ±] :\n    @CompleteSpace Œ± (polishSpaceMetric Œ±).toUniformSpace := by\n  convert h.complete.choose_spec.2\n  exact MetricSpace.replaceTopology_eq _ _\n\n"}
{"name":"PolishSpace.instMetrizableSpace","module":"Mathlib.Topology.MetricSpace.Polish","initialProofState":"Œ± : Type u_3\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : PolishSpace Œ±\n‚ä¢ TopologicalSpace.MetrizableSpace Œ±","decl":"instance (priority := 100) instMetrizableSpace (Œ± : Type*) [TopologicalSpace Œ±] [PolishSpace Œ±] :\n    MetrizableSpace Œ± := by\n  letI := upgradePolishSpace Œ±\n  infer_instance\n\n"}
{"name":"PolishSpace.pi_countable","module":"Mathlib.Topology.MetricSpace.Polish","initialProofState":"Œπ : Type u_3\ninst‚úù¬≤ : Countable Œπ\nE : Œπ ‚Üí Type u_4\ninst‚úù¬π : (i : Œπ) ‚Üí TopologicalSpace (E i)\ninst‚úù : ‚àÄ (i : Œπ), PolishSpace (E i)\n‚ä¢ PolishSpace ((i : Œπ) ‚Üí E i)","decl":"/-- A countable product of Polish spaces is Polish. -/\ninstance pi_countable {Œπ : Type*} [Countable Œπ] {E : Œπ ‚Üí Type*} [‚àÄ i, TopologicalSpace (E i)]\n    [‚àÄ i, PolishSpace (E i)] : PolishSpace (‚àÄ i, E i) := by\n  letI := fun i => upgradePolishSpace (E i)\n  infer_instance\n\n"}
{"name":"PolishSpace.sigma","module":"Mathlib.Topology.MetricSpace.Polish","initialProofState":"Œπ : Type u_3\ninst‚úù¬≤ : Countable Œπ\nE : Œπ ‚Üí Type u_4\ninst‚úù¬π : (n : Œπ) ‚Üí TopologicalSpace (E n)\ninst‚úù : ‚àÄ (n : Œπ), PolishSpace (E n)\n‚ä¢ PolishSpace (Sigma fun n => E n)","decl":"/-- A countable disjoint union of Polish spaces is Polish. -/\ninstance sigma {Œπ : Type*} [Countable Œπ] {E : Œπ ‚Üí Type*} [‚àÄ n, TopologicalSpace (E n)]\n    [‚àÄ n, PolishSpace (E n)] : PolishSpace (Œ£n, E n) :=\n  letI := fun n => upgradePolishSpace (E n)\n  letI : MetricSpace (Œ£n, E n) := Sigma.metricSpace\n  haveI : CompleteSpace (Œ£n, E n) := Sigma.completeSpace\n  inferInstance\n\n"}
{"name":"PolishSpace.prod","module":"Mathlib.Topology.MetricSpace.Polish","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù¬≥ : TopologicalSpace Œ±\ninst‚úù¬≤ : PolishSpace Œ±\ninst‚úù¬π : TopologicalSpace Œ≤\ninst‚úù : PolishSpace Œ≤\n‚ä¢ PolishSpace (Prod Œ± Œ≤)","decl":"/-- The product of two Polish spaces is Polish. -/\ninstance prod [TopologicalSpace Œ±] [PolishSpace Œ±] [TopologicalSpace Œ≤] [PolishSpace Œ≤] :\n    PolishSpace (Œ± √ó Œ≤) :=\n  letI := upgradePolishSpace Œ±\n  letI := upgradePolishSpace Œ≤\n  inferInstance\n\n"}
{"name":"PolishSpace.sum","module":"Mathlib.Topology.MetricSpace.Polish","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù¬≥ : TopologicalSpace Œ±\ninst‚úù¬≤ : PolishSpace Œ±\ninst‚úù¬π : TopologicalSpace Œ≤\ninst‚úù : PolishSpace Œ≤\n‚ä¢ PolishSpace (Sum Œ± Œ≤)","decl":"/-- The disjoint union of two Polish spaces is Polish. -/\ninstance sum [TopologicalSpace Œ±] [PolishSpace Œ±] [TopologicalSpace Œ≤] [PolishSpace Œ≤] :\n    PolishSpace (Œ± ‚äï Œ≤) :=\n  letI := upgradePolishSpace Œ±\n  letI := upgradePolishSpace Œ≤\n  inferInstance\n\n"}
{"name":"PolishSpace.exists_nat_nat_continuous_surjective","module":"Mathlib.Topology.MetricSpace.Polish","initialProofState":"Œ± : Type u_3\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : PolishSpace Œ±\ninst‚úù : Nonempty Œ±\n‚ä¢ Exists fun f => And (Continuous f) (Function.Surjective f)","decl":"/-- Any nonempty Polish space is the continuous image of the fundamental space `‚Ñï ‚Üí ‚Ñï`. -/\ntheorem exists_nat_nat_continuous_surjective (Œ± : Type*) [TopologicalSpace Œ±] [PolishSpace Œ±]\n    [Nonempty Œ±] : ‚àÉ f : (‚Ñï ‚Üí ‚Ñï) ‚Üí Œ±, Continuous f ‚àß Surjective f :=\n  letI := upgradePolishSpace Œ±\n  exists_nat_nat_continuous_surjective_of_completeSpace Œ±\n\n"}
{"name":"Topology.IsClosedEmbedding.polishSpace","module":"Mathlib.Topology.MetricSpace.Polish","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : TopologicalSpace Œ≤\ninst‚úù : PolishSpace Œ≤\nf : Œ± ‚Üí Œ≤\nhf : Topology.IsClosedEmbedding f\n‚ä¢ PolishSpace Œ±","decl":"/-- Given a closed embedding into a Polish space, the source space is also Polish. -/\ntheorem _root_.Topology.IsClosedEmbedding.polishSpace [TopologicalSpace Œ±] [TopologicalSpace Œ≤]\n    [PolishSpace Œ≤] {f : Œ± ‚Üí Œ≤} (hf : IsClosedEmbedding f) : PolishSpace Œ± := by\n  letI := upgradePolishSpace Œ≤\n  letI : MetricSpace Œ± := hf.isEmbedding.comapMetricSpace f\n  haveI : SecondCountableTopology Œ± := hf.isEmbedding.secondCountableTopology\n  have : CompleteSpace Œ± := by\n    rw [completeSpace_iff_isComplete_range hf.isEmbedding.to_isometry.isUniformInducing]\n    exact hf.isClosed_range.isComplete\n  infer_instance\n\n"}
{"name":"ClosedEmbedding.polishSpace","module":"Mathlib.Topology.MetricSpace.Polish","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : TopologicalSpace Œ≤\ninst‚úù : PolishSpace Œ≤\nf : Œ± ‚Üí Œ≤\nhf : Topology.IsClosedEmbedding f\n‚ä¢ PolishSpace Œ±","decl":"@[deprecated (since := \"2024-10-20\")]\nalias _root_.ClosedEmbedding.polishSpace := IsClosedEmbedding.polishSpace\n\n"}
{"name":"PolishSpace.polish_of_countable","module":"Mathlib.Topology.MetricSpace.Polish","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : TopologicalSpace Œ±\nh : Countable Œ±\ninst‚úù : DiscreteTopology Œ±\n‚ä¢ PolishSpace Œ±","decl":"/-- Any countable discrete space is Polish. -/\ninstance (priority := 50) polish_of_countable [TopologicalSpace Œ±]\n    [h : Countable Œ±] [DiscreteTopology Œ±] : PolishSpace Œ± := by\n  obtain ‚ü®f, hf‚ü© := h.exists_injective_nat\n  have : IsClosedEmbedding f :=\n    .of_continuous_injective_isClosedMap continuous_of_discreteTopology hf\n      fun t _ ‚Ü¶ isClosed_discrete _\n  exact this.polishSpace\n\n"}
{"name":"Equiv.polishSpace_induced","module":"Mathlib.Topology.MetricSpace.Polish","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nt : TopologicalSpace Œ≤\ninst‚úù : PolishSpace Œ≤\nf : Equiv Œ± Œ≤\n‚ä¢ PolishSpace Œ±","decl":"/-- Pulling back a Polish topology under an equiv gives again a Polish topology. -/\ntheorem _root_.Equiv.polishSpace_induced [t : TopologicalSpace Œ≤] [PolishSpace Œ≤] (f : Œ± ‚âÉ Œ≤) :\n    @PolishSpace Œ± (t.induced f) :=\n  letI : TopologicalSpace Œ± := t.induced f\n  (f.toHomeomorphOfIsInducing ‚ü®rfl‚ü©).isClosedEmbedding.polishSpace\n\n"}
{"name":"IsClosed.polishSpace","module":"Mathlib.Topology.MetricSpace.Polish","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : PolishSpace Œ±\ns : Set Œ±\nhs : IsClosed s\n‚ä¢ PolishSpace ‚Üës","decl":"/-- A closed subset of a Polish space is also Polish. -/\ntheorem _root_.IsClosed.polishSpace [TopologicalSpace Œ±] [PolishSpace Œ±] {s : Set Œ±}\n    (hs : IsClosed s) : PolishSpace s :=\n  hs.isClosedEmbedding_subtypeVal.polishSpace\n\n"}
{"name":"PolishSpace.instPolishSpaceUniv","module":"Mathlib.Topology.MetricSpace.Polish","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : PolishSpace Œ±\n‚ä¢ PolishSpace ‚ÜëSet.univ","decl":"instance instPolishSpaceUniv [TopologicalSpace Œ±] [PolishSpace Œ±] :\n    PolishSpace (univ : Set Œ±) :=\n  isClosed_univ.polishSpace\n\n"}
{"name":"CompletePseudometrizable.iInf","module":"Mathlib.Topology.MetricSpace.Polish","initialProofState":"Œ± : Type u_1\nŒπ : Type u_3\ninst‚úù : Countable Œπ\nt : Œπ ‚Üí TopologicalSpace Œ±\nht‚ÇÄ : Exists fun t‚ÇÄ => And (T2Space Œ±) (‚àÄ (i : Œπ), LE.le (t i) t‚ÇÄ)\nht : ‚àÄ (i : Œπ), Exists fun u => And (CompleteSpace Œ±) (And (uniformity Œ±).IsCountablyGenerated (Eq UniformSpace.toTopologicalSpace (t i)))\n‚ä¢ Exists fun u => And (CompleteSpace Œ±) (And (uniformity Œ±).IsCountablyGenerated (Eq UniformSpace.toTopologicalSpace (iInf fun i => t i)))","decl":"protected theorem _root_.CompletePseudometrizable.iInf {Œπ : Type*} [Countable Œπ]\n    {t : Œπ ‚Üí TopologicalSpace Œ±} (ht‚ÇÄ : ‚àÉ t‚ÇÄ, @T2Space Œ± t‚ÇÄ ‚àß ‚àÄ i, t i ‚â§ t‚ÇÄ)\n    (ht : ‚àÄ i, ‚àÉ u : UniformSpace Œ±, CompleteSpace Œ± ‚àß ùì§[u].IsCountablyGenerated ‚àß\n      u.toTopologicalSpace = t i) :\n    ‚àÉ u : UniformSpace Œ±, CompleteSpace Œ± ‚àß\n      ùì§[u].IsCountablyGenerated ‚àß u.toTopologicalSpace = ‚®Ö i, t i := by\n  choose u hcomp hcount hut using ht\n  obtain rfl : t = fun i ‚Ü¶ (u i).toTopologicalSpace := (funext hut).symm\n  refine ‚ü®‚®Ö i, u i, .iInf hcomp ht‚ÇÄ, ?_, UniformSpace.toTopologicalSpace_iInf‚ü©\n  rw [iInf_uniformity]\n  infer_instance\n\n"}
{"name":"PolishSpace.iInf","module":"Mathlib.Topology.MetricSpace.Polish","initialProofState":"Œ± : Type u_1\nŒπ : Type u_3\ninst‚úù : Countable Œπ\nt : Œπ ‚Üí TopologicalSpace Œ±\nht‚ÇÄ : Exists fun i‚ÇÄ => ‚àÄ (i : Œπ), LE.le (t i) (t i‚ÇÄ)\nht : ‚àÄ (i : Œπ), PolishSpace Œ±\n‚ä¢ PolishSpace Œ±","decl":"protected theorem iInf {Œπ : Type*} [Countable Œπ] {t : Œπ ‚Üí TopologicalSpace Œ±}\n    (ht‚ÇÄ : ‚àÉ i‚ÇÄ, ‚àÄ i, t i ‚â§ t i‚ÇÄ) (ht : ‚àÄ i, @PolishSpace Œ± (t i)) : @PolishSpace Œ± (‚®Ö i, t i) := by\n  rcases ht‚ÇÄ with ‚ü®i‚ÇÄ, hi‚ÇÄ‚ü©\n  rcases CompletePseudometrizable.iInf ‚ü®t i‚ÇÄ, letI := t i‚ÇÄ; haveI := ht i‚ÇÄ; inferInstance, hi‚ÇÄ‚ü©\n    fun i ‚Ü¶\n      letI := t i; haveI := ht i; letI := upgradePolishSpace Œ±\n      ‚ü®inferInstance, inferInstance, inferInstance, rfl‚ü©\n    with ‚ü®u, hcomp, hcount, htop‚ü©\n  rw [‚Üê htop]\n  have : @SecondCountableTopology Œ± u.toTopologicalSpace :=\n    htop.symm ‚ñ∏ secondCountableTopology_iInf fun i ‚Ü¶ letI := t i; (ht i).toSecondCountableTopology\n  have : @T1Space Œ± u.toTopologicalSpace :=\n    htop.symm ‚ñ∏ t1Space_antitone (iInf_le _ i‚ÇÄ) (by letI := t i‚ÇÄ; haveI := ht i‚ÇÄ; infer_instance)\n  infer_instance\n\n"}
{"name":"PolishSpace.exists_polishSpace_forall_le","module":"Mathlib.Topology.MetricSpace.Polish","initialProofState":"Œ± : Type u_1\nŒπ : Type u_3\ninst‚úù : Countable Œπ\nt : TopologicalSpace Œ±\np : PolishSpace Œ±\nm : Œπ ‚Üí TopologicalSpace Œ±\nhm : ‚àÄ (n : Œπ), LE.le (m n) t\nh'm : ‚àÄ (n : Œπ), PolishSpace Œ±\n‚ä¢ Exists fun t' => And (‚àÄ (n : Œπ), LE.le t' (m n)) (And (LE.le t' t) (PolishSpace Œ±))","decl":"/-- Given a Polish space, and countably many finer Polish topologies, there exists another Polish\ntopology which is finer than all of them. -/\ntheorem exists_polishSpace_forall_le {Œπ : Type*} [Countable Œπ] [t : TopologicalSpace Œ±]\n    [p : PolishSpace Œ±] (m : Œπ ‚Üí TopologicalSpace Œ±) (hm : ‚àÄ n, m n ‚â§ t)\n    (h'm : ‚àÄ n, @PolishSpace Œ± (m n)) :\n    ‚àÉ t' : TopologicalSpace Œ±, (‚àÄ n, t' ‚â§ m n) ‚àß t' ‚â§ t ‚àß @PolishSpace Œ± t' :=\n  ‚ü®‚®Ö i : Option Œπ, i.elim t m, fun i ‚Ü¶ iInf_le _ (some i), iInf_le _ none,\n    .iInf ‚ü®none, Option.forall.2 ‚ü®le_rfl, hm‚ü©‚ü© <| Option.forall.2 ‚ü®p, h'm‚ü©‚ü©\n\n"}
{"name":"PolishSpace.instENNReal","module":"Mathlib.Topology.MetricSpace.Polish","initialProofState":"‚ä¢ PolishSpace ENNReal","decl":"instance : PolishSpace ENNReal :=\n  ENNReal.orderIsoUnitIntervalBirational.toHomeomorph.isClosedEmbedding.polishSpace\n\n"}
{"name":"TopologicalSpace.Opens.CompleteCopy.dist_eq","module":"Mathlib.Topology.MetricSpace.Polish","initialProofState":"Œ± : Type u_1\ninst‚úù : MetricSpace Œ±\ns : TopologicalSpace.Opens Œ±\nx y : s.CompleteCopy\n‚ä¢ Eq (Dist.dist x y) (HAdd.hAdd (Dist.dist ‚Üëx ‚Üëy) (abs (HSub.hSub (HDiv.hDiv 1 (Metric.infDist (‚Üëx) (HasCompl.compl ‚Üës))) (HDiv.hDiv 1 (Metric.infDist (‚Üëy) (HasCompl.compl ‚Üës))))))","decl":"theorem dist_eq (x y : CompleteCopy s) :\n    dist x y = dist x.1 y.1 + abs (1 / infDist x.1 s·∂ú - 1 / infDist y.1 s·∂ú) :=\n  rfl\n\n"}
{"name":"TopologicalSpace.Opens.CompleteCopy.dist_val_le_dist","module":"Mathlib.Topology.MetricSpace.Polish","initialProofState":"Œ± : Type u_1\ninst‚úù : MetricSpace Œ±\ns : TopologicalSpace.Opens Œ±\nx y : s.CompleteCopy\n‚ä¢ LE.le (Dist.dist ‚Üëx ‚Üëy) (Dist.dist x y)","decl":"theorem dist_val_le_dist (x y : CompleteCopy s) : dist x.1 y.1 ‚â§ dist x y :=\n  le_add_of_nonneg_right (abs_nonneg _)\n\n"}
{"name":"TopologicalSpace.Opens.CompleteCopy.instSecondCountableTopology","module":"Mathlib.Topology.MetricSpace.Polish","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : MetricSpace Œ±\ns : TopologicalSpace.Opens Œ±\ninst‚úù : SecondCountableTopology Œ±\n‚ä¢ SecondCountableTopology s.CompleteCopy","decl":"instance [SecondCountableTopology Œ±] : SecondCountableTopology (CompleteCopy s) :=\n  inferInstanceAs (SecondCountableTopology s)\n"}
{"name":"TopologicalSpace.Opens.CompleteCopy.instT0Space","module":"Mathlib.Topology.MetricSpace.Polish","initialProofState":"Œ± : Type u_1\ninst‚úù : MetricSpace Œ±\ns : TopologicalSpace.Opens Œ±\n‚ä¢ T0Space s.CompleteCopy","decl":"instance : T0Space (CompleteCopy s) := inferInstanceAs (T0Space s)\n\n"}
{"name":"TopologicalSpace.Opens.CompleteCopy.instCompleteSpace","module":"Mathlib.Topology.MetricSpace.Polish","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : MetricSpace Œ±\ns : TopologicalSpace.Opens Œ±\ninst‚úù : CompleteSpace Œ±\n‚ä¢ CompleteSpace s.CompleteCopy","decl":"instance instCompleteSpace [CompleteSpace Œ±] : CompleteSpace (CompleteCopy s) := by\n  refine Metric.complete_of_convergent_controlled_sequences ((1 / 2) ^ ¬∑) (by simp) fun u hu ‚Ü¶ ?_\n  have A : CauchySeq fun n => (u n).1 := by\n    refine cauchySeq_of_le_tendsto_0 (fun n : ‚Ñï => (1 / 2) ^ n) (fun n m N hNn hNm => ?_) ?_\n    ¬∑ exact (dist_val_le_dist (u n) (u m)).trans (hu N n m hNn hNm).le\n    ¬∑ exact tendsto_pow_atTop_nhds_zero_of_lt_one (by norm_num) (by norm_num)\n  obtain ‚ü®x, xlim‚ü© : ‚àÉ x, Tendsto (fun n => (u n).1) atTop (ùìù x) := cauchySeq_tendsto_of_complete A\n  by_cases xs : x ‚àà s\n  ¬∑ exact ‚ü®‚ü®x, xs‚ü©, tendsto_subtype_rng.2 xlim‚ü©\n  obtain ‚ü®C, hC‚ü© : ‚àÉ C, ‚àÄ n, 1 / infDist (u n).1 s·∂ú < C := by\n    refine ‚ü®(1 / 2) ^ 0 + 1 / infDist (u 0).1 s·∂ú, fun n ‚Ü¶ ?_‚ü©\n    rw [‚Üê sub_lt_iff_lt_add]\n    calc\n      _ ‚â§ |1 / infDist (u n).1 s·∂ú - 1 / infDist (u 0).1 s·∂ú| := le_abs_self _\n      _ = |1 / infDist (u 0).1 s·∂ú - 1 / infDist (u n).1 s·∂ú| := abs_sub_comm _ _\n      _ ‚â§ dist (u 0) (u n) := le_add_of_nonneg_left dist_nonneg\n      _ < (1 / 2) ^ 0 := hu 0 0 n le_rfl n.zero_le\n  have Cpos : 0 < C := lt_of_le_of_lt (div_nonneg zero_le_one infDist_nonneg) (hC 0)\n  have Hmem : ‚àÄ {y}, y ‚àà s ‚Üî 0 < infDist y s·∂ú := fun {y} ‚Ü¶ by\n    rw [‚Üê s.isOpen.isClosed_compl.not_mem_iff_infDist_pos ‚ü®x, xs‚ü©]; exact not_not.symm\n  have I : ‚àÄ n, 1 / C ‚â§ infDist (u n).1 s·∂ú := fun n ‚Ü¶ by\n    have : 0 < infDist (u n).1 s·∂ú := Hmem.1 (u n).2\n    rw [div_le_iff‚ÇÄ' Cpos]\n    exact (div_le_iff‚ÇÄ this).1 (hC n).le\n  have I' : 1 / C ‚â§ infDist x s·∂ú :=\n    have : Tendsto (fun n => infDist (u n).1 s·∂ú) atTop (ùìù (infDist x s·∂ú)) :=\n      ((continuous_infDist_pt (s·∂ú : Set Œ±)).tendsto x).comp xlim\n    ge_of_tendsto' this I\n  exact absurd (Hmem.2 <| lt_of_lt_of_le (div_pos one_pos Cpos) I') xs\n\n"}
{"name":"IsOpen.polishSpace","module":"Mathlib.Topology.MetricSpace.Polish","initialProofState":"Œ± : Type u_3\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : PolishSpace Œ±\ns : Set Œ±\nhs : IsOpen s\n‚ä¢ PolishSpace ‚Üës","decl":"/-- An open subset of a Polish space is also Polish. -/\ntheorem _root_.IsOpen.polishSpace {Œ± : Type*} [TopologicalSpace Œ±] [PolishSpace Œ±] {s : Set Œ±}\n    (hs : IsOpen s) : PolishSpace s := by\n  letI := upgradePolishSpace Œ±\n  lift s to Opens Œ± using hs\n  exact inferInstanceAs (PolishSpace s.CompleteCopy)\n\n"}
{"name":"IsClosed.isClopenable","module":"Mathlib.Topology.MetricSpace.Polish","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : PolishSpace Œ±\ns : Set Œ±\nhs : IsClosed s\n‚ä¢ PolishSpace.IsClopenable s","decl":"/-- Given a closed set `s` in a Polish space, one can construct a finer Polish topology for\nwhich `s` is both open and closed. -/\ntheorem _root_.IsClosed.isClopenable [TopologicalSpace Œ±] [PolishSpace Œ±] {s : Set Œ±}\n    (hs : IsClosed s) : IsClopenable s := by\n  /- Both sets `s` and `s·∂ú` admit a Polish topology. So does their disjoint union `s ‚äï s·∂ú`.\n    Pulling back this topology by the canonical bijection with `Œ±` gives the desired Polish\n    topology in which `s` is both open and closed. -/\n  classical\n  haveI : PolishSpace s := hs.polishSpace\n  let t : Set Œ± := s·∂ú\n  haveI : PolishSpace t := hs.isOpen_compl.polishSpace\n  let f : s ‚äï t ‚âÉ Œ± := Equiv.Set.sumCompl s\n  have hle : TopologicalSpace.coinduced f instTopologicalSpaceSum ‚â§ ‚Äπ_‚Ä∫ := by\n    simp only [instTopologicalSpaceSum, coinduced_sup, coinduced_compose, sup_le_iff,\n      ‚Üê continuous_iff_coinduced_le]\n    exact ‚ü®continuous_subtype_val, continuous_subtype_val‚ü©\n  refine ‚ü®.coinduced f instTopologicalSpaceSum, hle, ?_, hs.mono hle, ?_‚ü©\n  ¬∑ rw [‚Üê f.induced_symm]\n    exact f.symm.polishSpace_induced\n  ¬∑ rw [isOpen_coinduced, isOpen_sum_iff]\n    simp only [preimage_preimage, f]\n    have inl (x : s) : (Equiv.Set.sumCompl s) (Sum.inl x) = x := Equiv.Set.sumCompl_apply_inl ..\n    have inr (x : ‚Üës·∂ú) : (Equiv.Set.sumCompl s) (Sum.inr x) = x := Equiv.Set.sumCompl_apply_inr ..\n    simp_rw [t, inl, inr, Subtype.coe_preimage_self]\n    simp only [isOpen_univ, true_and]\n    rw [Subtype.preimage_coe_compl']\n    simp\n\n"}
{"name":"PolishSpace.IsClopenable.compl","module":"Mathlib.Topology.MetricSpace.Polish","initialProofState":"Œ± : Type u_1\ninst‚úù : TopologicalSpace Œ±\ns : Set Œ±\nhs : PolishSpace.IsClopenable s\n‚ä¢ PolishSpace.IsClopenable (HasCompl.compl s)","decl":"theorem IsClopenable.compl [TopologicalSpace Œ±] {s : Set Œ±} (hs : IsClopenable s) :\n    IsClopenable s·∂ú := by\n  rcases hs with ‚ü®t, t_le, t_polish, h, h'‚ü©\n  exact ‚ü®t, t_le, t_polish, @IsOpen.isClosed_compl Œ± t s h', @IsClosed.isOpen_compl Œ± t s h‚ü©\n\n"}
{"name":"IsOpen.isClopenable","module":"Mathlib.Topology.MetricSpace.Polish","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : PolishSpace Œ±\ns : Set Œ±\nhs : IsOpen s\n‚ä¢ PolishSpace.IsClopenable s","decl":"theorem _root_.IsOpen.isClopenable [TopologicalSpace Œ±] [PolishSpace Œ±] {s : Set Œ±}\n    (hs : IsOpen s) : IsClopenable s := by\n  simpa using hs.isClosed_compl.isClopenable.compl\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO: generalize for free to `[Countable Œπ] {s : Œπ ‚Üí Set Œ±}`\n"}
{"name":"PolishSpace.IsClopenable.iUnion","module":"Mathlib.Topology.MetricSpace.Polish","initialProofState":"Œ± : Type u_1\nt : TopologicalSpace Œ±\ninst‚úù : PolishSpace Œ±\ns : Nat ‚Üí Set Œ±\nhs : ‚àÄ (n : Nat), PolishSpace.IsClopenable (s n)\n‚ä¢ PolishSpace.IsClopenable (Set.iUnion fun n => s n)","decl":"theorem IsClopenable.iUnion [t : TopologicalSpace Œ±] [PolishSpace Œ±] {s : ‚Ñï ‚Üí Set Œ±}\n    (hs : ‚àÄ n, IsClopenable (s n)) : IsClopenable (‚ãÉ n, s n) := by\n  choose m mt m_polish _ m_open using hs\n  obtain ‚ü®t', t'm, -, t'_polish‚ü© :\n      ‚àÉ t' : TopologicalSpace Œ±, (‚àÄ n : ‚Ñï, t' ‚â§ m n) ‚àß t' ‚â§ t ‚àß @PolishSpace Œ± t' :=\n    exists_polishSpace_forall_le m mt m_polish\n  have A : IsOpen[t'] (‚ãÉ n, s n) := by\n    apply isOpen_iUnion\n    intro n\n    apply t'm n\n    exact m_open n\n  obtain ‚ü®t'', t''_le, t''_polish, h1, h2‚ü© : ‚àÉ t'' : TopologicalSpace Œ±,\n      t'' ‚â§ t' ‚àß @PolishSpace Œ± t'' ‚àß IsClosed[t''] (‚ãÉ n, s n) ‚àß IsOpen[t''] (‚ãÉ n, s n) :=\n    @IsOpen.isClopenable Œ± t' t'_polish _ A\n  exact ‚ü®t'', t''_le.trans ((t'm 0).trans (mt 0)), t''_polish, h1, h2‚ü©\n\n"}
