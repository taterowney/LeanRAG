{"name":"ContinuousAffineMap.coe_contLinear","module":"Mathlib.Analysis.Normed.Affine.ContinuousAffineMap","initialProofState":"R : Type u_2\nV : Type u_3\nW : Type u_4\nP : Type u_6\nQ : Type u_7\ninst✝⁸ : NormedAddCommGroup V\ninst✝⁷ : MetricSpace P\ninst✝⁶ : NormedAddTorsor V P\ninst✝⁵ : NormedAddCommGroup W\ninst✝⁴ : MetricSpace Q\ninst✝³ : NormedAddTorsor W Q\ninst✝² : NormedField R\ninst✝¹ : NormedSpace R V\ninst✝ : NormedSpace R W\nf : ContinuousAffineMap R P Q\n⊢ Eq ⇑f.contLinear ⇑f.linear","decl":"@[simp]\ntheorem coe_contLinear (f : P →ᴬ[R] Q) : (f.contLinear : V → W) = f.linear :=\n  rfl\n\n"}
{"name":"ContinuousAffineMap.coe_contLinear_eq_linear","module":"Mathlib.Analysis.Normed.Affine.ContinuousAffineMap","initialProofState":"R : Type u_2\nV : Type u_3\nW : Type u_4\nP : Type u_6\nQ : Type u_7\ninst✝⁸ : NormedAddCommGroup V\ninst✝⁷ : MetricSpace P\ninst✝⁶ : NormedAddTorsor V P\ninst✝⁵ : NormedAddCommGroup W\ninst✝⁴ : MetricSpace Q\ninst✝³ : NormedAddTorsor W Q\ninst✝² : NormedField R\ninst✝¹ : NormedSpace R V\ninst✝ : NormedSpace R W\nf : ContinuousAffineMap R P Q\n⊢ Eq (↑f.contLinear) f.linear","decl":"@[simp]\ntheorem coe_contLinear_eq_linear (f : P →ᴬ[R] Q) :\n    (f.contLinear : V →ₗ[R] W) = (f : P →ᵃ[R] Q).linear := by ext; rfl\n\n"}
{"name":"ContinuousAffineMap.coe_mk_const_linear_eq_linear","module":"Mathlib.Analysis.Normed.Affine.ContinuousAffineMap","initialProofState":"R : Type u_2\nV : Type u_3\nW : Type u_4\nP : Type u_6\nQ : Type u_7\ninst✝⁸ : NormedAddCommGroup V\ninst✝⁷ : MetricSpace P\ninst✝⁶ : NormedAddTorsor V P\ninst✝⁵ : NormedAddCommGroup W\ninst✝⁴ : MetricSpace Q\ninst✝³ : NormedAddTorsor W Q\ninst✝² : NormedField R\ninst✝¹ : NormedSpace R V\ninst✝ : NormedSpace R W\nf : AffineMap R P Q\nh : Continuous f.toFun\n⊢ Eq ⇑{ toAffineMap := f, cont := h }.contLinear ⇑f.linear","decl":"@[simp]\ntheorem coe_mk_const_linear_eq_linear (f : P →ᵃ[R] Q) (h) :\n    ((⟨f, h⟩ : P →ᴬ[R] Q).contLinear : V → W) = f.linear :=\n  rfl\n\n"}
{"name":"ContinuousAffineMap.coe_linear_eq_coe_contLinear","module":"Mathlib.Analysis.Normed.Affine.ContinuousAffineMap","initialProofState":"R : Type u_2\nV : Type u_3\nW : Type u_4\nP : Type u_6\nQ : Type u_7\ninst✝⁸ : NormedAddCommGroup V\ninst✝⁷ : MetricSpace P\ninst✝⁶ : NormedAddTorsor V P\ninst✝⁵ : NormedAddCommGroup W\ninst✝⁴ : MetricSpace Q\ninst✝³ : NormedAddTorsor W Q\ninst✝² : NormedField R\ninst✝¹ : NormedSpace R V\ninst✝ : NormedSpace R W\nf : ContinuousAffineMap R P Q\n⊢ Eq ⇑f.linear ⇑f.contLinear","decl":"theorem coe_linear_eq_coe_contLinear (f : P →ᴬ[R] Q) :\n    ((f : P →ᵃ[R] Q).linear : V → W) = (⇑f.contLinear : V → W) :=\n  rfl\n\n"}
{"name":"ContinuousAffineMap.comp_contLinear","module":"Mathlib.Analysis.Normed.Affine.ContinuousAffineMap","initialProofState":"R : Type u_2\nV : Type u_3\nW : Type u_4\nW₂ : Type u_5\nP : Type u_6\nQ : Type u_7\nQ₂ : Type u_8\ninst✝¹² : NormedAddCommGroup V\ninst✝¹¹ : MetricSpace P\ninst✝¹⁰ : NormedAddTorsor V P\ninst✝⁹ : NormedAddCommGroup W\ninst✝⁸ : MetricSpace Q\ninst✝⁷ : NormedAddTorsor W Q\ninst✝⁶ : NormedAddCommGroup W₂\ninst✝⁵ : MetricSpace Q₂\ninst✝⁴ : NormedAddTorsor W₂ Q₂\ninst✝³ : NormedField R\ninst✝² : NormedSpace R V\ninst✝¹ : NormedSpace R W\ninst✝ : NormedSpace R W₂\nf : ContinuousAffineMap R P Q\ng : ContinuousAffineMap R Q Q₂\n⊢ Eq (g.comp f).contLinear (g.contLinear.comp f.contLinear)","decl":"@[simp]\ntheorem comp_contLinear (f : P →ᴬ[R] Q) (g : Q →ᴬ[R] Q₂) :\n    (g.comp f).contLinear = g.contLinear.comp f.contLinear :=\n  rfl\n\n"}
{"name":"ContinuousAffineMap.map_vadd","module":"Mathlib.Analysis.Normed.Affine.ContinuousAffineMap","initialProofState":"R : Type u_2\nV : Type u_3\nW : Type u_4\nP : Type u_6\nQ : Type u_7\ninst✝⁸ : NormedAddCommGroup V\ninst✝⁷ : MetricSpace P\ninst✝⁶ : NormedAddTorsor V P\ninst✝⁵ : NormedAddCommGroup W\ninst✝⁴ : MetricSpace Q\ninst✝³ : NormedAddTorsor W Q\ninst✝² : NormedField R\ninst✝¹ : NormedSpace R V\ninst✝ : NormedSpace R W\nf : ContinuousAffineMap R P Q\np : P\nv : V\n⊢ Eq (f (HVAdd.hVAdd v p)) (HVAdd.hVAdd (f.contLinear v) (f p))","decl":"@[simp]\ntheorem map_vadd (f : P →ᴬ[R] Q) (p : P) (v : V) : f (v +ᵥ p) = f.contLinear v +ᵥ f p :=\n  f.map_vadd' p v\n\n"}
{"name":"ContinuousAffineMap.contLinear_map_vsub","module":"Mathlib.Analysis.Normed.Affine.ContinuousAffineMap","initialProofState":"R : Type u_2\nV : Type u_3\nW : Type u_4\nP : Type u_6\nQ : Type u_7\ninst✝⁸ : NormedAddCommGroup V\ninst✝⁷ : MetricSpace P\ninst✝⁶ : NormedAddTorsor V P\ninst✝⁵ : NormedAddCommGroup W\ninst✝⁴ : MetricSpace Q\ninst✝³ : NormedAddTorsor W Q\ninst✝² : NormedField R\ninst✝¹ : NormedSpace R V\ninst✝ : NormedSpace R W\nf : ContinuousAffineMap R P Q\np₁ p₂ : P\n⊢ Eq (f.contLinear (VSub.vsub p₁ p₂)) (VSub.vsub (f p₁) (f p₂))","decl":"@[simp]\ntheorem contLinear_map_vsub (f : P →ᴬ[R] Q) (p₁ p₂ : P) : f.contLinear (p₁ -ᵥ p₂) = f p₁ -ᵥ f p₂ :=\n  f.toAffineMap.linearMap_vsub p₁ p₂\n\n"}
{"name":"ContinuousAffineMap.const_contLinear","module":"Mathlib.Analysis.Normed.Affine.ContinuousAffineMap","initialProofState":"R : Type u_2\nV : Type u_3\nW : Type u_4\nP : Type u_6\nQ : Type u_7\ninst✝⁸ : NormedAddCommGroup V\ninst✝⁷ : MetricSpace P\ninst✝⁶ : NormedAddTorsor V P\ninst✝⁵ : NormedAddCommGroup W\ninst✝⁴ : MetricSpace Q\ninst✝³ : NormedAddTorsor W Q\ninst✝² : NormedField R\ninst✝¹ : NormedSpace R V\ninst✝ : NormedSpace R W\nq : Q\n⊢ Eq (ContinuousAffineMap.const R P q).contLinear 0","decl":"@[simp]\ntheorem const_contLinear (q : Q) : (const R P q).contLinear = 0 :=\n  rfl\n\n"}
{"name":"ContinuousAffineMap.contLinear_eq_zero_iff_exists_const","module":"Mathlib.Analysis.Normed.Affine.ContinuousAffineMap","initialProofState":"R : Type u_2\nV : Type u_3\nW : Type u_4\nP : Type u_6\nQ : Type u_7\ninst✝⁸ : NormedAddCommGroup V\ninst✝⁷ : MetricSpace P\ninst✝⁶ : NormedAddTorsor V P\ninst✝⁵ : NormedAddCommGroup W\ninst✝⁴ : MetricSpace Q\ninst✝³ : NormedAddTorsor W Q\ninst✝² : NormedField R\ninst✝¹ : NormedSpace R V\ninst✝ : NormedSpace R W\nf : ContinuousAffineMap R P Q\n⊢ Iff (Eq f.contLinear 0) (Exists fun q => Eq f (ContinuousAffineMap.const R P q))","decl":"theorem contLinear_eq_zero_iff_exists_const (f : P →ᴬ[R] Q) :\n    f.contLinear = 0 ↔ ∃ q, f = const R P q := by\n  have h₁ : f.contLinear = 0 ↔ (f : P →ᵃ[R] Q).linear = 0 := by\n    refine ⟨fun h => ?_, fun h => ?_⟩ <;> ext\n    · rw [← coe_contLinear_eq_linear, h]; rfl\n    · rw [← coe_linear_eq_coe_contLinear, h]; rfl\n  have h₂ : ∀ q : Q, f = const R P q ↔ (f : P →ᵃ[R] Q) = AffineMap.const R P q := by\n    intro q\n    refine ⟨fun h => ?_, fun h => ?_⟩ <;> ext\n    · rw [h]; rfl\n    · rw [← coe_to_affineMap, h]; rfl\n  simp_rw [h₁, h₂]\n  exact (f : P →ᵃ[R] Q).linear_eq_zero_iff_exists_const\n\n"}
{"name":"ContinuousAffineMap.to_affine_map_contLinear","module":"Mathlib.Analysis.Normed.Affine.ContinuousAffineMap","initialProofState":"R : Type u_2\nV : Type u_3\nW : Type u_4\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : NormedAddCommGroup W\ninst✝² : NormedField R\ninst✝¹ : NormedSpace R V\ninst✝ : NormedSpace R W\nf : ContinuousLinearMap (RingHom.id R) V W\n⊢ Eq f.toContinuousAffineMap.contLinear f","decl":"@[simp]\ntheorem to_affine_map_contLinear (f : V →L[R] W) : f.toContinuousAffineMap.contLinear = f := by\n  ext\n  rfl\n\n"}
{"name":"ContinuousAffineMap.zero_contLinear","module":"Mathlib.Analysis.Normed.Affine.ContinuousAffineMap","initialProofState":"R : Type u_2\nV : Type u_3\nW : Type u_4\nP : Type u_6\ninst✝⁶ : NormedAddCommGroup V\ninst✝⁵ : MetricSpace P\ninst✝⁴ : NormedAddTorsor V P\ninst✝³ : NormedAddCommGroup W\ninst✝² : NormedField R\ninst✝¹ : NormedSpace R V\ninst✝ : NormedSpace R W\n⊢ Eq (ContinuousAffineMap.contLinear 0) 0","decl":"@[simp]\ntheorem zero_contLinear : (0 : P →ᴬ[R] W).contLinear = 0 :=\n  rfl\n\n"}
{"name":"ContinuousAffineMap.add_contLinear","module":"Mathlib.Analysis.Normed.Affine.ContinuousAffineMap","initialProofState":"R : Type u_2\nV : Type u_3\nW : Type u_4\nP : Type u_6\ninst✝⁶ : NormedAddCommGroup V\ninst✝⁵ : MetricSpace P\ninst✝⁴ : NormedAddTorsor V P\ninst✝³ : NormedAddCommGroup W\ninst✝² : NormedField R\ninst✝¹ : NormedSpace R V\ninst✝ : NormedSpace R W\nf g : ContinuousAffineMap R P W\n⊢ Eq (HAdd.hAdd f g).contLinear (HAdd.hAdd f.contLinear g.contLinear)","decl":"@[simp]\ntheorem add_contLinear (f g : P →ᴬ[R] W) : (f + g).contLinear = f.contLinear + g.contLinear :=\n  rfl\n\n"}
{"name":"ContinuousAffineMap.sub_contLinear","module":"Mathlib.Analysis.Normed.Affine.ContinuousAffineMap","initialProofState":"R : Type u_2\nV : Type u_3\nW : Type u_4\nP : Type u_6\ninst✝⁶ : NormedAddCommGroup V\ninst✝⁵ : MetricSpace P\ninst✝⁴ : NormedAddTorsor V P\ninst✝³ : NormedAddCommGroup W\ninst✝² : NormedField R\ninst✝¹ : NormedSpace R V\ninst✝ : NormedSpace R W\nf g : ContinuousAffineMap R P W\n⊢ Eq (HSub.hSub f g).contLinear (HSub.hSub f.contLinear g.contLinear)","decl":"@[simp]\ntheorem sub_contLinear (f g : P →ᴬ[R] W) : (f - g).contLinear = f.contLinear - g.contLinear :=\n  rfl\n\n"}
{"name":"ContinuousAffineMap.neg_contLinear","module":"Mathlib.Analysis.Normed.Affine.ContinuousAffineMap","initialProofState":"R : Type u_2\nV : Type u_3\nW : Type u_4\nP : Type u_6\ninst✝⁶ : NormedAddCommGroup V\ninst✝⁵ : MetricSpace P\ninst✝⁴ : NormedAddTorsor V P\ninst✝³ : NormedAddCommGroup W\ninst✝² : NormedField R\ninst✝¹ : NormedSpace R V\ninst✝ : NormedSpace R W\nf : ContinuousAffineMap R P W\n⊢ Eq (Neg.neg f).contLinear (Neg.neg f.contLinear)","decl":"@[simp]\ntheorem neg_contLinear (f : P →ᴬ[R] W) : (-f).contLinear = -f.contLinear :=\n  rfl\n\n"}
{"name":"ContinuousAffineMap.smul_contLinear","module":"Mathlib.Analysis.Normed.Affine.ContinuousAffineMap","initialProofState":"R : Type u_2\nV : Type u_3\nW : Type u_4\nP : Type u_6\ninst✝⁶ : NormedAddCommGroup V\ninst✝⁵ : MetricSpace P\ninst✝⁴ : NormedAddTorsor V P\ninst✝³ : NormedAddCommGroup W\ninst✝² : NormedField R\ninst✝¹ : NormedSpace R V\ninst✝ : NormedSpace R W\nt : R\nf : ContinuousAffineMap R P W\n⊢ Eq (HSMul.hSMul t f).contLinear (HSMul.hSMul t f.contLinear)","decl":"@[simp]\ntheorem smul_contLinear (t : R) (f : P →ᴬ[R] W) : (t • f).contLinear = t • f.contLinear :=\n  rfl\n\n"}
{"name":"ContinuousAffineMap.decomp","module":"Mathlib.Analysis.Normed.Affine.ContinuousAffineMap","initialProofState":"R : Type u_2\nV : Type u_3\nW : Type u_4\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : NormedAddCommGroup W\ninst✝² : NormedField R\ninst✝¹ : NormedSpace R V\ninst✝ : NormedSpace R W\nf : ContinuousAffineMap R V W\n⊢ Eq (⇑f) (HAdd.hAdd (⇑f.contLinear) (Function.const V (f 0)))","decl":"theorem decomp (f : V →ᴬ[R] W) : (f : V → W) = f.contLinear + Function.const V (f 0) := by\n  rcases f with ⟨f, h⟩\n  rw [coe_mk_const_linear_eq_linear, coe_mk, f.decomp, Pi.add_apply, LinearMap.map_zero, zero_add,\n    ← Function.const_def]\n\n"}
{"name":"ContinuousAffineMap.norm_def","module":"Mathlib.Analysis.Normed.Affine.ContinuousAffineMap","initialProofState":"𝕜 : Type u_1\nV : Type u_3\nW : Type u_4\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : NormedAddCommGroup W\ninst✝² : NontriviallyNormedField 𝕜\ninst✝¹ : NormedSpace 𝕜 V\ninst✝ : NormedSpace 𝕜 W\nf : ContinuousAffineMap 𝕜 V W\n⊢ Eq (Norm.norm f) (Max.max (Norm.norm (f 0)) (Norm.norm f.contLinear))","decl":"theorem norm_def : ‖f‖ = max ‖f 0‖ ‖f.contLinear‖ :=\n  rfl\n\n"}
{"name":"ContinuousAffineMap.norm_contLinear_le","module":"Mathlib.Analysis.Normed.Affine.ContinuousAffineMap","initialProofState":"𝕜 : Type u_1\nV : Type u_3\nW : Type u_4\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : NormedAddCommGroup W\ninst✝² : NontriviallyNormedField 𝕜\ninst✝¹ : NormedSpace 𝕜 V\ninst✝ : NormedSpace 𝕜 W\nf : ContinuousAffineMap 𝕜 V W\n⊢ LE.le (Norm.norm f.contLinear) (Norm.norm f)","decl":"theorem norm_contLinear_le : ‖f.contLinear‖ ≤ ‖f‖ :=\n  le_max_right _ _\n\n"}
{"name":"ContinuousAffineMap.norm_image_zero_le","module":"Mathlib.Analysis.Normed.Affine.ContinuousAffineMap","initialProofState":"𝕜 : Type u_1\nV : Type u_3\nW : Type u_4\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : NormedAddCommGroup W\ninst✝² : NontriviallyNormedField 𝕜\ninst✝¹ : NormedSpace 𝕜 V\ninst✝ : NormedSpace 𝕜 W\nf : ContinuousAffineMap 𝕜 V W\n⊢ LE.le (Norm.norm (f 0)) (Norm.norm f)","decl":"theorem norm_image_zero_le : ‖f 0‖ ≤ ‖f‖ :=\n  le_max_left _ _\n\n"}
{"name":"ContinuousAffineMap.norm_eq","module":"Mathlib.Analysis.Normed.Affine.ContinuousAffineMap","initialProofState":"𝕜 : Type u_1\nV : Type u_3\nW : Type u_4\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : NormedAddCommGroup W\ninst✝² : NontriviallyNormedField 𝕜\ninst✝¹ : NormedSpace 𝕜 V\ninst✝ : NormedSpace 𝕜 W\nf : ContinuousAffineMap 𝕜 V W\nh : Eq (f 0) 0\n⊢ Eq (Norm.norm f) (Norm.norm f.contLinear)","decl":"@[simp]\ntheorem norm_eq (h : f 0 = 0) : ‖f‖ = ‖f.contLinear‖ :=\n  calc\n    ‖f‖ = max ‖f 0‖ ‖f.contLinear‖ := by rw [norm_def]\n    _ = max 0 ‖f.contLinear‖ := by rw [h, norm_zero]\n    _ = ‖f.contLinear‖ := max_eq_right (norm_nonneg _)\n\n"}
{"name":"ContinuousAffineMap.norm_comp_le","module":"Mathlib.Analysis.Normed.Affine.ContinuousAffineMap","initialProofState":"𝕜 : Type u_1\nV : Type u_3\nW : Type u_4\nW₂ : Type u_5\ninst✝⁶ : NormedAddCommGroup V\ninst✝⁵ : NormedAddCommGroup W\ninst✝⁴ : NormedAddCommGroup W₂\ninst✝³ : NontriviallyNormedField 𝕜\ninst✝² : NormedSpace 𝕜 V\ninst✝¹ : NormedSpace 𝕜 W\ninst✝ : NormedSpace 𝕜 W₂\nf : ContinuousAffineMap 𝕜 V W\ng : ContinuousAffineMap 𝕜 W₂ V\n⊢ LE.le (Norm.norm (f.comp g)) (HAdd.hAdd (HMul.hMul (Norm.norm f) (Norm.norm g)) (Norm.norm (f 0)))","decl":"theorem norm_comp_le (g : W₂ →ᴬ[𝕜] V) : ‖f.comp g‖ ≤ ‖f‖ * ‖g‖ + ‖f 0‖ := by\n  rw [norm_def, max_le_iff]\n  constructor\n  · calc\n      ‖f.comp g 0‖ = ‖f (g 0)‖ := by simp\n      _ = ‖f.contLinear (g 0) + f 0‖ := by rw [f.decomp]; simp\n      _ ≤ ‖f.contLinear‖ * ‖g 0‖ + ‖f 0‖ :=\n        ((norm_add_le _ _).trans (add_le_add_right (f.contLinear.le_opNorm _) _))\n      _ ≤ ‖f‖ * ‖g‖ + ‖f 0‖ :=\n        add_le_add_right\n          (mul_le_mul f.norm_contLinear_le g.norm_image_zero_le (norm_nonneg _) (norm_nonneg _)) _\n  · calc\n      ‖(f.comp g).contLinear‖ ≤ ‖f.contLinear‖ * ‖g.contLinear‖ :=\n        (g.comp_contLinear f).symm ▸ f.contLinear.opNorm_comp_le _\n      _ ≤ ‖f‖ * ‖g‖ :=\n        (mul_le_mul f.norm_contLinear_le g.norm_contLinear_le (norm_nonneg _) (norm_nonneg _))\n      _ ≤ ‖f‖ * ‖g‖ + ‖f 0‖ := by rw [le_add_iff_nonneg_right]; apply norm_nonneg\n\n"}
{"name":"ContinuousAffineMap.toConstProdContinuousLinearMap_fst","module":"Mathlib.Analysis.Normed.Affine.ContinuousAffineMap","initialProofState":"𝕜 : Type u_1\nV : Type u_3\nW : Type u_4\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : NormedAddCommGroup W\ninst✝² : NontriviallyNormedField 𝕜\ninst✝¹ : NormedSpace 𝕜 V\ninst✝ : NormedSpace 𝕜 W\nf : ContinuousAffineMap 𝕜 V W\n⊢ Eq ((ContinuousAffineMap.toConstProdContinuousLinearMap 𝕜 V W) f).1 (f 0)","decl":"@[simp]\ntheorem toConstProdContinuousLinearMap_fst (f : V →ᴬ[𝕜] W) :\n    (toConstProdContinuousLinearMap 𝕜 V W f).fst = f 0 :=\n  rfl\n\n"}
{"name":"ContinuousAffineMap.toConstProdContinuousLinearMap_snd","module":"Mathlib.Analysis.Normed.Affine.ContinuousAffineMap","initialProofState":"𝕜 : Type u_1\nV : Type u_3\nW : Type u_4\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : NormedAddCommGroup W\ninst✝² : NontriviallyNormedField 𝕜\ninst✝¹ : NormedSpace 𝕜 V\ninst✝ : NormedSpace 𝕜 W\nf : ContinuousAffineMap 𝕜 V W\n⊢ Eq ((ContinuousAffineMap.toConstProdContinuousLinearMap 𝕜 V W) f).2 f.contLinear","decl":"@[simp]\ntheorem toConstProdContinuousLinearMap_snd (f : V →ᴬ[𝕜] W) :\n    (toConstProdContinuousLinearMap 𝕜 V W f).snd = f.contLinear :=\n  rfl\n\n"}
