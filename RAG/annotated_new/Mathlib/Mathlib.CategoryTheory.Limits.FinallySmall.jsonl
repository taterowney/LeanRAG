{"name":"CategoryTheory.FinallySmall.final_smallCategory","module":"Mathlib.CategoryTheory.Limits.FinallySmall","initialProofState":"J : Type u\ninst✝ : CategoryTheory.Category.{v, u} J\nself : CategoryTheory.FinallySmall J\n⊢ Exists fun S => Exists fun x => Exists fun F => F.Final","decl":"/-- A category is `FinallySmall.{w}` if there is a final functor from a `w`-small category. -/\nclass FinallySmall : Prop where\n  /-- There is a final functor from a small category. -/\n  final_smallCategory : ∃ (S : Type w) (_ : SmallCategory S) (F : S ⥤ J), Final F\n\n"}
{"name":"CategoryTheory.FinallySmall.mk'","module":"Mathlib.CategoryTheory.Limits.FinallySmall","initialProofState":"J : Type u\ninst✝² : CategoryTheory.Category.{v, u} J\nS : Type w\ninst✝¹ : CategoryTheory.SmallCategory S\nF : CategoryTheory.Functor S J\ninst✝ : F.Final\n⊢ CategoryTheory.FinallySmall J","decl":"/-- Constructor for `FinallySmall C` from an explicit small category witness. -/\ntheorem FinallySmall.mk' {J : Type u} [Category.{v} J] {S : Type w} [SmallCategory S]\n    (F : S ⥤ J) [Final F] : FinallySmall.{w} J :=\n  ⟨S, _, F, inferInstance⟩\n\n"}
{"name":"CategoryTheory.final_fromFinalModel","module":"Mathlib.CategoryTheory.Limits.FinallySmall","initialProofState":"J : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} J\ninst✝ : CategoryTheory.FinallySmall J\n⊢ (CategoryTheory.fromFinalModel J).Final","decl":"instance final_fromFinalModel [FinallySmall.{w} J] : Final (fromFinalModel J) :=\n  Classical.choose_spec (Classical.choose_spec (Classical.choose_spec\n    (@FinallySmall.final_smallCategory J _ _)))\n\n"}
{"name":"CategoryTheory.finallySmall_of_essentiallySmall","module":"Mathlib.CategoryTheory.Limits.FinallySmall","initialProofState":"J : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} J\ninst✝ : CategoryTheory.EssentiallySmall.{w, v, u} J\n⊢ CategoryTheory.FinallySmall J","decl":"theorem finallySmall_of_essentiallySmall [EssentiallySmall.{w} J] : FinallySmall.{w} J :=\n  FinallySmall.mk' (equivSmallModel.{w} J).inverse\n\n"}
{"name":"CategoryTheory.finallySmall_of_final_of_finallySmall","module":"Mathlib.CategoryTheory.Limits.FinallySmall","initialProofState":"J : Type u\ninst✝³ : CategoryTheory.Category.{v, u} J\nK : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} K\ninst✝¹ : CategoryTheory.FinallySmall K\nF : CategoryTheory.Functor K J\ninst✝ : F.Final\n⊢ CategoryTheory.FinallySmall J","decl":"theorem finallySmall_of_final_of_finallySmall [FinallySmall.{w} K] (F : K ⥤ J) [Final F] :\n    FinallySmall.{w} J :=\n  suffices Final ((fromFinalModel K) ⋙ F) from .mk' ((fromFinalModel K) ⋙ F)\n  final_comp _ _\n\n"}
{"name":"CategoryTheory.finallySmall_of_final_of_essentiallySmall","module":"Mathlib.CategoryTheory.Limits.FinallySmall","initialProofState":"J : Type u\ninst✝³ : CategoryTheory.Category.{v, u} J\nK : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} K\ninst✝¹ : CategoryTheory.EssentiallySmall.{w, v₁, u₁} K\nF : CategoryTheory.Functor K J\ninst✝ : F.Final\n⊢ CategoryTheory.FinallySmall J","decl":"theorem finallySmall_of_final_of_essentiallySmall [EssentiallySmall.{w} K] (F : K ⥤ J) [Final F] :\n    FinallySmall.{w} J :=\n  have := finallySmall_of_essentiallySmall K\n  finallySmall_of_final_of_finallySmall F\n\n"}
{"name":"CategoryTheory.InitiallySmall.initial_smallCategory","module":"Mathlib.CategoryTheory.Limits.FinallySmall","initialProofState":"J : Type u\ninst✝ : CategoryTheory.Category.{v, u} J\nself : CategoryTheory.InitiallySmall J\n⊢ Exists fun S => Exists fun x => Exists fun F => F.Initial","decl":"/-- A category is `InitiallySmall.{w}` if there is an initial functor from a `w`-small category. -/\nclass InitiallySmall : Prop where\n  /-- There is an initial functor from a small category. -/\n  initial_smallCategory : ∃ (S : Type w) (_ : SmallCategory S) (F : S ⥤ J), Initial F\n\n"}
{"name":"CategoryTheory.InitiallySmall.mk'","module":"Mathlib.CategoryTheory.Limits.FinallySmall","initialProofState":"J : Type u\ninst✝² : CategoryTheory.Category.{v, u} J\nS : Type w\ninst✝¹ : CategoryTheory.SmallCategory S\nF : CategoryTheory.Functor S J\ninst✝ : F.Initial\n⊢ CategoryTheory.InitiallySmall J","decl":"/-- Constructor for `InitialSmall C` from an explicit small category witness. -/\ntheorem InitiallySmall.mk' {J : Type u} [Category.{v} J] {S : Type w} [SmallCategory S]\n    (F : S ⥤ J) [Initial F] : InitiallySmall.{w} J :=\n  ⟨S, _, F, inferInstance⟩\n\n"}
{"name":"CategoryTheory.initial_fromInitialModel","module":"Mathlib.CategoryTheory.Limits.FinallySmall","initialProofState":"J : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} J\ninst✝ : CategoryTheory.InitiallySmall J\n⊢ (CategoryTheory.fromInitialModel J).Initial","decl":"instance initial_fromInitialModel [InitiallySmall.{w} J] : Initial (fromInitialModel J) :=\n  Classical.choose_spec (Classical.choose_spec (Classical.choose_spec\n    (@InitiallySmall.initial_smallCategory J _ _)))\n\n"}
{"name":"CategoryTheory.initiallySmall_of_essentiallySmall","module":"Mathlib.CategoryTheory.Limits.FinallySmall","initialProofState":"J : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} J\ninst✝ : CategoryTheory.EssentiallySmall.{w, v, u} J\n⊢ CategoryTheory.InitiallySmall J","decl":"theorem initiallySmall_of_essentiallySmall [EssentiallySmall.{w} J] : InitiallySmall.{w} J :=\n  InitiallySmall.mk' (equivSmallModel.{w} J).inverse\n\n"}
{"name":"CategoryTheory.initiallySmall_of_initial_of_initiallySmall","module":"Mathlib.CategoryTheory.Limits.FinallySmall","initialProofState":"J : Type u\ninst✝³ : CategoryTheory.Category.{v, u} J\nK : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} K\ninst✝¹ : CategoryTheory.InitiallySmall K\nF : CategoryTheory.Functor K J\ninst✝ : F.Initial\n⊢ CategoryTheory.InitiallySmall J","decl":"theorem initiallySmall_of_initial_of_initiallySmall [InitiallySmall.{w} K]\n    (F : K ⥤ J) [Initial F] : InitiallySmall.{w} J :=\n  suffices Initial ((fromInitialModel K) ⋙ F) from .mk' ((fromInitialModel K) ⋙ F)\n  initial_comp _ _\n\n"}
{"name":"CategoryTheory.initiallySmall_of_initial_of_essentiallySmall","module":"Mathlib.CategoryTheory.Limits.FinallySmall","initialProofState":"J : Type u\ninst✝³ : CategoryTheory.Category.{v, u} J\nK : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} K\ninst✝¹ : CategoryTheory.EssentiallySmall.{w, v₁, u₁} K\nF : CategoryTheory.Functor K J\ninst✝ : F.Initial\n⊢ CategoryTheory.InitiallySmall J","decl":"theorem initiallySmall_of_initial_of_essentiallySmall [EssentiallySmall.{w} K]\n    (F : K ⥤ J) [Initial F] : InitiallySmall.{w} J :=\n  have := initiallySmall_of_essentiallySmall K\n  initiallySmall_of_initial_of_initiallySmall F\n\n"}
{"name":"CategoryTheory.FinallySmall.exists_small_weakly_terminal_set","module":"Mathlib.CategoryTheory.Limits.FinallySmall","initialProofState":"J : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} J\ninst✝ : CategoryTheory.FinallySmall J\n⊢ Exists fun s => Exists fun x => ∀ (i : J), Exists fun j => And (Membership.mem s j) (Nonempty (Quiver.Hom i j))","decl":"/-- The converse is true if `J` is filtered, see `finallySmall_of_small_weakly_terminal_set`. -/\ntheorem FinallySmall.exists_small_weakly_terminal_set [FinallySmall.{w} J] :\n    ∃ (s : Set J) (_ : Small.{w} s), ∀ i, ∃ j ∈ s, Nonempty (i ⟶ j) := by\n  refine ⟨Set.range (fromFinalModel J).obj, inferInstance, fun i => ?_⟩\n  obtain ⟨f⟩ : Nonempty (StructuredArrow i (fromFinalModel J)) := IsConnected.is_nonempty\n  exact ⟨(fromFinalModel J).obj f.right, Set.mem_range_self _, ⟨f.hom⟩⟩\n\n"}
{"name":"CategoryTheory.finallySmall_of_small_weakly_terminal_set","module":"Mathlib.CategoryTheory.Limits.FinallySmall","initialProofState":"J : Type u\ninst✝² : CategoryTheory.Category.{v, u} J\ninst✝¹ : CategoryTheory.IsFilteredOrEmpty J\ns : Set J\ninst✝ : Small.{v, u} ↑s\nhs : ∀ (i : J), Exists fun j => And (Membership.mem s j) (Nonempty (Quiver.Hom i j))\n⊢ CategoryTheory.FinallySmall J","decl":"variable {J} in\ntheorem finallySmall_of_small_weakly_terminal_set [IsFilteredOrEmpty J] (s : Set J) [Small.{v} s]\n    (hs : ∀ i, ∃ j ∈ s, Nonempty (i ⟶ j)) : FinallySmall.{v} J := by\n  suffices Functor.Final (fullSubcategoryInclusion (· ∈ s)) from\n    finallySmall_of_final_of_essentiallySmall (fullSubcategoryInclusion (· ∈ s))\n  refine Functor.final_of_exists_of_isFiltered_of_fullyFaithful _ (fun i => ?_)\n  obtain ⟨j, hj₁, hj₂⟩ := hs i\n  exact ⟨⟨j, hj₁⟩, hj₂⟩\n\n"}
{"name":"CategoryTheory.finallySmall_iff_exists_small_weakly_terminal_set","module":"Mathlib.CategoryTheory.Limits.FinallySmall","initialProofState":"J : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} J\ninst✝ : CategoryTheory.IsFilteredOrEmpty J\n⊢ Iff (CategoryTheory.FinallySmall J) (Exists fun s => Exists fun x => ∀ (i : J), Exists fun j => And (Membership.mem s j) (Nonempty (Quiver.Hom i j)))","decl":"theorem finallySmall_iff_exists_small_weakly_terminal_set [IsFilteredOrEmpty J] :\n    FinallySmall.{v} J ↔ ∃ (s : Set J) (_ : Small.{v} s), ∀ i, ∃ j ∈ s, Nonempty (i ⟶ j) := by\n  refine ⟨fun _ => FinallySmall.exists_small_weakly_terminal_set _, fun h => ?_⟩\n  rcases h with ⟨s, hs, hs'⟩\n  exact finallySmall_of_small_weakly_terminal_set s hs'\n\n"}
{"name":"CategoryTheory.InitiallySmall.exists_small_weakly_initial_set","module":"Mathlib.CategoryTheory.Limits.FinallySmall","initialProofState":"J : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} J\ninst✝ : CategoryTheory.InitiallySmall J\n⊢ Exists fun s => Exists fun x => ∀ (i : J), Exists fun j => And (Membership.mem s j) (Nonempty (Quiver.Hom j i))","decl":"/-- The converse is true if `J` is cofiltered, see `initiallySmall_of_small_weakly_initial_set`. -/\ntheorem InitiallySmall.exists_small_weakly_initial_set [InitiallySmall.{w} J] :\n    ∃ (s : Set J) (_ : Small.{w} s), ∀ i, ∃ j ∈ s, Nonempty (j ⟶ i) := by\n  refine ⟨Set.range (fromInitialModel J).obj, inferInstance, fun i => ?_⟩\n  obtain ⟨f⟩ : Nonempty (CostructuredArrow (fromInitialModel J) i) := IsConnected.is_nonempty\n  exact ⟨(fromInitialModel J).obj f.left, Set.mem_range_self _, ⟨f.hom⟩⟩\n\n"}
{"name":"CategoryTheory.initiallySmall_of_small_weakly_initial_set","module":"Mathlib.CategoryTheory.Limits.FinallySmall","initialProofState":"J : Type u\ninst✝² : CategoryTheory.Category.{v, u} J\ninst✝¹ : CategoryTheory.IsCofilteredOrEmpty J\ns : Set J\ninst✝ : Small.{v, u} ↑s\nhs : ∀ (i : J), Exists fun j => And (Membership.mem s j) (Nonempty (Quiver.Hom j i))\n⊢ CategoryTheory.InitiallySmall J","decl":"variable {J} in\ntheorem initiallySmall_of_small_weakly_initial_set [IsCofilteredOrEmpty J] (s : Set J) [Small.{v} s]\n    (hs : ∀ i, ∃ j ∈ s, Nonempty (j ⟶ i)) : InitiallySmall.{v} J := by\n  suffices Functor.Initial (fullSubcategoryInclusion (· ∈ s)) from\n    initiallySmall_of_initial_of_essentiallySmall (fullSubcategoryInclusion (· ∈ s))\n  refine Functor.initial_of_exists_of_isCofiltered_of_fullyFaithful _ (fun i => ?_)\n  obtain ⟨j, hj₁, hj₂⟩ := hs i\n  exact ⟨⟨j, hj₁⟩, hj₂⟩\n\n"}
{"name":"CategoryTheory.initiallySmall_iff_exists_small_weakly_initial_set","module":"Mathlib.CategoryTheory.Limits.FinallySmall","initialProofState":"J : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} J\ninst✝ : CategoryTheory.IsCofilteredOrEmpty J\n⊢ Iff (CategoryTheory.InitiallySmall J) (Exists fun s => Exists fun x => ∀ (i : J), Exists fun j => And (Membership.mem s j) (Nonempty (Quiver.Hom j i)))","decl":"theorem initiallySmall_iff_exists_small_weakly_initial_set [IsCofilteredOrEmpty J] :\n    InitiallySmall.{v} J ↔ ∃ (s : Set J) (_ : Small.{v} s), ∀ i, ∃ j ∈ s, Nonempty (j ⟶ i) := by\n  refine ⟨fun _ => InitiallySmall.exists_small_weakly_initial_set _, fun h => ?_⟩\n  rcases h with ⟨s, hs, hs'⟩\n  exact initiallySmall_of_small_weakly_initial_set s hs'\n\n"}
{"name":"CategoryTheory.Limits.hasColimitsOfShape_of_finallySmall","module":"Mathlib.CategoryTheory.Limits.FinallySmall","initialProofState":"J : Type u\ninst✝³ : CategoryTheory.Category.{v, u} J\ninst✝² : CategoryTheory.FinallySmall J\nC : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Limits.HasColimitsOfSize.{w, w, v₁, u₁} C\n⊢ CategoryTheory.Limits.HasColimitsOfShape J C","decl":"theorem hasColimitsOfShape_of_finallySmall (J : Type u) [Category.{v} J] [FinallySmall.{w} J]\n    (C : Type u₁) [Category.{v₁} C] [HasColimitsOfSize.{w, w} C] : HasColimitsOfShape J C :=\n  Final.hasColimitsOfShape_of_final (fromFinalModel J)\n\n"}
{"name":"CategoryTheory.Limits.hasLimitsOfShape_of_initiallySmall","module":"Mathlib.CategoryTheory.Limits.FinallySmall","initialProofState":"J : Type u\ninst✝³ : CategoryTheory.Category.{v, u} J\ninst✝² : CategoryTheory.InitiallySmall J\nC : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Limits.HasLimitsOfSize.{w, w, v₁, u₁} C\n⊢ CategoryTheory.Limits.HasLimitsOfShape J C","decl":"theorem hasLimitsOfShape_of_initiallySmall (J : Type u) [Category.{v} J] [InitiallySmall.{w} J]\n    (C : Type u₁) [Category.{v₁} C] [HasLimitsOfSize.{w, w} C] : HasLimitsOfShape J C :=\n  Initial.hasLimitsOfShape_of_initial (fromInitialModel J)\n\n"}
