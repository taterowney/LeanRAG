{"name":"CliffordAlgebra.map_mul_map_of_isOrtho_of_mem_evenOdd","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Prod","initialProofState":"R : Type u_1\nM₁ : Type u_2\nM₂ : Type u_3\nN : Type u_4\ninst✝⁶ : CommRing R\ninst✝⁵ : AddCommGroup M₁\ninst✝⁴ : AddCommGroup M₂\ninst✝³ : AddCommGroup N\ninst✝² : Module R M₁\ninst✝¹ : Module R M₂\ninst✝ : Module R N\nQ₁ : QuadraticForm R M₁\nQ₂ : QuadraticForm R M₂\nQₙ : QuadraticForm R N\nf₁ : QuadraticMap.Isometry Q₁ Qₙ\nf₂ : QuadraticMap.Isometry Q₂ Qₙ\nhf : ∀ (x : M₁) (y : M₂), QuadraticMap.IsOrtho Qₙ (f₁ x) (f₂ y)\nm₁ : CliffordAlgebra Q₁\nm₂ : CliffordAlgebra Q₂\ni₁ i₂ : ZMod 2\nhm₁ : Membership.mem (CliffordAlgebra.evenOdd Q₁ i₁) m₁\nhm₂ : Membership.mem (CliffordAlgebra.evenOdd Q₂ i₂) m₂\n⊢ Eq (HMul.hMul ((CliffordAlgebra.map f₁) m₁) ((CliffordAlgebra.map f₂) m₂)) (HSMul.hSMul (HPow.hPow (-1) (HMul.hMul i₂ i₁)) (HMul.hMul ((CliffordAlgebra.map f₂) m₂) ((CliffordAlgebra.map f₁) m₁)))","decl":"/-- If `m₁` and `m₂` are both homogeneous,\nand the quadratic spaces `Q₁` and `Q₂` map into\northogonal subspaces of `Qₙ` (for instance, when `Qₙ = Q₁.prod Q₂`),\nthen the product of the embedding in `CliffordAlgebra Q` commutes up to a sign factor. -/\nnonrec theorem map_mul_map_of_isOrtho_of_mem_evenOdd\n    {i₁ i₂ : ZMod 2} (hm₁ : m₁ ∈ evenOdd Q₁ i₁) (hm₂ : m₂ ∈ evenOdd Q₂ i₂) :\n    map f₁ m₁ * map f₂ m₂ = (-1 : ℤˣ) ^ (i₂ * i₁) • (map f₂ m₂ * map f₁ m₁) := by\n  -- the strategy; for each variable, induct on powers of `ι`, then on the exponent of each\n  -- power.\n  induction hm₁ using Submodule.iSup_induction' with\n  | zero => rw [map_zero, zero_mul, mul_zero, smul_zero]\n  | add _ _ _ _ ihx ihy => rw [map_add, add_mul, mul_add, ihx, ihy, smul_add]\n  | mem i₁' m₁' hm₁ =>\n    obtain ⟨i₁n, rfl⟩ := i₁'\n    dsimp only at *\n    induction hm₁ using Submodule.pow_induction_on_left' with\n    | algebraMap =>\n      rw [AlgHom.commutes, Nat.cast_zero, mul_zero, uzpow_zero, one_smul, Algebra.commutes]\n    | add _ _ _ _ _ ihx ihy =>\n      rw [map_add, add_mul, mul_add, ihx, ihy, smul_add]\n    | mem_mul m₁ hm₁ i x₁ _hx₁ ih₁ =>\n      obtain ⟨v₁, rfl⟩ := hm₁\n      -- this is the first interesting goal\n      rw [map_mul, mul_assoc, ih₁, mul_smul_comm, map_apply_ι, Nat.cast_succ, mul_add_one,\n        uzpow_add, mul_smul, ← mul_assoc, ← mul_assoc, ← smul_mul_assoc ((-1) ^ i₂)]\n      clear ih₁\n      congr 2\n      induction hm₂ using Submodule.iSup_induction' with\n      | zero => rw [map_zero, zero_mul, mul_zero, smul_zero]\n      | add _ _ _ _ ihx ihy => rw [map_add, add_mul, mul_add, ihx, ihy, smul_add]\n      | mem i₂' m₂' hm₂ =>\n        clear m₂\n        obtain ⟨i₂n, rfl⟩ := i₂'\n        dsimp only at *\n        induction hm₂ using Submodule.pow_induction_on_left' with\n        | algebraMap =>\n          rw [AlgHom.commutes, Nat.cast_zero, uzpow_zero, one_smul, Algebra.commutes]\n        | add _ _ _ _ _ ihx ihy =>\n          rw [map_add, add_mul, mul_add, ihx, ihy, smul_add]\n        | mem_mul m₂ hm₂ i x₂ _hx₂ ih₂ =>\n          obtain ⟨v₂, rfl⟩ := hm₂\n          -- this is the second interesting goal\n          rw [map_mul, map_apply_ι, Nat.cast_succ, ← mul_assoc,\n            ι_mul_ι_comm_of_isOrtho (hf _ _), neg_mul, mul_assoc, ih₂, mul_smul_comm,\n            ← mul_assoc, ← Units.neg_smul, uzpow_add, uzpow_one, mul_neg_one]\n\n"}
{"name":"CliffordAlgebra.commute_map_mul_map_of_isOrtho_of_mem_evenOdd_zero_left","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Prod","initialProofState":"R : Type u_1\nM₁ : Type u_2\nM₂ : Type u_3\nN : Type u_4\ninst✝⁶ : CommRing R\ninst✝⁵ : AddCommGroup M₁\ninst✝⁴ : AddCommGroup M₂\ninst✝³ : AddCommGroup N\ninst✝² : Module R M₁\ninst✝¹ : Module R M₂\ninst✝ : Module R N\nQ₁ : QuadraticForm R M₁\nQ₂ : QuadraticForm R M₂\nQₙ : QuadraticForm R N\nf₁ : QuadraticMap.Isometry Q₁ Qₙ\nf₂ : QuadraticMap.Isometry Q₂ Qₙ\nhf : ∀ (x : M₁) (y : M₂), QuadraticMap.IsOrtho Qₙ (f₁ x) (f₂ y)\nm₁ : CliffordAlgebra Q₁\nm₂ : CliffordAlgebra Q₂\ni₂ : ZMod 2\nhm₁ : Membership.mem (CliffordAlgebra.evenOdd Q₁ 0) m₁\nhm₂ : Membership.mem (CliffordAlgebra.evenOdd Q₂ i₂) m₂\n⊢ Commute ((CliffordAlgebra.map f₁) m₁) ((CliffordAlgebra.map f₂) m₂)","decl":"theorem commute_map_mul_map_of_isOrtho_of_mem_evenOdd_zero_left\n    {i₂ : ZMod 2} (hm₁ : m₁ ∈ evenOdd Q₁ 0) (hm₂ : m₂ ∈ evenOdd Q₂ i₂) :\n    Commute (map f₁ m₁) (map f₂ m₂) :=\n  (map_mul_map_of_isOrtho_of_mem_evenOdd _ _ hf _ _ hm₁ hm₂).trans <| by simp\n\n"}
{"name":"CliffordAlgebra.commute_map_mul_map_of_isOrtho_of_mem_evenOdd_zero_right","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Prod","initialProofState":"R : Type u_1\nM₁ : Type u_2\nM₂ : Type u_3\nN : Type u_4\ninst✝⁶ : CommRing R\ninst✝⁵ : AddCommGroup M₁\ninst✝⁴ : AddCommGroup M₂\ninst✝³ : AddCommGroup N\ninst✝² : Module R M₁\ninst✝¹ : Module R M₂\ninst✝ : Module R N\nQ₁ : QuadraticForm R M₁\nQ₂ : QuadraticForm R M₂\nQₙ : QuadraticForm R N\nf₁ : QuadraticMap.Isometry Q₁ Qₙ\nf₂ : QuadraticMap.Isometry Q₂ Qₙ\nhf : ∀ (x : M₁) (y : M₂), QuadraticMap.IsOrtho Qₙ (f₁ x) (f₂ y)\nm₁ : CliffordAlgebra Q₁\nm₂ : CliffordAlgebra Q₂\ni₁ : ZMod 2\nhm₁ : Membership.mem (CliffordAlgebra.evenOdd Q₁ i₁) m₁\nhm₂ : Membership.mem (CliffordAlgebra.evenOdd Q₂ 0) m₂\n⊢ Commute ((CliffordAlgebra.map f₁) m₁) ((CliffordAlgebra.map f₂) m₂)","decl":"theorem commute_map_mul_map_of_isOrtho_of_mem_evenOdd_zero_right\n    {i₁ : ZMod 2} (hm₁ : m₁ ∈ evenOdd Q₁ i₁) (hm₂ : m₂ ∈ evenOdd Q₂ 0) :\n    Commute (map f₁ m₁) (map f₂ m₂) :=\n  (map_mul_map_of_isOrtho_of_mem_evenOdd _ _ hf _ _ hm₁ hm₂).trans <| by simp\n\n"}
{"name":"CliffordAlgebra.map_mul_map_eq_neg_of_isOrtho_of_mem_evenOdd_one","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Prod","initialProofState":"R : Type u_1\nM₁ : Type u_2\nM₂ : Type u_3\nN : Type u_4\ninst✝⁶ : CommRing R\ninst✝⁵ : AddCommGroup M₁\ninst✝⁴ : AddCommGroup M₂\ninst✝³ : AddCommGroup N\ninst✝² : Module R M₁\ninst✝¹ : Module R M₂\ninst✝ : Module R N\nQ₁ : QuadraticForm R M₁\nQ₂ : QuadraticForm R M₂\nQₙ : QuadraticForm R N\nf₁ : QuadraticMap.Isometry Q₁ Qₙ\nf₂ : QuadraticMap.Isometry Q₂ Qₙ\nhf : ∀ (x : M₁) (y : M₂), QuadraticMap.IsOrtho Qₙ (f₁ x) (f₂ y)\nm₁ : CliffordAlgebra Q₁\nm₂ : CliffordAlgebra Q₂\nhm₁ : Membership.mem (CliffordAlgebra.evenOdd Q₁ 1) m₁\nhm₂ : Membership.mem (CliffordAlgebra.evenOdd Q₂ 1) m₂\n⊢ Eq (HMul.hMul ((CliffordAlgebra.map f₁) m₁) ((CliffordAlgebra.map f₂) m₂)) (HMul.hMul (Neg.neg ((CliffordAlgebra.map f₂) m₂)) ((CliffordAlgebra.map f₁) m₁))","decl":"theorem map_mul_map_eq_neg_of_isOrtho_of_mem_evenOdd_one\n    (hm₁ : m₁ ∈ evenOdd Q₁ 1) (hm₂ : m₂ ∈ evenOdd Q₂ 1) :\n    map f₁ m₁ * map f₂ m₂ = - map f₂ m₂ * map f₁ m₁ := by\n  simp [map_mul_map_of_isOrtho_of_mem_evenOdd _ _ hf _ _ hm₁ hm₂]\n\n"}
{"name":"CliffordAlgebra.ofProd_ι_mk","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Prod","initialProofState":"R : Type u_1\nM₁ : Type u_2\nM₂ : Type u_3\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M₁\ninst✝² : AddCommGroup M₂\ninst✝¹ : Module R M₁\ninst✝ : Module R M₂\nQ₁ : QuadraticForm R M₁\nQ₂ : QuadraticForm R M₂\nm₁ : M₁\nm₂ : M₂\n⊢ Eq ((CliffordAlgebra.ofProd Q₁ Q₂) ((CliffordAlgebra.ι (QuadraticMap.prod Q₁ Q₂)) { fst := m₁, snd := m₂ })) (HAdd.hAdd (GradedTensorProduct.tmul R ((CliffordAlgebra.ι Q₁) m₁) 1) (GradedTensorProduct.tmul R 1 ((CliffordAlgebra.ι Q₂) m₂)))","decl":"@[simp]\nlemma ofProd_ι_mk (m₁ : M₁) (m₂ : M₂) :\n    ofProd Q₁ Q₂ (ι _ (m₁, m₂)) = ι Q₁ m₁ ᵍ⊗ₜ 1 + 1 ᵍ⊗ₜ ι Q₂ m₂ := by\n  rw [ofProd, lift_ι_apply]\n  rfl\n\n"}
{"name":"CliffordAlgebra.toProd_ι_tmul_one","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Prod","initialProofState":"R : Type u_1\nM₁ : Type u_2\nM₂ : Type u_3\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M₁\ninst✝² : AddCommGroup M₂\ninst✝¹ : Module R M₁\ninst✝ : Module R M₂\nQ₁ : QuadraticForm R M₁\nQ₂ : QuadraticForm R M₂\nm₁ : M₁\n⊢ Eq ((CliffordAlgebra.toProd Q₁ Q₂) (GradedTensorProduct.tmul R ((CliffordAlgebra.ι Q₁) m₁) 1)) ((CliffordAlgebra.ι (QuadraticMap.prod Q₁ Q₂)) { fst := m₁, snd := 0 })","decl":"@[simp]\nlemma toProd_ι_tmul_one (m₁ : M₁) : toProd Q₁ Q₂ (ι _ m₁ ᵍ⊗ₜ 1) = ι _ (m₁, 0) := by\n  rw [toProd, GradedTensorProduct.lift_tmul, map_one, mul_one, map_apply_ι,\n    QuadraticMap.Isometry.inl_apply]\n\n"}
{"name":"CliffordAlgebra.toProd_one_tmul_ι","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Prod","initialProofState":"R : Type u_1\nM₁ : Type u_2\nM₂ : Type u_3\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M₁\ninst✝² : AddCommGroup M₂\ninst✝¹ : Module R M₁\ninst✝ : Module R M₂\nQ₁ : QuadraticForm R M₁\nQ₂ : QuadraticForm R M₂\nm₂ : M₂\n⊢ Eq ((CliffordAlgebra.toProd Q₁ Q₂) (GradedTensorProduct.tmul R 1 ((CliffordAlgebra.ι Q₂) m₂))) ((CliffordAlgebra.ι (QuadraticMap.prod Q₁ Q₂)) { fst := 0, snd := m₂ })","decl":"@[simp]\nlemma toProd_one_tmul_ι (m₂ : M₂) : toProd Q₁ Q₂ (1 ᵍ⊗ₜ ι _ m₂) = ι _ (0, m₂) := by\n  rw [toProd, GradedTensorProduct.lift_tmul, map_one, one_mul, map_apply_ι,\n    QuadraticMap.Isometry.inr_apply]\n\n"}
{"name":"CliffordAlgebra.toProd_comp_ofProd","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Prod","initialProofState":"R : Type u_1\nM₁ : Type u_2\nM₂ : Type u_3\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M₁\ninst✝² : AddCommGroup M₂\ninst✝¹ : Module R M₁\ninst✝ : Module R M₂\nQ₁ : QuadraticForm R M₁\nQ₂ : QuadraticForm R M₂\n⊢ Eq ((CliffordAlgebra.toProd Q₁ Q₂).comp (CliffordAlgebra.ofProd Q₁ Q₂)) (AlgHom.id R (CliffordAlgebra (QuadraticMap.prod Q₁ Q₂)))","decl":"lemma toProd_comp_ofProd : (toProd Q₁ Q₂).comp (ofProd Q₁ Q₂) = AlgHom.id _ _ := by\n  ext m <;> dsimp\n  · rw [ofProd_ι_mk, map_add, toProd_one_tmul_ι, toProd_ι_tmul_one, Prod.mk_zero_zero,\n      LinearMap.map_zero, add_zero]\n  · rw [ofProd_ι_mk, map_add, toProd_one_tmul_ι, toProd_ι_tmul_one, Prod.mk_zero_zero,\n      LinearMap.map_zero, zero_add]\n\n"}
{"name":"CliffordAlgebra.ofProd_comp_toProd","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Prod","initialProofState":"R : Type u_1\nM₁ : Type u_2\nM₂ : Type u_3\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M₁\ninst✝² : AddCommGroup M₂\ninst✝¹ : Module R M₁\ninst✝ : Module R M₂\nQ₁ : QuadraticForm R M₁\nQ₂ : QuadraticForm R M₂\n⊢ Eq ((CliffordAlgebra.ofProd Q₁ Q₂).comp (CliffordAlgebra.toProd Q₁ Q₂)) (AlgHom.id R (GradedTensorProduct R (CliffordAlgebra.evenOdd Q₁) (CliffordAlgebra.evenOdd Q₂)))","decl":"lemma ofProd_comp_toProd : (ofProd Q₁ Q₂).comp (toProd Q₁ Q₂) = AlgHom.id _ _ := by\n  ext <;> (dsimp; simp)\n\n"}
{"name":"CliffordAlgebra.prodEquiv_symm_apply","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Prod","initialProofState":"R : Type u_1\nM₁ : Type u_2\nM₂ : Type u_3\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M₁\ninst✝² : AddCommGroup M₂\ninst✝¹ : Module R M₁\ninst✝ : Module R M₂\nQ₁ : QuadraticForm R M₁\nQ₂ : QuadraticForm R M₂\na : GradedTensorProduct R (CliffordAlgebra.evenOdd Q₁) (CliffordAlgebra.evenOdd Q₂)\n⊢ Eq ((CliffordAlgebra.prodEquiv Q₁ Q₂).symm a) ((CliffordAlgebra.toProd Q₁ Q₂) a)","decl":"/-- The Clifford algebra over an orthogonal direct sum of quadratic vector spaces is isomorphic\nas an algebra to the graded tensor product of the Clifford algebras of each space.\n\nThis is `CliffordAlgebra.toProd` and `CliffordAlgebra.ofProd` as an equivalence. -/\n@[simps!]\ndef prodEquiv : CliffordAlgebra (Q₁.prod Q₂) ≃ₐ[R] (evenOdd Q₁ ᵍ⊗[R] evenOdd Q₂) :=\n  AlgEquiv.ofAlgHom (ofProd Q₁ Q₂) (toProd Q₁ Q₂) (ofProd_comp_toProd _ _) (toProd_comp_ofProd _ _)\n\n"}
{"name":"CliffordAlgebra.prodEquiv_apply","module":"Mathlib.LinearAlgebra.CliffordAlgebra.Prod","initialProofState":"R : Type u_1\nM₁ : Type u_2\nM₂ : Type u_3\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M₁\ninst✝² : AddCommGroup M₂\ninst✝¹ : Module R M₁\ninst✝ : Module R M₂\nQ₁ : QuadraticForm R M₁\nQ₂ : QuadraticForm R M₂\na : CliffordAlgebra (QuadraticMap.prod Q₁ Q₂)\n⊢ Eq ((CliffordAlgebra.prodEquiv Q₁ Q₂) a) ((CliffordAlgebra.ofProd Q₁ Q₂) a)","decl":"/-- The Clifford algebra over an orthogonal direct sum of quadratic vector spaces is isomorphic\nas an algebra to the graded tensor product of the Clifford algebras of each space.\n\nThis is `CliffordAlgebra.toProd` and `CliffordAlgebra.ofProd` as an equivalence. -/\n@[simps!]\ndef prodEquiv : CliffordAlgebra (Q₁.prod Q₂) ≃ₐ[R] (evenOdd Q₁ ᵍ⊗[R] evenOdd Q₂) :=\n  AlgEquiv.ofAlgHom (ofProd Q₁ Q₂) (toProd Q₁ Q₂) (ofProd_comp_toProd _ _) (toProd_comp_ofProd _ _)\n\n"}
