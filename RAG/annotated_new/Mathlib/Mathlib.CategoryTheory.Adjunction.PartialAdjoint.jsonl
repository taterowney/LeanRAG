{"name":"CategoryTheory.Functor.leftAdjointObjIsDefined_iff","module":"Mathlib.CategoryTheory.Adjunction.PartialAdjoint","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor D C\nX : C\n‚ä¢ Iff (F.LeftAdjointObjIsDefined X) (F.comp (CategoryTheory.coyoneda.obj { unop := X })).IsCorepresentable","decl":"lemma leftAdjointObjIsDefined_iff (X : C) :\n    F.LeftAdjointObjIsDefined X ‚Üî IsCorepresentable (F ‚ãô coyoneda.obj (op X)) := by rfl\n\n"}
{"name":"CategoryTheory.Functor.leftAdjointObjIsDefined_of_adjunction","module":"Mathlib.CategoryTheory.Adjunction.PartialAdjoint","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor D C\nG : CategoryTheory.Functor C D\nadj : CategoryTheory.Adjunction G F\nX : C\n‚ä¢ F.LeftAdjointObjIsDefined X","decl":"variable {F} in\nlemma leftAdjointObjIsDefined_of_adjunction {G : C ‚•§ D} (adj : G ‚ä£ F) (X : C) :\n    F.LeftAdjointObjIsDefined X :=\n  (adj.corepresentableBy X).isCorepresentable\n\n"}
{"name":"CategoryTheory.Functor.instIsCorepresentableCompObjOppositeTypeCoyonedaOpObjLeftAdjointObjIsDefined","module":"Mathlib.CategoryTheory.Adjunction.PartialAdjoint","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor D C\nX : F.PartialLeftAdjointSource\n‚ä¢ (F.comp (CategoryTheory.coyoneda.obj { unop := X.obj })).IsCorepresentable","decl":"instance (X : F.PartialLeftAdjointSource) :\n    IsCorepresentable (F ‚ãô coyoneda.obj (op X.obj)) := X.property\n\n"}
{"name":"CategoryTheory.Functor.partialLeftAdjointHomEquiv_comp","module":"Mathlib.CategoryTheory.Adjunction.PartialAdjoint","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor D C\nX : F.PartialLeftAdjointSource\nY Y' : D\nf : Quiver.Hom (F.partialLeftAdjointObj X) Y\ng : Quiver.Hom Y Y'\n‚ä¢ Eq (F.partialLeftAdjointHomEquiv (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (F.partialLeftAdjointHomEquiv f) (F.map g))","decl":"lemma partialLeftAdjointHomEquiv_comp {X : F.PartialLeftAdjointSource} {Y Y' : D}\n    (f : F.partialLeftAdjointObj X ‚ü∂ Y) (g : Y ‚ü∂ Y') :\n    F.partialLeftAdjointHomEquiv (f ‚â´ g) =\n      F.partialLeftAdjointHomEquiv f ‚â´ F.map g := by\n  apply CorepresentableBy.homEquiv_comp\n\n"}
{"name":"CategoryTheory.Functor.partialLeftAdjointHomEquiv_map","module":"Mathlib.CategoryTheory.Adjunction.PartialAdjoint","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor D C\nX Y : F.PartialLeftAdjointSource\nf : Quiver.Hom X Y\n‚ä¢ Eq (F.partialLeftAdjointHomEquiv (F.partialLeftAdjointMap f)) (CategoryTheory.CategoryStruct.comp f (F.partialLeftAdjointHomEquiv (CategoryTheory.CategoryStruct.id (F.partialLeftAdjointObj Y))))","decl":"@[simp]\nlemma partialLeftAdjointHomEquiv_map {X Y : F.PartialLeftAdjointSource}\n    (f : X ‚ü∂ Y) :\n    F.partialLeftAdjointHomEquiv (F.partialLeftAdjointMap f) =\n      by exact f ‚â´ F.partialLeftAdjointHomEquiv (ùüô _) := by\n  simp [partialLeftAdjointMap]\n\n"}
{"name":"CategoryTheory.Functor.partialLeftAdjointHomEquiv_map_comp","module":"Mathlib.CategoryTheory.Adjunction.PartialAdjoint","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor D C\nX X' : F.PartialLeftAdjointSource\nY : D\nf : Quiver.Hom X X'\ng : Quiver.Hom (F.partialLeftAdjointObj X') Y\n‚ä¢ Eq (F.partialLeftAdjointHomEquiv (CategoryTheory.CategoryStruct.comp (F.partialLeftAdjointMap f) g)) (CategoryTheory.CategoryStruct.comp f (F.partialLeftAdjointHomEquiv g))","decl":"lemma partialLeftAdjointHomEquiv_map_comp {X X' : F.PartialLeftAdjointSource} {Y : D}\n    (f : X ‚ü∂ X') (g : F.partialLeftAdjointObj X' ‚ü∂ Y) :\n    F.partialLeftAdjointHomEquiv (F.partialLeftAdjointMap f ‚â´ g) =\n      by exact f ‚â´ F.partialLeftAdjointHomEquiv g := by\n  rw [partialLeftAdjointHomEquiv_comp, partialLeftAdjointHomEquiv_map, assoc,\n    ‚Üê partialLeftAdjointHomEquiv_comp, id_comp]\n\n"}
{"name":"CategoryTheory.Functor.partialLeftAdjoint_map","module":"Mathlib.CategoryTheory.Adjunction.PartialAdjoint","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor D C\nX‚úù Y‚úù : F.PartialLeftAdjointSource\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (F.partialLeftAdjoint.map f) (F.partialLeftAdjointMap f)","decl":"/-- Given `F : D ‚•§ C`, this is the partial adjoint functor `F.PartialLeftAdjointSource ‚•§ D`. -/\n@[simps]\nnoncomputable def partialLeftAdjoint : F.PartialLeftAdjointSource ‚•§ D where\n  obj := F.partialLeftAdjointObj\n  map := F.partialLeftAdjointMap\n  map_id X := by\n    apply F.partialLeftAdjointHomEquiv.injective\n    dsimp\n    rw [partialLeftAdjointHomEquiv_map]\n    erw [id_comp]\n  map_comp {X Y Z} f g := by\n    apply F.partialLeftAdjointHomEquiv.injective\n    dsimp\n    rw [partialLeftAdjointHomEquiv_map, partialLeftAdjointHomEquiv_comp,\n      partialLeftAdjointHomEquiv_map, assoc]\n    erw [assoc]\n    rw [‚Üê F.partialLeftAdjointHomEquiv_comp, id_comp,\n      partialLeftAdjointHomEquiv_map]\n\n"}
{"name":"CategoryTheory.Functor.partialLeftAdjoint_obj","module":"Mathlib.CategoryTheory.Adjunction.PartialAdjoint","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor D C\nX : F.PartialLeftAdjointSource\n‚ä¢ Eq (F.partialLeftAdjoint.obj X) (F.partialLeftAdjointObj X)","decl":"/-- Given `F : D ‚•§ C`, this is the partial adjoint functor `F.PartialLeftAdjointSource ‚•§ D`. -/\n@[simps]\nnoncomputable def partialLeftAdjoint : F.PartialLeftAdjointSource ‚•§ D where\n  obj := F.partialLeftAdjointObj\n  map := F.partialLeftAdjointMap\n  map_id X := by\n    apply F.partialLeftAdjointHomEquiv.injective\n    dsimp\n    rw [partialLeftAdjointHomEquiv_map]\n    erw [id_comp]\n  map_comp {X Y Z} f g := by\n    apply F.partialLeftAdjointHomEquiv.injective\n    dsimp\n    rw [partialLeftAdjointHomEquiv_map, partialLeftAdjointHomEquiv_comp,\n      partialLeftAdjointHomEquiv_map, assoc]\n    erw [assoc]\n    rw [‚Üê F.partialLeftAdjointHomEquiv_comp, id_comp,\n      partialLeftAdjointHomEquiv_map]\n\n"}
{"name":"CategoryTheory.Functor.isRightAdjoint_of_leftAdjointObjIsDefined_eq_top","module":"Mathlib.CategoryTheory.Adjunction.PartialAdjoint","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor D C\nh : Eq F.LeftAdjointObjIsDefined Top.top\n‚ä¢ F.IsRightAdjoint","decl":"lemma isRightAdjoint_of_leftAdjointObjIsDefined_eq_top\n    (h : F.LeftAdjointObjIsDefined = ‚ä§) : F.IsRightAdjoint := by\n  replace h : ‚àÄ X, IsCorepresentable (F ‚ãô coyoneda.obj (op X)) := fun X ‚Ü¶ by\n    simp only [‚Üê leftAdjointObjIsDefined_iff, h, Pi.top_apply, Prop.top_eq_true]\n  exact (Adjunction.adjunctionOfEquivLeft\n    (fun X Y ‚Ü¶ (F ‚ãô coyoneda.obj (op X)).corepresentableBy.homEquiv)\n    (fun X Y Y' g f ‚Ü¶ by apply CorepresentableBy.homEquiv_comp)).isRightAdjoint\n\n"}
{"name":"CategoryTheory.Functor.isRightAdjoint_iff_leftAdjointObjIsDefined_eq_top","module":"Mathlib.CategoryTheory.Adjunction.PartialAdjoint","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor D C\n‚ä¢ Iff F.IsRightAdjoint (Eq F.LeftAdjointObjIsDefined Top.top)","decl":"variable (F) in\nlemma isRightAdjoint_iff_leftAdjointObjIsDefined_eq_top :\n    F.IsRightAdjoint ‚Üî F.LeftAdjointObjIsDefined = ‚ä§ := by\n  refine ‚ü®fun h ‚Ü¶ ?_, isRightAdjoint_of_leftAdjointObjIsDefined_eq_top‚ü©\n  ext X\n  simpa only [Pi.top_apply, Prop.top_eq_true, iff_true]\n    using leftAdjointObjIsDefined_of_adjunction (Adjunction.ofIsRightAdjoint F) X\n\n"}
{"name":"CategoryTheory.Functor.leftAdjointObjIsDefined_of_isColimit","module":"Mathlib.CategoryTheory.Adjunction.PartialAdjoint","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor D C\nJ : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} J\nR : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cocone R\nhc : CategoryTheory.Limits.IsColimit c\ninst‚úù : CategoryTheory.Limits.HasColimitsOfShape J D\nh : ‚àÄ (j : J), F.LeftAdjointObjIsDefined (R.obj j)\n‚ä¢ F.LeftAdjointObjIsDefined c.pt","decl":"lemma leftAdjointObjIsDefined_of_isColimit {J : Type*} [Category J] {R : J ‚•§ C} {c : Cocone R}\n    (hc : IsColimit c) [HasColimitsOfShape J D]\n    (h : ‚àÄ (j : J), F.LeftAdjointObjIsDefined (R.obj j)) :\n    F.LeftAdjointObjIsDefined c.pt :=\n  (corepresentableByCompCoyonedaObjOfIsColimit\n    (R := FullSubcategory.lift _ R h) hc (colimit.isColimit _)).isCorepresentable\n\n"}
{"name":"CategoryTheory.Functor.leftAdjointObjIsDefined_colimit","module":"Mathlib.CategoryTheory.Adjunction.PartialAdjoint","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor D C\nJ : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} J\nR : CategoryTheory.Functor J C\ninst‚úù¬π : CategoryTheory.Limits.HasColimit R\ninst‚úù : CategoryTheory.Limits.HasColimitsOfShape J D\nh : ‚àÄ (j : J), F.LeftAdjointObjIsDefined (R.obj j)\n‚ä¢ F.LeftAdjointObjIsDefined (CategoryTheory.Limits.colimit R)","decl":"lemma leftAdjointObjIsDefined_colimit {J : Type*} [Category J] (R : J ‚•§ C)\n    [HasColimit R] [HasColimitsOfShape J D]\n    (h : ‚àÄ (j : J), F.LeftAdjointObjIsDefined (R.obj j)) :\n    F.LeftAdjointObjIsDefined (colimit R) :=\n  leftAdjointObjIsDefined_of_isColimit (colimit.isColimit R) h\n\n"}
